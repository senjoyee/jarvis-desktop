import {
  require_shim
} from "./chunk-GL7YRBYQ.js";
import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  ArrowDownRegular,
  ArrowUpRegular,
  Checkmark12Filled,
  Checkmark16Filled,
  CheckmarkCircle12Filled,
  CheckmarkCircleFilled,
  CheckmarkFilled,
  ChevronDown16Regular,
  ChevronDown20Regular,
  ChevronDownRegular,
  ChevronLeftFilled,
  ChevronLeftRegular,
  ChevronRight12Regular,
  ChevronRightFilled,
  ChevronRightRegular,
  ChevronUp16Regular,
  CircleFilled,
  Dismiss12Regular,
  Dismiss20Regular,
  DismissCircleFilled,
  DismissFilled,
  DismissRegular,
  ErrorCircle12Filled,
  IconDirectionContextProvider,
  Info12Filled,
  Info12Regular,
  Info16Filled,
  Info16Regular,
  Info20Filled,
  Info20Regular,
  InfoFilled,
  Lightbulb16Regular,
  MoreHorizontalFilled,
  MoreHorizontalRegular,
  Navigation20Filled,
  PauseCircleRegular,
  PersonRegular,
  Pin20Regular,
  PlayCircleRegular,
  PresenceAvailable10Filled,
  PresenceAvailable10Regular,
  PresenceAvailable12Filled,
  PresenceAvailable12Regular,
  PresenceAvailable16Filled,
  PresenceAvailable16Regular,
  PresenceAvailable20Filled,
  PresenceAvailable20Regular,
  PresenceAway10Filled,
  PresenceAway10Regular,
  PresenceAway12Filled,
  PresenceAway12Regular,
  PresenceAway16Filled,
  PresenceAway16Regular,
  PresenceAway20Filled,
  PresenceAway20Regular,
  PresenceBlocked10Regular,
  PresenceBlocked12Regular,
  PresenceBlocked16Regular,
  PresenceBlocked20Regular,
  PresenceBusy10Filled,
  PresenceBusy12Filled,
  PresenceBusy16Filled,
  PresenceBusy20Filled,
  PresenceDnd10Filled,
  PresenceDnd10Regular,
  PresenceDnd12Filled,
  PresenceDnd12Regular,
  PresenceDnd16Filled,
  PresenceDnd16Regular,
  PresenceDnd20Filled,
  PresenceDnd20Regular,
  PresenceOffline10Regular,
  PresenceOffline12Regular,
  PresenceOffline16Regular,
  PresenceOffline20Regular,
  PresenceOof10Regular,
  PresenceOof12Regular,
  PresenceOof16Regular,
  PresenceOof20Regular,
  PresenceUnknown10Regular,
  PresenceUnknown12Regular,
  PresenceUnknown16Regular,
  PresenceUnknown20Regular,
  ProhibitedFilled,
  RendererProvider,
  SearchRegular,
  Square12Filled,
  Square16Filled,
  StarFilled,
  StarRegular,
  TextDirectionProvider,
  Warning12Filled,
  WarningFilled,
  __css,
  __resetCSS,
  __resetStyles,
  __styles,
  __styles2,
  bundleIcon,
  createDOMRenderer,
  iconFilledClassName,
  iconRegularClassName,
  makeResetStyles,
  makeStaticStyles,
  makeStyles,
  mergeClasses,
  renderToStyleElements,
  shorthands,
  useRenderer
} from "./chunk-WURDCBO7.js";
import {
  require_react_dom
} from "./chunk-YCOEJRGR.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType2(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment12 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment12;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    (function() {
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent2 = heap[parentIndex];
          if (0 < compare(parent2, node))
            heap[parentIndex] = node, heap[index] = parent2, index = parentIndex;
          else break a;
        }
      }
      function peek(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left2 = heap[leftIndex], rightIndex = leftIndex + 1, right2 = heap[rightIndex];
            if (0 > compare(left2, last))
              rightIndex < length && 0 > compare(right2, left2) ? (heap[index] = right2, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left2, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length && 0 > compare(right2, last))
              heap[index] = right2, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      function advanceTimers(currentTime) {
        for (var timer = peek(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek(timerQueue);
            null !== firstTimer && requestHostTimeout(
              handleTimeout,
              firstTimer.startTime - currentTime
            );
          }
      }
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      if ("function" === typeof localSetImmediate)
        var schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/createCSSRuleFromTheme.js
function createCSSRuleFromTheme(selector, theme) {
  if (theme) {
    const cssVarsAsString = Object.keys(theme).reduce((cssVarRule, cssVar) => {
      return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
    }, "");
    return `${selector} { ${cssVarsAsString} }`;
  }
  return `${selector} {}`;
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
var React59 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
var slot_exports = {};
__export(slot_exports, {
  always: () => always,
  optional: () => optional,
  resolveShorthand: () => resolveShorthand
});
var React = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/compose/constants.js
var SLOT_RENDER_FUNCTION_SYMBOL = Symbol.for("fui.slotRenderFunction");
var SLOT_ELEMENT_TYPE_SYMBOL = Symbol.for("fui.slotElementType");
var SLOT_CLASS_NAME_PROP_SYMBOL = Symbol.for("fui.slotClassNameProp");

// node_modules/@fluentui/react-utilities/lib/compose/slot.js
function always(value, options) {
  const { defaultProps, elementType } = options;
  const props = resolveShorthand(value);
  const propsWithMetadata = {
    ...defaultProps,
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: elementType,
    [SLOT_CLASS_NAME_PROP_SYMBOL]: (props === null || props === void 0 ? void 0 : props.className) || (defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.className)
  };
  if (props && typeof props.children === "function") {
    propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
    propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
  }
  return propsWithMetadata;
}
function optional(value, options) {
  if (value === null || value === void 0 && !options.renderByDefault) {
    return void 0;
  }
  return always(value, options);
}
function resolveShorthand(value) {
  if (typeof value === "string" || typeof value === "number" || isIterable(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
  React.isValidElement(value)) {
    return {
      children: value
    };
  }
  if (value && typeof value !== "object" && true) {
    console.error(`@fluentui/react-utilities [slot.${resolveShorthand.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
  }
  return value;
}
var isIterable = (value) => typeof value === "object" && value !== null && Symbol.iterator in value;

// node_modules/@fluentui/react-utilities/lib/compose/isResolvedShorthand.js
var React2 = __toESM(require_react());
function isResolvedShorthand(shorthand) {
  return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !React2.isValidElement(shorthand);
}

// node_modules/@fluentui/react-utilities/lib/compose/isSlot.js
function isSlot(element) {
  return Boolean(element === null || element === void 0 ? void 0 : element.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
}

// node_modules/@fluentui/react-utilities/lib/compose/assertSlots.js
var React3 = __toESM(require_react());
function assertSlots(state) {
  if (true) {
    const typedState = state;
    for (const slotName of Object.keys(typedState.components)) {
      const slotElement = typedState[slotName];
      if (slotElement === void 0) {
        continue;
      }
      if (!isSlot(slotElement)) {
        typedState[slotName] = always(slotElement, {
          // eslint-disable-next-line @typescript-eslint/no-deprecated
          elementType: typedState.components[slotName]
        });
        console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" is not a slot!
Be sure to create slots properly by using "slot.always" or "slot.optional".`);
      } else {
        const { [SLOT_ELEMENT_TYPE_SYMBOL]: elementType } = slotElement;
        if (elementType !== typedState.components[slotName]) {
          slotElement[SLOT_ELEMENT_TYPE_SYMBOL] = typedState.components[slotName];
          console.warn(`@fluentui/react-utilities [${assertSlots.name}]:
"state.${slotName}" element type differs from "state.components.${slotName}",
${elementType} !== ${typedState.components[slotName]}.
Be sure to create slots properly by using "slot.always" or "slot.optional" with the correct elementType.`);
        }
      }
    }
  }
}

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var React5 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var React4 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/properties.js
var toObjectMap = (...items) => {
  const result = {};
  for (const item of items) {
    const keys = Array.isArray(item) ? item : Object.keys(item);
    for (const key of keys) {
      result[key] = 1;
    }
  }
  return result;
};
var baseElementEvents = toObjectMap([
  "onAuxClick",
  "onAnimationEnd",
  "onAnimationStart",
  "onCopy",
  "onCut",
  "onPaste",
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate",
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  "onChange",
  "onInput",
  "onSubmit",
  "onLoad",
  "onError",
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyUp",
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onDoubleClick",
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onMouseUpCapture",
  "onSelect",
  "onTouchCancel",
  "onTouchEnd",
  "onTouchMove",
  "onTouchStart",
  "onScroll",
  "onWheel",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onGotPointerCapture",
  "onLostPointerCapture"
]);
var baseElementProperties = toObjectMap([
  "accessKey",
  "children",
  "className",
  "contentEditable",
  "dir",
  "draggable",
  "hidden",
  "htmlFor",
  "id",
  "lang",
  "popover",
  "focusgroup",
  "ref",
  "role",
  "style",
  "tabIndex",
  "title",
  "translate",
  "spellCheck",
  "name"
]);
var microdataProperties = toObjectMap([
  "itemID",
  "itemProp",
  "itemRef",
  "itemScope",
  "itemType"
]);
var htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
var labelProperties = toObjectMap(htmlElementProperties, [
  "form"
]);
var audioProperties = toObjectMap(htmlElementProperties, [
  "height",
  "loop",
  "muted",
  "preload",
  "src",
  "width"
]);
var videoProperties = toObjectMap(audioProperties, [
  "poster"
]);
var olProperties = toObjectMap(htmlElementProperties, [
  "start"
]);
var liProperties = toObjectMap(htmlElementProperties, [
  "value"
]);
var anchorProperties = toObjectMap(htmlElementProperties, [
  "download",
  "href",
  "hrefLang",
  "media",
  "referrerPolicy",
  "rel",
  "target",
  "type"
]);
var timeProperties = toObjectMap(htmlElementProperties, [
  "dateTime"
]);
var buttonProperties = toObjectMap(htmlElementProperties, [
  "autoFocus",
  "disabled",
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "popoverTarget",
  "popoverTargetAction",
  "type",
  "value"
]);
var inputProperties = toObjectMap(buttonProperties, [
  "accept",
  "alt",
  "autoCorrect",
  "autoCapitalize",
  "autoComplete",
  "checked",
  "dirname",
  "form",
  "height",
  "inputMode",
  "list",
  "max",
  "maxLength",
  "min",
  "minLength",
  "multiple",
  "pattern",
  "placeholder",
  "readOnly",
  "required",
  "src",
  "step",
  "size",
  "type",
  "value",
  "width"
]);
var textAreaProperties = toObjectMap(buttonProperties, [
  "autoCapitalize",
  "cols",
  "dirname",
  "form",
  "maxLength",
  "placeholder",
  "readOnly",
  "required",
  "rows",
  "wrap"
]);
var selectProperties = toObjectMap(buttonProperties, [
  "form",
  "multiple",
  "required"
]);
var optionProperties = toObjectMap(htmlElementProperties, [
  "selected",
  "value"
]);
var tableProperties = toObjectMap(htmlElementProperties, [
  "cellPadding",
  "cellSpacing"
]);
var trProperties = htmlElementProperties;
var thProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "rowSpan",
  "scope"
]);
var tdProperties = toObjectMap(htmlElementProperties, [
  "colSpan",
  "headers",
  "rowSpan",
  "scope"
]);
var colGroupProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var colProperties = toObjectMap(htmlElementProperties, [
  "span"
]);
var fieldsetProperties = toObjectMap(htmlElementProperties, [
  "disabled",
  "form"
]);
var formProperties = toObjectMap(htmlElementProperties, [
  "acceptCharset",
  "action",
  "encType",
  "encType",
  "method",
  "noValidate",
  "target"
]);
var iframeProperties = toObjectMap(htmlElementProperties, [
  "allow",
  "allowFullScreen",
  "allowPaymentRequest",
  "allowTransparency",
  "csp",
  "height",
  "importance",
  "referrerPolicy",
  "sandbox",
  "src",
  "srcDoc",
  "width"
]);
var imgProperties = toObjectMap(htmlElementProperties, [
  "alt",
  "crossOrigin",
  "height",
  "src",
  "srcSet",
  "useMap",
  "width"
]);
var dialogProperties = toObjectMap(htmlElementProperties, [
  "open",
  "onCancel",
  "onClose"
]);
function getNativeProps(props, allowedPropNames, excludedPropNames) {
  const isArray = Array.isArray(allowedPropNames);
  const result = {};
  const keys = Object.keys(props);
  for (const key of keys) {
    const isNativeProp = !isArray && allowedPropNames[key] || isArray && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
    if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
      result[key] = props[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/utils/getNativeElementProps.js
var nativeElementMap = {
  label: labelProperties,
  audio: audioProperties,
  video: videoProperties,
  ol: olProperties,
  li: liProperties,
  a: anchorProperties,
  button: buttonProperties,
  input: inputProperties,
  textarea: textAreaProperties,
  select: selectProperties,
  option: optionProperties,
  table: tableProperties,
  tr: trProperties,
  th: thProperties,
  td: tdProperties,
  colGroup: colGroupProperties,
  col: colProperties,
  fieldset: fieldsetProperties,
  form: formProperties,
  iframe: iframeProperties,
  img: imgProperties,
  time: timeProperties,
  dialog: dialogProperties
};
function getNativeElementProps(tagName, props, excludedPropNames) {
  const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
  allowedPropNames.as = 1;
  return getNativeProps(props, allowedPropNames, excludedPropNames);
}
var getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
  return {
    root: {
      style: props.style,
      className: props.className
    },
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    primary: getNativeElementProps(primarySlotTagName, props, [
      ...excludedPropNames || [],
      "style",
      "className"
    ])
  };
};

// node_modules/@fluentui/react-utilities/lib/compose/getIntrinsicElementProps.js
var getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
  var _props_as;
  return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
};

// node_modules/@fluentui/react-utilities/lib/compose/getSlotClassNameProp.js
var getSlotClassNameProp = (slot) => {
  if (SLOT_CLASS_NAME_PROP_SYMBOL in slot && typeof slot[SLOT_CLASS_NAME_PROP_SYMBOL] === "string") {
    return slot[SLOT_CLASS_NAME_PROP_SYMBOL];
  }
  return void 0;
};

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlots.js
var React6 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/omit.js
function omit(obj, exclusions) {
  const result = {};
  for (const key in obj) {
    if (exclusions.indexOf(key) === -1 && obj.hasOwnProperty(key)) {
      result[key] = obj[key];
    }
  }
  return result;
}

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlots.js
function getSlots(state) {
  const typeState = state;
  const slots = {};
  const slotProps = {};
  const slotNames = Object.keys(typeState.components);
  for (const slotName of slotNames) {
    const [slot, props] = getSlot(typeState, slotName);
    slots[slotName] = slot;
    slotProps[slotName] = props;
  }
  return {
    slots,
    slotProps
  };
}
function getSlot(state, slotName) {
  var _state_components, _state_components1;
  const props = state[slotName];
  if (props === void 0) {
    return [
      null,
      void 0
    ];
  }
  const { as: asProp, children, ...rest } = props;
  const renderFunction = isSlot(props) ? props[SLOT_RENDER_FUNCTION_SYMBOL] : void 0;
  const slot = ((_state_components = state.components) === null || _state_components === void 0 ? void 0 : _state_components[slotName]) === void 0 || // eslint-disable-line @typescript-eslint/no-deprecated
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof state.components[slotName] === "string" ? asProp || ((_state_components1 = state.components) === null || _state_components1 === void 0 ? void 0 : _state_components1[slotName]) || "div" : state.components[slotName];
  const asserted = slot;
  if (renderFunction || typeof children === "function") {
    const render = renderFunction || children;
    return [
      React6.Fragment,
      {
        children: render(asserted, rest)
      }
    ];
  }
  const shouldOmitAsProp = typeof slot === "string" && asProp;
  const slotProps = shouldOmitAsProp ? omit(props, [
    "as"
  ]) : props;
  return [
    asserted,
    slotProps
  ];
}

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/resolveShorthand.js
var resolveShorthand2 = (value, options) => optional(value, {
  ...options,
  renderByDefault: options === null || options === void 0 ? void 0 : options.required,
  // elementType as undefined is the way to identify between a slot and a resolveShorthand call
  // in the case elementType is undefined assertSlots will fail, ensuring it'll only work with slot method.
  elementType: void 0
});

// node_modules/@fluentui/react-utilities/lib/compose/deprecated/getSlotsNext.js
var React7 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useBrowserTimer.js
var React8 = __toESM(require_react());
function useBrowserTimer(setTimer, cancelTimer) {
  const id = React8.useRef(void 0);
  const set = React8.useCallback((fn, delay) => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
    }
    id.current = setTimer(fn, delay);
    return id.current;
  }, [
    cancelTimer,
    setTimer
  ]);
  const cancel = React8.useCallback(() => {
    if (id.current !== void 0) {
      cancelTimer(id.current);
      id.current = void 0;
    }
  }, [
    cancelTimer
  ]);
  React8.useEffect(() => cancel, [
    cancel
  ]);
  return [
    set,
    cancel
  ];
}

// node_modules/@fluentui/react-shared-contexts/lib/ThemeContext/ThemeContext.js
var React9 = __toESM(require_react());
var ThemeContext = React9.createContext(void 0);
var ThemeProvider = ThemeContext.Provider;

// node_modules/@fluentui/react-shared-contexts/lib/ThemeClassNameContext/ThemeClassNameContext.js
var React10 = __toESM(require_react());
var ThemeClassNameContext = React10.createContext(void 0);
var themeClassNameContextDefaultVaue = "";
var ThemeClassNameProvider = ThemeClassNameContext.Provider;
function useThemeClassName() {
  var _React_useContext;
  return (_React_useContext = React10.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
}

// node_modules/@fluentui/react-shared-contexts/lib/TooltipVisibilityContext/TooltipContext.js
var React11 = __toESM(require_react());
var TooltipVisibilityContext = React11.createContext(void 0);
var tooltipVisibilityContextDefaultValue = {};
var TooltipVisibilityProvider = TooltipVisibilityContext.Provider;
function useTooltipVisibility() {
  var _React_useContext;
  return (_React_useContext = React11.useContext(TooltipVisibilityContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tooltipVisibilityContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/ProviderContext/ProviderContext.js
var React12 = __toESM(require_react());
var ProviderContext = React12.createContext(void 0);
var providerContextDefaultValue = {
  // eslint-disable-next-line @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )
  targetDocument: typeof document === "object" ? document : void 0,
  dir: "ltr"
};
var Provider = ProviderContext.Provider;
function useFluent() {
  var _React_useContext;
  return (_React_useContext = React12.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
}

// node_modules/@fluentui/react-shared-contexts/lib/OverridesContext/OverridesContext.js
var React13 = __toESM(require_react());
var OverridesContext = React13.createContext(void 0);
var OverridesProvider = OverridesContext.Provider;
function useOverrides() {
  var _React_useContext;
  return (_React_useContext = React13.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
}

// node_modules/@fluentui/react-shared-contexts/lib/CustomStyleHooksContext/CustomStyleHooksContext.js
var React14 = __toESM(require_react());
var CustomStyleHooksContext = React14.createContext(void 0);
var noop = () => {
};
var CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
var useCustomStyleHook = (hook) => {
  var _React_useContext;
  var _React_useContext_hook;
  return (_React_useContext_hook = (_React_useContext = React14.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop;
};

// node_modules/@fluentui/react-shared-contexts/lib/BackgroundAppearanceContext/BackgroundAppearanceContext.js
var React15 = __toESM(require_react());
var BackgroundAppearanceContext = React15.createContext(void 0);
var BackgroundAppearanceProvider = BackgroundAppearanceContext.Provider;
function useBackgroundAppearance() {
  return React15.useContext(BackgroundAppearanceContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/PortalMountNodeContext.js
var React16 = __toESM(require_react());
var PortalMountNodeContext = React16.createContext(void 0);
var PortalMountNodeProvider = PortalMountNodeContext.Provider;
function usePortalMountNode() {
  return React16.useContext(PortalMountNodeContext);
}

// node_modules/@fluentui/react-shared-contexts/lib/AnnounceContext/AnnounceContext.js
var React17 = __toESM(require_react());
var AnnounceContext = React17.createContext(void 0);
var AnnounceProvider = AnnounceContext.Provider;
function useAnnounce() {
  var _React_useContext;
  return (_React_useContext = React17.useContext(AnnounceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {
    announce: () => void 0
  };
}

// node_modules/@fluentui/react-utilities/lib/hooks/useAnimationFrame.js
var setAnimationFrameNoop = (callback) => {
  callback(0);
  return 0;
};
var cancelAnimationFrameNoop = (handle) => handle;
function useAnimationFrame() {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const setAnimationFrame = win ? win.requestAnimationFrame : setAnimationFrameNoop;
  const clearAnimationFrame = win ? win.cancelAnimationFrame : cancelAnimationFrameNoop;
  return useBrowserTimer(setAnimationFrame, clearAnimationFrame);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useApplyScrollbarWidth.js
var React18 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/measureScrollBarWidth.js
function measureScrollbarWidth(targetDocument) {
  const outer = targetDocument.createElement("div");
  outer.style.visibility = "hidden";
  outer.style.overflow = "scroll";
  const inner = targetDocument.createElement("div");
  outer.appendChild(inner);
  targetDocument.body.appendChild(outer);
  const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
  outer.remove();
  return scrollbarWidth;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useApplyScrollbarWidth.js
var cache = /* @__PURE__ */ new WeakMap();
function useApplyScrollbarWidth(options = {}) {
  const { force, property = "width" } = options;
  const applyScrollbarWidth = React18.useCallback((element) => {
    if (!element) {
      return;
    }
    if (!force && cache.has(element.ownerDocument)) {
      const cachedWidth = cache.get(element.ownerDocument);
      if (cachedWidth !== void 0) {
        element.style.setProperty(property, `${cachedWidth}px`);
        return;
      }
    }
    const scrollbarWidth = measureScrollbarWidth(element.ownerDocument);
    cache.set(element.ownerDocument, scrollbarWidth);
    element.style.setProperty(property, `${scrollbarWidth}px`);
  }, [
    force,
    property
  ]);
  return applyScrollbarWidth;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useControllableState.js
var React19 = __toESM(require_react());
function isFactoryDispatch(newState) {
  return typeof newState === "function";
}
var useControllableState = (options) => {
  "use no memo";
  if (true) {
    if (options.state !== void 0 && options.defaultState !== void 0) {
      console.error(`@fluentui/react-utilities [useControllableState]:
A component must be either controlled or uncontrolled (specify either the state or the defaultState, but not both).
Decide between using a controlled or uncontrolled component and remove one of this props.
More info: https://reactjs.org/link/controlled-components
${new Error().stack}`);
    }
  }
  const [internalState, setInternalState] = React19.useState(() => {
    if (options.defaultState === void 0) {
      return options.initialState;
    }
    return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
  });
  const stateValueRef = React19.useRef(options.state);
  React19.useEffect(() => {
    stateValueRef.current = options.state;
  }, [
    options.state
  ]);
  const setControlledState = React19.useCallback((newState) => {
    if (isFactoryDispatch(newState)) {
      newState(stateValueRef.current);
    }
  }, []);
  return useIsControlled(options.state) ? [
    options.state,
    setControlledState
  ] : [
    internalState,
    setInternalState
  ];
};
function isInitializer(value) {
  return typeof value === "function";
}
var useIsControlled = (controlledValue) => {
  "use no memo";
  const [isControlled] = React19.useState(() => controlledValue !== void 0);
  if (true) {
    React19.useEffect(() => {
      if (isControlled !== (controlledValue !== void 0)) {
        const error = new Error();
        const controlWarning = isControlled ? "a controlled value to be uncontrolled" : "an uncontrolled value to be controlled";
        const undefinedWarning = isControlled ? "defined to an undefined" : "undefined to a defined";
        console.error(`@fluentui/react-utilities [useControllableState]:
A component is changing ${controlWarning}. This is likely caused by the value changing from ${undefinedWarning} value, which should not happen.
Decide between using a controlled or uncontrolled input element for the lifetime of the component.
More info: https://reactjs.org/link/controlled-components
${error.stack}`);
      }
    }, [
      isControlled,
      controlledValue
    ]);
  }
  return isControlled;
};

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var React22 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var React21 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/ssr/canUseDOM.js
function canUseDOM() {
  return (
    /* eslint-disable @nx/workspace-no-restricted-globals -- expected ignore ( SSR friendly acquisition of globals )*/
    typeof window !== "undefined" && !!(window.document && // eslint-disable-next-line @typescript-eslint/no-deprecated
    window.document.createElement)
  );
}

// node_modules/@fluentui/react-utilities/lib/ssr/SSRContext.js
var React20 = __toESM(require_react());
var defaultSSRContextValue = {
  current: 0
};
var SSRContext = React20.createContext(void 0);
function useSSRContext() {
  var _React_useContext;
  return (_React_useContext = React20.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
}
var SSRProvider = (props) => {
  const [value] = React20.useState(() => ({
    current: 0
  }));
  return React20.createElement(SSRContext.Provider, {
    value
  }, props.children);
};
function useIsSSR() {
  const isInSSRContext = useSSRContext() !== defaultSSRContextValue;
  const [isSSR, setIsSSR] = React20.useState(isInSSRContext);
  if (true) {
    if (!isInSSRContext && !canUseDOM()) {
      console.error(`@fluentui/react-components [${useIsSSR.name}]:
When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.


Check documentation at https://aka.ms/fluentui-ssr.`);
    }
  }
  if (canUseDOM() && isInSSRContext) {
    React20.useLayoutEffect(() => {
      setIsSSR(false);
    }, []);
  }
  return isSSR;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = canUseDOM() ? React21.useLayoutEffect : React21.useEffect;

// node_modules/@fluentui/react-utilities/lib/hooks/useEventCallback.js
var useEventCallback = (fn) => {
  const callbackRef = React22.useRef(() => {
    throw new Error("Cannot call an event handler while rendering");
  });
  useIsomorphicLayoutEffect(() => {
    callbackRef.current = fn;
  }, [
    fn
  ]);
  return React22.useCallback((...args) => {
    const callback = callbackRef.current;
    return callback(...args);
  }, [
    callbackRef
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useFirstMount.js
var React23 = __toESM(require_react());
function useFirstMount() {
  const isFirst = React23.useRef(true);
  React23.useEffect(() => {
    if (isFirst.current) {
      isFirst.current = false;
    }
  }, []);
  return isFirst.current;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useForceUpdate.js
var React24 = __toESM(require_react());
function useForceUpdate() {
  return React24.useReducer((x) => x + 1, 0)[1];
}

// node_modules/@fluentui/react-utilities/lib/hooks/useId.js
var React25 = __toESM(require_react());
var IdPrefixContext = React25.createContext(void 0);
var IdPrefixProvider = IdPrefixContext.Provider;
function useIdPrefix() {
  return React25.useContext(IdPrefixContext) || "";
}
function resetIdsForTests() {
  defaultSSRContextValue.current = 0;
}
function useId2(prefix = "fui-", providedId) {
  "use no memo";
  const contextValue = useSSRContext();
  const idPrefix = useIdPrefix();
  const _useId = React25["useId"];
  if (_useId) {
    const generatedId = _useId();
    const escapedId = React25.useMemo(() => generatedId.replace(/:/g, ""), [
      generatedId
    ]);
    return providedId || `${idPrefix}${prefix}${escapedId}`;
  }
  return React25.useMemo(() => {
    if (providedId) {
      return providedId;
    }
    return `${idPrefix}${prefix}${++contextValue.current}`;
  }, [
    idPrefix,
    prefix,
    providedId,
    contextValue
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useMergedRefs.js
var React26 = __toESM(require_react());
function useMergedRefs(...refs) {
  "use no memo";
  const mergedCallback = React26.useCallback(
    (value) => {
      mergedCallback.current = value;
      for (const ref of refs) {
        if (typeof ref === "string" && true) {
          console.error(`@fluentui/react-utilities [useMergedRefs]:
This hook does not support the usage of string refs. Please use React.useRef instead.

For more info on 'React.useRef', see https://react.dev/reference/react/useRef.
For more info on string refs, see https://react.dev/blog/2024/04/25/react-19-upgrade-guide#removed-string-refs.`);
        }
        if (typeof ref === "function") {
          ref(value);
        } else if (ref) {
          ref.current = value;
        }
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
    [
      ...refs
    ]
  );
  return mergedCallback;
}

// node_modules/@fluentui/react-utilities/lib/hooks/useOnClickOutside.js
var React27 = __toESM(require_react());
var DEFAULT_CONTAINS = (parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child));
var useOnClickOutside = (options) => {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const { refs, callback, element, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
  const timeoutId = React27.useRef(void 0);
  useIFrameFocus({
    element,
    disabled: disabledFocusOnIframe || disabled,
    callback,
    refs,
    contains
  });
  const isMouseDownInsideRef = React27.useRef(false);
  const listener = useEventCallback((ev) => {
    if (isMouseDownInsideRef.current) {
      isMouseDownInsideRef.current = false;
      return;
    }
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  const handleMouseDown = useEventCallback((ev) => {
    isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
  });
  React27.useEffect(() => {
    if (disabled) {
      return;
    }
    let currentEvent = getWindowEvent(win);
    const conditionalHandler = (event) => {
      if (event === currentEvent) {
        currentEvent = void 0;
        return;
      }
      listener(event);
    };
    element === null || element === void 0 ? void 0 : element.addEventListener("click", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchstart", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("contextmenu", conditionalHandler, true);
    element === null || element === void 0 ? void 0 : element.addEventListener("mousedown", handleMouseDown, true);
    timeoutId.current = win === null || win === void 0 ? void 0 : win.setTimeout(() => {
      currentEvent = void 0;
    }, 1);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("click", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchstart", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("contextmenu", conditionalHandler, true);
      element === null || element === void 0 ? void 0 : element.removeEventListener("mousedown", handleMouseDown, true);
      win === null || win === void 0 ? void 0 : win.clearTimeout(timeoutId.current);
      currentEvent = void 0;
    };
  }, [
    listener,
    element,
    disabled,
    handleMouseDown,
    win
  ]);
};
var getWindowEvent = (target) => {
  if (target) {
    var _target_ownerDocument_defaultView, _target_ownerDocument;
    if (typeof target.window === "object" && target.window === target) {
      return target.event;
    }
    var _target_ownerDocument_defaultView_event;
    return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
  }
  return void 0;
};
var FUI_FRAME_EVENT = "fuiframefocus";
var useIFrameFocus = (options) => {
  const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 100, refs } = options;
  const timeoutRef = React27.useRef(void 0);
  const listener = useEventCallback((e) => {
    const isOutside = refs.every((ref) => !contains(ref.current || null, e.target));
    if (isOutside && !disabled) {
      callback(e);
    }
  });
  React27.useEffect(() => {
    if (disabled) {
      return;
    }
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
    return () => {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
    };
  }, [
    targetDocument,
    disabled,
    listener
  ]);
  React27.useEffect(() => {
    var _targetDocument_defaultView;
    if (disabled) {
      return;
    }
    timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
      const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
      if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
        const event = new CustomEvent(FUI_FRAME_EVENT, {
          bubbles: true
        });
        activeElement.dispatchEvent(event);
      }
    }, pollDuration);
    return () => {
      var _targetDocument_defaultView2;
      targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.clearInterval(timeoutRef.current);
    };
  }, [
    targetDocument,
    disabled,
    pollDuration
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/useOnScrollOutside.js
var React28 = __toESM(require_react());
var useOnScrollOutside = (options) => {
  const { refs, callback, element, disabled, contains: containsProp } = options;
  const listener = useEventCallback((ev) => {
    const contains = containsProp || ((parent2, child) => !!(parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child)));
    const target = ev.composedPath()[0];
    const isOutside = refs.every((ref) => !contains(ref.current || null, target));
    if (isOutside && !disabled) {
      callback(ev);
    }
  });
  React28.useEffect(() => {
    if (disabled) {
      return;
    }
    element === null || element === void 0 ? void 0 : element.addEventListener("wheel", listener);
    element === null || element === void 0 ? void 0 : element.addEventListener("touchmove", listener);
    return () => {
      element === null || element === void 0 ? void 0 : element.removeEventListener("wheel", listener);
      element === null || element === void 0 ? void 0 : element.removeEventListener("touchmove", listener);
    };
  }, [
    listener,
    element,
    disabled
  ]);
};

// node_modules/@fluentui/react-utilities/lib/hooks/usePrevious.js
var React29 = __toESM(require_react());
var usePrevious = (value) => {
  const ref = React29.useRef(null);
  React29.useEffect(() => {
    ref.current = value;
  }, [
    value
  ]);
  return ref.current;
};

// node_modules/@fluentui/react-utilities/lib/hooks/useScrollbarWidth.js
var React30 = __toESM(require_react());
var cache2 = /* @__PURE__ */ new WeakMap();
function useScrollbarWidth(options) {
  const { targetDocument, force } = options;
  return React30.useMemo(() => {
    if (!targetDocument) {
      return 0;
    }
    if (!force && cache2.has(targetDocument)) {
      return cache2.get(targetDocument);
    }
    const scrollbarWidth = measureScrollbarWidth(targetDocument);
    cache2.set(targetDocument, scrollbarWidth);
    return scrollbarWidth;
  }, [
    targetDocument,
    force
  ]);
}

// node_modules/@fluentui/react-utilities/lib/hooks/useTimeout.js
var setTimeoutNoop = (_callback) => -1;
var clearTimeoutNoop = (_handle) => void 0;
function useTimeout() {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const setTimerFn = win ? win.setTimeout : setTimeoutNoop;
  const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop;
  return useBrowserTimer(setTimerFn, clearTimerFn);
}

// node_modules/@fluentui/react-utilities/lib/utils/clamp.js
var clamp = (value, min2, max2) => Math.max(min2, Math.min(max2, value || 0));

// node_modules/@fluentui/react-utilities/lib/utils/getReactElementRef.js
var React31 = __toESM(require_react());
var IS_REACT_19_OR_HIGHER = parseInt(React31.version, 10) >= 19;
function getReactElementRef(element) {
  if (!element) {
    return void 0;
  }
  if (IS_REACT_19_OR_HIGHER) {
    return element.props.ref;
  }
  return element.ref;
}

// node_modules/@fluentui/react-utilities/lib/utils/getRTLSafeKey.js
var getRTLSafeKey = (key, dir) => {
  if (dir === "rtl") {
    switch (key) {
      case "ArrowLeft": {
        return "ArrowRight";
      }
      case "ArrowRight": {
        return "ArrowLeft";
      }
    }
  }
  return key;
};

// node_modules/@fluentui/react-utilities/lib/utils/mergeCallbacks.js
function mergeCallbacks(callback1, callback2) {
  return (...args) => {
    callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
    callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
  };
}

// node_modules/@fluentui/react-utilities/lib/utils/isHTMLElement.js
function isHTMLElement(element, options) {
  var _typedElement_ownerDocument;
  const typedElement = element;
  var _options_constructorName;
  return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
}

// node_modules/@fluentui/react-utilities/lib/utils/isInteractiveHTMLElement.js
function isInteractiveHTMLElement(element) {
  if (!isHTMLElement(element)) {
    return false;
  }
  const { tagName } = element;
  switch (tagName) {
    case "BUTTON":
    case "A":
    case "INPUT":
    case "TEXTAREA":
      return true;
  }
  return element.isContentEditable;
}

// node_modules/@fluentui/react-utilities/lib/utils/priorityQueue.js
function createPriorityQueue(compare) {
  const arr = [];
  let size3 = 0;
  const swap = (a, b) => {
    const tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
  };
  const heapify = (i) => {
    let smallest = i;
    const l = left(i);
    const r = right(i);
    if (l < size3 && compare(arr[l], arr[smallest]) < 0) {
      smallest = l;
    }
    if (r < size3 && compare(arr[r], arr[smallest]) < 0) {
      smallest = r;
    }
    if (smallest !== i) {
      swap(smallest, i);
      heapify(smallest);
    }
  };
  const dequeue = () => {
    if (size3 === 0) {
      throw new Error("Priority queue empty");
    }
    const res = arr[0];
    arr[0] = arr[--size3];
    heapify(0);
    return res;
  };
  const peek = () => {
    if (size3 === 0) {
      return null;
    }
    return arr[0];
  };
  const enqueue = (item) => {
    arr[size3++] = item;
    let i = size3 - 1;
    let p = parent(i);
    while (i > 0 && compare(arr[p], arr[i]) > 0) {
      swap(p, i);
      i = p;
      p = parent(i);
    }
  };
  const contains = (item) => {
    const index = arr.indexOf(item);
    return index >= 0 && index < size3;
  };
  const remove = (item) => {
    const i = arr.indexOf(item);
    if (i === -1 || i >= size3) {
      return;
    }
    arr[i] = arr[--size3];
    heapify(i);
  };
  const clear = () => {
    size3 = 0;
  };
  const all = () => {
    return arr.slice(0, size3);
  };
  return {
    all,
    clear,
    contains,
    dequeue,
    enqueue,
    peek,
    remove,
    size: () => size3
  };
}
var left = (i) => {
  return 2 * i + 1;
};
var right = (i) => {
  return 2 * i + 2;
};
var parent = (i) => {
  return Math.floor((i - 1) / 2);
};

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
var React33 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/trigger/isFluentTrigger.js
var React32 = __toESM(require_react());
function isFluentTrigger(element) {
  return Boolean(element.type.isFluentTriggerComponent);
}

// node_modules/@fluentui/react-utilities/lib/trigger/applyTriggerPropsToChildren.js
function applyTriggerPropsToChildren(children, triggerChildProps) {
  if (typeof children === "function") {
    return children(triggerChildProps);
  } else if (children) {
    return cloneTriggerTree(children, triggerChildProps);
  }
  return children || null;
}
function cloneTriggerTree(child, triggerProps) {
  if (!React33.isValidElement(child) || child.type === React33.Fragment) {
    throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
  }
  if (isFluentTrigger(child)) {
    const grandchild = cloneTriggerTree(child.props.children, triggerProps);
    return React33.cloneElement(child, void 0, grandchild);
  } else {
    return React33.cloneElement(child, triggerProps);
  }
}

// node_modules/@fluentui/react-utilities/lib/trigger/getTriggerChild.js
var React34 = __toESM(require_react());
function getTriggerChild(children) {
  if (!React34.isValidElement(children)) {
    return null;
  }
  return isFluentTrigger(children) ? getTriggerChild(
    // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
    // but for some reason it's failing on build
    children.props.children
  ) : children;
}

// node_modules/@fluentui/react-utilities/lib/events/mouseTouchHelpers.js
var React35 = __toESM(require_react());
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse") || [
    "click",
    "contextmenu",
    "dblclick"
  ].indexOf(event.type) > -1;
}
function getEventClientCoords(event) {
  if (isMouseEvent(event)) {
    return {
      clientX: event.clientX,
      clientY: event.clientY
    };
  } else if (isTouchEvent(event)) {
    return {
      clientX: event.touches[0].clientX,
      clientY: event.touches[0].clientY
    };
  } else {
    if (true) {
      throw new Error("@fluentui/react-utilities]: Unable to get clientX. Unknown event type.");
    }
    return {
      clientX: 0,
      clientY: 0
    };
  }
}

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
var React36 = __toESM(require_react());

// node_modules/@fluentui/react-utilities/lib/utils/createSetFromIterable.js
function createSetFromIterable(iterable) {
  return iterable instanceof Set ? iterable : new Set(iterable);
}

// node_modules/@fluentui/react-utilities/lib/selection/useSelection.js
function useSelectionState(params) {
  const [selected, setSelected] = useControllableState({
    initialState: /* @__PURE__ */ new Set(),
    defaultState: React36.useMemo(() => params.defaultSelectedItems && createSetFromIterable(params.defaultSelectedItems), [
      params.defaultSelectedItems
    ]),
    state: React36.useMemo(() => params.selectedItems && createSetFromIterable(params.selectedItems), [
      params.selectedItems
    ])
  });
  const changeSelection = (event, nextSelectedItems) => {
    var _params_onSelectionChange;
    (_params_onSelectionChange = params.onSelectionChange) === null || _params_onSelectionChange === void 0 ? void 0 : _params_onSelectionChange.call(params, event, {
      selectedItems: nextSelectedItems
    });
    setSelected(nextSelectedItems);
  };
  return [
    selected,
    changeSelection
  ];
}
function useSingleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    deselectItem: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    selectItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    toggleAllItems: () => {
      if (true) {
        throw new Error("[react-utilities]: `toggleAllItems` should not be used in single selection mode");
      }
    },
    toggleItem: (event, itemId) => changeSelection(event, /* @__PURE__ */ new Set([
      itemId
    ])),
    clearItems: (event) => changeSelection(event, /* @__PURE__ */ new Set()),
    isSelected: (itemId) => {
      var _selected_has;
      return (_selected_has = selected.has(itemId)) !== null && _selected_has !== void 0 ? _selected_has : false;
    }
  };
  return [
    selected,
    methods
  ];
}
function useMultipleSelection(params) {
  const [selected, changeSelection] = useSelectionState(params);
  const methods = {
    toggleItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      if (selected.has(itemId)) {
        nextSelectedItems.delete(itemId);
      } else {
        nextSelectedItems.add(itemId);
      }
      changeSelection(event, nextSelectedItems);
    },
    selectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.add(itemId);
      changeSelection(event, nextSelectedItems);
    },
    deselectItem: (event, itemId) => {
      const nextSelectedItems = new Set(selected);
      nextSelectedItems.delete(itemId);
      changeSelection(event, nextSelectedItems);
    },
    clearItems: (event) => {
      changeSelection(event, /* @__PURE__ */ new Set());
    },
    isSelected: (itemId) => selected.has(itemId),
    toggleAllItems: (event, itemIds) => {
      const allItemsSelected = itemIds.every((itemId) => selected.has(itemId));
      const nextSelectedItems = new Set(selected);
      if (allItemsSelected) {
        nextSelectedItems.clear();
      } else {
        itemIds.forEach((itemId) => nextSelectedItems.add(itemId));
      }
      changeSelection(event, nextSelectedItems);
    }
  };
  return [
    selected,
    methods
  ];
}
function useSelection(params) {
  "use no memo";
  if (params.selectionMode === "multiselect") {
    return useMultipleSelection(params);
  }
  return useSingleSelection(params);
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/isVirtualElement.js
function isVirtualElement(element) {
  return element && !!element._virtual;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/getParent.js
function getVirtualParent(child) {
  return isVirtualElement(child) ? child._virtual.parent || null : null;
}
function getParent(child, options = {}) {
  if (!child) {
    return null;
  }
  if (!options.skipVirtual) {
    const virtualParent = getVirtualParent(child);
    if (virtualParent) {
      return virtualParent;
    }
  }
  const parent2 = child.parentNode;
  if (parent2 && parent2.nodeType === 11) {
    return parent2.host;
  }
  return parent2;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/elementContains.js
function elementContains(parent2, child) {
  if (!parent2 || !child) {
    return false;
  }
  if (parent2 === child) {
    return true;
  } else {
    const set = /* @__PURE__ */ new WeakSet();
    while (child) {
      const nextParent = getParent(child, {
        skipVirtual: set.has(child)
      });
      set.add(child);
      if (nextParent === parent2) {
        return true;
      }
      child = nextParent;
    }
  }
  return false;
}

// node_modules/@fluentui/react-utilities/lib/virtualParent/setVirtualParent.js
function setVirtualParent(child, parent2) {
  if (!child) {
    return;
  }
  Object.assign(child, {
    _virtual: {
      parent: parent2
    }
  });
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
var React39 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/createCompatSlotComponent.js
var React37 = __toESM(require_react());
function createCompatSlotComponent(type, props) {
  return {
    ...props,
    [SLOT_ELEMENT_TYPE_SYMBOL]: type
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/warnIfElementTypeIsInvalid.js
var React38 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
function warnIfElementTypeIsInvalid(type) {
  if (typeof type === "object" && !(0, import_react_is.isValidElementType)(type)) {
    console.error(`@fluentui/react-jsx-runtime:
Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: ${type}.

If this happened in a slot of Fluent UI component, you might be facing package resolution issues.
Please make sure you don't have multiple versions of "@fluentui/react-utilities" installed in your dependencies or sub-dependencies.
You can check this by searching up for matching entries in a lockfile produced by your package manager (yarn.lock, pnpm-lock.yaml or package-lock.json).`);
  }
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/createJSX.js
function createJSX(runtime, slotRuntime) {
  return function jsx2(type, overrideProps, key, source, self) {
    if (isSlot(overrideProps)) {
      return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self);
    }
    if (isSlot(type)) {
      return slotRuntime(type, overrideProps, key, source, self);
    }
    warnIfElementTypeIsInvalid(type);
    return runtime(type, overrideProps, key, source, self);
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var React40 = __toESM(require_react());

// node_modules/@fluentui/react-jsx-runtime/lib/utils/getMetadataFromSlotComponent.js
function getMetadataFromSlotComponent(type) {
  const { as, [SLOT_CLASS_NAME_PROP_SYMBOL]: _classNameProp, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
  const props = propsWithoutMetadata;
  const elementType = typeof baseElementType === "string" ? as !== null && as !== void 0 ? as : baseElementType : baseElementType;
  if (typeof elementType !== "string" && as) {
    props.as = as;
  }
  return {
    elementType,
    props,
    renderFunction
  };
}

// node_modules/@fluentui/react-jsx-runtime/lib/utils/Runtime.js
var ReactRuntime = __toESM(require_jsx_runtime());
var Runtime = ReactRuntime;

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxSlot.js
var jsxSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React40.Fragment, {
      children: renderFunction(elementType, props)
    }, key);
  }
  return Runtime.jsx(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx/jsxsSlot.js
var React41 = __toESM(require_react());
var jsxsSlot = (type, overrideProps, key) => {
  const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
  const props = {
    ...slotProps,
    ...overrideProps
  };
  if (renderFunction) {
    return Runtime.jsx(React41.Fragment, {
      children: renderFunction(elementType, {
        ...props,
        children: Runtime.jsxs(React41.Fragment, {
          children: props.children
        }, void 0)
      })
    }, key);
  }
  return Runtime.jsxs(elementType, props, key);
};

// node_modules/@fluentui/react-jsx-runtime/lib/jsx-runtime.js
var import_react = __toESM(require_react());
var jsx = createJSX(Runtime.jsx, jsxSlot);
var jsxs = createJSX(Runtime.jsxs, jsxsSlot);

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/renderFluentProvider.js
var renderFluentProvider_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(Provider, {
    value: contextValues.provider,
    children: jsx(ThemeProvider, {
      value: contextValues.theme,
      children: jsx(ThemeClassNameProvider, {
        value: contextValues.themeClassName,
        children: jsx(CustomStyleHooksProvider, {
          value: contextValues.customStyleHooks_unstable,
          children: jsx(TooltipVisibilityProvider, {
            value: contextValues.tooltip,
            children: jsx(TextDirectionProvider, {
              dir: contextValues.textDirection,
              children: jsx(IconDirectionContextProvider, {
                value: contextValues.iconDirection,
                children: jsx(OverridesProvider, {
                  value: contextValues.overrides_unstable,
                  children: jsxs(state.root, {
                    children: [
                      canUseDOM() ? null : jsx("style", {
                        // Using dangerous HTML because react can escape characters
                        // which can lead to invalid CSS.
                        // eslint-disable-next-line react/no-danger
                        dangerouslySetInnerHTML: {
                          __html: state.serverStyleProps.cssRule
                        },
                        ...state.serverStyleProps.attributes
                      }),
                      state.root.children
                    ]
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};

// node_modules/keyborg/dist/esm/index.js
var _canUseWeakRef = typeof WeakRef !== "undefined";
var WeakRefInstance = class {
  constructor(instance) {
    if (_canUseWeakRef && typeof instance === "object") {
      this._weakRef = new WeakRef(instance);
    } else {
      this._instance = instance;
    }
  }
  /**
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
   */
  deref() {
    var _a, _b;
    let instance;
    if (this._weakRef) {
      instance = (_a = this._weakRef) == null ? void 0 : _a.deref();
      if (!instance) {
        delete this._weakRef;
      }
    } else {
      instance = this._instance;
      if ((_b = instance == null ? void 0 : instance.isDisposed) == null ? void 0 : _b.call(instance)) {
        delete this._instance;
      }
    }
    return instance;
  }
};
var KEYBORG_FOCUSIN = "keyborg:focusin";
var KEYBORG_FOCUSOUT = "keyborg:focusout";
function canOverrideNativeFocus(win) {
  const HTMLElement2 = win.HTMLElement;
  const origFocus = HTMLElement2.prototype.focus;
  let isCustomFocusCalled = false;
  HTMLElement2.prototype.focus = function focus() {
    isCustomFocusCalled = true;
  };
  const btn = win.document.createElement("button");
  btn.focus();
  HTMLElement2.prototype.focus = origFocus;
  return isCustomFocusCalled;
}
var _canOverrideNativeFocus = false;
function nativeFocus(element) {
  const focus = element.focus;
  if (focus.__keyborgNativeFocus) {
    focus.__keyborgNativeFocus.call(element);
  } else {
    element.focus();
  }
}
function setupFocusEvent(win) {
  const kwin = win;
  if (!_canOverrideNativeFocus) {
    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
  }
  const origFocus = kwin.HTMLElement.prototype.focus;
  if (origFocus.__keyborgNativeFocus) {
    return;
  }
  kwin.HTMLElement.prototype.focus = focus;
  const shadowTargets = /* @__PURE__ */ new Set();
  const focusOutHandler = (e) => {
    const target = e.target;
    if (!target) {
      return;
    }
    const event = new CustomEvent(KEYBORG_FOCUSOUT, {
      cancelable: true,
      bubbles: true,
      // Allows the event to bubble past an open shadow root
      composed: true,
      detail: {
        originalEvent: e
      }
    });
    target.dispatchEvent(event);
  };
  const focusInHandler = (e) => {
    const target = e.target;
    if (!target) {
      return;
    }
    let node = e.composedPath()[0];
    const currentShadows = /* @__PURE__ */ new Set();
    while (node) {
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        currentShadows.add(node);
        node = node.host;
      } else {
        node = node.parentNode;
      }
    }
    for (const shadowRootWeakRef of shadowTargets) {
      const shadowRoot = shadowRootWeakRef.deref();
      if (!shadowRoot || !currentShadows.has(shadowRoot)) {
        shadowTargets.delete(shadowRootWeakRef);
        if (shadowRoot) {
          shadowRoot.removeEventListener("focusin", focusInHandler, true);
          shadowRoot.removeEventListener("focusout", focusOutHandler, true);
        }
      }
    }
    onFocusIn(target, e.relatedTarget || void 0);
  };
  const onFocusIn = (target, relatedTarget, originalEvent) => {
    var _a;
    const shadowRoot = target.shadowRoot;
    if (shadowRoot) {
      for (const shadowRootWeakRef of shadowTargets) {
        if (shadowRootWeakRef.deref() === shadowRoot) {
          return;
        }
      }
      shadowRoot.addEventListener("focusin", focusInHandler, true);
      shadowRoot.addEventListener("focusout", focusOutHandler, true);
      shadowTargets.add(new WeakRefInstance(shadowRoot));
      return;
    }
    const details = {
      relatedTarget,
      originalEvent
    };
    const event = new CustomEvent(KEYBORG_FOCUSIN, {
      cancelable: true,
      bubbles: true,
      // Allows the event to bubble past an open shadow root
      composed: true,
      detail: details
    });
    event.details = details;
    if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
      details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) == null ? void 0 : _a.deref());
      data.lastFocusedProgrammatically = void 0;
    }
    target.dispatchEvent(event);
  };
  const data = kwin.__keyborgData = {
    focusInHandler,
    focusOutHandler,
    shadowTargets
  };
  kwin.document.addEventListener(
    "focusin",
    kwin.__keyborgData.focusInHandler,
    true
  );
  kwin.document.addEventListener(
    "focusout",
    kwin.__keyborgData.focusOutHandler,
    true
  );
  function focus() {
    const keyborgNativeFocusEvent = kwin.__keyborgData;
    if (keyborgNativeFocusEvent) {
      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(
        this
      );
    }
    return origFocus.apply(this, arguments);
  }
  let activeElement = kwin.document.activeElement;
  while (activeElement && activeElement.shadowRoot) {
    onFocusIn(activeElement);
    activeElement = activeElement.shadowRoot.activeElement;
  }
  focus.__keyborgNativeFocus = origFocus;
}
function disposeFocusEvent(win) {
  const kwin = win;
  const proto = kwin.HTMLElement.prototype;
  const origFocus = proto.focus.__keyborgNativeFocus;
  const keyborgNativeFocusEvent = kwin.__keyborgData;
  if (keyborgNativeFocusEvent) {
    kwin.document.removeEventListener(
      "focusin",
      keyborgNativeFocusEvent.focusInHandler,
      true
    );
    kwin.document.removeEventListener(
      "focusout",
      keyborgNativeFocusEvent.focusOutHandler,
      true
    );
    for (const shadowRootWeakRef of keyborgNativeFocusEvent.shadowTargets) {
      const shadowRoot = shadowRootWeakRef.deref();
      if (shadowRoot) {
        shadowRoot.removeEventListener(
          "focusin",
          keyborgNativeFocusEvent.focusInHandler,
          true
        );
        shadowRoot.removeEventListener(
          "focusout",
          keyborgNativeFocusEvent.focusOutHandler,
          true
        );
      }
    }
    keyborgNativeFocusEvent.shadowTargets.clear();
    delete kwin.__keyborgData;
  }
  if (origFocus) {
    proto.focus = origFocus;
  }
}
var _dismissTimeout = 500;
var _lastId = 0;
var KeyborgCore = class {
  constructor(win, props) {
    this._isNavigatingWithKeyboard_DO_NOT_USE = false;
    this._onFocusIn = (e) => {
      if (this._isMouseOrTouchUsedTimer) {
        return;
      }
      if (this.isNavigatingWithKeyboard) {
        return;
      }
      const details = e.detail;
      if (!details.relatedTarget) {
        return;
      }
      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
        return;
      }
      this.isNavigatingWithKeyboard = true;
    };
    this._onMouseDown = (e) => {
      if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {
        return;
      }
      this._onMouseOrTouch();
    };
    this._onMouseOrTouch = () => {
      const win2 = this._win;
      if (win2) {
        if (this._isMouseOrTouchUsedTimer) {
          win2.clearTimeout(this._isMouseOrTouchUsedTimer);
        }
        this._isMouseOrTouchUsedTimer = win2.setTimeout(() => {
          delete this._isMouseOrTouchUsedTimer;
        }, 1e3);
      }
      this.isNavigatingWithKeyboard = false;
    };
    this._onKeyDown = (e) => {
      const isNavigatingWithKeyboard = this.isNavigatingWithKeyboard;
      if (isNavigatingWithKeyboard) {
        if (this._shouldDismissKeyboardNavigation(e)) {
          this._scheduleDismiss();
        }
      } else {
        if (this._shouldTriggerKeyboardNavigation(e)) {
          this.isNavigatingWithKeyboard = true;
        }
      }
    };
    this.id = "c" + ++_lastId;
    this._win = win;
    const doc = win.document;
    if (props) {
      const triggerKeys = props.triggerKeys;
      const dismissKeys = props.dismissKeys;
      if (triggerKeys == null ? void 0 : triggerKeys.length) {
        this._triggerKeys = new Set(triggerKeys);
      }
      if (dismissKeys == null ? void 0 : dismissKeys.length) {
        this._dismissKeys = new Set(dismissKeys);
      }
    }
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    doc.addEventListener("mousedown", this._onMouseDown, true);
    win.addEventListener("keydown", this._onKeyDown, true);
    doc.addEventListener("touchstart", this._onMouseOrTouch, true);
    doc.addEventListener("touchend", this._onMouseOrTouch, true);
    doc.addEventListener("touchcancel", this._onMouseOrTouch, true);
    setupFocusEvent(win);
  }
  get isNavigatingWithKeyboard() {
    return this._isNavigatingWithKeyboard_DO_NOT_USE;
  }
  set isNavigatingWithKeyboard(val) {
    if (this._isNavigatingWithKeyboard_DO_NOT_USE !== val) {
      this._isNavigatingWithKeyboard_DO_NOT_USE = val;
      this.update();
    }
  }
  dispose() {
    const win = this._win;
    if (win) {
      if (this._isMouseOrTouchUsedTimer) {
        win.clearTimeout(this._isMouseOrTouchUsedTimer);
        this._isMouseOrTouchUsedTimer = void 0;
      }
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      disposeFocusEvent(win);
      const doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.removeEventListener("mousedown", this._onMouseDown, true);
      win.removeEventListener("keydown", this._onKeyDown, true);
      doc.removeEventListener("touchstart", this._onMouseOrTouch, true);
      doc.removeEventListener("touchend", this._onMouseOrTouch, true);
      doc.removeEventListener("touchcancel", this._onMouseOrTouch, true);
      delete this._win;
    }
  }
  isDisposed() {
    return !!this._win;
  }
  /**
   * Updates all keyborg instances with the keyboard navigation state
   */
  update() {
    var _a, _b;
    const keyborgs = (_b = (_a = this._win) == null ? void 0 : _a.__keyborg) == null ? void 0 : _b.refs;
    if (keyborgs) {
      for (const id of Object.keys(keyborgs)) {
        Keyborg.update(keyborgs[id], this.isNavigatingWithKeyboard);
      }
    }
  }
  /**
   * @returns whether the keyboard event should trigger keyboard navigation mode
   */
  _shouldTriggerKeyboardNavigation(e) {
    var _a;
    if (e.key === "Tab") {
      return true;
    }
    const activeElement = (_a = this._win) == null ? void 0 : _a.document.activeElement;
    const isTriggerKey = !this._triggerKeys || this._triggerKeys.has(e.keyCode);
    const isEditable = activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable);
    return isTriggerKey && !isEditable;
  }
  /**
   * @returns whether the keyboard event should dismiss keyboard navigation mode
   */
  _shouldDismissKeyboardNavigation(e) {
    var _a;
    return (_a = this._dismissKeys) == null ? void 0 : _a.has(e.keyCode);
  }
  _scheduleDismiss() {
    const win = this._win;
    if (win) {
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = void 0;
      }
      const was = win.document.activeElement;
      this._dismissTimer = win.setTimeout(() => {
        this._dismissTimer = void 0;
        const cur = win.document.activeElement;
        if (was && cur && was === cur) {
          this.isNavigatingWithKeyboard = false;
        }
      }, _dismissTimeout);
    }
  }
};
var Keyborg = class _Keyborg {
  constructor(win, props) {
    this._cb = [];
    this._id = "k" + ++_lastId;
    this._win = win;
    const current = win.__keyborg;
    if (current) {
      this._core = current.core;
      current.refs[this._id] = this;
    } else {
      this._core = new KeyborgCore(win, props);
      win.__keyborg = {
        core: this._core,
        refs: { [this._id]: this }
      };
    }
  }
  static create(win, props) {
    return new _Keyborg(win, props);
  }
  static dispose(instance) {
    instance.dispose();
  }
  /**
   * Updates all subscribed callbacks with the keyboard navigation state
   */
  static update(instance, isNavigatingWithKeyboard) {
    instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
  }
  dispose() {
    var _a;
    const current = (_a = this._win) == null ? void 0 : _a.__keyborg;
    if (current == null ? void 0 : current.refs[this._id]) {
      delete current.refs[this._id];
      if (Object.keys(current.refs).length === 0) {
        current.core.dispose();
        delete this._win.__keyborg;
      }
    } else if (true) {
      console.error(
        `Keyborg instance ${this._id} is being disposed incorrectly.`
      );
    }
    this._cb = [];
    delete this._core;
    delete this._win;
  }
  /**
   * @returns Whether the user is navigating with keyboard
   */
  isNavigatingWithKeyboard() {
    var _a;
    return !!((_a = this._core) == null ? void 0 : _a.isNavigatingWithKeyboard);
  }
  /**
   * @param callback - Called when the keyboard navigation state changes
   */
  subscribe(callback) {
    this._cb.push(callback);
  }
  /**
   * @param callback - Registered with subscribe
   */
  unsubscribe(callback) {
    const index = this._cb.indexOf(callback);
    if (index >= 0) {
      this._cb.splice(index, 1);
    }
  }
  /**
   * Manually set the keyboard navigtion state
   */
  setVal(isNavigatingWithKeyboard) {
    if (this._core) {
      this._core.isNavigatingWithKeyboard = isNavigatingWithKeyboard;
    }
  }
};
function createKeyborg(win, props) {
  return Keyborg.create(win, props);
}
function disposeKeyborg(instance) {
  Keyborg.dispose(instance);
}

// node_modules/tabster/dist/tabster.esm.js
var TABSTER_ATTRIBUTE_NAME = "data-tabster";
var TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME = "data-tabster-dummy";
var FOCUSABLE_SELECTOR = `:is(${["a[href]", "button", "input", "select", "textarea", "*[tabindex]", "*[contenteditable]", "details > summary", "audio[controls]", "video[controls]"].join(", ")}):not(:disabled)`;
var AsyncFocusSources = {
  EscapeGroupper: 1,
  Restorer: 2,
  Deloser: 3
};
var ObservedElementAccessibilities = {
  Any: 0,
  Accessible: 1,
  Focusable: 2
};
var ObservedElementRequestStatuses = {
  Waiting: 0,
  Succeeded: 1,
  Canceled: 2,
  TimedOut: 3
};
var ObservedElementFailureReasons = {
  CanceledFocusChange: 1,
  TimeoutElementNotInDOM: 2,
  TimeoutElementNotAccessible: 3,
  TimeoutElementNotFocusable: 4,
  TimeoutElementNotReady: 5,
  SupersededByNewRequest: 6,
  FocusCallFailed: 7
};
var Visibilities = {
  Invisible: 0,
  PartiallyVisible: 1,
  Visible: 2
};
var RestorerTypes = {
  Source: 0,
  Target: 1
};
var MoverDirections = {
  Both: 0,
  // Default, both left/up keys move to the previous, right/down move to the next.
  Vertical: 1,
  // Only up/down arrows move to the next/previous.
  Horizontal: 2,
  // Only left/right arrows move to the next/previous.
  Grid: 3,
  // Two-dimentional movement depending on the visual placement.
  GridLinear: 4
  // Two-dimentional movement depending on the visual placement. Allows linear movement.
};
var MoverKeys = {
  ArrowUp: 1,
  ArrowDown: 2,
  ArrowLeft: 3,
  ArrowRight: 4,
  PageUp: 5,
  PageDown: 6,
  Home: 7,
  End: 8
};
var GroupperTabbabilities = {
  Unlimited: 0,
  Limited: 1,
  // The tabbability is limited to the container and explicit Enter is needed to go inside.
  LimitedTrapFocus: 2
  // The focus is limited as above, plus trapped when inside.
};
var GroupperMoveFocusActions = {
  Enter: 1,
  Escape: 2
};
var SysDummyInputsPositions = {
  Auto: 0,
  // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.
  Inside: 1,
  // Tabster will always place dummy inputs inside the container.
  Outside: 2
  // Tabster will always place dummy inputs outside of the container.
};
function getTabsterOnElement(tabster, element) {
  var _a;
  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
}
function updateTabsterByAttribute(tabster, element, dispose) {
  var _a, _b, _c;
  const newAttrValue = dispose || tabster._noop ? void 0 : element.getAttribute(TABSTER_ATTRIBUTE_NAME);
  let entry = tabster.storageEntry(element);
  let newAttr;
  if (newAttrValue) {
    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {
      try {
        const newValue = JSON.parse(newAttrValue);
        if (typeof newValue !== "object") {
          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
        }
        newAttr = {
          string: newAttrValue,
          object: newValue
        };
      } catch (e) {
        if (true) {
          console.error(`data-tabster attribute error: ${e}`, element);
        }
      }
    } else {
      return;
    }
  } else if (!entry) {
    return;
  }
  if (!entry) {
    entry = tabster.storageEntry(element, true);
  }
  if (!entry.tabster) {
    entry.tabster = {};
  }
  const tabsterOnElement = entry.tabster || {};
  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
  for (const key of Object.keys(oldTabsterProps)) {
    if (!newTabsterProps[key]) {
      if (key === "root") {
        const root = tabsterOnElement[key];
        if (root) {
          tabster.root.onRoot(root, true);
        }
      }
      switch (key) {
        case "deloser":
        case "root":
        case "groupper":
        case "modalizer":
        case "restorer":
        case "mover":
          const part = tabsterOnElement[key];
          if (part) {
            part.dispose();
            delete tabsterOnElement[key];
          }
          break;
        case "observed":
          delete tabsterOnElement[key];
          if (tabster.observedElement) {
            tabster.observedElement.onObservedElementUpdate(element);
          }
          break;
        case "focusable":
        case "outline":
        case "uncontrolled":
        case "sys":
          delete tabsterOnElement[key];
          break;
      }
    }
  }
  for (const key of Object.keys(newTabsterProps)) {
    const sys = newTabsterProps.sys;
    switch (key) {
      case "deloser":
        if (tabsterOnElement.deloser) {
          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
        } else {
          if (tabster.deloser) {
            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);
          } else if (true) {
            console.error("Deloser API used before initialization, please call `getDeloser()`");
          }
        }
        break;
      case "root":
        if (tabsterOnElement.root) {
          tabsterOnElement.root.setProps(newTabsterProps.root);
        } else {
          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);
        }
        tabster.root.onRoot(tabsterOnElement.root);
        break;
      case "modalizer":
        {
          let newModalizerProps;
          const modalizerAPI = tabster.modalizer;
          if (tabsterOnElement.modalizer) {
            const props = newTabsterProps.modalizer;
            const newModalizerId = props.id;
            if (newModalizerId && ((_c = oldTabsterProps === null || oldTabsterProps === void 0 ? void 0 : oldTabsterProps.modalizer) === null || _c === void 0 ? void 0 : _c.id) !== newModalizerId) {
              tabsterOnElement.modalizer.dispose();
              newModalizerProps = props;
            } else {
              tabsterOnElement.modalizer.setProps(props);
            }
          } else {
            if (modalizerAPI) {
              newModalizerProps = newTabsterProps.modalizer;
            } else if (true) {
              console.error("Modalizer API used before initialization, please call `getModalizer()`");
            }
          }
          if (modalizerAPI && newModalizerProps) {
            tabsterOnElement.modalizer = modalizerAPI.createModalizer(element, newModalizerProps, sys);
          }
        }
        break;
      case "restorer":
        if (tabsterOnElement.restorer) {
          tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
        } else {
          if (tabster.restorer) {
            if (newTabsterProps.restorer) {
              tabsterOnElement.restorer = tabster.restorer.createRestorer(element, newTabsterProps.restorer);
            }
          } else if (true) {
            console.error("Restorer API used before initialization, please call `getRestorer()`");
          }
        }
        break;
      case "focusable":
        tabsterOnElement.focusable = newTabsterProps.focusable;
        break;
      case "groupper":
        if (tabsterOnElement.groupper) {
          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
        } else {
          if (tabster.groupper) {
            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);
          } else if (true) {
            console.error("Groupper API used before initialization, please call `getGroupper()`");
          }
        }
        break;
      case "mover":
        if (tabsterOnElement.mover) {
          tabsterOnElement.mover.setProps(newTabsterProps.mover);
        } else {
          if (tabster.mover) {
            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);
          } else if (true) {
            console.error("Mover API used before initialization, please call `getMover()`");
          }
        }
        break;
      case "observed":
        if (tabster.observedElement) {
          tabsterOnElement.observed = newTabsterProps.observed;
          tabster.observedElement.onObservedElementUpdate(element);
        } else if (true) {
          console.error("ObservedElement API used before initialization, please call `getObservedElement()`");
        }
        break;
      case "uncontrolled":
        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
        break;
      case "outline":
        if (tabster.outline) {
          tabsterOnElement.outline = newTabsterProps.outline;
        } else if (true) {
          console.error("Outline API used before initialization, please call `getOutline()`");
        }
        break;
      case "sys":
        tabsterOnElement.sys = newTabsterProps.sys;
        break;
      default:
        console.error(`Unknown key '${key}' in data-tabster attribute value.`);
    }
  }
  if (newAttr) {
    entry.attr = newAttr;
  } else {
    if (Object.keys(tabsterOnElement).length === 0) {
      delete entry.tabster;
      delete entry.attr;
    }
    tabster.storageEntry(element, false);
  }
}
var TabsterFocusInEventName = "tabster:focusin";
var TabsterFocusOutEventName = "tabster:focusout";
var TabsterMoveFocusEventName = "tabster:movefocus";
var ModalizerActiveEventName = "tabster:modalizer:active";
var ModalizerInactiveEventName = "tabster:modalizer:inactive";
var MoverStateEventName = "tabster:mover:state";
var MoverMoveFocusEventName = "tabster:mover:movefocus";
var MoverMemorizedElementEventName = "tabster:mover:memorized-element";
var GroupperMoveFocusEventName = "tabster:groupper:movefocus";
var RestorerRestoreFocusEventName = "tabster:restorer:restore-focus";
var RootFocusEventName = "tabster:root:focus";
var RootBlurEventName = "tabster:root:blur";
var CustomEvent_ = typeof CustomEvent !== "undefined" ? CustomEvent : function() {
};
var TabsterCustomEvent = class extends CustomEvent_ {
  constructor(type, detail) {
    super(type, {
      bubbles: true,
      cancelable: true,
      composed: true,
      detail
    });
    this.details = detail;
  }
};
var TabsterFocusInEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterFocusInEventName, detail);
  }
};
var TabsterFocusOutEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterFocusOutEventName, detail);
  }
};
var TabsterMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(TabsterMoveFocusEventName, detail);
  }
};
var MoverStateEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(MoverStateEventName, detail);
  }
};
var MoverMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(MoverMoveFocusEventName, detail);
  }
};
var GroupperMoveFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(GroupperMoveFocusEventName, detail);
  }
};
var ModalizerActiveEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(ModalizerActiveEventName, detail);
  }
};
var ModalizerInactiveEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(ModalizerInactiveEventName, detail);
  }
};
var RestorerRestoreFocusEvent = class extends TabsterCustomEvent {
  constructor() {
    super(RestorerRestoreFocusEventName);
  }
};
var RootFocusEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(RootFocusEventName, detail);
  }
};
var RootBlurEvent = class extends TabsterCustomEvent {
  constructor(detail) {
    super(RootBlurEventName, detail);
  }
};
var _createMutationObserver = (callback) => new MutationObserver(callback);
var _createTreeWalker = (doc, root, whatToShow, filter) => doc.createTreeWalker(root, whatToShow, filter);
var _getParentNode = (node) => node ? node.parentNode : null;
var _getParentElement = (element) => element ? element.parentElement : null;
var _nodeContains = (parent2, child) => !!(child && (parent2 === null || parent2 === void 0 ? void 0 : parent2.contains(child)));
var _getActiveElement = (doc) => doc.activeElement;
var _querySelector = (element, selector) => element.querySelector(selector);
var _querySelectorAll = (element, selector) => Array.prototype.slice.call(element.querySelectorAll(selector), 0);
var _getElementById = (doc, id) => doc.getElementById(id);
var _getFirstChild = (node) => (node === null || node === void 0 ? void 0 : node.firstChild) || null;
var _getLastChild = (node) => (node === null || node === void 0 ? void 0 : node.lastChild) || null;
var _getNextSibling = (node) => (node === null || node === void 0 ? void 0 : node.nextSibling) || null;
var _getPreviousSibling = (node) => (node === null || node === void 0 ? void 0 : node.previousSibling) || null;
var _getFirstElementChild = (element) => (element === null || element === void 0 ? void 0 : element.firstElementChild) || null;
var _getLastElementChild = (element) => (element === null || element === void 0 ? void 0 : element.lastElementChild) || null;
var _getNextElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.nextElementSibling) || null;
var _getPreviousElementSibling = (element) => (element === null || element === void 0 ? void 0 : element.previousElementSibling) || null;
var _appendChild = (parent2, child) => parent2.appendChild(child);
var _insertBefore = (parent2, child, referenceChild) => parent2.insertBefore(child, referenceChild);
var _getSelection = (ref) => {
  var _a;
  return ((_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.getSelection()) || null;
};
var _getElementsByName = (referenceElement, name) => referenceElement.ownerDocument.getElementsByName(name);
var dom = {
  createMutationObserver: _createMutationObserver,
  createTreeWalker: _createTreeWalker,
  getParentNode: _getParentNode,
  getParentElement: _getParentElement,
  nodeContains: _nodeContains,
  getActiveElement: _getActiveElement,
  querySelector: _querySelector,
  querySelectorAll: _querySelectorAll,
  getElementById: _getElementById,
  getFirstChild: _getFirstChild,
  getLastChild: _getLastChild,
  getNextSibling: _getNextSibling,
  getPreviousSibling: _getPreviousSibling,
  getFirstElementChild: _getFirstElementChild,
  getLastElementChild: _getLastElementChild,
  getNextElementSibling: _getNextElementSibling,
  getPreviousElementSibling: _getPreviousElementSibling,
  appendChild: _appendChild,
  insertBefore: _insertBefore,
  getSelection: _getSelection,
  getElementsByName: _getElementsByName
};
function setDOMAPI(domapi) {
  for (const key of Object.keys(domapi)) {
    dom[key] = domapi[key];
  }
}
var _isBrokenIE11;
var _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
  constructor(x, y, width, height) {
    this.left = x || 0;
    this.top = y || 0;
    this.right = (x || 0) + (width || 0);
    this.bottom = (y || 0) + (height || 0);
  }
};
var _uidCounter = 0;
try {
  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
  _isBrokenIE11 = false;
} catch (e) {
  _isBrokenIE11 = true;
}
var _updateDummyInputsTimeout = 100;
function getInstanceContext(getWindow2) {
  const win = getWindow2();
  let ctx = win.__tabsterInstanceContext;
  if (!ctx) {
    ctx = {
      elementByUId: {},
      basics: {
        Promise: win.Promise || void 0,
        WeakRef: win.WeakRef || void 0
      },
      containerBoundingRectCache: {},
      lastContainerBoundingRectCacheId: 0,
      fakeWeakRefs: [],
      fakeWeakRefsStarted: false
    };
    win.__tabsterInstanceContext = ctx;
  }
  return ctx;
}
function disposeInstanceContext(win) {
  const ctx = win.__tabsterInstanceContext;
  if (ctx) {
    ctx.elementByUId = {};
    delete ctx.WeakRef;
    ctx.containerBoundingRectCache = {};
    if (ctx.containerBoundingRectCacheTimer) {
      win.clearTimeout(ctx.containerBoundingRectCacheTimer);
    }
    if (ctx.fakeWeakRefsTimer) {
      win.clearTimeout(ctx.fakeWeakRefsTimer);
    }
    ctx.fakeWeakRefs = [];
    delete win.__tabsterInstanceContext;
  }
}
function createWeakMap(win) {
  const ctx = win.__tabsterInstanceContext;
  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
}
function hasSubFocusable(element) {
  return !!element.querySelector(FOCUSABLE_SELECTOR);
}
var FakeWeakRef = class {
  constructor(target) {
    this._target = target;
  }
  deref() {
    return this._target;
  }
  static cleanup(fwr, forceRemove) {
    if (!fwr._target) {
      return true;
    }
    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
      delete fwr._target;
      return true;
    }
    return false;
  }
};
var WeakHTMLElement = class {
  constructor(getWindow2, element, data) {
    const context = getInstanceContext(getWindow2);
    let ref;
    if (context.WeakRef) {
      ref = new context.WeakRef(element);
    } else {
      ref = new FakeWeakRef(element);
      context.fakeWeakRefs.push(ref);
    }
    this._ref = ref;
    this._data = data;
  }
  get() {
    const ref = this._ref;
    let element;
    if (ref) {
      element = ref.deref();
      if (!element) {
        delete this._ref;
      }
    }
    return element;
  }
  getData() {
    return this._data;
  }
};
function cleanupFakeWeakRefs(getWindow2, forceRemove) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefs = context.fakeWeakRefs.filter((e) => !FakeWeakRef.cleanup(e, forceRemove));
}
function startFakeWeakRefsCleanup(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (!context.fakeWeakRefsStarted) {
    context.fakeWeakRefsStarted = true;
    context.WeakRef = getWeakRef(context);
  }
  if (!context.fakeWeakRefsTimer) {
    context.fakeWeakRefsTimer = getWindow2().setTimeout(() => {
      context.fakeWeakRefsTimer = void 0;
      cleanupFakeWeakRefs(getWindow2);
      startFakeWeakRefsCleanup(getWindow2);
    }, 2 * 60 * 1e3);
  }
}
function stopFakeWeakRefsCleanupAndClearStorage(getWindow2) {
  const context = getInstanceContext(getWindow2);
  context.fakeWeakRefsStarted = false;
  if (context.fakeWeakRefsTimer) {
    getWindow2().clearTimeout(context.fakeWeakRefsTimer);
    context.fakeWeakRefsTimer = void 0;
    context.fakeWeakRefs = [];
  }
}
function createElementTreeWalker(doc, root, acceptNode) {
  if (root.nodeType !== Node.ELEMENT_NODE) {
    return void 0;
  }
  const filter = _isBrokenIE11 ? acceptNode : {
    acceptNode
  };
  return dom.createTreeWalker(
    doc,
    root,
    NodeFilter.SHOW_ELEMENT,
    filter,
    // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
    false
    /* Last argument is not optional for IE11! */
  );
}
function getBoundingRect(getWindow2, element) {
  let cacheId = element.__tabsterCacheId;
  const context = getInstanceContext(getWindow2);
  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
  if (cached) {
    return cached.rect;
  }
  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;
  if (!scrollingElement) {
    return new _DOMRect();
  }
  let left2 = 0;
  let top = 0;
  let right2 = scrollingElement.clientWidth;
  let bottom = scrollingElement.clientHeight;
  if (element !== scrollingElement) {
    const r = element.getBoundingClientRect();
    left2 = Math.max(left2, r.left);
    top = Math.max(top, r.top);
    right2 = Math.min(right2, r.right);
    bottom = Math.min(bottom, r.bottom);
  }
  const rect = new _DOMRect(left2 < right2 ? left2 : -1, top < bottom ? top : -1, left2 < right2 ? right2 - left2 : 0, top < bottom ? bottom - top : 0);
  if (!cacheId) {
    cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
    element.__tabsterCacheId = cacheId;
  }
  context.containerBoundingRectCache[cacheId] = {
    rect,
    element
  };
  if (!context.containerBoundingRectCacheTimer) {
    context.containerBoundingRectCacheTimer = window.setTimeout(() => {
      context.containerBoundingRectCacheTimer = void 0;
      for (const cId of Object.keys(context.containerBoundingRectCache)) {
        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
      }
      context.containerBoundingRectCache = {};
    }, 50);
  }
  return rect;
}
function isElementVerticallyVisibleInContainer(getWindow2, element, tolerance) {
  const container = getScrollableContainer(element);
  if (!container) {
    return false;
  }
  const containerRect = getBoundingRect(getWindow2, container);
  const elementRect = element.getBoundingClientRect();
  const intersectionTolerance = elementRect.height * (1 - tolerance);
  const topIntersection = Math.max(0, containerRect.top - elementRect.top);
  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
  const totalIntersection = topIntersection + bottomIntersection;
  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
}
function scrollIntoView(getWindow2, element, alignToTop) {
  const container = getScrollableContainer(element);
  if (container) {
    const containerRect = getBoundingRect(getWindow2, container);
    const elementRect = element.getBoundingClientRect();
    if (alignToTop) {
      container.scrollTop += elementRect.top - containerRect.top;
    } else {
      container.scrollTop += elementRect.bottom - containerRect.bottom;
    }
  }
}
function getScrollableContainer(element) {
  const doc = element.ownerDocument;
  if (doc) {
    for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
        return el;
      }
    }
    return doc.documentElement;
  }
  return null;
}
function makeFocusIgnored(element) {
  element.__shouldIgnoreFocus = true;
}
function shouldIgnoreFocus(element) {
  return !!element.__shouldIgnoreFocus;
}
function getUId(wnd) {
  const rnd = new Uint32Array(4);
  if (wnd.crypto && wnd.crypto.getRandomValues) {
    wnd.crypto.getRandomValues(rnd);
  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
    wnd.msCrypto.getRandomValues(rnd);
  } else {
    for (let i = 0; i < rnd.length; i++) {
      rnd[i] = 4294967295 * Math.random();
    }
  }
  const srnd = [];
  for (let i = 0; i < rnd.length; i++) {
    srnd.push(rnd[i].toString(36));
  }
  srnd.push("|");
  srnd.push((++_uidCounter).toString(36));
  srnd.push("|");
  srnd.push(Date.now().toString(36));
  return srnd.join("");
}
function getElementUId(getWindow2, element) {
  const context = getInstanceContext(getWindow2);
  let uid = element.__tabsterElementUID;
  if (!uid) {
    uid = element.__tabsterElementUID = getUId(getWindow2());
  }
  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {
    context.elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
  }
  return uid;
}
function clearElementCache(getWindow2, parent2) {
  const context = getInstanceContext(getWindow2);
  for (const key of Object.keys(context.elementByUId)) {
    const wel = context.elementByUId[key];
    const el = wel && wel.get();
    if (el && parent2) {
      if (!dom.nodeContains(parent2, el)) {
        continue;
      }
    }
    delete context.elementByUId[key];
  }
}
function documentContains(doc, element) {
  return dom.nodeContains(doc === null || doc === void 0 ? void 0 : doc.body, element);
}
function matchesSelector(element, selector) {
  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
  return matches && matches.call(element, selector);
}
function getPromise(getWindow2) {
  const context = getInstanceContext(getWindow2);
  if (context.basics.Promise) {
    return context.basics.Promise;
  }
  throw new Error("No Promise defined.");
}
function getWeakRef(context) {
  return context.basics.WeakRef;
}
var _lastTabsterPartId = 0;
var TabsterPart = class {
  constructor(tabster, element, props) {
    const getWindow2 = tabster.getWindow;
    this._tabster = tabster;
    this._element = new WeakHTMLElement(getWindow2, element);
    this._props = {
      ...props
    };
    this.id = "i" + ++_lastTabsterPartId;
  }
  getElement() {
    return this._element.get();
  }
  getProps() {
    return this._props;
  }
  setProps(props) {
    this._props = {
      ...props
    };
  }
};
var DummyInput = class {
  constructor(getWindow2, isOutside, props, element, fixedTarget) {
    var _a;
    this._focusIn = (e) => {
      if (this._fixedTarget) {
        const target = this._fixedTarget.get();
        if (target) {
          nativeFocus(target);
        }
        return;
      }
      const input2 = this.input;
      if (this.onFocusIn && input2) {
        const relatedTarget = e.relatedTarget;
        this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
      }
    };
    this._focusOut = (e) => {
      if (this._fixedTarget) {
        return;
      }
      this.useDefaultAction = false;
      const input2 = this.input;
      if (this.onFocusOut && input2) {
        const relatedTarget = e.relatedTarget;
        this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
      }
    };
    const win = getWindow2();
    const input = win.document.createElement("i");
    input.tabIndex = 0;
    input.setAttribute("role", "none");
    input.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, "");
    input.setAttribute("aria-hidden", "true");
    const style = input.style;
    style.position = "fixed";
    style.width = style.height = "1px";
    style.opacity = "0.001";
    style.zIndex = "-1";
    style.setProperty("content-visibility", "hidden");
    makeFocusIgnored(input);
    this.input = input;
    this.isFirst = props.isFirst;
    this.isOutside = isOutside;
    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
    this._fixedTarget = fixedTarget;
    input.addEventListener("focusin", this._focusIn);
    input.addEventListener("focusout", this._focusOut);
    input.__tabsterDummyContainer = element;
    if (this._isPhantom) {
      this._disposeTimer = win.setTimeout(() => {
        delete this._disposeTimer;
        this.dispose();
      }, 0);
      this._clearDisposeTimeout = () => {
        if (this._disposeTimer) {
          win.clearTimeout(this._disposeTimer);
          delete this._disposeTimer;
        }
        delete this._clearDisposeTimeout;
      };
    }
  }
  dispose() {
    var _a;
    if (this._clearDisposeTimeout) {
      this._clearDisposeTimeout();
    }
    const input = this.input;
    if (!input) {
      return;
    }
    delete this._fixedTarget;
    delete this.onFocusIn;
    delete this.onFocusOut;
    delete this.input;
    input.removeEventListener("focusin", this._focusIn);
    input.removeEventListener("focusout", this._focusOut);
    delete input.__tabsterDummyContainer;
    (_a = dom.getParentNode(input)) === null || _a === void 0 ? void 0 : _a.removeChild(input);
  }
  setTopLeft(top, left2) {
    var _a;
    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;
    if (style) {
      style.top = `${top}px`;
      style.left = `${left2}px`;
    }
  }
  _isBackward(isIn, current, previous) {
    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);
  }
};
var DummyInputManagerPriorities = {
  Root: 1,
  Modalizer: 2,
  Mover: 3,
  Groupper: 4
};
var DummyInputManager = class {
  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {
    this._element = element;
    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);
  }
  _setHandlers(onFocusIn, onFocusOut) {
    this._onFocusIn = onFocusIn;
    this._onFocusOut = onFocusOut;
  }
  moveOut(backwards) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);
  }
  moveOutWithDefaultAction(backwards, relatedEvent) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards, relatedEvent);
  }
  getHandler(isIn) {
    return isIn ? this._onFocusIn : this._onFocusOut;
  }
  setTabbable(tabbable) {
    var _a;
    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);
  }
  dispose() {
    if (this._instance) {
      this._instance.dispose(this);
      delete this._instance;
    }
    delete this._onFocusIn;
    delete this._onFocusOut;
  }
  static moveWithPhantomDummy(tabster, element, moveOutOfElement, isBackward, relatedEvent) {
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    });
    const input = dummy.input;
    if (input) {
      let parent2;
      let insertBefore2;
      if (element.tagName === "BODY") {
        parent2 = element;
        insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getFirstElementChild(element) : null;
      } else {
        if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element, false, true, true))) {
          parent2 = element;
          insertBefore2 = isBackward ? element.firstElementChild : null;
        } else {
          parent2 = dom.getParentElement(element);
          insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element : dom.getNextElementSibling(element);
        }
        let potentialDummy;
        let dummyFor;
        do {
          potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? dom.getPreviousElementSibling(insertBefore2) : insertBefore2;
          dummyFor = getDummyInputContainer(potentialDummy);
          if (dummyFor === element) {
            insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : dom.getNextElementSibling(potentialDummy);
          } else {
            dummyFor = null;
          }
        } while (dummyFor);
      }
      if (parent2 === null || parent2 === void 0 ? void 0 : parent2.dispatchEvent(new TabsterMoveFocusEvent({
        by: "root",
        owner: parent2,
        next: null,
        relatedEvent
      }))) {
        dom.insertBefore(parent2, input, insertBefore2);
        nativeFocus(input);
      }
    }
  }
  static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
    const dummy = new DummyInput(tabster.getWindow, true, {
      isPhantom: true,
      isFirst: true
    }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
    const input = dummy.input;
    if (input) {
      let dummyParent;
      let insertBefore2;
      if (hasSubFocusable(sourceElement) && !isBackward) {
        dummyParent = sourceElement;
        insertBefore2 = dom.getFirstElementChild(sourceElement);
      } else {
        dummyParent = dom.getParentElement(sourceElement);
        insertBefore2 = isBackward ? sourceElement : dom.getNextElementSibling(sourceElement);
      }
      if (dummyParent) {
        dom.insertBefore(dummyParent, input, insertBefore2);
      }
    }
  }
};
function setDummyInputDebugValue(dummy, wrappers) {
  var _a;
  const what = {
    1: "Root",
    2: "Modalizer",
    3: "Mover",
    4: "Groupper"
  };
  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TABSTER_DUMMY_INPUT_ATTRIBUTE_NAME, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map((w) => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(", "));
}
var DummyInputObserver = class {
  constructor(win) {
    this._updateQueue = /* @__PURE__ */ new Set();
    this._lastUpdateQueueTime = 0;
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyElements = [];
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._domChanged = (parent2) => {
      var _a;
      if (this._changedParents.has(parent2)) {
        return;
      }
      this._changedParents.add(parent2);
      if (this._updateDummyInputsTimer) {
        return;
      }
      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
        delete this._updateDummyInputsTimer;
        for (const ref of this._dummyElements) {
          const dummyElement = ref.get();
          if (dummyElement) {
            const callback = this._dummyCallbacks.get(dummyElement);
            if (callback) {
              const dummyParent = dom.getParentNode(dummyElement);
              if (!dummyParent || this._changedParents.has(dummyParent)) {
                callback();
              }
            }
          }
        }
        this._changedParents = /* @__PURE__ */ new WeakSet();
      }, _updateDummyInputsTimeout);
    };
    this._win = win;
  }
  add(dummy, callback) {
    if (!this._dummyCallbacks.has(dummy) && this._win) {
      this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
      this._dummyCallbacks.set(dummy, callback);
      this.domChanged = this._domChanged;
    }
  }
  remove(dummy) {
    this._dummyElements = this._dummyElements.filter((ref) => {
      const element = ref.get();
      return element && element !== dummy;
    });
    this._dummyCallbacks.delete(dummy);
    if (this._dummyElements.length === 0) {
      delete this.domChanged;
    }
  }
  dispose() {
    var _a;
    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);
    if (this._updateTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    if (this._updateDummyInputsTimer) {
      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
      delete this._updateDummyInputsTimer;
    }
    this._changedParents = /* @__PURE__ */ new WeakSet();
    this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
    this._dummyElements = [];
    this._updateQueue.clear();
    delete this.domChanged;
    delete this._win;
  }
  updatePositions(compute) {
    if (!this._win) {
      return;
    }
    this._updateQueue.add(compute);
    this._lastUpdateQueueTime = Date.now();
    this._scheduledUpdatePositions();
  }
  _scheduledUpdatePositions() {
    var _a;
    if (this._updateTimer) {
      return;
    }
    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {
      delete this._updateTimer;
      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
        const scrollTopLeftCache = /* @__PURE__ */ new Map();
        const setTopLeftCallbacks = [];
        for (const compute of this._updateQueue) {
          setTopLeftCallbacks.push(compute(scrollTopLeftCache));
        }
        this._updateQueue.clear();
        for (const setTopLeft of setTopLeftCallbacks) {
          setTopLeft();
        }
        scrollTopLeftCache.clear();
      } else {
        this._scheduledUpdatePositions();
      }
    }, _updateDummyInputsTimeout);
  }
};
var DummyInputManagerCore = class {
  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {
    this._wrappers = [];
    this._isOutside = false;
    this._transformElements = /* @__PURE__ */ new Set();
    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(true, dummyInput, isBackward, relatedTarget);
    };
    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
      this._onFocus(false, dummyInput, isBackward, relatedTarget);
    };
    this.moveOut = (backwards) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            firstInput.tabIndex = 0;
            toFocus = firstInput;
          } else {
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
      var _a;
      const first = this._firstDummy;
      const last = this._lastDummy;
      if (first && last) {
        this._ensurePosition();
        const firstInput = first.input;
        const lastInput = last.input;
        const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
        if (firstInput && lastInput && element2) {
          let toFocus;
          if (backwards) {
            if (!first.isOutside && this._tabster.focusable.isFocusable(element2, true, true, true)) {
              toFocus = element2;
            } else {
              first.useDefaultAction = true;
              firstInput.tabIndex = 0;
              toFocus = firstInput;
            }
          } else {
            last.useDefaultAction = true;
            lastInput.tabIndex = 0;
            toFocus = lastInput;
          }
          if (toFocus && element2.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: element2,
            next: null,
            relatedEvent
          }))) {
            nativeFocus(toFocus);
          }
        }
      }
    };
    this.setTabbable = (manager2, tabbable) => {
      var _a, _b;
      for (const w of this._wrappers) {
        if (w.manager === manager2) {
          w.tabbable = tabbable;
          break;
        }
      }
      const wrapper = this._getCurrent();
      if (wrapper) {
        const tabIndex = wrapper.tabbable ? 0 : -1;
        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
        if (input) {
          input.tabIndex = tabIndex;
        }
      }
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
      }
    };
    this._addDummyInputs = () => {
      if (this._addTimer) {
        return;
      }
      this._addTimer = this._getWindow().setTimeout(() => {
        delete this._addTimer;
        this._ensurePosition();
        if (true) {
          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);
          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);
        }
        this._addTransformOffsets();
      }, 0);
    };
    this._addTransformOffsets = () => {
      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
    };
    this._computeTransformOffsets = (scrollTopLeftCache) => {
      var _a, _b;
      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
      const transformElements = this._transformElements;
      const newTransformElements = /* @__PURE__ */ new Set();
      let scrollTop = 0;
      let scrollLeft = 0;
      const win = this._getWindow();
      for (let element2 = from; element2 && element2.nodeType === Node.ELEMENT_NODE; element2 = dom.getParentElement(element2)) {
        let scrollTopLeft = scrollTopLeftCache.get(element2);
        if (scrollTopLeft === void 0) {
          const transform = win.getComputedStyle(element2).transform;
          if (transform && transform !== "none") {
            scrollTopLeft = {
              scrollTop: element2.scrollTop,
              scrollLeft: element2.scrollLeft
            };
          }
          scrollTopLeftCache.set(element2, scrollTopLeft || null);
        }
        if (scrollTopLeft) {
          newTransformElements.add(element2);
          if (!transformElements.has(element2)) {
            element2.addEventListener("scroll", this._addTransformOffsets);
          }
          scrollTop += scrollTopLeft.scrollTop;
          scrollLeft += scrollTopLeft.scrollLeft;
        }
      }
      for (const el2 of transformElements) {
        if (!newTransformElements.has(el2)) {
          el2.removeEventListener("scroll", this._addTransformOffsets);
        }
      }
      this._transformElements = newTransformElements;
      return () => {
        var _a2, _b2;
        (_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.setTopLeft(scrollTop, scrollLeft);
        (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
      };
    };
    const el = element.get();
    if (!el) {
      throw new Error("No element");
    }
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._callForDefaultAction = callForDefaultAction;
    const instance = el.__tabsterDummy;
    (instance || this)._wrappers.push({
      manager,
      priority,
      tabbable: true
    });
    if (instance) {
      if (true) {
        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);
        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);
      }
      return instance;
    }
    el.__tabsterDummy = this;
    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
    const tagName = el.tagName;
    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: true
    }, element);
    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
      isFirst: false
    }, element);
    const dummyElement = this._firstDummy.input;
    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
    this._firstDummy.onFocusIn = this._onFocusIn;
    this._firstDummy.onFocusOut = this._onFocusOut;
    this._lastDummy.onFocusIn = this._onFocusIn;
    this._lastDummy.onFocusOut = this._onFocusOut;
    this._element = element;
    this._addDummyInputs();
  }
  dispose(manager, force) {
    var _a, _b, _c, _d;
    const wrappers = this._wrappers = this._wrappers.filter((w) => w.manager !== manager && !force);
    if (true) {
      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);
      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);
    }
    if (wrappers.length === 0) {
      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;
      for (const el of this._transformElements) {
        el.removeEventListener("scroll", this._addTransformOffsets);
      }
      this._transformElements.clear();
      const win = this._getWindow();
      if (this._addTimer) {
        win.clearTimeout(this._addTimer);
        delete this._addTimer;
      }
      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
      dummyElement && this._tabster._dummyObserver.remove(dummyElement);
      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
    }
  }
  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
    var _a;
    const wrapper = this._getCurrent();
    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);
    }
  }
  _getCurrent() {
    this._wrappers.sort((a, b) => {
      if (a.tabbable !== b.tabbable) {
        return a.tabbable ? -1 : 1;
      }
      return a.priority - b.priority;
    });
    return this._wrappers[0];
  }
  _ensurePosition() {
    var _a, _b, _c;
    const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
    const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
    const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
    if (!element || !firstDummyInput || !lastDummyInput) {
      return;
    }
    if (this._isOutside) {
      const elementParent = dom.getParentNode(element);
      if (elementParent) {
        const nextSibling = dom.getNextSibling(element);
        if (nextSibling !== lastDummyInput) {
          dom.insertBefore(elementParent, lastDummyInput, nextSibling);
        }
        if (dom.getPreviousElementSibling(element) !== firstDummyInput) {
          dom.insertBefore(elementParent, firstDummyInput, element);
        }
      }
    } else {
      if (dom.getLastElementChild(element) !== lastDummyInput) {
        dom.appendChild(element, lastDummyInput);
      }
      const firstElementChild = dom.getFirstElementChild(element);
      if (firstElementChild && firstElementChild !== firstDummyInput && firstElementChild.parentNode) {
        dom.insertBefore(firstElementChild.parentNode, firstDummyInput, firstElementChild);
      }
    }
  }
};
function getLastChild$2(container) {
  let lastChild = null;
  for (let i = dom.getLastElementChild(container); i; i = dom.getLastElementChild(i)) {
    lastChild = i;
  }
  return lastChild || void 0;
}
function getAdjacentElement(from, prev) {
  let cur = from;
  let adjacent = null;
  while (cur && !adjacent) {
    adjacent = prev ? dom.getPreviousElementSibling(cur) : dom.getNextElementSibling(cur);
    cur = dom.getParentElement(cur);
  }
  return adjacent || void 0;
}
function augmentAttribute(tabster, element, name, value) {
  const entry = tabster.storageEntry(element, true);
  let ret = false;
  if (!entry.aug) {
    if (value === void 0) {
      return ret;
    }
    entry.aug = {};
  }
  if (value === void 0) {
    if (name in entry.aug) {
      const origVal = entry.aug[name];
      delete entry.aug[name];
      if (origVal === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, origVal);
      }
      ret = true;
    }
  } else {
    let origValue;
    if (!(name in entry.aug)) {
      origValue = element.getAttribute(name);
    }
    if (origValue !== void 0 && origValue !== value) {
      entry.aug[name] = origValue;
      if (value === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value);
      }
      ret = true;
    }
  }
  if (value === void 0 && Object.keys(entry.aug).length === 0) {
    delete entry.aug;
    tabster.storageEntry(element, false);
  }
  return ret;
}
function isDisplayNone(element) {
  var _a, _b;
  const elementDocument = element.ownerDocument;
  const computedStyle = (_a = elementDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getComputedStyle(element);
  if (element.offsetParent === null && elementDocument.body !== element && (computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) !== "fixed") {
    return true;
  }
  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.visibility) === "hidden") {
    return true;
  }
  if ((computedStyle === null || computedStyle === void 0 ? void 0 : computedStyle.position) === "fixed") {
    if (computedStyle.display === "none") {
      return true;
    }
    if (((_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.offsetParent) === null && elementDocument.body !== element.parentElement) {
      return true;
    }
  }
  return false;
}
function isRadio(element) {
  return element.tagName === "INPUT" && !!element.name && element.type === "radio";
}
function getRadioButtonGroup(element) {
  if (!isRadio(element)) {
    return;
  }
  const name = element.name;
  let radioButtons = Array.from(dom.getElementsByName(element, name));
  let checked;
  radioButtons = radioButtons.filter((el) => {
    if (isRadio(el)) {
      if (el.checked) {
        checked = el;
      }
      return true;
    }
    return false;
  });
  return {
    name,
    buttons: new Set(radioButtons),
    checked
  };
}
function getDummyInputContainer(element) {
  var _a;
  return ((_a = element === null || element === void 0 ? void 0 : element.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) || null;
}
function getTabsterAttribute(props, plain) {
  const attr = JSON.stringify(props);
  if (plain === true) {
    return attr;
  }
  return {
    [TABSTER_ATTRIBUTE_NAME]: attr
  };
}
function mergeTabsterProps(props, newProps) {
  for (const key of Object.keys(newProps)) {
    const value = newProps[key];
    if (value) {
      props[key] = value;
    } else {
      delete props[key];
    }
  }
}
function setTabsterAttribute(element, newProps, update) {
  let props;
  if (update) {
    const attr = element.getAttribute(TABSTER_ATTRIBUTE_NAME);
    if (attr) {
      try {
        props = JSON.parse(attr);
      } catch (e) {
        if (true) {
          console.error(`data-tabster attribute error: ${e}`, element);
        }
      }
    }
  }
  if (!props) {
    props = {};
  }
  mergeTabsterProps(props, newProps);
  if (Object.keys(props).length > 0) {
    element.setAttribute(TABSTER_ATTRIBUTE_NAME, getTabsterAttribute(props, true));
  } else {
    element.removeAttribute(TABSTER_ATTRIBUTE_NAME);
  }
}
function _setInformativeStyle$3(weakElement, remove, id) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-root");
      } else {
        element.style.setProperty("--tabster-root", id + ",");
      }
    }
  }
}
var RootDummyManager = class extends DummyInputManager {
  constructor(tabster, element, setFocused, sys) {
    super(tabster, element, DummyInputManagerPriorities.Root, sys, void 0, true);
    this._onDummyInputFocus = (dummyInput) => {
      var _a;
      if (dummyInput.useDefaultAction) {
        this._setFocused(false);
      } else {
        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
        const element2 = this._element.get();
        if (element2) {
          this._setFocused(true);
          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
            container: element2,
            ignoreAccessibility: true
          });
          if (toFocus) {
            nativeFocus(toFocus);
            return;
          }
        }
        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
    this._setHandlers(this._onDummyInputFocus);
    this._tabster = tabster;
    this._setFocused = setFocused;
  }
};
var Root = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._isFocused = false;
    this._setFocused = (hasFocused) => {
      var _a;
      if (this._setFocusedTimer) {
        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
        delete this._setFocusedTimer;
      }
      if (this._isFocused === hasFocused) {
        return;
      }
      const element2 = this._element.get();
      if (element2) {
        if (hasFocused) {
          this._isFocused = true;
          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);
          element2.dispatchEvent(new RootFocusEvent({
            element: element2
          }));
        } else {
          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
            var _a2;
            delete this._setFocusedTimer;
            this._isFocused = false;
            (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(true);
            element2.dispatchEvent(new RootBlurEvent({
              element: element2
            }));
          }, 0);
        }
      }
    };
    this._onFocusIn = (event) => {
      const getParent2 = this._tabster.getParent;
      const rootElement = this._element.get();
      let curElement = event.composedPath()[0];
      do {
        if (curElement === rootElement) {
          this._setFocused(true);
          return;
        }
        curElement = curElement && getParent2(curElement);
      } while (curElement);
    };
    this._onFocusOut = () => {
      this._setFocused(false);
    };
    this._onDispose = onDispose;
    const win = tabster.getWindow;
    this.uid = getElementUId(win, element);
    this._sys = sys;
    if (tabster.controlTab || tabster.rootDummyInputs) {
      this.addDummyInputs();
    }
    const w = win();
    const doc = w.document;
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
    doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
    this._add();
  }
  addDummyInputs() {
    if (!this._dummyManager) {
      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const win = this._tabster.getWindow();
    const doc = win.document;
    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);
    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);
    if (this._setFocusedTimer) {
      win.clearTimeout(this._setFocusedTimer);
      delete this._setFocusedTimer;
    }
    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    this._remove();
  }
  moveOutWithDefaultAction(isBackward, relatedEvent) {
    const dummyManager = this._dummyManager;
    if (dummyManager) {
      dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
    } else {
      const el = this.getElement();
      if (el) {
        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
      }
    }
  }
  _add() {
    if (true) {
      _setInformativeStyle$3(this._element, false, this.uid);
    }
  }
  _remove() {
    if (true) {
      _setInformativeStyle$3(this._element, true);
    }
  }
};
var RootAPI = class {
  constructor(tabster, autoRoot) {
    this._autoRootWaiting = false;
    this._roots = {};
    this._forceDummy = false;
    this.rootById = {};
    this._autoRootCreate = () => {
      var _a;
      const doc = this._win().document;
      const body = doc.body;
      if (body) {
        this._autoRootUnwait(doc);
        const props = this._autoRoot;
        if (props) {
          setTabsterAttribute(body, {
            root: props
          }, true);
          updateTabsterByAttribute(this._tabster, body);
          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;
        }
      } else if (!this._autoRootWaiting) {
        this._autoRootWaiting = true;
        doc.addEventListener("readystatechange", this._autoRootCreate);
      }
      return void 0;
    };
    this._onRootDispose = (root) => {
      delete this._roots[root.id];
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._autoRoot = autoRoot;
    tabster.queueInit(() => {
      if (this._autoRoot) {
        this._autoRootCreate();
      }
    });
  }
  _autoRootUnwait(doc) {
    doc.removeEventListener("readystatechange", this._autoRootCreate);
    this._autoRootWaiting = false;
  }
  dispose() {
    const win = this._win();
    this._autoRootUnwait(win.document);
    delete this._autoRoot;
    Object.keys(this._roots).forEach((rootId) => {
      if (this._roots[rootId]) {
        this._roots[rootId].dispose();
        delete this._roots[rootId];
      }
    });
    this.rootById = {};
  }
  createRoot(element, props, sys) {
    if (true) ;
    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);
    this._roots[newRoot.id] = newRoot;
    if (this._forceDummy) {
      newRoot.addDummyInputs();
    }
    return newRoot;
  }
  addDummyInputs() {
    this._forceDummy = true;
    const roots = this._roots;
    for (const id of Object.keys(roots)) {
      roots[id].addDummyInputs();
    }
  }
  static getRootByUId(getWindow2, id) {
    const tabster = getWindow2().__tabsterInstance;
    return tabster && tabster.root.rootById[id];
  }
  /**
   * Fetches the tabster context for an element walking up its ancestors
   *
   * @param tabster Tabster instance
   * @param element The element the tabster context should represent
   * @param options Additional options
   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
   */
  static getTabsterContext(tabster, element, options = {}) {
    var _a, _b, _c, _d;
    if (!element.ownerDocument) {
      return void 0;
    }
    const {
      checkRtl,
      referenceElement
    } = options;
    const getParent2 = tabster.getParent;
    tabster.drainInitQueue();
    let root;
    let modalizer;
    let groupper;
    let mover;
    let excludedFromMover = false;
    let groupperBeforeMover;
    let modalizerInGroupper;
    let dirRightToLeft;
    let uncontrolled;
    let curElement = referenceElement || element;
    const ignoreKeydown = {};
    while (curElement && (!root || checkRtl)) {
      const tabsterOnElement = getTabsterOnElement(tabster, curElement);
      if (checkRtl && dirRightToLeft === void 0) {
        const dir = curElement.dir;
        if (dir) {
          dirRightToLeft = dir.toLowerCase() === "rtl";
        }
      }
      if (!tabsterOnElement) {
        curElement = getParent2(curElement);
        continue;
      }
      const tagName = curElement.tagName;
      if ((tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") && tabster.focusable.isVisible(curElement)) {
        uncontrolled = curElement;
      }
      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {
        excludedFromMover = true;
      }
      const curModalizer = tabsterOnElement.modalizer;
      const curGroupper = tabsterOnElement.groupper;
      const curMover = tabsterOnElement.mover;
      if (!modalizer && curModalizer) {
        modalizer = curModalizer;
      }
      if (!groupper && curGroupper && (!modalizer || curModalizer)) {
        if (modalizer) {
          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
            modalizer = void 0;
            groupper = curGroupper;
          }
          modalizerInGroupper = curGroupper;
        } else {
          groupper = curGroupper;
        }
      }
      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element) && curElement.contains(element)) {
        mover = curMover;
        groupperBeforeMover = !!groupper && groupper !== curGroupper;
      }
      if (tabsterOnElement.root) {
        root = tabsterOnElement.root;
      }
      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
      }
      curElement = getParent2(curElement);
    }
    if (!root) {
      const rootAPI = tabster.root;
      const autoRoot = rootAPI._autoRoot;
      if (autoRoot) {
        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
          root = rootAPI._autoRootCreate();
        }
      }
    }
    if (groupper && !mover) {
      groupperBeforeMover = true;
    }
    if (!root) {
      if (modalizer || groupper || mover) {
        console.error("Tabster Root is required for Mover, Groupper and Modalizer to work.");
      }
    }
    const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
    return root ? {
      root,
      modalizer,
      groupper,
      mover,
      groupperBeforeMover,
      modalizerInGroupper,
      rtl: checkRtl ? !!dirRightToLeft : void 0,
      uncontrolled,
      excludedFromMover,
      ignoreKeydown: shouldIgnoreKeydown
    } : void 0;
  }
  static getRoot(tabster, element) {
    var _a;
    const getParent2 = tabster.getParent;
    for (let el = element; el; el = getParent2(el)) {
      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;
      if (root) {
        return root;
      }
    }
    return void 0;
  }
  onRoot(root, removed) {
    if (removed) {
      delete this.rootById[root.uid];
    } else {
      this.rootById[root.uid] = root;
    }
  }
};
var Subscribable = class {
  constructor() {
    this._callbacks = [];
  }
  dispose() {
    this._callbacks = [];
    delete this._val;
  }
  subscribe(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index < 0) {
      callbacks.push(callback);
    }
  }
  subscribeFirst(callback) {
    const callbacks = this._callbacks;
    const index = callbacks.indexOf(callback);
    if (index >= 0) {
      callbacks.splice(index, 1);
    }
    callbacks.unshift(callback);
  }
  unsubscribe(callback) {
    const index = this._callbacks.indexOf(callback);
    if (index >= 0) {
      this._callbacks.splice(index, 1);
    }
  }
  setVal(val, detail) {
    if (this._val === val) {
      return;
    }
    this._val = val;
    this._callCallbacks(val, detail);
  }
  getVal() {
    return this._val;
  }
  trigger(val, detail) {
    this._callCallbacks(val, detail);
  }
  _callCallbacks(val, detail) {
    this._callbacks.forEach((callback) => callback(val, detail));
  }
};
var FocusableAPI = class {
  constructor(tabster) {
    this._tabster = tabster;
  }
  dispose() {
  }
  getProps(element) {
    const tabsterOnElement = getTabsterOnElement(this._tabster, element);
    return tabsterOnElement && tabsterOnElement.focusable || {};
  }
  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
    if (matchesSelector(el, FOCUSABLE_SELECTOR) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
    }
    return false;
  }
  isVisible(el) {
    if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
      return false;
    }
    if (isDisplayNone(el)) {
      return false;
    }
    const rect = el.ownerDocument.body.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) {
      return false;
    }
    return true;
  }
  isAccessible(el) {
    var _a;
    for (let e = el; e; e = dom.getParentElement(e)) {
      const tabsterOnElement = getTabsterOnElement(this._tabster, e);
      if (this._isHidden(e)) {
        return false;
      }
      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;
      if (!ignoreDisabled && this._isDisabled(e)) {
        return false;
      }
    }
    return true;
  }
  _isDisabled(el) {
    return el.hasAttribute("disabled");
  }
  _isHidden(el) {
    var _a;
    const attrVal = el.getAttribute("aria-hidden");
    if (attrVal && attrVal.toLowerCase() === "true") {
      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {
        return true;
      }
    }
    return false;
  }
  findFirst(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findLast(options, out) {
    return this.findElement({
      isBackward: true,
      ...options
    }, out);
  }
  findNext(options, out) {
    return this.findElement({
      ...options
    }, out);
  }
  findPrev(options, out) {
    return this.findElement({
      ...options,
      isBackward: true
    }, out);
  }
  findDefault(options, out) {
    return this.findElement({
      ...options,
      acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
    }, out) || null;
  }
  findAll(options) {
    return this._findElements(true, options) || [];
  }
  findElement(options, out) {
    const found = this._findElements(false, options, out);
    return found ? found[0] : found;
  }
  _findElements(isFindAll, options, out) {
    var _a, _b, _c;
    const {
      container,
      currentElement = null,
      includeProgrammaticallyFocusable,
      useActiveModalizer,
      ignoreAccessibility,
      modalizerId,
      isBackward,
      onElement
    } = options;
    if (!out) {
      out = {};
    }
    const elements = [];
    let {
      acceptCondition
    } = options;
    const hasCustomCondition = !!acceptCondition;
    if (!container) {
      return null;
    }
    if (!acceptCondition) {
      acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
    }
    const acceptElementState = {
      container,
      modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
      from: currentElement || container,
      isBackward,
      isFindAll,
      acceptCondition,
      hasCustomCondition,
      includeProgrammaticallyFocusable,
      ignoreAccessibility,
      cachedGrouppers: {},
      cachedRadioGroups: {}
    };
    const walker = createElementTreeWalker(container.ownerDocument, container, (node) => this._acceptElement(node, acceptElementState));
    if (!walker) {
      return null;
    }
    const prepareForNextElement = (shouldContinueIfNotFound) => {
      var _a2, _b2;
      const foundElement = (_a2 = acceptElementState.foundElement) !== null && _a2 !== void 0 ? _a2 : acceptElementState.foundBackward;
      if (foundElement) {
        elements.push(foundElement);
      }
      if (isFindAll) {
        if (foundElement) {
          acceptElementState.found = false;
          delete acceptElementState.foundElement;
          delete acceptElementState.foundBackward;
          delete acceptElementState.fromCtx;
          acceptElementState.from = foundElement;
          if (onElement && !onElement(foundElement)) {
            return false;
          }
        }
        return !!(foundElement || shouldContinueIfNotFound);
      } else {
        if (foundElement && out) {
          out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
        }
        return !!(shouldContinueIfNotFound && !foundElement);
      }
    };
    if (!currentElement) {
      out.outOfDOMOrder = true;
    }
    if (currentElement && dom.nodeContains(container, currentElement)) {
      walker.currentNode = currentElement;
    } else if (isBackward) {
      const lastChild = getLastChild$2(container);
      if (!lastChild) {
        return null;
      }
      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
        if (acceptElementState.skippedFocusable) {
          out.outOfDOMOrder = true;
        }
        return elements;
      }
      walker.currentNode = lastChild;
    }
    do {
      if (isBackward) {
        walker.previousNode();
      } else {
        walker.nextNode();
      }
    } while (prepareForNextElement());
    if (acceptElementState.skippedFocusable) {
      out.outOfDOMOrder = true;
    }
    return elements.length ? elements : null;
  }
  _acceptElement(element, state) {
    var _a, _b, _c;
    if (state.found) {
      return NodeFilter.FILTER_ACCEPT;
    }
    const foundBackward = state.foundBackward;
    if (foundBackward && (element === foundBackward || !dom.nodeContains(foundBackward, element))) {
      state.found = true;
      state.foundElement = foundBackward;
      return NodeFilter.FILTER_ACCEPT;
    }
    const container = state.container;
    if (element === container) {
      return NodeFilter.FILTER_SKIP;
    }
    if (!dom.nodeContains(container, element)) {
      return NodeFilter.FILTER_REJECT;
    }
    if (getDummyInputContainer(element)) {
      return NodeFilter.FILTER_REJECT;
    }
    if (dom.nodeContains(state.rejectElementsFrom, element)) {
      return NodeFilter.FILTER_REJECT;
    }
    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element);
    if (!ctx) {
      return NodeFilter.FILTER_SKIP;
    }
    if (shouldIgnoreFocus(element)) {
      if (this.isFocusable(element, void 0, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_SKIP;
    }
    if (!state.hasCustomCondition && (element.tagName === "IFRAME" || element.tagName === "WEBVIEW")) {
      if (this.isVisible(element) && ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
        state.found = true;
        state.rejectElementsFrom = state.foundElement = element;
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_REJECT;
      }
    }
    if (!state.ignoreAccessibility && !this.isAccessible(element)) {
      if (this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
      return NodeFilter.FILTER_REJECT;
    }
    let result;
    let fromCtx = state.fromCtx;
    if (!fromCtx) {
      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
    }
    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
    let groupper = ctx.groupper;
    let mover = ctx.mover;
    result = (_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.acceptElement(element, state);
    if (result !== void 0) {
      state.skippedFocusable = true;
    }
    if (result === void 0 && (groupper || mover || fromMover)) {
      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
      if (moverElement && dom.nodeContains(fromMoverElement, moverElement) && dom.nodeContains(container, fromMoverElement) && (!groupperElement || !mover || dom.nodeContains(fromMoverElement, groupperElement))) {
        mover = fromMover;
        moverElement = fromMoverElement;
      }
      if (groupperElement) {
        if (groupperElement === container || !dom.nodeContains(container, groupperElement)) {
          groupper = void 0;
        } else if (!dom.nodeContains(groupperElement, element)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (moverElement) {
        if (!dom.nodeContains(container, moverElement)) {
          mover = void 0;
        } else if (!dom.nodeContains(moverElement, element)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (groupper && mover) {
        if (moverElement && groupperElement && !dom.nodeContains(groupperElement, moverElement)) {
          mover = void 0;
        } else {
          groupper = void 0;
        }
      }
      if (groupper) {
        result = groupper.acceptElement(element, state);
      }
      if (mover) {
        result = mover.acceptElement(element, state);
      }
    }
    if (result === void 0) {
      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element, false, true, true)) {
        state.skippedFocusable = true;
      }
    }
    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
      if (!state.isFindAll && isRadio(element) && !element.checked) {
        const radioGroupName = element.name;
        let radioGroup = state.cachedRadioGroups[radioGroupName];
        if (!radioGroup) {
          radioGroup = getRadioButtonGroup(element);
          if (radioGroup) {
            state.cachedRadioGroups[radioGroupName] = radioGroup;
          }
        }
        if ((radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.checked) && radioGroup.checked !== element) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      if (state.isBackward) {
        state.foundBackward = element;
        result = NodeFilter.FILTER_SKIP;
      } else {
        state.found = true;
        state.foundElement = element;
      }
    }
    return result;
  }
};
var Keys = {
  Tab: "Tab",
  Enter: "Enter",
  Escape: "Escape",
  PageUp: "PageUp",
  PageDown: "PageDown",
  End: "End",
  Home: "Home",
  ArrowLeft: "ArrowLeft",
  ArrowUp: "ArrowUp",
  ArrowRight: "ArrowRight",
  ArrowDown: "ArrowDown"
};
function getUncontrolledCompletelyContainer(tabster, element) {
  var _a;
  const getParent2 = tabster.getParent;
  let el = element;
  do {
    const uncontrolledOnElement = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.uncontrolled;
    if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
      return el;
    }
    el = getParent2(el);
  } while (el);
  return void 0;
}
var AsyncFocusIntentPriorityBySource = {
  [AsyncFocusSources.Restorer]: 0,
  [AsyncFocusSources.Deloser]: 1,
  [AsyncFocusSources.EscapeGroupper]: 2
};
var FocusedElementState = class _FocusedElementState extends Subscribable {
  constructor(tabster, getWindow2) {
    super();
    this._init = () => {
      const win = this._win();
      const doc = win.document;
      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
      doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      const activeElement = dom.getActiveElement(doc);
      if (activeElement && activeElement !== doc.body) {
        this._setFocusedElement(activeElement);
      }
      this.subscribe(this._onChanged);
    };
    this._onFocusIn = (e) => {
      const target = e.composedPath()[0];
      if (target) {
        this._setFocusedElement(target, e.detail.relatedTarget, e.detail.isFocusedProgrammatically);
      }
    };
    this._onFocusOut = (e) => {
      var _a;
      this._setFocusedElement(void 0, (_a = e.detail) === null || _a === void 0 ? void 0 : _a.originalEvent.relatedTarget);
    };
    this._validateFocusedElement = (element) => {
    };
    this._onKeyDown = (event) => {
      if (event.key !== Keys.Tab || event.ctrlKey) {
        return;
      }
      const currentElement = this.getVal();
      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
        return;
      }
      const tabster2 = this._tabster;
      const controlTab = tabster2.controlTab;
      const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
      if (!ctx || ctx.ignoreKeydown(event)) {
        return;
      }
      const isBackward = event.shiftKey;
      const next = _FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
      const rootElement = ctx.root.getElement();
      if (!rootElement) {
        return;
      }
      const nextElement = next === null || next === void 0 ? void 0 : next.element;
      const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
      if (nextElement) {
        const nextUncontrolled = next.uncontrolled;
        if (ctx.uncontrolled || dom.nodeContains(nextUncontrolled, currentElement)) {
          if (!next.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !dom.nodeContains(uncontrolledCompletelyContainer, nextElement)) {
            return;
          }
          DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
          return;
        }
        if (nextUncontrolled && tabster2.focusable.isVisible(nextUncontrolled) || nextElement.tagName === "IFRAME" && tabster2.focusable.isVisible(nextElement)) {
          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: nextElement,
            relatedEvent: event
          }))) {
            DummyInputManager.moveWithPhantomDummy(tabster2, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
          }
          return;
        }
        if (controlTab || (next === null || next === void 0 ? void 0 : next.outOfDOMOrder)) {
          if (rootElement.dispatchEvent(new TabsterMoveFocusEvent({
            by: "root",
            owner: rootElement,
            next: nextElement,
            relatedEvent: event
          }))) {
            event.preventDefault();
            event.stopImmediatePropagation();
            nativeFocus(nextElement);
          }
        }
      } else {
        if (!uncontrolledCompletelyContainer && rootElement.dispatchEvent(new TabsterMoveFocusEvent({
          by: "root",
          owner: rootElement,
          next: null,
          relatedEvent: event
        }))) {
          ctx.root.moveOutWithDefaultAction(isBackward, event);
        }
      }
    };
    this._onChanged = (element, detail) => {
      var _a, _b;
      if (element) {
        element.dispatchEvent(new TabsterFocusInEvent(detail));
      } else {
        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
        if (last) {
          const d = {
            ...detail
          };
          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
          if (modalizerId) {
            d.modalizerId = modalizerId;
          }
          last.dispatchEvent(new TabsterFocusOutEvent(d));
        }
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    super.dispose();
    const win = this._win();
    const doc = win.document;
    doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
    doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    this.unsubscribe(this._onChanged);
    const asyncFocus = this._asyncFocus;
    if (asyncFocus) {
      win.clearTimeout(asyncFocus.timeout);
      delete this._asyncFocus;
    }
    delete _FocusedElementState._lastResetElement;
    delete this._nextVal;
    delete this._lastVal;
  }
  static forgetMemorized(instance, parent2) {
    var _a, _b;
    let wel = _FocusedElementState._lastResetElement;
    let el = wel && wel.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete _FocusedElementState._lastResetElement;
    }
    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete instance._nextVal;
    }
    wel = instance._lastVal;
    el = wel && wel.get();
    if (el && dom.nodeContains(parent2, el)) {
      delete instance._lastVal;
    }
  }
  getFocusedElement() {
    return this.getVal();
  }
  getLastFocusedElement() {
    var _a;
    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();
    if (!el || el && !documentContains(el.ownerDocument, el)) {
      this._lastVal = el = void 0;
    }
    return el;
  }
  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck, preventScroll) {
    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
      return false;
    }
    element.focus({
      preventScroll
    });
    return true;
  }
  focusDefault(container) {
    const el = this._tabster.focusable.findDefault({
      container
    });
    if (el) {
      this._tabster.focusedElement.focus(el);
      return true;
    }
    return false;
  }
  getFirstOrLastTabbable(isFirst, props) {
    var _a;
    const {
      container,
      ignoreAccessibility
    } = props;
    let toFocus;
    if (container) {
      const ctx = RootAPI.getTabsterContext(this._tabster, container);
      if (ctx) {
        toFocus = (_a = _FocusedElementState.findNextTabbable(this._tabster, ctx, container, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a === void 0 ? void 0 : _a.element;
      }
    }
    if (toFocus && !dom.nodeContains(container, toFocus)) {
      toFocus = void 0;
    }
    return toFocus || void 0;
  }
  _focusFirstOrLast(isFirst, props) {
    const toFocus = this.getFirstOrLastTabbable(isFirst, props);
    if (toFocus) {
      this.focus(toFocus, false, true);
      return true;
    }
    return false;
  }
  focusFirst(props) {
    return this._focusFirstOrLast(true, props);
  }
  focusLast(props) {
    return this._focusFirstOrLast(false, props);
  }
  resetFocus(container) {
    if (!this._tabster.focusable.isVisible(container)) {
      return false;
    }
    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
      const prevTabIndex = container.getAttribute("tabindex");
      const prevAriaHidden = container.getAttribute("aria-hidden");
      container.tabIndex = -1;
      container.setAttribute("aria-hidden", "true");
      _FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
      this.focus(container, true, true);
      this._setOrRemoveAttribute(container, "tabindex", prevTabIndex);
      this._setOrRemoveAttribute(container, "aria-hidden", prevAriaHidden);
    } else {
      this.focus(container);
    }
    return true;
  }
  requestAsyncFocus(source, callback, delay) {
    const win = this._tabster.getWindow();
    const currentAsyncFocus = this._asyncFocus;
    if (currentAsyncFocus) {
      if (AsyncFocusIntentPriorityBySource[source] > AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]) {
        return;
      }
      win.clearTimeout(currentAsyncFocus.timeout);
    }
    this._asyncFocus = {
      source,
      callback,
      timeout: win.setTimeout(() => {
        this._asyncFocus = void 0;
        callback();
      }, delay)
    };
  }
  cancelAsyncFocus(source) {
    const asyncFocus = this._asyncFocus;
    if ((asyncFocus === null || asyncFocus === void 0 ? void 0 : asyncFocus.source) === source) {
      this._tabster.getWindow().clearTimeout(asyncFocus.timeout);
      this._asyncFocus = void 0;
    }
  }
  _setOrRemoveAttribute(element, name, value) {
    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }
  }
  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {
    var _a, _b;
    if (this._tabster._noop) {
      return;
    }
    const detail = {
      relatedTarget
    };
    if (element) {
      const lastResetElement = (_a = _FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
      _FocusedElementState._lastResetElement = void 0;
      if (lastResetElement === element || shouldIgnoreFocus(element)) {
        return;
      }
      detail.isFocusedProgrammatically = isFocusedProgrammatically;
      const ctx = RootAPI.getTabsterContext(this._tabster, element);
      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
      if (modalizerId) {
        detail.modalizerId = modalizerId;
      }
    }
    const nextVal = this._nextVal = {
      element: element ? new WeakHTMLElement(this._win, element) : void 0,
      detail
    };
    if (element && element !== this._val) {
      this._validateFocusedElement(element);
    }
    if (this._nextVal === nextVal) {
      this.setVal(element, detail);
    }
    this._nextVal = void 0;
  }
  setVal(val, detail) {
    super.setVal(val, detail);
    if (val) {
      this._lastVal = new WeakHTMLElement(this._win, val);
    }
  }
  static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const actualContainer = container || ctx.root.getElement();
    if (!actualContainer) {
      return null;
    }
    let next = null;
    const isTabbingTimer = _FocusedElementState._isTabbingTimer;
    const win = tabster.getWindow();
    if (isTabbingTimer) {
      win.clearTimeout(isTabbingTimer);
    }
    _FocusedElementState.isTabbing = true;
    _FocusedElementState._isTabbingTimer = win.setTimeout(() => {
      delete _FocusedElementState._isTabbingTimer;
      _FocusedElementState.isTabbing = false;
    }, 0);
    const modalizer = ctx.modalizer;
    const groupper = ctx.groupper;
    const mover = ctx.mover;
    const callFindNext = (what) => {
      next = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
      if (currentElement && !(next === null || next === void 0 ? void 0 : next.element)) {
        const parentElement2 = what !== modalizer && dom.getParentElement(what.getElement());
        if (parentElement2) {
          const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
            referenceElement: parentElement2
          });
          if (parentCtx) {
            const currentScopeElement = what.getElement();
            const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild$2(currentScopeElement) || currentScopeElement;
            if (newCurrent) {
              next = _FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement2, isBackward, ignoreAccessibility);
              if (next) {
                next.outOfDOMOrder = true;
              }
            }
          }
        }
      }
    };
    if (groupper && mover) {
      callFindNext(ctx.groupperBeforeMover ? groupper : mover);
    } else if (groupper) {
      callFindNext(groupper);
    } else if (mover) {
      callFindNext(mover);
    } else if (modalizer) {
      callFindNext(modalizer);
    } else {
      const findProps = {
        container: actualContainer,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      next = {
        element: nextElement,
        outOfDOMOrder: findPropsOut.outOfDOMOrder,
        uncontrolled: findPropsOut.uncontrolled
      };
    }
    return next;
  }
};
FocusedElementState.isTabbing = false;
var GroupperDummyManager = class extends DummyInputManager {
  constructor(element, groupper, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);
    this._setHandlers((dummyInput, isBackward, relatedTarget) => {
      var _a, _b;
      const container = element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(tabster, input);
        if (ctx) {
          let next;
          next = (_a = groupper.findNextTabbable(relatedTarget || void 0, void 0, isBackward, true)) === null || _a === void 0 ? void 0 : _a.element;
          if (!next) {
            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, void 0, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
          }
          if (next) {
            nativeFocus(next);
          }
        }
      }
    });
  }
};
var Groupper = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    super(tabster, element, props);
    this._shouldTabInside = false;
    this.makeTabbable(false);
    this._onDispose = onDispose;
    if (!tabster.controlTab) {
      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    const element = this._element.get();
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    if (element) {
      if (true) {
        _setInformativeStyle$1(this._element, true);
      }
    }
    delete this._first;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const groupperElement = this.getElement();
    if (!groupperElement) {
      return null;
    }
    const currentIsDummy = getDummyInputContainer(currentElement) === groupperElement;
    if (!this._shouldTabInside && currentElement && dom.nodeContains(groupperElement, currentElement) && !currentIsDummy) {
      return {
        element: void 0,
        outOfDOMOrder: true
      };
    }
    const groupperFirstFocusable = this.getFirst(true);
    if (!currentElement || !dom.nodeContains(groupperElement, currentElement) || currentIsDummy) {
      return {
        element: groupperFirstFocusable,
        outOfDOMOrder: true
      };
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._shouldTabInside && groupperFirstFocusable) {
      const findProps = {
        container: groupperElement,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      if (!next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container: groupperElement,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        outOfDOMOrder = true;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  makeTabbable(isTabbable) {
    this._shouldTabInside = isTabbable || !this._props.tabbability;
    if (true) {
      _setInformativeStyle$1(this._element, !this._shouldTabInside);
    }
  }
  isActive(noIfFirstIsFocused) {
    var _a;
    const element = this.getElement() || null;
    let isParentActive = true;
    for (let e = dom.getParentElement(element); e; e = dom.getParentElement(e)) {
      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (g) {
        if (!g._shouldTabInside) {
          isParentActive = false;
        }
      }
    }
    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : void 0;
    if (ret && noIfFirstIsFocused) {
      const focused = this._tabster.focusedElement.getFocusedElement();
      if (focused) {
        ret = focused !== this.getFirst(true);
      }
    }
    return ret;
  }
  getFirst(orContainer) {
    var _a;
    const groupperElement = this.getElement();
    let first;
    if (groupperElement) {
      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {
        return groupperElement;
      }
      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();
      if (!first) {
        first = this._tabster.focusable.findFirst({
          container: groupperElement,
          useActiveModalizer: true
        }) || void 0;
        if (first) {
          this.setFirst(first);
        }
      }
    }
    return first;
  }
  setFirst(element) {
    if (element) {
      this._first = new WeakHTMLElement(this._tabster.getWindow, element);
    } else {
      delete this._first;
    }
  }
  acceptElement(element, state) {
    const cachedGrouppers = state.cachedGrouppers;
    const parentElement2 = dom.getParentElement(this.getElement());
    const parentCtx = parentElement2 && RootAPI.getTabsterContext(this._tabster, parentElement2);
    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupperBeforeMover) ? parentCtxGroupper : void 0;
    let parentGroupperElement;
    const getIsActive = (groupper) => {
      let cached = cachedGrouppers[groupper.id];
      let isActive2;
      if (cached) {
        isActive2 = cached.isActive;
      } else {
        isActive2 = this.isActive(true);
        cached = cachedGrouppers[groupper.id] = {
          isActive: isActive2
        };
      }
      return isActive2;
    };
    if (parentGroupper) {
      parentGroupperElement = parentGroupper.getElement();
      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && dom.nodeContains(state.container, parentGroupperElement)) {
        state.skippedFocusable = true;
        return NodeFilter.FILTER_REJECT;
      }
    }
    const isActive = getIsActive(this);
    const groupperElement = this.getElement();
    if (groupperElement) {
      if (isActive !== true) {
        if (groupperElement === element && parentCtxGroupper) {
          if (!parentGroupperElement) {
            parentGroupperElement = parentCtxGroupper.getElement();
          }
          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && dom.nodeContains(state.container, parentGroupperElement) && parentGroupperElement !== state.container) {
            state.skippedFocusable = true;
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (groupperElement !== element && dom.nodeContains(groupperElement, element)) {
          state.skippedFocusable = true;
          return NodeFilter.FILTER_REJECT;
        }
        const cached = cachedGrouppers[this.id];
        let first;
        if ("first" in cached) {
          first = cached.first;
        } else {
          first = cached.first = this.getFirst(true);
        }
        if (first && state.acceptCondition(first)) {
          state.rejectElementsFrom = groupperElement;
          state.skippedFocusable = true;
          if (first !== state.from) {
            state.found = true;
            state.foundElement = first;
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_REJECT;
          }
        }
      }
    }
    return void 0;
  }
};
var GroupperAPI = class {
  constructor(tabster, getWindow2) {
    this._current = {};
    this._grouppers = {};
    this._init = () => {
      const win = this._win();
      this._tabster.focusedElement.subscribeFirst(this._onFocus);
      const doc = win.document;
      const activeElement = dom.getActiveElement(doc);
      if (activeElement) {
        this._onFocus(activeElement);
      }
      doc.addEventListener("mousedown", this._onMouseDown, true);
      win.addEventListener("keydown", this._onKeyDown, true);
      win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
    };
    this._onGroupperDispose = (groupper) => {
      delete this._grouppers[groupper.id];
    };
    this._onFocus = (element) => {
      if (element) {
        this._updateCurrent(element);
      }
    };
    this._onMouseDown = (e) => {
      let target = e.target;
      while (target && !this._tabster.focusable.isFocusable(target)) {
        target = this._tabster.getParent(target);
      }
      if (target) {
        this._updateCurrent(target);
      }
    };
    this._onKeyDown = (event) => {
      if (event.key !== Keys.Enter && event.key !== Keys.Escape) {
        return;
      }
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      const element = this._tabster.focusedElement.getFocusedElement();
      if (element) {
        this.handleKeyPress(element, event);
      }
    };
    this._onMoveFocus = (e) => {
      var _a;
      const element = e.composedPath()[0];
      const action = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.action;
      if (element && action !== void 0 && !e.defaultPrevented) {
        if (action === GroupperMoveFocusActions.Enter) {
          this._enterGroupper(element);
        } else {
          this._escapeGroupper(element);
        }
        e.stopImmediatePropagation();
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    tabster.queueInit(this._init);
  }
  dispose() {
    const win = this._win();
    this._tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
    this._current = {};
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    win.document.removeEventListener("mousedown", this._onMouseDown, true);
    win.removeEventListener("keydown", this._onKeyDown, true);
    win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);
    Object.keys(this._grouppers).forEach((groupperId) => {
      if (this._grouppers[groupperId]) {
        this._grouppers[groupperId].dispose();
        delete this._grouppers[groupperId];
      }
    });
  }
  createGroupper(element, props, sys) {
    if (true) ;
    const tabster = this._tabster;
    const newGroupper = new Groupper(tabster, element, this._onGroupperDispose, props, sys);
    this._grouppers[newGroupper.id] = newGroupper;
    const focusedElement = tabster.focusedElement.getFocusedElement();
    if (focusedElement && dom.nodeContains(element, focusedElement) && !this._updateTimer) {
      this._updateTimer = this._win().setTimeout(() => {
        delete this._updateTimer;
        if (focusedElement === tabster.focusedElement.getFocusedElement()) {
          this._updateCurrent(focusedElement);
        }
      }, 0);
    }
    return newGroupper;
  }
  forgetCurrentGrouppers() {
    this._current = {};
  }
  _updateCurrent(element) {
    var _a;
    if (this._updateTimer) {
      this._win().clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    const tabster = this._tabster;
    const newIds = {};
    for (let el = tabster.getParent(element); el; el = tabster.getParent(el)) {
      const groupper = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;
      if (groupper) {
        newIds[groupper.id] = true;
        this._current[groupper.id] = groupper;
        const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);
        groupper.makeTabbable(isTabbable);
      }
    }
    for (const id of Object.keys(this._current)) {
      const groupper = this._current[id];
      if (!(groupper.id in newIds)) {
        groupper.makeTabbable(false);
        groupper.setFirst(void 0);
        delete this._current[id];
      }
    }
  }
  _enterGroupper(element, relatedEvent) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    const groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
    if (groupper && groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {
      const next = tabster.focusable.findNext({
        container: groupperElement,
        currentElement: element,
        useActiveModalizer: true
      });
      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
        by: "groupper",
        owner: groupperElement,
        next,
        relatedEvent
      })))) {
        if (relatedEvent) {
          relatedEvent.preventDefault();
          relatedEvent.stopImmediatePropagation();
        }
        next.focus();
        return next;
      }
    }
    return null;
  }
  _escapeGroupper(element, relatedEvent, fromModalizer) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper);
    const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
    if (groupper && groupperElement && dom.nodeContains(groupperElement, element)) {
      let next;
      if (element !== groupperElement || fromModalizer) {
        next = groupper.getFirst(true);
      } else {
        const parentElement2 = dom.getParentElement(groupperElement);
        const parentCtx = parentElement2 ? RootAPI.getTabsterContext(tabster, parentElement2) : void 0;
        groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;
        next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
      }
      if (next && (!relatedEvent || relatedEvent && groupperElement.dispatchEvent(new TabsterMoveFocusEvent({
        by: "groupper",
        owner: groupperElement,
        next,
        relatedEvent
      })))) {
        if (groupper) {
          groupper.makeTabbable(false);
        }
        next.focus();
        return next;
      }
    }
    return null;
  }
  moveFocus(element, action) {
    return action === GroupperMoveFocusActions.Enter ? this._enterGroupper(element) : this._escapeGroupper(element);
  }
  handleKeyPress(element, event, fromModalizer) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, element);
    if (ctx && ((ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || (ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper))) {
      tabster.focusedElement.cancelAsyncFocus(AsyncFocusSources.EscapeGroupper);
      if (ctx.ignoreKeydown(event)) {
        return;
      }
      if (event.key === Keys.Enter) {
        this._enterGroupper(element, event);
      } else if (event.key === Keys.Escape) {
        const focusedElement = tabster.focusedElement.getFocusedElement();
        tabster.focusedElement.requestAsyncFocus(AsyncFocusSources.EscapeGroupper, () => {
          if (focusedElement !== tabster.focusedElement.getFocusedElement() && // A part of Modalizer that has called this handler to escape the active groupper
          // might have been removed from DOM, if the focus is on body, we still want to handle Esc.
          (fromModalizer && !focusedElement || !fromModalizer)) {
            return;
          }
          this._escapeGroupper(element, event, fromModalizer);
        }, 0);
      }
    }
  }
};
function _setInformativeStyle$1(weakElement, remove) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-groupper");
      } else {
        element.style.setProperty("--tabster-groupper", "unlimited");
      }
    }
  }
}
var KeyboardNavigationState = class extends Subscribable {
  constructor(getWindow2) {
    super();
    this._onChange = (isNavigatingWithKeyboard) => {
      this.setVal(isNavigatingWithKeyboard, void 0);
    };
    this._keyborg = createKeyborg(getWindow2());
    this._keyborg.subscribe(this._onChange);
  }
  dispose() {
    super.dispose();
    if (this._keyborg) {
      this._keyborg.unsubscribe(this._onChange);
      disposeKeyborg(this._keyborg);
      delete this._keyborg;
    }
  }
  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
    var _a;
    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);
  }
  isNavigatingWithKeyboard() {
    var _a;
    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
  }
};
var _wasFocusedCounter = 0;
var _ariaHidden = "aria-hidden";
function _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {
  if (true) {
    const element = weakElement.get();
    if (element) {
      if (remove) {
        element.style.removeProperty("--tabster-modalizer");
      } else {
        element.style.setProperty("--tabster-modalizer", internalId + "," + userId + "," + (isActive ? "active" : "inactive") + ",," + (wasFocused ? `focused(${wasFocused})` : "not-focused"));
      }
    }
  }
}
var ModalizerDummyManager = class extends DummyInputManager {
  constructor(element, tabster, sys) {
    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);
    this._setHandlers((dummyInput, isBackward) => {
      var _a, _b;
      const el = element.get();
      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());
      const input = dummyInput.input;
      let toFocus;
      if (container && input) {
        const dummyContainer = getDummyInputContainer(input);
        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
        if (ctx) {
          toFocus = (_b = FocusedElementState.findNextTabbable(tabster, ctx, container, input, void 0, isBackward, true)) === null || _b === void 0 ? void 0 : _b.element;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    });
  }
};
var Modalizer = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys, activeElements) {
    super(tabster, element, props);
    this._wasFocused = 0;
    this.userId = props.id;
    this._onDispose = onDispose;
    this._activeElements = activeElements;
    if (!tabster.controlTab) {
      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
    }
    if (true) {
      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
    }
  }
  makeActive(isActive) {
    if (this._isActive !== isActive) {
      this._isActive = isActive;
      const element = this.getElement();
      if (element) {
        const activeElements = this._activeElements;
        const index = activeElements.map((e) => e.get()).indexOf(element);
        if (isActive) {
          if (index < 0) {
            activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element));
          }
        } else {
          if (index >= 0) {
            activeElements.splice(index, 1);
          }
        }
      }
      if (true) {
        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);
      }
      this._dispatchEvent(isActive);
    }
  }
  focused(noIncrement) {
    if (!noIncrement) {
      this._wasFocused = ++_wasFocusedCounter;
    }
    return this._wasFocused;
  }
  setProps(props) {
    if (props.id) {
      this.userId = props.id;
    }
    this._props = {
      ...props
    };
  }
  dispose() {
    var _a;
    this.makeActive(false);
    this._onDispose(this);
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
    this._activeElements = [];
    this._remove();
  }
  isActive() {
    return !!this._isActive;
  }
  contains(element) {
    return dom.nodeContains(this.getElement(), element);
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    var _a, _b;
    const modalizerElement = this.getElement();
    if (!modalizerElement) {
      return null;
    }
    const tabster = this._tabster;
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());
    if (container) {
      const findProps = {
        container,
        currentElement,
        referenceElement,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      if (!next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
        next = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
          container,
          ignoreAccessibility,
          useActiveModalizer: true
        }, findPropsOut);
        if (next === null) {
          next = currentElement;
        }
        outOfDOMOrder = true;
      } else {
        outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      }
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  _dispatchEvent(isActive, allElements) {
    const element = this.getElement();
    let defaultPrevented = false;
    if (element) {
      const elements = allElements ? this._activeElements.map((e) => e.get()) : [element];
      for (const el of elements) {
        if (el) {
          const eventDetail = {
            id: this.userId,
            element
          };
          const event = isActive ? new ModalizerActiveEvent(eventDetail) : new ModalizerInactiveEvent(eventDetail);
          el.dispatchEvent(event);
          if (event.defaultPrevented) {
            defaultPrevented = true;
          }
        }
      }
    }
    return defaultPrevented;
  }
  _remove() {
    if (true) {
      _setInformativeStyle(this._element, true);
    }
  }
};
var ModalizerAPI = class {
  constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
    this._onModalizerDispose = (modalizer) => {
      const id = modalizer.id;
      const userId = modalizer.userId;
      const part = this._parts[userId];
      delete this._modalizers[id];
      if (part) {
        delete part[id];
        if (Object.keys(part).length === 0) {
          delete this._parts[userId];
          const activationHistory = this._activationHistory;
          const cleanActivationHistory = [];
          let prevHistoryItem;
          for (let i = activationHistory.length; i--; ) {
            const modalizerUserIdFromHistory = activationHistory[i];
            if (modalizerUserIdFromHistory === userId) {
              continue;
            }
            if (modalizerUserIdFromHistory !== prevHistoryItem) {
              prevHistoryItem = modalizerUserIdFromHistory;
              if (modalizerUserIdFromHistory || cleanActivationHistory.length > 0) {
                cleanActivationHistory.unshift(modalizerUserIdFromHistory);
              }
            }
          }
          this._activationHistory = cleanActivationHistory;
          if (this.activeId === userId) {
            const prevActiveId = cleanActivationHistory[0];
            const prevActive = prevActiveId ? Object.values(this._parts[prevActiveId])[0] : void 0;
            this.setActive(prevActive);
          }
        }
      }
    };
    this._onKeyDown = (event) => {
      var _a;
      if (event.key !== Keys.Escape) {
        return;
      }
      const tabster2 = this._tabster;
      const element = tabster2.focusedElement.getFocusedElement();
      if (element) {
        const ctx = RootAPI.getTabsterContext(tabster2, element);
        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
          const activeId = modalizer.userId;
          if (activeId) {
            const part = this._parts[activeId];
            if (part) {
              const focusedSince = Object.keys(part).map((id) => {
                var _a2;
                const m = part[id];
                const el = m.getElement();
                let groupper;
                if (el) {
                  groupper = (_a2 = getTabsterOnElement(tabster2, el)) === null || _a2 === void 0 ? void 0 : _a2.groupper;
                }
                return m && el && groupper ? {
                  el,
                  focusedSince: m.focused(true)
                } : {
                  focusedSince: 0
                };
              }).filter((f) => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);
              if (focusedSince.length) {
                const groupperElement = focusedSince[0].el;
                if (groupperElement) {
                  (_a = tabster2.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);
                }
              }
            }
          }
        }
      }
    };
    this._onFocus = (focusedElement, detail) => {
      var _a;
      const tabster2 = this._tabster;
      const ctx = focusedElement && RootAPI.getTabsterContext(tabster2, focusedElement);
      if (!ctx || !focusedElement) {
        return;
      }
      const augmentedMap = this._augMap;
      for (let e = focusedElement; e; e = dom.getParentElement(e)) {
        if (augmentedMap.has(e)) {
          augmentedMap.delete(e);
          augmentAttribute(tabster2, e, _ariaHidden);
        }
      }
      let modalizer = ctx.modalizer;
      const tabsterOnFocusedElement = getTabsterOnElement(tabster2, focusedElement);
      const modalizerOnFocusedElement = tabsterOnFocusedElement === null || tabsterOnFocusedElement === void 0 ? void 0 : tabsterOnFocusedElement.modalizer;
      if (modalizerOnFocusedElement) {
        modalizerOnFocusedElement.focused();
        if (modalizerOnFocusedElement.userId === this.activeId && tabsterOnFocusedElement.groupper) {
          const parentElement2 = tabster2.getParent(focusedElement);
          const parentModalizer = parentElement2 && ((_a = RootAPI.getTabsterContext(tabster2, parentElement2)) === null || _a === void 0 ? void 0 : _a.modalizer);
          if (parentModalizer) {
            modalizer = parentModalizer;
          } else {
            this.setActive(void 0);
            return;
          }
        }
      }
      modalizer === null || modalizer === void 0 ? void 0 : modalizer.focused();
      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
        return;
      }
      if (detail.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
        this.setActive(modalizer);
      } else {
        const win2 = this._win();
        win2.clearTimeout(this._restoreModalizerFocusTimer);
        this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._modalizers = {};
    this._parts = {};
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._alwaysAccessibleSelector = alwaysAccessibleSelector;
    this._accessibleCheck = accessibleCheck;
    this._activationHistory = [];
    this.activeElements = [];
    if (!tabster.controlTab) {
      tabster.root.addDummyInputs();
    }
    const win = this._win();
    win.addEventListener("keydown", this._onKeyDown, true);
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    const win = this._win();
    win.removeEventListener("keydown", this._onKeyDown, true);
    Object.keys(this._modalizers).forEach((modalizerId) => {
      if (this._modalizers[modalizerId]) {
        this._modalizers[modalizerId].dispose();
        delete this._modalizers[modalizerId];
      }
    });
    win.clearTimeout(this._restoreModalizerFocusTimer);
    win.clearTimeout(this._hiddenUpdateTimer);
    this._parts = {};
    delete this.activeId;
    this.activeElements = [];
    this._augMap = /* @__PURE__ */ new WeakMap();
    this._aug = [];
    this._tabster.focusedElement.unsubscribe(this._onFocus);
  }
  createModalizer(element, props, sys) {
    var _a;
    if (true) ;
    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);
    const id = modalizer.id;
    const userId = props.id;
    this._modalizers[id] = modalizer;
    let part = this._parts[userId];
    if (!part) {
      part = this._parts[userId] = {};
    }
    part[id] = modalizer;
    const focusedElement = (_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null;
    if (element !== focusedElement && dom.nodeContains(element, focusedElement)) {
      if (userId !== this.activeId) {
        this.setActive(modalizer);
      } else {
        modalizer.makeActive(true);
      }
    }
    return modalizer;
  }
  isAugmented(element) {
    return this._augMap.has(element);
  }
  hiddenUpdate() {
    if (this._hiddenUpdateTimer) {
      return;
    }
    this._hiddenUpdateTimer = this._win().setTimeout(() => {
      delete this._hiddenUpdateTimer;
      this._hiddenUpdate();
    }, 250);
  }
  setActive(modalizer) {
    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
    const activeId = this.activeId;
    if (activeId === userId) {
      return;
    }
    this.activeId = userId;
    if (activeId) {
      const part = this._parts[activeId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(false);
        }
      }
    }
    if (userId) {
      const part = this._parts[userId];
      if (part) {
        for (const id of Object.keys(part)) {
          part[id].makeActive(true);
        }
      }
    }
    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
    this.hiddenUpdate();
    const activationHistory = this._activationHistory;
    if (activationHistory[0] !== userId && (userId !== void 0 || activationHistory.length > 0)) {
      activationHistory.unshift(userId);
    }
  }
  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, elementFromModalizer);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    if (modalizer) {
      this.setActive(modalizer);
      const props = modalizer.getProps();
      const modalizerRoot = modalizer.getElement();
      if (modalizerRoot) {
        if (noFocusFirst === void 0) {
          noFocusFirst = props.isNoFocusFirst;
        }
        if (!noFocusFirst && tabster.keyboardNavigation.isNavigatingWithKeyboard() && tabster.focusedElement.focusFirst({
          container: modalizerRoot
        })) {
          return true;
        }
        if (noFocusDefault === void 0) {
          noFocusDefault = props.isNoFocusDefault;
        }
        if (!noFocusDefault && tabster.focusedElement.focusDefault(modalizerRoot)) {
          return true;
        }
        tabster.focusedElement.resetFocus(modalizerRoot);
      }
    } else if (true) {
      console.error("Element is not in Modalizer.", elementFromModalizer);
    }
    return false;
  }
  activate(modalizerElementOrContainer) {
    var _a;
    const modalizerToActivate = modalizerElementOrContainer ? (_a = RootAPI.getTabsterContext(this._tabster, modalizerElementOrContainer)) === null || _a === void 0 ? void 0 : _a.modalizer : void 0;
    if (!modalizerElementOrContainer || modalizerToActivate) {
      this.setActive(modalizerToActivate);
      return true;
    }
    return false;
  }
  acceptElement(element, state) {
    var _a;
    const modalizerUserId = state.modalizerUserId;
    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;
    if (modalizerUserId) {
      for (const e of this.activeElements) {
        const el = e.get();
        if (el && (dom.nodeContains(element, el) || el === element)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
    }
    const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
    if (ret !== void 0) {
      state.skippedFocusable = true;
    }
    return ret;
  }
  _hiddenUpdate() {
    var _a;
    const tabster = this._tabster;
    const body = tabster.getWindow().document.body;
    const activeId = this.activeId;
    const parts = this._parts;
    const visibleElements = [];
    const hiddenElements = [];
    const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
    const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(dom.querySelectorAll(body, alwaysAccessibleSelector)) : [];
    const activeModalizerElements = [];
    for (const userId of Object.keys(parts)) {
      const modalizerParts = parts[userId];
      for (const id of Object.keys(modalizerParts)) {
        const modalizer = modalizerParts[id];
        const el = modalizer.getElement();
        const props = modalizer.getProps();
        const isAlwaysAccessible = props.isAlwaysAccessible;
        if (el) {
          if (userId === activeId) {
            activeModalizerElements.push(el);
            if (!this.currentIsOthersAccessible) {
              visibleElements.push(el);
            }
          } else if (isAlwaysAccessible) {
            alwaysAccessibleElements.push(el);
          } else {
            hiddenElements.push(el);
          }
        }
      }
    }
    const augmentedMap = this._augMap;
    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
    const newAugmented = [];
    const newAugmentedMap = /* @__PURE__ */ new WeakMap();
    const toggle = (element, hide3) => {
      var _a2;
      const tagName = element.tagName;
      if (tagName === "SCRIPT" || tagName === "STYLE") {
        return;
      }
      let isAugmented = false;
      if (augmentedMap.has(element)) {
        if (hide3) {
          isAugmented = true;
        } else {
          augmentedMap.delete(element);
          augmentAttribute(tabster, element, _ariaHidden);
        }
      } else if (hide3 && !((_a2 = this._accessibleCheck) === null || _a2 === void 0 ? void 0 : _a2.call(this, element, activeModalizerElements)) && augmentAttribute(tabster, element, _ariaHidden, "true")) {
        augmentedMap.set(element, true);
        isAugmented = true;
      }
      if (isAugmented) {
        newAugmented.push(new WeakHTMLElement(tabster.getWindow, element));
        newAugmentedMap.set(element, true);
      }
    };
    const walk = (element) => {
      var _a2;
      for (let el = dom.getFirstElementChild(element); el; el = dom.getNextElementSibling(el)) {
        let skip = false;
        let containsModalizer = false;
        let containedByModalizer = false;
        if (allVisibleElements) {
          const elParent = tabster.getParent(el);
          for (const c of allVisibleElements) {
            if (el === c) {
              skip = true;
              break;
            }
            if (dom.nodeContains(el, c)) {
              containsModalizer = true;
              break;
            } else if (dom.nodeContains(c, elParent)) {
              containedByModalizer = true;
            }
          }
          if (containsModalizer || ((_a2 = el.__tabsterElementFlags) === null || _a2 === void 0 ? void 0 : _a2.noDirectAriaHidden)) {
            walk(el);
          } else if (!skip && !containedByModalizer) {
            toggle(el, true);
          }
        } else {
          toggle(el, false);
        }
      }
    };
    if (!allVisibleElements) {
      alwaysAccessibleElements.forEach((e) => toggle(e, false));
    }
    hiddenElements.forEach((e) => toggle(e, true));
    if (body) {
      walk(body);
    }
    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map((e) => e.get()).forEach((e) => {
      if (e && !newAugmentedMap.get(e)) {
        toggle(e, false);
      }
    });
    this._aug = newAugmented;
    this._augMap = newAugmentedMap;
  }
  /**
   * Called when an element is focused outside of an active modalizer.
   * Attempts to pull focus back into the active modalizer
   * @param outsideElement - An element being focused outside of the modalizer
   */
  _restoreModalizerFocus(outsideElement) {
    var _a;
    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
    if (!outsideElement || !ownerDocument) {
      return;
    }
    const focusedElement = this._tabster.focusedElement.getFocusedElement();
    const focusedElementModalizer = focusedElement && ((_a = RootAPI.getTabsterContext(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer);
    if (!focusedElement || focusedElement && (focusedElementModalizer === null || focusedElementModalizer === void 0 ? void 0 : focusedElementModalizer.userId) === this.activeId) {
      return;
    }
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, outsideElement);
    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
    const activeId = this.activeId;
    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
      return;
    }
    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
    if (container) {
      let toFocus = tabster.focusable.findFirst({
        container,
        useActiveModalizer: true
      });
      if (toFocus) {
        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
          toFocus = tabster.focusable.findLast({
            container,
            useActiveModalizer: true
          });
          if (!toFocus) {
            throw new Error("Something went wrong.");
          }
        }
        tabster.focusedElement.focus(toFocus);
        return;
      }
    }
    outsideElement.blur();
  }
};
var _inputSelector = ["input", "textarea", "*[contenteditable]"].join(", ");
var MoverDummyManager = class extends DummyInputManager {
  constructor(element, tabster, getMemorized, sys) {
    super(tabster, element, DummyInputManagerPriorities.Mover, sys);
    this._onFocusDummyInput = (dummyInput) => {
      var _a, _b;
      const container = this._element.get();
      const input = dummyInput.input;
      if (container && input) {
        const ctx = RootAPI.getTabsterContext(this._tabster, container);
        let toFocus;
        if (ctx) {
          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;
        }
        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
        if (memorized && this._tabster.focusable.isFocusable(memorized)) {
          toFocus = memorized;
        }
        if (toFocus) {
          nativeFocus(toFocus);
        }
      }
    };
    this._tabster = tabster;
    this._getMemorized = getMemorized;
    this._setHandlers(this._onFocusDummyInput);
  }
};
var _moverUpdateAdd = 1;
var _moverUpdateAttr = 2;
var _moverUpdateRemove = 3;
var Mover = class extends TabsterPart {
  constructor(tabster, element, onDispose, props, sys) {
    var _a;
    super(tabster, element, props);
    this._visible = {};
    this._onIntersection = (entries) => {
      for (const entry of entries) {
        const el = entry.target;
        const id = getElementUId(this._win, el);
        let newVisibility;
        let fullyVisible = this._fullyVisible;
        if (entry.intersectionRatio >= 0.25) {
          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
          if (newVisibility === Visibilities.Visible) {
            fullyVisible = id;
          }
        } else {
          newVisibility = Visibilities.Invisible;
        }
        if (this._visible[id] !== newVisibility) {
          if (newVisibility === void 0) {
            delete this._visible[id];
            if (fullyVisible === id) {
              delete this._fullyVisible;
            }
          } else {
            this._visible[id] = newVisibility;
            this._fullyVisible = fullyVisible;
          }
          const state = this.getState(el);
          if (state) {
            el.dispatchEvent(new MoverStateEvent(state));
          }
        }
      }
    };
    this._win = tabster.getWindow;
    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;
    if (this._props.trackState || this._props.visibilityAware) {
      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
        threshold: [0, 0.25, 0.5, 0.75, 1]
      });
      this._observeState();
    }
    this._onDispose = onDispose;
    const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
    if (!tabster.controlTab) {
      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
    }
  }
  dispose() {
    var _a;
    this._onDispose(this);
    if (this._intersectionObserver) {
      this._intersectionObserver.disconnect();
      delete this._intersectionObserver;
    }
    delete this._current;
    delete this._fullyVisible;
    delete this._allElements;
    delete this._updateQueue;
    if (this._unobserve) {
      this._unobserve();
      delete this._unobserve;
    }
    const win = this._win();
    if (this._setCurrentTimer) {
      win.clearTimeout(this._setCurrentTimer);
      delete this._setCurrentTimer;
    }
    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      delete this._updateTimer;
    }
    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();
    delete this.dummyManager;
  }
  setCurrent(element) {
    if (element) {
      this._current = new WeakHTMLElement(this._win, element);
    } else {
      this._current = void 0;
    }
    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
      this._setCurrentTimer = this._win().setTimeout(() => {
        var _a;
        delete this._setCurrentTimer;
        const changed = [];
        if (this._current !== this._prevCurrent) {
          changed.push(this._current);
          changed.push(this._prevCurrent);
          this._prevCurrent = this._current;
        }
        for (const weak of changed) {
          const el = weak === null || weak === void 0 ? void 0 : weak.get();
          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {
            const props = this._props;
            if (el && (props.visibilityAware !== void 0 || props.trackState)) {
              const state = this.getState(el);
              if (state) {
                el.dispatchEvent(new MoverStateEvent(state));
              }
            }
          }
        }
      });
    }
  }
  getCurrent() {
    var _a;
    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
  }
  findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
    const container = this.getElement();
    const currentIsDummy = container && getDummyInputContainer(currentElement) === container;
    if (!container) {
      return null;
    }
    let next = null;
    let outOfDOMOrder = false;
    let uncontrolled;
    if (this._props.tabbable || currentIsDummy || currentElement && !dom.nodeContains(container, currentElement)) {
      const findProps = {
        currentElement,
        referenceElement,
        container,
        ignoreAccessibility,
        useActiveModalizer: true
      };
      const findPropsOut = {};
      next = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
      outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
      uncontrolled = findPropsOut.uncontrolled;
    }
    return {
      element: next,
      uncontrolled,
      outOfDOMOrder
    };
  }
  acceptElement(element, state) {
    var _a, _b;
    if (!FocusedElementState.isTabbing) {
      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
    }
    const {
      memorizeCurrent,
      visibilityAware,
      hasDefault = true
    } = this._props;
    const moverElement = this.getElement();
    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!dom.nodeContains(moverElement, state.from) || getDummyInputContainer(state.from) === moverElement)) {
      let found;
      if (memorizeCurrent) {
        const current = (_b = this._current) === null || _b === void 0 ? void 0 : _b.get();
        if (current && state.acceptCondition(current)) {
          found = current;
        }
      }
      if (!found && hasDefault) {
        found = this._tabster.focusable.findDefault({
          container: moverElement,
          useActiveModalizer: true
        });
      }
      if (!found && visibilityAware) {
        found = this._tabster.focusable.findElement({
          container: moverElement,
          useActiveModalizer: true,
          isBackward: state.isBackward,
          acceptCondition: (el) => {
            var _a2;
            const id = getElementUId(this._win, el);
            const visibility = this._visible[id];
            return moverElement !== el && !!((_a2 = this._allElements) === null || _a2 === void 0 ? void 0 : _a2.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
          }
        });
      }
      if (found) {
        state.found = true;
        state.foundElement = found;
        state.rejectElementsFrom = moverElement;
        state.skippedFocusable = true;
        return NodeFilter.FILTER_ACCEPT;
      }
    }
    return void 0;
  }
  _observeState() {
    const element = this.getElement();
    if (this._unobserve || !element || typeof MutationObserver === "undefined") {
      return;
    }
    const win = this._win();
    const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
    const tabsterFocusable = this._tabster.focusable;
    let updateQueue = this._updateQueue = [];
    const observer = dom.createMutationObserver((mutations) => {
      for (const mutation of mutations) {
        const target = mutation.target;
        const removed = mutation.removedNodes;
        const added = mutation.addedNodes;
        if (mutation.type === "attributes") {
          if (mutation.attributeName === "tabindex") {
            updateQueue.push({
              element: target,
              type: _moverUpdateAttr
            });
          }
        } else {
          for (let i = 0; i < removed.length; i++) {
            updateQueue.push({
              element: removed[i],
              type: _moverUpdateRemove
            });
          }
          for (let i = 0; i < added.length; i++) {
            updateQueue.push({
              element: added[i],
              type: _moverUpdateAdd
            });
          }
        }
      }
      requestUpdate();
    });
    const setElement = (element2, remove) => {
      var _a, _b;
      const current = allElements.get(element2);
      if (current && remove) {
        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element2);
        allElements.delete(element2);
      }
      if (!current && !remove) {
        allElements.set(element2, this);
        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element2);
      }
    };
    const updateElement = (element2) => {
      const isFocusable = tabsterFocusable.isFocusable(element2);
      const current = allElements.get(element2);
      if (current) {
        if (!isFocusable) {
          setElement(element2, true);
        }
      } else {
        if (isFocusable) {
          setElement(element2);
        }
      }
    };
    const addNewElements = (element2) => {
      const {
        mover
      } = getMoverGroupper(element2);
      if (mover && mover !== this) {
        if (mover.getElement() === element2 && tabsterFocusable.isFocusable(element2)) {
          setElement(element2);
        } else {
          return;
        }
      }
      const walker = createElementTreeWalker(win.document, element2, (node) => {
        const {
          mover: mover2,
          groupper
        } = getMoverGroupper(node);
        if (mover2 && mover2 !== this) {
          return NodeFilter.FILTER_REJECT;
        }
        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {
          return NodeFilter.FILTER_REJECT;
        }
        if (tabsterFocusable.isFocusable(node)) {
          setElement(node);
        }
        return NodeFilter.FILTER_SKIP;
      });
      if (walker) {
        walker.currentNode = element2;
        while (walker.nextNode()) {
        }
      }
    };
    const removeWalk = (element2) => {
      const current = allElements.get(element2);
      if (current) {
        setElement(element2, true);
      }
      for (let el = dom.getFirstElementChild(element2); el; el = dom.getNextElementSibling(el)) {
        removeWalk(el);
      }
    };
    const requestUpdate = () => {
      if (!this._updateTimer && updateQueue.length) {
        this._updateTimer = win.setTimeout(() => {
          delete this._updateTimer;
          for (const {
            element: element2,
            type
          } of updateQueue) {
            switch (type) {
              case _moverUpdateAttr:
                updateElement(element2);
                break;
              case _moverUpdateAdd:
                addNewElements(element2);
                break;
              case _moverUpdateRemove:
                removeWalk(element2);
                break;
            }
          }
          updateQueue = this._updateQueue = [];
        }, 0);
      }
    };
    const getMoverGroupper = (element2) => {
      const ret = {};
      for (let el = element2; el; el = dom.getParentElement(el)) {
        const toe = getTabsterOnElement(this._tabster, el);
        if (toe) {
          if (toe.groupper && !ret.groupper) {
            ret.groupper = toe.groupper;
          }
          if (toe.mover) {
            ret.mover = toe.mover;
            break;
          }
        }
      }
      return ret;
    };
    updateQueue.push({
      element,
      type: _moverUpdateAdd
    });
    requestUpdate();
    observer.observe(element, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["tabindex"]
    });
    this._unobserve = () => {
      observer.disconnect();
    };
  }
  getState(element) {
    const id = getElementUId(this._win, element);
    if (id in this._visible) {
      const visibility = this._visible[id] || Visibilities.Invisible;
      const isCurrent = this._current ? this._current.get() === element : void 0;
      return {
        isCurrent,
        visibility
      };
    }
    return void 0;
  }
};
function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
}
var MoverAPI = class {
  constructor(tabster, getWindow2) {
    this._init = () => {
      const win = this._win();
      win.addEventListener("keydown", this._onKeyDown, true);
      win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);
      win.addEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
      this._tabster.focusedElement.subscribe(this._onFocus);
    };
    this._onMoverDispose = (mover) => {
      delete this._movers[mover.id];
    };
    this._onFocus = (element) => {
      var _a;
      let currentFocusableElement = element;
      let deepestFocusableElement = element;
      for (let el = dom.getParentElement(element); el; el = dom.getParentElement(el)) {
        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;
        if (mover) {
          mover.setCurrent(deepestFocusableElement);
          currentFocusableElement = void 0;
        }
        if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
          currentFocusableElement = deepestFocusableElement = el;
        }
      }
    };
    this._onKeyDown = async (event) => {
      var _a;
      if (this._ignoredInputTimer) {
        this._win().clearTimeout(this._ignoredInputTimer);
        delete this._ignoredInputTimer;
      }
      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
      if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
        return;
      }
      const key = event.key;
      let moverKey;
      if (key === Keys.ArrowDown) {
        moverKey = MoverKeys.ArrowDown;
      } else if (key === Keys.ArrowRight) {
        moverKey = MoverKeys.ArrowRight;
      } else if (key === Keys.ArrowUp) {
        moverKey = MoverKeys.ArrowUp;
      } else if (key === Keys.ArrowLeft) {
        moverKey = MoverKeys.ArrowLeft;
      } else if (key === Keys.PageDown) {
        moverKey = MoverKeys.PageDown;
      } else if (key === Keys.PageUp) {
        moverKey = MoverKeys.PageUp;
      } else if (key === Keys.Home) {
        moverKey = MoverKeys.Home;
      } else if (key === Keys.End) {
        moverKey = MoverKeys.End;
      }
      if (!moverKey) {
        return;
      }
      const focused = this._tabster.focusedElement.getFocusedElement();
      if (!focused || await this._isIgnoredInput(focused, key)) {
        return;
      }
      this._moveFocus(focused, moverKey, event);
    };
    this._onMoveFocus = (e) => {
      var _a;
      const element = e.composedPath()[0];
      const key = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.key;
      if (element && key !== void 0 && !e.defaultPrevented) {
        this._moveFocus(element, key);
        e.stopImmediatePropagation();
      }
    };
    this._onMemorizedElement = (e) => {
      var _a;
      const target = e.composedPath()[0];
      let memorizedElement = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.memorizedElement;
      if (target) {
        const ctx = RootAPI.getTabsterContext(this._tabster, target);
        const mover = ctx === null || ctx === void 0 ? void 0 : ctx.mover;
        if (mover) {
          if (memorizedElement && !dom.nodeContains(mover.getElement(), memorizedElement)) {
            memorizedElement = void 0;
          }
          mover.setCurrent(memorizedElement);
          e.stopImmediatePropagation();
        }
      }
    };
    this._tabster = tabster;
    this._win = getWindow2;
    this._movers = {};
    tabster.queueInit(this._init);
  }
  dispose() {
    var _a;
    const win = this._win();
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
    if (this._ignoredInputTimer) {
      win.clearTimeout(this._ignoredInputTimer);
      delete this._ignoredInputTimer;
    }
    win.removeEventListener("keydown", this._onKeyDown, true);
    win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);
    win.removeEventListener(MoverMemorizedElementEventName, this._onMemorizedElement);
    Object.keys(this._movers).forEach((moverId) => {
      if (this._movers[moverId]) {
        this._movers[moverId].dispose();
        delete this._movers[moverId];
      }
    });
  }
  createMover(element, props, sys) {
    if (true) ;
    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);
    this._movers[newMover.id] = newMover;
    return newMover;
  }
  moveFocus(fromElement, key) {
    return this._moveFocus(fromElement, key);
  }
  _moveFocus(fromElement, key, relatedEvent) {
    var _a, _b;
    const tabster = this._tabster;
    const ctx = RootAPI.getTabsterContext(tabster, fromElement, {
      checkRtl: true
    });
    if (!ctx || !ctx.mover || ctx.excludedFromMover || relatedEvent && ctx.ignoreKeydown(relatedEvent)) {
      return null;
    }
    const mover = ctx.mover;
    const container = mover.getElement();
    if (ctx.groupperBeforeMover) {
      const groupper = ctx.groupper;
      if (groupper && !groupper.isActive(true)) {
        for (let el = dom.getParentElement(groupper.getElement()); el && el !== container; el = dom.getParentElement(el)) {
          if ((_b = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper) === null || _b === void 0 ? void 0 : _b.isActive(true)) {
            return null;
          }
        }
      } else {
        return null;
      }
    }
    if (!container) {
      return null;
    }
    const focusable = tabster.focusable;
    const moverProps = mover.getProps();
    const direction = moverProps.direction || MoverDirections.Both;
    const isBoth = direction === MoverDirections.Both;
    const isVertical = isBoth || direction === MoverDirections.Vertical;
    const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
    const isGridLinear = direction === MoverDirections.GridLinear;
    const isGrid = isGridLinear || direction === MoverDirections.Grid;
    const isCyclic = moverProps.cyclic;
    let next;
    let scrollIntoViewArg;
    let focusedElementRect;
    let focusedElementX1 = 0;
    let focusedElementX2 = 0;
    if (isGrid) {
      focusedElementRect = fromElement.getBoundingClientRect();
      focusedElementX1 = Math.ceil(focusedElementRect.left);
      focusedElementX2 = Math.floor(focusedElementRect.right);
    }
    if (ctx.rtl) {
      if (key === MoverKeys.ArrowRight) {
        key = MoverKeys.ArrowLeft;
      } else if (key === MoverKeys.ArrowLeft) {
        key = MoverKeys.ArrowRight;
      }
    }
    if (key === MoverKeys.ArrowDown && isVertical || key === MoverKeys.ArrowRight && (isHorizontal || isGrid)) {
      next = focusable.findNext({
        currentElement: fromElement,
        container,
        useActiveModalizer: true
      });
      if (next && isGrid) {
        const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);
        if (!isGridLinear && focusedElementX2 > nextElementX1) {
          next = void 0;
        }
      } else if (!next && isCyclic) {
        next = focusable.findFirst({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.ArrowUp && isVertical || key === MoverKeys.ArrowLeft && (isHorizontal || isGrid)) {
      next = focusable.findPrev({
        currentElement: fromElement,
        container,
        useActiveModalizer: true
      });
      if (next && isGrid) {
        const nextElementX2 = Math.floor(next.getBoundingClientRect().right);
        if (!isGridLinear && nextElementX2 > focusedElementX1) {
          next = void 0;
        }
      } else if (!next && isCyclic) {
        next = focusable.findLast({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.Home) {
      if (isGrid) {
        focusable.findElement({
          container,
          currentElement: fromElement,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            var _a2;
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
            if (el !== fromElement && focusedElementX1 <= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      } else {
        next = focusable.findFirst({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.End) {
      if (isGrid) {
        focusable.findElement({
          container,
          currentElement: fromElement,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            var _a2;
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil((_a2 = el.getBoundingClientRect().left) !== null && _a2 !== void 0 ? _a2 : 0);
            if (el !== fromElement && focusedElementX1 >= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      } else {
        next = focusable.findLast({
          container,
          useActiveModalizer: true
        });
      }
    } else if (key === MoverKeys.PageUp) {
      focusable.findElement({
        currentElement: fromElement,
        container,
        useActiveModalizer: true,
        isBackward: true,
        acceptCondition: (el) => {
          if (!focusable.isFocusable(el)) {
            return false;
          }
          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
            next = el;
            return false;
          }
          return true;
        }
      });
      if (isGrid && next) {
        const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);
        focusable.findElement({
          currentElement: next,
          container,
          useActiveModalizer: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
            if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      }
      scrollIntoViewArg = false;
    } else if (key === MoverKeys.PageDown) {
      focusable.findElement({
        currentElement: fromElement,
        container,
        useActiveModalizer: true,
        acceptCondition: (el) => {
          if (!focusable.isFocusable(el)) {
            return false;
          }
          if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
            next = el;
            return false;
          }
          return true;
        }
      });
      if (isGrid && next) {
        const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);
        focusable.findElement({
          currentElement: next,
          container,
          useActiveModalizer: true,
          isBackward: true,
          acceptCondition: (el) => {
            if (!focusable.isFocusable(el)) {
              return false;
            }
            const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
            if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
              return true;
            }
            next = el;
            return false;
          }
        });
      }
      scrollIntoViewArg = true;
    } else if (isGrid) {
      const isBackward = key === MoverKeys.ArrowUp;
      const ax1 = focusedElementX1;
      const ay1 = Math.ceil(focusedElementRect.top);
      const ax2 = focusedElementX2;
      const ay2 = Math.floor(focusedElementRect.bottom);
      let targetElement;
      let lastDistance;
      let lastIntersection = 0;
      focusable.findAll({
        container,
        currentElement: fromElement,
        isBackward,
        onElement: (el) => {
          const rect = el.getBoundingClientRect();
          const bx1 = Math.ceil(rect.left);
          const by1 = Math.ceil(rect.top);
          const bx2 = Math.floor(rect.right);
          const by2 = Math.floor(rect.bottom);
          if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
            return true;
          }
          const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
          const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
          if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
            const intersection = xIntersectionWidth / minWidth;
            if (intersection > lastIntersection) {
              targetElement = el;
              lastIntersection = intersection;
            }
          } else if (lastIntersection === 0) {
            const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
            if (lastDistance === void 0 || distance < lastDistance) {
              lastDistance = distance;
              targetElement = el;
            }
          } else if (lastIntersection > 0) {
            return false;
          }
          return true;
        }
      });
      next = targetElement;
    }
    if (next && (!relatedEvent || relatedEvent && container.dispatchEvent(new TabsterMoveFocusEvent({
      by: "mover",
      owner: container,
      next,
      relatedEvent
    })))) {
      if (scrollIntoViewArg !== void 0) {
        scrollIntoView(this._win, next, scrollIntoViewArg);
      }
      if (relatedEvent) {
        relatedEvent.preventDefault();
        relatedEvent.stopImmediatePropagation();
      }
      nativeFocus(next);
      return next;
    }
    return null;
  }
  async _isIgnoredInput(element, key) {
    if (element.getAttribute("aria-expanded") === "true" && (element.hasAttribute("aria-activedescendant") || element.getAttribute("role") === "combobox")) {
      return true;
    }
    if (matchesSelector(element, _inputSelector)) {
      let selectionStart = 0;
      let selectionEnd = 0;
      let textLength = 0;
      let asyncRet;
      if (element.tagName === "INPUT" || element.tagName === "TEXTAREA") {
        const type = element.type;
        const value = element.value;
        textLength = (value || "").length;
        if (type === "email" || type === "number") {
          if (textLength) {
            const selection = dom.getSelection(element);
            if (selection) {
              const initialLength = selection.toString().length;
              const isBackward = key === Keys.ArrowLeft || key === Keys.ArrowUp;
              selection.modify("extend", isBackward ? "backward" : "forward", "character");
              if (initialLength !== selection.toString().length) {
                selection.modify("extend", isBackward ? "forward" : "backward", "character");
                return true;
              } else {
                textLength = 0;
              }
            }
          }
        } else {
          const selStart = element.selectionStart;
          if (selStart === null) {
            return type === "hidden";
          }
          selectionStart = selStart || 0;
          selectionEnd = element.selectionEnd || 0;
        }
      } else if (element.contentEditable === "true") {
        asyncRet = new (getPromise(this._win))((resolve) => {
          this._ignoredInputResolve = (value) => {
            delete this._ignoredInputResolve;
            resolve(value);
          };
          const win = this._win();
          if (this._ignoredInputTimer) {
            win.clearTimeout(this._ignoredInputTimer);
          }
          const {
            anchorNode: prevAnchorNode,
            focusNode: prevFocusNode,
            anchorOffset: prevAnchorOffset,
            focusOffset: prevFocusOffset
          } = dom.getSelection(element) || {};
          this._ignoredInputTimer = win.setTimeout(() => {
            var _a, _b, _c;
            delete this._ignoredInputTimer;
            const {
              anchorNode,
              focusNode,
              anchorOffset,
              focusOffset
            } = dom.getSelection(element) || {};
            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);
              return;
            }
            selectionStart = anchorOffset || 0;
            selectionEnd = focusOffset || 0;
            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
            if (anchorNode && focusNode) {
              if (dom.nodeContains(element, anchorNode) && dom.nodeContains(element, focusNode)) {
                if (anchorNode !== element) {
                  let anchorFound = false;
                  const addOffsets = (node) => {
                    if (node === anchorNode) {
                      anchorFound = true;
                    } else if (node === focusNode) {
                      return true;
                    }
                    const nodeText = node.textContent;
                    if (nodeText && !dom.getFirstChild(node)) {
                      const len = nodeText.length;
                      if (anchorFound) {
                        if (focusNode !== anchorNode) {
                          selectionEnd += len;
                        }
                      } else {
                        selectionStart += len;
                        selectionEnd += len;
                      }
                    }
                    let stop = false;
                    for (let e = dom.getFirstChild(node); e && !stop; e = e.nextSibling) {
                      stop = addOffsets(e);
                    }
                    return stop;
                  };
                  addOffsets(element);
                }
              }
            }
            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
          }, 0);
        });
      }
      if (asyncRet && !await asyncRet) {
        return true;
      }
      if (selectionStart !== selectionEnd) {
        return true;
      }
      if (selectionStart > 0 && (key === Keys.ArrowLeft || key === Keys.ArrowUp || key === Keys.Home)) {
        return true;
      }
      if (selectionStart < textLength && (key === Keys.ArrowRight || key === Keys.ArrowDown || key === Keys.End)) {
        return true;
      }
    }
    return false;
  }
};
function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
  if (typeof MutationObserver === "undefined") {
    return () => {
    };
  }
  const getWindow2 = tabster.getWindow;
  let elementByUId;
  const onMutation = (mutations) => {
    var _a, _b, _c, _d, _e;
    const removedNodes = /* @__PURE__ */ new Set();
    for (const mutation of mutations) {
      const target = mutation.target;
      const removed = mutation.removedNodes;
      const added = mutation.addedNodes;
      if (mutation.type === "attributes") {
        if (mutation.attributeName === TABSTER_ATTRIBUTE_NAME) {
          if (!removedNodes.has(target)) {
            updateTabsterByAttribute2(tabster, target);
          }
        }
      } else {
        for (let i = 0; i < removed.length; i++) {
          const removedNode = removed[i];
          removedNodes.add(removedNode);
          updateTabsterElements(removedNode, true);
          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);
        }
        for (let i = 0; i < added.length; i++) {
          updateTabsterElements(added[i]);
          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
        }
      }
    }
    removedNodes.clear();
    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
  };
  function updateTabsterElements(node, removed) {
    if (!elementByUId) {
      elementByUId = getInstanceContext(getWindow2).elementByUId;
    }
    processNode(node, removed);
    const walker = createElementTreeWalker(doc, node, (element) => {
      return processNode(element, removed);
    });
    if (walker) {
      while (walker.nextNode()) {
      }
    }
  }
  function processNode(element, removed) {
    var _a;
    if (!element.getAttribute) {
      return NodeFilter.FILTER_SKIP;
    }
    const uid = element.__tabsterElementUID;
    if (uid && elementByUId) {
      if (removed) {
        delete elementByUId[uid];
      } else {
        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow2, element);
      }
    }
    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TABSTER_ATTRIBUTE_NAME)) {
      updateTabsterByAttribute2(tabster, element, removed);
    }
    return NodeFilter.FILTER_SKIP;
  }
  const observer = dom.createMutationObserver(onMutation);
  if (syncState) {
    updateTabsterElements(getWindow2().document.body);
  }
  observer.observe(doc, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: [TABSTER_ATTRIBUTE_NAME]
  });
  return () => {
    observer.disconnect();
  };
}
var _conditionCheckTimeout = 100;
var ObservedElementAPI = class extends Subscribable {
  constructor(tabster) {
    super();
    this._waiting = {};
    this._lastRequestFocusId = 0;
    this._observedById = {};
    this._observedByName = {};
    this._currentRequestTimestamp = 0;
    this._onFocus = (e) => {
      if (e) {
        const current = this._currentRequest;
        if (current) {
          const delta = Date.now() - this._currentRequestTimestamp;
          const settleTime = 300;
          if (delta >= settleTime) {
            delete this._currentRequest;
            const elementRef = new WeakRef(e);
            current.diagnostics.getCancelTriggeringElement = () => {
              var _a;
              return (_a = elementRef.deref()) !== null && _a !== void 0 ? _a : null;
            };
            current.diagnostics.reason = ObservedElementFailureReasons.CanceledFocusChange;
            current.cancel();
          }
        }
      }
    };
    this.onObservedElementUpdate = (element) => {
      var _a, _b;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      const uid = getElementUId(this._win, element);
      let info = this._observedById[uid];
      if (observed && documentContains(element.ownerDocument, element)) {
        const isNewElement = !info;
        if (!info) {
          info = this._observedById[uid] = {
            element: new WeakHTMLElement(this._win, element)
          };
        }
        observed.names.sort();
        const observedNames = observed.names;
        const prevNames = info.prevNames;
        if (this._isObservedNamesUpdated(observedNames, prevNames)) {
          if (prevNames) {
            prevNames.forEach((prevName) => {
              const obn = this._observedByName[prevName];
              if (obn && obn[uid]) {
                if (Object.keys(obn).length > 1) {
                  delete obn[uid];
                } else {
                  delete this._observedByName[prevName];
                }
              }
            });
          }
          info.prevNames = observedNames;
          this._notifyObservedElementChange(element, observedNames, prevNames, isNewElement);
        }
        observedNames.forEach((observedName) => {
          let obn = this._observedByName[observedName];
          if (!obn) {
            obn = this._observedByName[observedName] = {};
          }
          obn[uid] = info;
          this._waitConditional(observedName);
        });
      } else if (info) {
        const prevNames = info.prevNames;
        if (prevNames) {
          prevNames.forEach((prevName) => {
            const obn = this._observedByName[prevName];
            if (obn && obn[uid]) {
              if (Object.keys(obn).length > 1) {
                delete obn[uid];
              } else {
                delete this._observedByName[prevName];
              }
            }
          });
          (_b = this.onObservedElementChange) === null || _b === void 0 ? void 0 : _b.call(this, {
            element,
            type: "removed",
            names: [],
            removedNames: prevNames
          });
        }
        delete this._observedById[uid];
      }
    };
    this._tabster = tabster;
    this._win = tabster.getWindow;
    tabster.queueInit(() => {
      this._tabster.focusedElement.subscribe(this._onFocus);
    });
  }
  dispose() {
    this._tabster.focusedElement.unsubscribe(this._onFocus);
    for (const key of Object.keys(this._waiting)) {
      this._rejectWaiting(key);
    }
    this._observedById = {};
    this._observedByName = {};
    this.onObservedElementChange = void 0;
  }
  _rejectWaiting(key, shouldResolve) {
    const w = this._waiting[key];
    if (w) {
      const win = this._win();
      if (w.timer) {
        win.clearTimeout(w.timer);
      }
      if (w.conditionTimer) {
        win.clearTimeout(w.conditionTimer);
      }
      if (!shouldResolve && w.reject) {
        w.reject();
      } else if (shouldResolve && w.resolve) {
        w.resolve(null);
      }
      delete this._waiting[key];
    }
  }
  _populateTimeoutDiagnostics(request, observedName, timeout, startTime) {
    const elementInDOM = this.getElement(observedName);
    const inDOM = !!elementInDOM;
    let isAccessible;
    let isFocusable;
    let reason;
    if (!elementInDOM) {
      reason = ObservedElementFailureReasons.TimeoutElementNotInDOM;
    } else {
      isAccessible = this._tabster.focusable.isAccessible(elementInDOM);
      isFocusable = this._tabster.focusable.isFocusable(elementInDOM, true);
      if (!isAccessible) {
        reason = ObservedElementFailureReasons.TimeoutElementNotAccessible;
      } else if (!isFocusable) {
        reason = ObservedElementFailureReasons.TimeoutElementNotFocusable;
      } else {
        reason = ObservedElementFailureReasons.TimeoutElementNotReady;
      }
    }
    request.diagnostics.reason = reason;
    request.diagnostics.waitForElementDuration = Date.now() - startTime;
    request.diagnostics.targetState = {
      inDOM,
      isAccessible,
      isFocusable
    };
  }
  _isObservedNamesUpdated(cur, prev) {
    if (!prev || cur.length !== prev.length) {
      return true;
    }
    for (let i = 0; i < cur.length; ++i) {
      if (cur[i] !== prev[i]) {
        return true;
      }
    }
    return false;
  }
  _notifyObservedElementChange(element, observedNames, prevNames, isNewElement) {
    if (!this.onObservedElementChange) {
      return;
    }
    const addedNames = observedNames.filter((name) => !prevNames || !prevNames.includes(name));
    const removedNames = prevNames ? prevNames.filter((name) => !observedNames.includes(name)) : [];
    if (isNewElement) {
      this.onObservedElementChange({
        element,
        type: "added",
        names: observedNames,
        addedNames: observedNames
      });
    } else if (addedNames.length > 0 || removedNames.length > 0) {
      this.onObservedElementChange({
        element,
        type: "updated",
        names: observedNames,
        addedNames: addedNames.length > 0 ? addedNames : void 0,
        removedNames: removedNames.length > 0 ? removedNames : void 0
      });
    }
  }
  /**
   * Returns all registered observed names with their respective elements and full names arrays
   *
   * @returns Map<string, Array<{ element: HTMLElement; names: string[] }>> A map where keys are observed names
   * and values are arrays of objects containing the element and its complete names array (in the order they were defined)
   */
  getAllObservedElements() {
    const result = /* @__PURE__ */ new Map();
    for (const name of Object.keys(this._observedByName)) {
      const elementsWithNames = [];
      const observed = this._observedByName[name];
      for (const uid of Object.keys(observed)) {
        const el = observed[uid].element.get();
        if (el) {
          const info = this._observedById[uid];
          elementsWithNames.push({
            element: el,
            names: (info === null || info === void 0 ? void 0 : info.prevNames) || []
          });
        }
      }
      if (elementsWithNames.length > 0) {
        result.set(name, elementsWithNames);
      }
    }
    return result;
  }
  /**
   * Returns existing element by observed name
   *
   * @param observedName An observed name
   * @param accessibility Optionally, return only if the element is accessible or focusable
   * @returns HTMLElement | null
   */
  getElement(observedName, accessibility) {
    const o = this._observedByName[observedName];
    if (o) {
      for (const uid of Object.keys(o)) {
        let el = o[uid].element.get() || null;
        if (el) {
          if (accessibility === ObservedElementAccessibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccessibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {
            el = null;
          }
        } else {
          delete o[uid];
          delete this._observedById[uid];
        }
        return el;
      }
    }
    return null;
  }
  /**
   * Waits for the element to appear in the DOM and returns it.
   *
   * @param observedName An observed name
   * @param timeout Wait no longer than this timeout
   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it
   * @returns Promise<HTMLElement | null>
   */
  waitElement(observedName, timeout, accessibility) {
    const startTime = Date.now();
    const el = this.getElement(observedName, accessibility);
    if (el) {
      return {
        result: getPromise(this._win).resolve(el),
        cancel: () => {
        },
        status: ObservedElementRequestStatuses.Succeeded,
        diagnostics: {
          waitForElementDuration: Date.now() - startTime
        }
      };
    }
    let prefix;
    if (accessibility === ObservedElementAccessibilities.Accessible) {
      prefix = "a";
    } else if (accessibility === ObservedElementAccessibilities.Focusable) {
      prefix = "f";
    } else {
      prefix = "_";
    }
    const key = prefix + observedName;
    let w = this._waiting[key];
    if (w && w.request) {
      return w.request;
    }
    w = this._waiting[key] = {
      timer: this._win().setTimeout(() => {
        if (w.conditionTimer) {
          this._win().clearTimeout(w.conditionTimer);
        }
        delete this._waiting[key];
        if (w.request) {
          w.request.status = ObservedElementRequestStatuses.TimedOut;
          this._populateTimeoutDiagnostics(w.request, observedName, timeout, startTime);
        }
        if (w.resolve) {
          w.resolve(null);
        }
      }, timeout)
    };
    const promise = new (getPromise(this._win))((resolve, reject) => {
      w.resolve = resolve;
      w.reject = reject;
    }).catch(() => {
      return null;
    });
    const request = {
      result: promise,
      cancel: () => {
        if (request.status === ObservedElementRequestStatuses.Waiting) {
          request.status = ObservedElementRequestStatuses.Canceled;
          request.diagnostics.waitForElementDuration = Date.now() - startTime;
        }
        this._rejectWaiting(key, true);
      },
      status: ObservedElementRequestStatuses.Waiting,
      diagnostics: {}
    };
    w.request = request;
    if (accessibility && this.getElement(observedName)) {
      this._waitConditional(observedName);
    }
    return request;
  }
  requestFocus(observedName, timeout, options = {}) {
    const requestId = ++this._lastRequestFocusId;
    const currentRequestFocus = this._currentRequest;
    if (currentRequestFocus) {
      currentRequestFocus.diagnostics.reason = ObservedElementFailureReasons.SupersededByNewRequest;
      currentRequestFocus.cancel();
    }
    const request = this.waitElement(observedName, timeout, ObservedElementAccessibilities.Focusable);
    this._currentRequest = request;
    this._currentRequestTimestamp = Date.now();
    const ret = {
      result: request.result.then((element) => {
        if (this._lastRequestFocusId !== requestId) {
          request.diagnostics.reason = ObservedElementFailureReasons.SupersededByNewRequest;
          return false;
        }
        if (!element) {
          if (request.diagnostics.reason === void 0) {
            request.diagnostics.reason = ObservedElementFailureReasons.TimeoutElementNotInDOM;
          }
          return false;
        }
        const focusResult = this._tabster.focusedElement.focus(element, true, void 0, options.preventScroll);
        if (!focusResult) {
          request.diagnostics.reason = ObservedElementFailureReasons.FocusCallFailed;
        }
        return focusResult;
      }),
      cancel: () => {
        request.cancel();
      },
      status: request.status,
      diagnostics: request.diagnostics
    };
    request.result.finally(() => {
      if (this._currentRequest === request) {
        delete this._currentRequest;
      }
      ret.status = request.status;
    });
    return ret;
  }
  _waitConditional(observedName) {
    const waitingElementKey = "_" + observedName;
    const waitingAccessibleElementKey = "a" + observedName;
    const waitingFocusableElementKey = "f" + observedName;
    const waitingElement = this._waiting[waitingElementKey];
    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];
    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];
    const win = this._win();
    const resolve = (element, key, waiting, accessibility) => {
      var _a;
      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      if (!observed || !observed.names.includes(observedName)) {
        return;
      }
      if (waiting.timer) {
        win.clearTimeout(waiting.timer);
      }
      delete this._waiting[key];
      if (waiting.request) {
        waiting.request.status = ObservedElementRequestStatuses.Succeeded;
      }
      if (waiting.resolve) {
        waiting.resolve(element);
      }
      this.trigger(element, {
        names: [observedName],
        details: observed.details,
        accessibility
      });
    };
    if (waitingElement) {
      const element = this.getElement(observedName);
      if (element && documentContains(element.ownerDocument, element)) {
        resolve(element, waitingElementKey, waitingElement, ObservedElementAccessibilities.Any);
      }
    }
    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {
      const resolveAccessible = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {
          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccessibilities.Accessible);
        } else {
          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);
        }
      };
      resolveAccessible();
    }
    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {
      const resolveFocusable = () => {
        const element = this.getElement(observedName);
        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {
          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccessibilities.Focusable);
        } else {
          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);
        }
      };
      resolveFocusable();
    }
  }
};
var UncontrolledAPI = class {
  constructor(isUncontrolledCompletely) {
    this._isUncontrolledCompletely = isUncontrolledCompletely;
  }
  isUncontrolledCompletely(element, completely) {
    var _a;
    const isUncontrolledCompletely = (_a = this._isUncontrolledCompletely) === null || _a === void 0 ? void 0 : _a.call(this, element, completely);
    return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
  }
};
var Restorer = class extends TabsterPart {
  constructor(tabster, element, props) {
    var _a;
    super(tabster, element, props);
    this._hasFocus = false;
    this._onFocusOut = (e) => {
      var _a2;
      const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
      if (element2 && e.relatedTarget === null) {
        element2.dispatchEvent(new RestorerRestoreFocusEvent());
      }
      if (element2 && !dom.nodeContains(element2, e.relatedTarget)) {
        this._hasFocus = false;
      }
    };
    this._onFocusIn = () => {
      this._hasFocus = true;
    };
    if (this._props.type === RestorerTypes.Source) {
      const element2 = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusout", this._onFocusOut);
      element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("focusin", this._onFocusIn);
      this._hasFocus = dom.nodeContains(element2, element2 && dom.getActiveElement(element2.ownerDocument));
    }
  }
  dispose() {
    var _a;
    if (this._props.type === RestorerTypes.Source) {
      const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusout", this._onFocusOut);
      element === null || element === void 0 ? void 0 : element.removeEventListener("focusin", this._onFocusIn);
      if (this._hasFocus) {
        const doc = this._tabster.getWindow().document;
        doc.body.dispatchEvent(new RestorerRestoreFocusEvent());
      }
    }
  }
};
var History = class _History {
  constructor(getWindow2) {
    this._stack = [];
    this._getWindow = getWindow2;
  }
  /**
   * Push a weak element to the top of the history stack.
   * If the stack is full, the bottom weak element is removed.
   * If the element is already at the top of the stack, it is not duplicated.
   */
  push(element) {
    var _a;
    if (((_a = this._stack[this._stack.length - 1]) === null || _a === void 0 ? void 0 : _a.get()) === element) {
      return;
    }
    if (this._stack.length > _History.DEPTH) {
      this._stack.shift();
    }
    this._stack.push(new WeakHTMLElement(this._getWindow, element));
  }
  /**
   * Pop the first element from the history that satisfies the callback.
   * The history is searched from the top to the bottom (from the most recent to the least recent).
   *
   * If a weak reference to the element is broken,
   * or the element is no longer in the DOM,
   * the element is removed from the top of the stack while popping.
   *
   * If no matching element is found, undefined is returned.
   * If the stack is empty, undefined is returned.
   */
  pop(filter = () => true) {
    var _a;
    const doc = this._getWindow().document;
    for (let index = this._stack.length - 1; index >= 0; index--) {
      const maybeElement = (_a = this._stack.pop()) === null || _a === void 0 ? void 0 : _a.get();
      if (maybeElement && dom.nodeContains(doc.body, dom.getParentElement(maybeElement)) && filter(maybeElement)) {
        return maybeElement;
      }
    }
    return void 0;
  }
};
History.DEPTH = 10;
var RestorerAPI = class {
  constructor(tabster) {
    this._onRestoreFocus = (e) => {
      var _a, _b;
      this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
      const source = e.composedPath()[0];
      if (source) {
        const sourceId = (_b = (_a = getTabsterOnElement(this._tabster, source)) === null || _a === void 0 ? void 0 : _a.restorer) === null || _b === void 0 ? void 0 : _b.getProps().id;
        this._focusedElementState.requestAsyncFocus(AsyncFocusSources.Restorer, () => this._restoreFocus(source, sourceId), 0);
      }
    };
    this._onFocusIn = (element) => {
      var _a;
      if (!element) {
        return;
      }
      const tabsterAttribute = getTabsterOnElement(this._tabster, element);
      if (((_a = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a === void 0 ? void 0 : _a.getProps().type) !== RestorerTypes.Target) {
        return;
      }
      this._history.push(element);
    };
    this._restoreFocus = (source, sourceId) => {
      var _a;
      const doc = this._getWindow().document;
      if (dom.getActiveElement(doc) !== doc.body) {
        return;
      }
      if (
        // clicking on any empty space focuses body - this is can be a false positive
        !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
        dom.nodeContains(doc.body, source)
      ) {
        return;
      }
      const getId = (element) => {
        var _a2, _b;
        const restorerProps = (_b = (_a2 = getTabsterOnElement(this._tabster, element)) === null || _a2 === void 0 ? void 0 : _a2.restorer) === null || _b === void 0 ? void 0 : _b.getProps();
        return restorerProps ? restorerProps.id : null;
      };
      (_a = this._history.pop((target) => sourceId === getId(target))) === null || _a === void 0 ? void 0 : _a.focus();
    };
    this._tabster = tabster;
    this._getWindow = tabster.getWindow;
    this._getWindow().addEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
    this._history = new History(this._getWindow);
    this._keyboardNavState = tabster.keyboardNavigation;
    this._focusedElementState = tabster.focusedElement;
    this._focusedElementState.subscribe(this._onFocusIn);
  }
  dispose() {
    const win = this._getWindow();
    this._focusedElementState.unsubscribe(this._onFocusIn);
    this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);
    win.removeEventListener(RestorerRestoreFocusEventName, this._onRestoreFocus);
  }
  createRestorer(element, props) {
    const restorer = new Restorer(this._tabster, element, props);
    if (props.type === RestorerTypes.Target && dom.getActiveElement(element.ownerDocument) === element) {
      this._history.push(element);
    }
    return restorer;
  }
};
function getActiveElement(doc) {
  var _a;
  let activeElement = doc.activeElement;
  while ((_a = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement) {
    activeElement = activeElement.shadowRoot.activeElement;
  }
  return activeElement;
}
function nodeContains(node, otherNode) {
  var _a, _b;
  if (!node || !otherNode) {
    return false;
  }
  let currentNode = otherNode;
  while (currentNode) {
    if (currentNode === node) {
      return true;
    }
    if (typeof currentNode.assignedElements !== "function" && ((_a = currentNode.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {
      currentNode = (_b = currentNode.assignedSlot) === null || _b === void 0 ? void 0 : _b.parentNode;
    } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {
      currentNode = currentNode.host;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return false;
}
function getParentNode(node) {
  if (!node) {
    return null;
  }
  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.host) {
    return node.host;
  }
  return node.parentNode;
}
function getParentElement(element) {
  for (let parentNode = getParentNode(element); parentNode; parentNode = getParentNode(parentNode)) {
    if (parentNode.nodeType === Node.ELEMENT_NODE) {
      return parentNode;
    }
  }
  return null;
}
function getFirstChild(node) {
  if (!node) {
    return null;
  }
  if (node.shadowRoot) {
    const child = getFirstChild(node.shadowRoot);
    if (child) {
      return child;
    }
  }
  return node.firstChild;
}
function getLastChild$1(node) {
  if (!node) {
    return null;
  }
  if (!node.lastChild && node.shadowRoot) {
    return getLastChild$1(node.shadowRoot);
  }
  return node.lastChild;
}
function getNextSibling(node) {
  return (node === null || node === void 0 ? void 0 : node.nextSibling) || null;
}
function getPreviousSibling(node) {
  var _a;
  if (!node) {
    return null;
  }
  let sibling = node.previousSibling;
  if (!sibling && ((_a = node.parentElement) === null || _a === void 0 ? void 0 : _a.shadowRoot)) {
    sibling = getLastChild$1(node.parentElement.shadowRoot);
  }
  return sibling;
}
function getFirstElementChild(element) {
  let child = getFirstChild(element);
  while (child && child.nodeType !== Node.ELEMENT_NODE) {
    child = getNextSibling(child);
  }
  return child;
}
function getLastElementChild(element) {
  let child = getLastChild$1(element);
  while (child && child.nodeType !== Node.ELEMENT_NODE) {
    child = getPreviousSibling(child);
  }
  return child;
}
function getNextElementSibling(element) {
  let sibling = getNextSibling(element);
  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {
    sibling = getNextSibling(sibling);
  }
  return sibling;
}
function getPreviousElementSibling(element) {
  let sibling = getPreviousSibling(element);
  while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {
    sibling = getPreviousSibling(sibling);
  }
  return sibling;
}
function appendChild(parent2, child) {
  const shadowRoot = parent2.shadowRoot;
  return shadowRoot ? shadowRoot.appendChild(child) : parent2.appendChild(child);
}
function insertBefore(parent2, child, referenceChild) {
  const shadowRoot = parent2.shadowRoot;
  return shadowRoot ? shadowRoot.insertBefore(child, referenceChild) : parent2.insertBefore(child, referenceChild);
}
function getSelection(ref) {
  var _a;
  const win = (_a = ref.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  if (!win) {
    return null;
  }
  for (let el = ref; el; el = el.parentNode) {
    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      const tmp = el;
      if (tmp.getSelection) {
        return tmp.getSelection() || null;
      }
      break;
    }
  }
  return win.getSelection() || null;
}
function getElementsByName(referenceElement, name) {
  for (let el = referenceElement; el; el = el.parentNode) {
    if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      return el.querySelectorAll(`[name=${name}]`);
    }
  }
  return referenceElement.ownerDocument.getElementsByName(name);
}
function getLastChild(container) {
  let lastChild = null;
  for (let i = getLastElementChild(container); i; i = getLastElementChild(i)) {
    lastChild = i;
  }
  return lastChild || void 0;
}
var ShadowTreeWalker = class {
  constructor(doc, root, whatToShow, filter) {
    this._walkerStack = [];
    this._currentSetFor = /* @__PURE__ */ new Set();
    this._acceptNode = (node) => {
      var _a;
      if (node.nodeType === Node.ELEMENT_NODE) {
        const shadowRoot2 = node.shadowRoot;
        if (shadowRoot2) {
          const walker = this._doc.createTreeWalker(shadowRoot2, this.whatToShow, {
            acceptNode: this._acceptNode
          });
          this._walkerStack.unshift(walker);
          return NodeFilter.FILTER_ACCEPT;
        } else {
          if (typeof this.filter === "function") {
            return this.filter(node);
          } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
            return this.filter.acceptNode(node);
          } else if (this.filter === null) {
            return NodeFilter.FILTER_ACCEPT;
          }
        }
      }
      return NodeFilter.FILTER_SKIP;
    };
    this._doc = doc;
    this.root = root;
    this.filter = filter !== null && filter !== void 0 ? filter : null;
    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;
    this._currentNode = root;
    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));
    const shadowRoot = root.shadowRoot;
    if (shadowRoot) {
      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {
        acceptNode: this._acceptNode
      });
      this._walkerStack.unshift(walker);
    }
  }
  get currentNode() {
    return this._currentNode;
  }
  set currentNode(node) {
    if (!nodeContains(this.root, node)) {
      throw new Error("Cannot set currentNode to a node that is not contained by the root node.");
    }
    const walkers = [];
    let curNode = node;
    let currentWalkerCurrentNode = node;
    this._currentNode = node;
    while (curNode && curNode !== this.root) {
      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        const shadowRoot = curNode;
        const walker2 = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {
          acceptNode: this._acceptNode
        });
        walkers.push(walker2);
        walker2.currentNode = currentWalkerCurrentNode;
        this._currentSetFor.add(walker2);
        curNode = currentWalkerCurrentNode = shadowRoot.host;
      } else {
        curNode = curNode.parentNode;
      }
    }
    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {
      acceptNode: this._acceptNode
    });
    walkers.push(walker);
    walker.currentNode = currentWalkerCurrentNode;
    this._currentSetFor.add(walker);
    this._walkerStack = walkers;
  }
  firstChild() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  lastChild() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  nextNode() {
    var _a;
    const nextNode = this._walkerStack[0].nextNode();
    if (nextNode) {
      const shadowRoot = nextNode.shadowRoot;
      if (shadowRoot) {
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(nextNode);
        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
          nodeResult = this.filter.acceptNode(nextNode);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return nextNode;
        }
        return this.nextNode();
      }
      return nextNode;
    } else {
      if (this._walkerStack.length > 1) {
        this._walkerStack.shift();
        return this.nextNode();
      } else {
        return null;
      }
    }
  }
  previousNode() {
    var _a, _b;
    const currentWalker = this._walkerStack[0];
    if (currentWalker.currentNode === currentWalker.root) {
      if (this._currentSetFor.has(currentWalker)) {
        this._currentSetFor.delete(currentWalker);
        if (this._walkerStack.length > 1) {
          this._walkerStack.shift();
          return this.previousNode();
        } else {
          return null;
        }
      }
      const lastChild = getLastChild(currentWalker.root);
      if (lastChild) {
        currentWalker.currentNode = lastChild;
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(lastChild);
        } else if ((_a = this.filter) === null || _a === void 0 ? void 0 : _a.acceptNode) {
          nodeResult = this.filter.acceptNode(lastChild);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return lastChild;
        }
      }
    }
    const previousNode = currentWalker.previousNode();
    if (previousNode) {
      const shadowRoot = previousNode.shadowRoot;
      if (shadowRoot) {
        let nodeResult;
        if (typeof this.filter === "function") {
          nodeResult = this.filter(previousNode);
        } else if ((_b = this.filter) === null || _b === void 0 ? void 0 : _b.acceptNode) {
          nodeResult = this.filter.acceptNode(previousNode);
        }
        if (nodeResult === NodeFilter.FILTER_ACCEPT) {
          return previousNode;
        }
        return this.previousNode();
      }
      return previousNode;
    } else {
      if (this._walkerStack.length > 1) {
        this._walkerStack.shift();
        return this.previousNode();
      } else {
        return null;
      }
    }
  }
  nextSibling() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  previousSibling() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
  parentNode() {
    if (true) {
      throw new Error("Method not implemented.");
    }
    return null;
  }
};
function createShadowTreeWalker(doc, root, whatToShow, filter) {
  return new ShadowTreeWalker(doc, root, whatToShow, filter);
}
var ShadowMutationObserver = class _ShadowMutationObserver {
  static _overrideAttachShadow(win) {
    const origAttachShadow = win.Element.prototype.attachShadow;
    if (origAttachShadow.__origAttachShadow) {
      return;
    }
    Element.prototype.attachShadow = function(options) {
      const shadowRoot = origAttachShadow.call(this, options);
      for (const shadowObserver of _ShadowMutationObserver._shadowObservers) {
        shadowObserver._addSubObserver(shadowRoot);
      }
      return shadowRoot;
    };
    Element.prototype.attachShadow.__origAttachShadow = origAttachShadow;
  }
  constructor(callback) {
    this._isObserving = false;
    this._callbackWrapper = (mutations, observer) => {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          const removed = mutation.removedNodes;
          const added = mutation.addedNodes;
          for (let i = 0; i < removed.length; i++) {
            this._walkShadows(removed[i], true);
          }
          for (let i = 0; i < added.length; i++) {
            this._walkShadows(added[i]);
          }
        }
      }
      this._callback(mutations, observer);
    };
    this._callback = callback;
    this._observer = new MutationObserver(this._callbackWrapper);
    this._subObservers = /* @__PURE__ */ new Map();
  }
  _addSubObserver(shadowRoot) {
    if (!this._options || !this._callback || this._subObservers.has(shadowRoot)) {
      return;
    }
    if (this._options.subtree && nodeContains(this._root, shadowRoot)) {
      const subObserver = new MutationObserver(this._callbackWrapper);
      this._subObservers.set(shadowRoot, subObserver);
      if (this._isObserving) {
        subObserver.observe(shadowRoot, this._options);
      }
      this._walkShadows(shadowRoot);
    }
  }
  disconnect() {
    this._isObserving = false;
    delete this._options;
    _ShadowMutationObserver._shadowObservers.delete(this);
    for (const subObserver of this._subObservers.values()) {
      subObserver.disconnect();
    }
    this._subObservers.clear();
    this._observer.disconnect();
  }
  observe(target, options) {
    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
    const win = doc === null || doc === void 0 ? void 0 : doc.defaultView;
    if (!doc || !win) {
      return;
    }
    _ShadowMutationObserver._overrideAttachShadow(win);
    _ShadowMutationObserver._shadowObservers.add(this);
    this._root = target;
    this._options = options;
    this._isObserving = true;
    this._observer.observe(target, options);
    this._walkShadows(target);
  }
  _walkShadows(target, remove) {
    const doc = target.nodeType === Node.DOCUMENT_NODE ? target : target.ownerDocument;
    if (!doc) {
      return;
    }
    if (target === doc) {
      target = doc.body;
    } else {
      const shadowRoot = target.shadowRoot;
      if (shadowRoot) {
        this._addSubObserver(shadowRoot);
        return;
      }
    }
    const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (remove) {
            const subObserver = this._subObservers.get(node);
            if (subObserver) {
              subObserver.disconnect();
              this._subObservers.delete(node);
            }
          } else {
            const shadowRoot = node.shadowRoot;
            if (shadowRoot) {
              this._addSubObserver(shadowRoot);
            }
          }
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    walker.nextNode();
  }
  takeRecords() {
    const records = this._observer.takeRecords();
    for (const subObserver of this._subObservers.values()) {
      records.push(...subObserver.takeRecords());
    }
    return records;
  }
};
ShadowMutationObserver._shadowObservers = /* @__PURE__ */ new Set();
function createShadowMutationObserver(callback) {
  return new ShadowMutationObserver(callback);
}
function shadowQuerySelector(node, selector, all) {
  const elements = [];
  walk(node, selector);
  return elements;
  function walk(from, selector2) {
    let el = null;
    const walker = document.createTreeWalker(from, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (n) => {
        if (n.nodeType === Node.ELEMENT_NODE) {
          if (n.matches(selector2)) {
            el = n;
            elements.push(el);
            return all ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
          }
          const shadowRoot = n.shadowRoot;
          if (shadowRoot) {
            walk(shadowRoot, selector2);
            return !all && elements.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          }
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    walker.nextNode();
  }
}
function querySelectorAll(node, selector) {
  return shadowQuerySelector(node, selector, true);
}
function querySelector(node, selector) {
  return shadowQuerySelector(node, selector, false)[0] || null;
}
function getElementById(doc, id) {
  return querySelector(doc, "#" + id);
}
var shadowDOMAPI = Object.freeze({
  __proto__: null,
  appendChild,
  createMutationObserver: createShadowMutationObserver,
  createTreeWalker: createShadowTreeWalker,
  getActiveElement,
  getElementById,
  getElementsByName,
  getFirstChild,
  getFirstElementChild,
  getLastChild: getLastChild$1,
  getLastElementChild,
  getNextElementSibling,
  getNextSibling,
  getParentElement,
  getParentNode,
  getPreviousElementSibling,
  getPreviousSibling,
  getSelection,
  insertBefore,
  nodeContains,
  querySelector,
  querySelectorAll
});
var Tabster = class {
  constructor(tabster) {
    this.keyboardNavigation = tabster.keyboardNavigation;
    this.focusedElement = tabster.focusedElement;
    this.focusable = tabster.focusable;
    this.root = tabster.root;
    this.uncontrolled = tabster.uncontrolled;
    this.core = tabster;
  }
};
var TabsterCore = class {
  constructor(win, props) {
    var _a, _b;
    this._forgetMemorizedElements = [];
    this._wrappers = /* @__PURE__ */ new Set();
    this._initQueue = [];
    this._version = "8.7.0";
    this._noop = false;
    this.getWindow = () => {
      if (!this._win) {
        throw new Error("Using disposed Tabster.");
      }
      return this._win;
    };
    this._storage = createWeakMap(win);
    this._win = win;
    const getWindow2 = this.getWindow;
    if (props === null || props === void 0 ? void 0 : props.DOMAPI) {
      setDOMAPI({
        ...props.DOMAPI
      });
    }
    this.keyboardNavigation = new KeyboardNavigationState(getWindow2);
    this.focusedElement = new FocusedElementState(this, getWindow2);
    this.focusable = new FocusableAPI(this);
    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
    this.uncontrolled = new UncontrolledAPI(
      // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
      (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
    );
    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
    this._dummyObserver = new DummyInputObserver(getWindow2);
    this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : dom.getParentNode;
    this.internal = {
      stopObserver: () => {
        if (this._unobserve) {
          this._unobserve();
          delete this._unobserve;
        }
      },
      resumeObserver: (syncState) => {
        if (!this._unobserve) {
          const doc = getWindow2().document;
          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
        }
      }
    };
    startFakeWeakRefsCleanup(getWindow2);
    this.queueInit(() => {
      this.internal.resumeObserver(true);
    });
  }
  /**
   * Merges external props with the current props. Not all
   * props can/should be mergeable, so let's add more as we move on.
   * @param props Tabster props
   */
  _mergeProps(props) {
    var _a;
    if (!props) {
      return;
    }
    this.getParent = (_a = props.getParent) !== null && _a !== void 0 ? _a : this.getParent;
  }
  createTabster(noRefCount, props) {
    const wrapper = new Tabster(this);
    if (!noRefCount) {
      this._wrappers.add(wrapper);
    }
    this._mergeProps(props);
    return wrapper;
  }
  disposeTabster(wrapper, allInstances) {
    if (allInstances) {
      this._wrappers.clear();
    } else {
      this._wrappers.delete(wrapper);
    }
    if (this._wrappers.size === 0) {
      this.dispose();
    }
  }
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.internal.stopObserver();
    const win = this._win;
    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
    delete this._initTimer;
    this._initQueue = [];
    this._forgetMemorizedElements = [];
    if (win && this._forgetMemorizedTimer) {
      win.clearTimeout(this._forgetMemorizedTimer);
      delete this._forgetMemorizedTimer;
    }
    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();
    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
    (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
    this.keyboardNavigation.dispose();
    this.focusable.dispose();
    this.focusedElement.dispose();
    this.root.dispose();
    this._dummyObserver.dispose();
    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
    clearElementCache(this.getWindow);
    this._storage = /* @__PURE__ */ new WeakMap();
    this._wrappers.clear();
    if (win) {
      disposeInstanceContext(win);
      delete win.__tabsterInstance;
      delete this._win;
    }
  }
  storageEntry(element, addremove) {
    const storage = this._storage;
    let entry = storage.get(element);
    if (entry) {
      if (addremove === false && Object.keys(entry).length === 0) {
        storage.delete(element);
      }
    } else if (addremove === true) {
      entry = {};
      storage.set(element, entry);
    }
    return entry;
  }
  forceCleanup() {
    if (!this._win) {
      return;
    }
    this._forgetMemorizedElements.push(this._win.document.body);
    if (this._forgetMemorizedTimer) {
      return;
    }
    this._forgetMemorizedTimer = this._win.setTimeout(() => {
      delete this._forgetMemorizedTimer;
      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
        clearElementCache(this.getWindow, el);
        FocusedElementState.forgetMemorized(this.focusedElement, el);
      }
    }, 0);
    cleanupFakeWeakRefs(this.getWindow, true);
  }
  queueInit(callback) {
    var _a;
    if (!this._win) {
      return;
    }
    this._initQueue.push(callback);
    if (!this._initTimer) {
      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {
        delete this._initTimer;
        this.drainInitQueue();
      }, 0);
    }
  }
  drainInitQueue() {
    if (!this._win) {
      return;
    }
    const queue = this._initQueue;
    this._initQueue = [];
    queue.forEach((callback) => callback());
  }
};
function createTabster(win, props) {
  let tabster = getCurrentTabster(win);
  if (tabster) {
    return tabster.createTabster(false, props);
  }
  tabster = new TabsterCore(win, props);
  win.__tabsterInstance = tabster;
  return tabster.createTabster();
}
function getGroupper(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.groupper) {
    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.groupper;
}
function getMover(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.mover) {
    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
  }
  return tabsterCore.mover;
}
function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.modalizer) {
    tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
  }
  return tabsterCore.modalizer;
}
function getObservedElement(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.observedElement) {
    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);
  }
  return tabsterCore.observedElement;
}
function getRestorer(tabster) {
  const tabsterCore = tabster.core;
  if (!tabsterCore.restorer) {
    tabsterCore.restorer = new RestorerAPI(tabsterCore);
  }
  return tabsterCore.restorer;
}
function disposeTabster(tabster, allInstances) {
  tabster.core.disposeTabster(tabster, allInstances);
}
function getCurrentTabster(win) {
  return win.__tabsterInstance;
}
var Types = Object.freeze({
  __proto__: null
});
var EventsTypes = Object.freeze({
  __proto__: null
});

// node_modules/@fluentui/react-tabster/lib/hooks/useTabster.js
var React42 = __toESM(require_react());
var DEFAULT_FACTORY = (tabster) => {
  return tabster;
};
function createTabsterWithConfig(targetDocument) {
  const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
  const shadowDOMAPI2 = defaultView === null || defaultView === void 0 ? void 0 : defaultView.__tabsterShadowDOMAPI;
  if (defaultView) {
    return createTabster(defaultView, {
      autoRoot: {},
      controlTab: false,
      getParent,
      // The non-undefined return value of checkUncontrolledCompletely() dominates the value that the element might
      // have in its `uncontrolled: { completely: true }` part of the tabster attribute. We must make sure to return
      // undefined if we want the value from tabster attribute to be respected.
      checkUncontrolledCompletely: (element) => {
        var _element_firstElementChild;
        return ((_element_firstElementChild = element.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper")) === true || void 0;
      },
      DOMAPI: shadowDOMAPI2
    });
  }
}
function useTabster(factory = DEFAULT_FACTORY) {
  const { targetDocument } = useFluent();
  const factoryResultRef = React42.useRef(null);
  useIsomorphicLayoutEffect(() => {
    const tabster = createTabsterWithConfig(targetDocument);
    if (tabster) {
      factoryResultRef.current = factory(tabster);
      return () => {
        disposeTabster(tabster);
        factoryResultRef.current = null;
      };
    }
  }, [
    targetDocument,
    factory
  ]);
  if (true) {
    const previousFactory = usePrevious(factory);
    if (previousFactory !== null && previousFactory !== factory) {
      throw new Error([
        "@fluentui/react-tabster: ",
        "The factory function passed to useTabster has changed. This should not ever happen."
      ].join("\n"));
    }
  }
  return factoryResultRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useTabsterAttributes.js
var React43 = __toESM(require_react());
var useTabsterAttributes = (props) => {
  useTabster();
  const strAttr = getTabsterAttribute(props, true);
  return React43.useMemo(() => ({
    [TABSTER_ATTRIBUTE_NAME]: strAttr
  }), [
    strAttr
  ]);
};

// node_modules/@fluentui/react-tabster/lib/hooks/useArrowNavigationGroup.js
var useArrowNavigationGroup = (options = {}) => {
  const {
    circular,
    axis,
    memorizeCurrent = true,
    tabbable,
    ignoreDefaultKeydown,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault
  } = options;
  useTabster(getMover);
  return useTabsterAttributes({
    mover: {
      cyclic: !!circular,
      direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
      memorizeCurrent,
      tabbable,
      hasDefault: unstable_hasDefault
    },
    ...ignoreDefaultKeydown && {
      focusable: {
        ignoreKeydown: ignoreDefaultKeydown
      }
    }
  });
};
function axisToMoverDirection(axis) {
  switch (axis) {
    case "horizontal":
      return MoverDirections.Horizontal;
    case "grid":
      return MoverDirections.Grid;
    case "grid-linear":
      return MoverDirections.GridLinear;
    case "both":
      return MoverDirections.Both;
    case "vertical":
    default:
      return MoverDirections.Vertical;
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusableGroup.js
var useFocusableGroup = (options) => {
  useTabster(getGroupper);
  return useTabsterAttributes({
    groupper: {
      tabbability: getTabbability(options === null || options === void 0 ? void 0 : options.tabBehavior)
    },
    focusable: {
      ignoreKeydown: options === null || options === void 0 ? void 0 : options.ignoreDefaultKeydown
    }
  });
};
var getTabbability = (tabBehavior) => {
  switch (tabBehavior) {
    case "unlimited":
      return GroupperTabbabilities.Unlimited;
    case "limited":
      return GroupperTabbabilities.Limited;
    case "limited-trap-focus":
      return GroupperTabbabilities.LimitedTrapFocus;
    default:
      return void 0;
  }
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusFinders.js
var React44 = __toESM(require_react());
var useFocusFinders = () => {
  const tabsterRef = useTabster();
  const { targetDocument } = useFluent();
  const findAllFocusable = React44.useCallback((container, acceptCondition) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findAll({
      container,
      acceptCondition
    })) || [];
  }, [
    tabsterRef
  ]);
  const findFirstFocusable = React44.useCallback((container) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findFirst({
      container
    }));
  }, [
    tabsterRef
  ]);
  const findLastFocusable = React44.useCallback((container) => {
    var _tabsterRef_current;
    return container && ((_tabsterRef_current = tabsterRef.current) === null || _tabsterRef_current === void 0 ? void 0 : _tabsterRef_current.focusable.findLast({
      container
    }));
  }, [
    tabsterRef
  ]);
  const findNextFocusable = React44.useCallback((currentElement, options = {}) => {
    if (!tabsterRef.current || !targetDocument || !currentElement) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabsterRef.current.focusable.findNext({
      currentElement,
      container
    });
  }, [
    tabsterRef,
    targetDocument
  ]);
  const findPrevFocusable = React44.useCallback((currentElement, options = {}) => {
    if (!tabsterRef.current || !targetDocument || !currentElement) {
      return null;
    }
    const { container = targetDocument.body } = options;
    return tabsterRef.current.focusable.findPrev({
      currentElement,
      container
    });
  }, [
    tabsterRef,
    targetDocument
  ]);
  return {
    findAllFocusable,
    findFirstFocusable,
    findLastFocusable,
    findNextFocusable,
    findPrevFocusable
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
var React45 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/constants.js
var KEYBOARD_NAV_ATTRIBUTE = "data-keyboard-nav";
var KEYBOARD_NAV_SELECTOR = `:global([${KEYBOARD_NAV_ATTRIBUTE}])`;
var FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
var FOCUS_WITHIN_ATTR = "data-fui-focus-within";
var defaultOptions = {
  style: {},
  selector: "focus",
  customizeSelector: (selector) => selector
};

// node_modules/@fluentui/react-tabster/lib/focus/focusVisiblePolyfill.js
function applyFocusVisiblePolyfill(scope, targetWindow) {
  if (alreadyInScope(scope)) {
    return () => void 0;
  }
  const state = {
    current: void 0
  };
  const keyborg = createKeyborg(targetWindow);
  function registerElementIfNavigating(el) {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(el)) {
      state.current = el;
      el.setAttribute(FOCUS_VISIBLE_ATTR, "");
    }
  }
  function disposeCurrentElement() {
    if (state.current) {
      state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
      state.current = void 0;
    }
  }
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      disposeCurrentElement();
    } else {
      registerElementIfNavigating(targetWindow.document.activeElement);
    }
  });
  const keyborgListener = (e) => {
    disposeCurrentElement();
    const target = e.composedPath()[0];
    registerElementIfNavigating(target);
  };
  const blurListener = (e) => {
    if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {
      disposeCurrentElement();
    }
  };
  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  scope.addEventListener("focusout", blurListener);
  scope.focusVisible = true;
  if (scope.contains(targetWindow.document.activeElement)) {
    registerElementIfNavigating(targetWindow.document.activeElement);
  }
  return () => {
    disposeCurrentElement();
    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    scope.removeEventListener("focusout", blurListener);
    scope.focusVisible = void 0;
    disposeKeyborg(keyborg);
  };
}
function alreadyInScope(el) {
  if (!el) {
    return false;
  }
  if (el.focusVisible) {
    return true;
  }
  return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusVisible.js
function useFocusVisible(options = {}) {
  const contextValue = useFluent();
  const scopeRef = React45.useRef(null);
  var _options_targetDocument;
  const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
  React45.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
      return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
    }
  }, [
    scopeRef,
    targetDocument
  ]);
  return scopeRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
var React46 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/focus/focusWithinPolyfill.js
function applyFocusWithinPolyfill(element, win) {
  const keyborg = createKeyborg(win);
  keyborg.subscribe((isNavigatingWithKeyboard) => {
    if (!isNavigatingWithKeyboard) {
      removeFocusWithinClass(element);
    }
  });
  const keyborgListener = (e) => {
    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement2(e.target)) {
      applyFocusWithinClass(element);
    }
  };
  const blurListener = (e) => {
    if (!e.relatedTarget || isHTMLElement2(e.relatedTarget) && !element.contains(e.relatedTarget)) {
      removeFocusWithinClass(element);
    }
  };
  element.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
  element.addEventListener("focusout", blurListener);
  return () => {
    element.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
    element.removeEventListener("focusout", blurListener);
    disposeKeyborg(keyborg);
  };
}
function applyFocusWithinClass(el) {
  el.setAttribute(FOCUS_WITHIN_ATTR, "");
}
function removeFocusWithinClass(el) {
  el.removeAttribute(FOCUS_WITHIN_ATTR);
}
function isHTMLElement2(target) {
  if (!target) {
    return false;
  }
  return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusWithin.js
function useFocusWithin() {
  const { targetDocument } = useFluent();
  const elementRef = React46.useRef(null);
  React46.useEffect(() => {
    if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
      return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
    }
  }, [
    elementRef,
    targetDocument
  ]);
  return elementRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useKeyboardNavAttribute.js
var React47 = __toESM(require_react());
function useKeyboardNavAttribute() {
  const { targetDocument } = useFluent();
  const keyborg = React47.useMemo(() => targetDocument && createKeyborg(targetDocument.defaultView), [
    targetDocument
  ]);
  const ref = React47.useRef(null);
  React47.useEffect(() => {
    if (keyborg) {
      setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, keyborg.isNavigatingWithKeyboard());
      const cb = (next) => {
        setBooleanAttribute(ref, KEYBOARD_NAV_ATTRIBUTE, next);
      };
      keyborg.subscribe(cb);
      return () => keyborg.unsubscribe(cb);
    }
  }, [
    keyborg
  ]);
  return ref;
}
function setBooleanAttribute(elementRef, attribute, value) {
  if (!elementRef.current) {
    return;
  }
  if (value) {
    elementRef.current.setAttribute(attribute, "");
  } else {
    elementRef.current.removeAttribute(attribute);
  }
}

// node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
var React49 = __toESM(require_react());

// node_modules/@fluentui/react-tabster/lib/hooks/useKeyborgRef.js
var React48 = __toESM(require_react());
function useKeyborgRef() {
  const { targetDocument } = useFluent();
  const keyborgRef = React48.useRef(null);
  React48.useEffect(() => {
    const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (targetWindow) {
      const keyborg = createKeyborg(targetWindow);
      keyborgRef.current = keyborg;
      return () => {
        disposeKeyborg(keyborg);
        keyborgRef.current = null;
      };
    }
  }, [
    targetDocument
  ]);
  return keyborgRef;
}

// node_modules/@fluentui/react-tabster/lib/hooks/useOnKeyboardNavigationChange.js
function useOnKeyboardNavigationChange(callback) {
  const keyborgRef = useKeyborgRef();
  const eventCallback = useEventCallback(callback);
  React49.useEffect(() => {
    const keyborg = keyborgRef.current;
    if (keyborg) {
      const cb = (next) => {
        eventCallback(next);
      };
      keyborg.subscribe(cb);
      cb(keyborg.isNavigatingWithKeyboard());
      return () => {
        keyborg.unsubscribe(cb);
      };
    }
  }, [
    keyborgRef,
    eventCallback
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useModalAttributes.js
var DangerousNeverHiddenAttribute = "data-tabster-never-hide";
var DangerousNeverHiddenPropObject = {
  [DangerousNeverHiddenAttribute]: ""
};
function useDangerousNeverHidden_unstable() {
  return DangerousNeverHiddenPropObject;
}
var tabsterAccessibleCheck = (element) => {
  return element.hasAttribute(DangerousNeverHiddenAttribute);
};
function initTabsterModules(tabster) {
  getModalizer(tabster, void 0, tabsterAccessibleCheck);
  getRestorer(tabster);
}
var useModalAttributes = (options = {}) => {
  const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
  useTabster(initTabsterModules);
  const id = useId2("modal-", options.id);
  const modalAttributes = useTabsterAttributes({
    restorer: {
      type: RestorerTypes.Source
    },
    ...trapFocus && {
      modalizer: {
        id,
        isOthersAccessible: !trapFocus,
        isAlwaysAccessible: alwaysFocusable,
        isTrapped: legacyTrapFocus && trapFocus
      }
    }
  });
  const triggerAttributes = useTabsterAttributes({
    restorer: {
      type: RestorerTypes.Target
    }
  });
  return {
    modalAttributes,
    triggerAttributes
  };
};

// node_modules/@fluentui/react-tabster/lib/hooks/useObservedElement.js
function useObservedElement(name) {
  useTabster(getObservedElement);
  return useTabsterAttributes({
    observed: {
      names: Array.isArray(name) ? name : [
        name
      ]
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useMergeTabsterAttributes.js
var React50 = __toESM(require_react());
var useMergedTabsterAttributes_unstable = (...attributes) => {
  "use no memo";
  const stringAttributes = attributes.reduce((acc, curr) => {
    if (curr === null || curr === void 0 ? void 0 : curr[TABSTER_ATTRIBUTE_NAME]) {
      acc.push(curr[TABSTER_ATTRIBUTE_NAME]);
    }
    return acc;
  }, []);
  if (true) {
    useWarnIfUnstableAttributes(stringAttributes);
  }
  return React50.useMemo(
    () => ({
      [TABSTER_ATTRIBUTE_NAME]: stringAttributes.length > 0 ? stringAttributes.reduce(mergeJSONStrings) : void 0
    }),
    // disable exhaustive-deps because we want to memoize the result of the reduction
    // this is safe because the collection of attributes is not expected to change at runtime
    // eslint-disable-next-line react-hooks/exhaustive-deps
    stringAttributes
  );
};
var mergeJSONStrings = (a, b) => JSON.stringify(Object.assign(safelyParseJSON(a), safelyParseJSON(b)));
var safelyParseJSON = (json) => {
  try {
    return JSON.parse(json);
  } catch {
    return {};
  }
};
var useWarnIfUnstableAttributes = (attributes) => {
  "use no memo";
  const initialAttributesRef = React50.useRef(attributes);
  let isStable = initialAttributesRef.current.length === attributes.length;
  if (initialAttributesRef.current !== attributes && isStable) {
    for (let i = 0; i < attributes.length; i++) {
      if (initialAttributesRef.current[i] !== attributes[i]) {
        isStable = false;
        break;
      }
    }
  }
  React50.useEffect(() => {
    if (!isStable) {
      const error = new Error();
      console.warn(
        /** #__DE-INDENT__ */
        `
        @fluentui/react-tabster [useMergedTabsterAttributes]:
        The attributes passed to the hook changed at runtime.
        This might lead to unexpected behavior, please ensure that the attributes are stable.
        ${error.stack}
      `
      );
    }
  }, [
    isStable
  ]);
};

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusObserved.js
var React51 = __toESM(require_react());
function useFocusObserved(name, options = {}) {
  const { timeout = 1e3 } = options;
  const observedAPIRef = useTabster(getObservedElement);
  return React51.useCallback(() => {
    const observerAPI = observedAPIRef.current;
    if (observerAPI) {
      return observerAPI.requestFocus(name, timeout);
    }
    return {
      result: Promise.resolve(false),
      cancel: () => null
    };
  }, [
    observedAPIRef,
    name,
    timeout
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useRestoreFocus.js
function useRestoreFocusTarget() {
  useTabster(getRestorer);
  return getTabsterAttribute({
    restorer: {
      type: RestorerTypes.Target
    }
  });
}
function useRestoreFocusSource() {
  useTabster(getRestorer);
  return getTabsterAttribute({
    restorer: {
      type: RestorerTypes.Source
    }
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useUncontrolledFocus.js
function useUncontrolledFocus() {
  useTabster();
  return getTabsterAttribute({
    uncontrolled: {}
  });
}

// node_modules/@fluentui/react-tabster/lib/hooks/useIsNavigatingWithKeyboard.js
var React52 = __toESM(require_react());
function useIsNavigatingWithKeyboard() {
  const keyborgRef = useKeyborgRef();
  return React52.useCallback(() => {
    var _keyborgRef_current;
    var _keyborgRef_current_isNavigatingWithKeyboard;
    return (_keyborgRef_current_isNavigatingWithKeyboard = (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.isNavigatingWithKeyboard()) !== null && _keyborgRef_current_isNavigatingWithKeyboard !== void 0 ? _keyborgRef_current_isNavigatingWithKeyboard : false;
  }, [
    keyborgRef
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useSetKeyboardNavigation.js
var React53 = __toESM(require_react());
function useSetKeyboardNavigation() {
  const keyborgRef = useKeyborgRef();
  return React53.useCallback((isNavigatingWithKeyboard) => {
    var _keyborgRef_current;
    (_keyborgRef_current = keyborgRef.current) === null || _keyborgRef_current === void 0 ? void 0 : _keyborgRef_current.setVal(isNavigatingWithKeyboard);
  }, [
    keyborgRef
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useFocusedElementChange.js
var React54 = __toESM(require_react());
function useFocusedElementChange(callback) {
  const { targetDocument } = useFluent();
  const listener = useEventCallback(callback);
  React54.useEffect(() => {
    const tabster = createTabsterWithConfig(targetDocument);
    if (tabster) {
      tabster.focusedElement.subscribe(listener);
      return () => {
        tabster.focusedElement.unsubscribe(listener);
        disposeTabster(tabster);
      };
    }
  }, [
    listener,
    targetDocument
  ]);
}

// node_modules/@fluentui/react-tabster/lib/hooks/useActivateModal.js
var React55 = __toESM(require_react());
function useActivateModal() {
  const modalizerRefAPI = useTabster(getModalizer);
  const [setActivateModalTimeout] = useTimeout();
  const activateModal = React55.useCallback((elementFromModal) => {
    setActivateModalTimeout(() => {
      var _modalizerRefAPI_current;
      (_modalizerRefAPI_current = modalizerRefAPI.current) === null || _modalizerRefAPI_current === void 0 ? void 0 : _modalizerRefAPI_current.activate(elementFromModal);
    }, 0);
  }, [
    modalizerRefAPI,
    setActivateModalTimeout
  ]);
  return activateModal;
}

// node_modules/@fluentui/react-tabster/lib/focus/createCustomFocusIndicatorStyle.js
function createCustomFocusIndicatorStyle(style, { selector: selectorType = defaultOptions.selector, customizeSelector = defaultOptions.customizeSelector } = defaultOptions) {
  return {
    [customizeSelector(createBaseSelector(selectorType))]: style
  };
}
function createBaseSelector(selectorType) {
  switch (selectorType) {
    case "focus":
      return `&[${FOCUS_VISIBLE_ATTR}]`;
    case "focus-within":
      return `&[${FOCUS_WITHIN_ATTR}]:focus-within`;
  }
}

// node_modules/@fluentui/tokens/lib/global/colors.js
var grey = {
  "2": "#050505",
  "4": "#0a0a0a",
  "6": "#0f0f0f",
  "8": "#141414",
  "10": "#1a1a1a",
  "12": "#1f1f1f",
  "14": "#242424",
  "16": "#292929",
  "18": "#2e2e2e",
  "20": "#333333",
  "22": "#383838",
  "24": "#3d3d3d",
  "26": "#424242",
  "28": "#474747",
  "30": "#4d4d4d",
  "32": "#525252",
  "34": "#575757",
  "36": "#5c5c5c",
  "38": "#616161",
  "40": "#666666",
  "42": "#6b6b6b",
  "44": "#707070",
  "46": "#757575",
  "48": "#7a7a7a",
  "50": "#808080",
  "52": "#858585",
  "54": "#8a8a8a",
  "56": "#8f8f8f",
  "58": "#949494",
  "60": "#999999",
  "62": "#9e9e9e",
  "64": "#a3a3a3",
  "66": "#a8a8a8",
  "68": "#adadad",
  "70": "#b3b3b3",
  "72": "#b8b8b8",
  "74": "#bdbdbd",
  "76": "#c2c2c2",
  "78": "#c7c7c7",
  "80": "#cccccc",
  "82": "#d1d1d1",
  "84": "#d6d6d6",
  "86": "#dbdbdb",
  "88": "#e0e0e0",
  "90": "#e6e6e6",
  "92": "#ebebeb",
  "94": "#f0f0f0",
  "96": "#f5f5f5",
  "98": "#fafafa",
  "99": "#fcfcfc"
};
var whiteAlpha = {
  "5": "rgba(255, 255, 255, 0.05)",
  "10": "rgba(255, 255, 255, 0.1)",
  "20": "rgba(255, 255, 255, 0.2)",
  "30": "rgba(255, 255, 255, 0.3)",
  "40": "rgba(255, 255, 255, 0.4)",
  "50": "rgba(255, 255, 255, 0.5)",
  "60": "rgba(255, 255, 255, 0.6)",
  "70": "rgba(255, 255, 255, 0.7)",
  "80": "rgba(255, 255, 255, 0.8)",
  "90": "rgba(255, 255, 255, 0.9)"
};
var blackAlpha = {
  "5": "rgba(0, 0, 0, 0.05)",
  "10": "rgba(0, 0, 0, 0.1)",
  "20": "rgba(0, 0, 0, 0.2)",
  "30": "rgba(0, 0, 0, 0.3)",
  "40": "rgba(0, 0, 0, 0.4)",
  "50": "rgba(0, 0, 0, 0.5)",
  "60": "rgba(0, 0, 0, 0.6)",
  "70": "rgba(0, 0, 0, 0.7)",
  "80": "rgba(0, 0, 0, 0.8)",
  "90": "rgba(0, 0, 0, 0.9)"
};
var grey10Alpha = {
  "5": "rgba(26, 26, 26, 0.05)",
  "10": "rgba(26, 26, 26, 0.1)",
  "20": "rgba(26, 26, 26, 0.2)",
  "30": "rgba(26, 26, 26, 0.3)",
  "40": "rgba(26, 26, 26, 0.4)",
  "50": "rgba(26, 26, 26, 0.5)",
  "60": "rgba(26, 26, 26, 0.6)",
  "70": "rgba(26, 26, 26, 0.7)",
  "80": "rgba(26, 26, 26, 0.8)",
  "90": "rgba(26, 26, 26, 0.9)"
};
var grey12Alpha = {
  "5": "rgba(31, 31, 31, 0.05)",
  "10": "rgba(31, 31, 31, 0.1)",
  "20": "rgba(31, 31, 31, 0.2)",
  "30": "rgba(31, 31, 31, 0.3)",
  "40": "rgba(31, 31, 31, 0.4)",
  "50": "rgba(31, 31, 31, 0.5)",
  "60": "rgba(31, 31, 31, 0.6)",
  "70": "rgba(31, 31, 31, 0.7)",
  "80": "rgba(31, 31, 31, 0.8)",
  "90": "rgba(31, 31, 31, 0.9)"
};
var grey14Alpha = {
  "5": "rgba(36, 36, 36, 0.05)",
  "10": "rgba(36, 36, 36, 0.1)",
  "20": "rgba(36, 36, 36, 0.2)",
  "30": "rgba(36, 36, 36, 0.3)",
  "40": "rgba(36, 36, 36, 0.4)",
  "50": "rgba(36, 36, 36, 0.5)",
  "60": "rgba(36, 36, 36, 0.6)",
  "70": "rgba(36, 36, 36, 0.7)",
  "80": "rgba(36, 36, 36, 0.8)",
  "90": "rgba(36, 36, 36, 0.9)"
};
var white = "#ffffff";
var black = "#000000";
var hcHyperlink = "#ffff00";
var hcHighlight = "#1aebff";
var hcDisabled = "#3ff23f";
var hcCanvas = "#000000";
var hcCanvasText = "#ffffff";
var hcHighlightText = "#000000";
var hcButtonText = "#000000";
var hcButtonFace = "#ffffff";
var darkRed = {
  shade50: "#130204",
  shade40: "#230308",
  shade30: "#420610",
  shade20: "#590815",
  shade10: "#690a19",
  primary: "#750b1c",
  tint10: "#861b2c",
  tint20: "#962f3f",
  tint30: "#ac4f5e",
  tint40: "#d69ca5",
  tint50: "#e9c7cd",
  tint60: "#f9f0f2"
};
var cranberry = {
  shade50: "#200205",
  shade40: "#3b0509",
  shade30: "#6e0811",
  shade20: "#960b18",
  shade10: "#b10e1c",
  primary: "#c50f1f",
  tint10: "#cc2635",
  tint20: "#d33f4c",
  tint30: "#dc626d",
  tint40: "#eeacb2",
  tint50: "#f6d1d5",
  tint60: "#fdf3f4"
};
var red = {
  shade50: "#210809",
  shade40: "#3f1011",
  shade30: "#751d1f",
  shade20: "#9f282b",
  shade10: "#bc2f32",
  primary: "#d13438",
  tint10: "#d7494c",
  tint20: "#dc5e62",
  tint30: "#e37d80",
  tint40: "#f1bbbc",
  tint50: "#f8dadb",
  tint60: "#fdf6f6"
};
var darkOrange = {
  shade50: "#230900",
  shade40: "#411200",
  shade30: "#7a2101",
  shade20: "#a62d01",
  shade10: "#c43501",
  primary: "#da3b01",
  tint10: "#de501c",
  tint20: "#e36537",
  tint30: "#e9835e",
  tint40: "#f4bfab",
  tint50: "#f9dcd1",
  tint60: "#fdf6f3"
};
var pumpkin = {
  shade50: "#200d03",
  shade40: "#3d1805",
  shade30: "#712d09",
  shade20: "#9a3d0c",
  shade10: "#b6480e",
  primary: "#ca5010",
  tint10: "#d06228",
  tint20: "#d77440",
  tint30: "#df8e64",
  tint40: "#efc4ad",
  tint50: "#f7dfd2",
  tint60: "#fdf7f4"
};
var orange = {
  shade50: "#271002",
  shade40: "#4a1e04",
  shade30: "#8a3707",
  shade20: "#bc4b09",
  shade10: "#de590b",
  primary: "#f7630c",
  tint10: "#f87528",
  tint20: "#f98845",
  tint30: "#faa06b",
  tint40: "#fdcfb4",
  tint50: "#fee5d7",
  tint60: "#fff9f5"
};
var peach = {
  shade50: "#291600",
  shade40: "#4d2a00",
  shade30: "#8f4e00",
  shade20: "#c26a00",
  shade10: "#e67e00",
  primary: "#ff8c00",
  tint10: "#ff9a1f",
  tint20: "#ffa83d",
  tint30: "#ffba66",
  tint40: "#ffddb3",
  tint50: "#ffedd6",
  tint60: "#fffaf5"
};
var marigold = {
  shade50: "#251a00",
  shade40: "#463100",
  shade30: "#835b00",
  shade20: "#b27c00",
  shade10: "#d39300",
  primary: "#eaa300",
  tint10: "#edad1c",
  tint20: "#efb839",
  tint30: "#f2c661",
  tint40: "#f9e2ae",
  tint50: "#fcefd3",
  tint60: "#fefbf4"
};
var yellow = {
  shade50: "#282400",
  shade40: "#4c4400",
  shade30: "#817400",
  shade20: "#c0ad00",
  shade10: "#e4cc00",
  primary: "#fde300",
  tint10: "#fde61e",
  tint20: "#fdea3d",
  tint30: "#feee66",
  tint40: "#fef7b2",
  tint50: "#fffad6",
  tint60: "#fffef5"
};
var gold = {
  shade50: "#1f1900",
  shade40: "#3a2f00",
  shade30: "#6c5700",
  shade20: "#937700",
  shade10: "#ae8c00",
  primary: "#c19c00",
  tint10: "#c8a718",
  tint20: "#d0b232",
  tint30: "#dac157",
  tint40: "#ecdfa5",
  tint50: "#f5eece",
  tint60: "#fdfbf2"
};
var brass = {
  shade50: "#181202",
  shade40: "#2e2103",
  shade30: "#553e06",
  shade20: "#745408",
  shade10: "#89640a",
  primary: "#986f0b",
  tint10: "#a47d1e",
  tint20: "#b18c34",
  tint30: "#c1a256",
  tint40: "#e0cea2",
  tint50: "#efe4cb",
  tint60: "#fbf8f2"
};
var brown = {
  shade50: "#170e07",
  shade40: "#2b1a0e",
  shade30: "#50301a",
  shade20: "#6c4123",
  shade10: "#804d29",
  primary: "#8e562e",
  tint10: "#9c663f",
  tint20: "#a97652",
  tint30: "#bb8f6f",
  tint40: "#ddc3b0",
  tint50: "#edded3",
  tint60: "#faf7f4"
};
var forest = {
  shade50: "#0c1501",
  shade40: "#162702",
  shade30: "#294903",
  shade20: "#376304",
  shade10: "#427505",
  primary: "#498205",
  tint10: "#599116",
  tint20: "#6ba02b",
  tint30: "#85b44c",
  tint40: "#bdd99b",
  tint50: "#dbebc7",
  tint60: "#f6faf0"
};
var seafoam = {
  shade50: "#002111",
  shade40: "#003d20",
  shade30: "#00723b",
  shade20: "#009b51",
  shade10: "#00b85f",
  primary: "#00cc6a",
  tint10: "#19d279",
  tint20: "#34d889",
  tint30: "#5ae0a0",
  tint40: "#a8f0cd",
  tint50: "#cff7e4",
  tint60: "#f3fdf8"
};
var lightGreen = {
  shade50: "#031a02",
  shade40: "#063004",
  shade30: "#0b5a08",
  shade20: "#0e7a0b",
  shade10: "#11910d",
  primary: "#13a10e",
  tint10: "#27ac22",
  tint20: "#3db838",
  tint30: "#5ec75a",
  tint40: "#a7e3a5",
  tint50: "#cef0cd",
  tint60: "#f2fbf2"
};
var green = {
  shade50: "#031403",
  shade40: "#052505",
  shade30: "#094509",
  shade20: "#0c5e0c",
  shade10: "#0e700e",
  primary: "#107c10",
  tint10: "#218c21",
  tint20: "#359b35",
  tint30: "#54b054",
  tint40: "#9fd89f",
  tint50: "#c9eac9",
  tint60: "#f1faf1"
};
var darkGreen = {
  shade50: "#021102",
  shade40: "#032003",
  shade30: "#063b06",
  shade20: "#085108",
  shade10: "#0a5f0a",
  primary: "#0b6a0b",
  tint10: "#1a7c1a",
  tint20: "#2d8e2d",
  tint30: "#4da64d",
  tint40: "#9ad29a",
  tint50: "#c6e7c6",
  tint60: "#f0f9f0"
};
var lightTeal = {
  shade50: "#001d1f",
  shade40: "#00373a",
  shade30: "#00666d",
  shade20: "#008b94",
  shade10: "#00a5af",
  primary: "#00b7c3",
  tint10: "#18bfca",
  tint20: "#32c8d1",
  tint30: "#58d3db",
  tint40: "#a6e9ed",
  tint50: "#cef3f5",
  tint60: "#f2fcfd"
};
var teal = {
  shade50: "#001516",
  shade40: "#012728",
  shade30: "#02494c",
  shade20: "#026467",
  shade10: "#037679",
  primary: "#038387",
  tint10: "#159195",
  tint20: "#2aa0a4",
  tint30: "#4cb4b7",
  tint40: "#9bd9db",
  tint50: "#c7ebec",
  tint60: "#f0fafa"
};
var steel = {
  shade50: "#000f12",
  shade40: "#001b22",
  shade30: "#00333f",
  shade20: "#004555",
  shade10: "#005265",
  primary: "#005b70",
  tint10: "#0f6c81",
  tint20: "#237d92",
  tint30: "#4496a9",
  tint40: "#94c8d4",
  tint50: "#c3e1e8",
  tint60: "#eff7f9"
};
var blue = {
  shade50: "#001322",
  shade40: "#002440",
  shade30: "#004377",
  shade20: "#005ba1",
  shade10: "#006cbf",
  primary: "#0078d4",
  tint10: "#1a86d9",
  tint20: "#3595de",
  tint30: "#5caae5",
  tint40: "#a9d3f2",
  tint50: "#d0e7f8",
  tint60: "#f3f9fd"
};
var royalBlue = {
  shade50: "#000c16",
  shade40: "#00172a",
  shade30: "#002c4e",
  shade20: "#003b6a",
  shade10: "#00467e",
  primary: "#004e8c",
  tint10: "#125e9a",
  tint20: "#286fa8",
  tint30: "#4a89ba",
  tint40: "#9abfdc",
  tint50: "#c7dced",
  tint60: "#f0f6fa"
};
var cornflower = {
  shade50: "#0d1126",
  shade40: "#182047",
  shade30: "#2c3c85",
  shade20: "#3c51b4",
  shade10: "#4760d5",
  primary: "#4f6bed",
  tint10: "#637cef",
  tint20: "#778df1",
  tint30: "#93a4f4",
  tint40: "#c8d1fa",
  tint50: "#e1e6fc",
  tint60: "#f7f9fe"
};
var navy = {
  shade50: "#00061d",
  shade40: "#000c36",
  shade30: "#001665",
  shade20: "#001e89",
  shade10: "#0023a2",
  primary: "#0027b4",
  tint10: "#173bbd",
  tint20: "#3050c6",
  tint30: "#546fd2",
  tint40: "#a3b2e8",
  tint50: "#ccd5f3",
  tint60: "#f2f4fc"
};
var lavender = {
  shade50: "#120f25",
  shade40: "#221d46",
  shade30: "#3f3682",
  shade20: "#5649b0",
  shade10: "#6656d1",
  primary: "#7160e8",
  tint10: "#8172eb",
  tint20: "#9184ee",
  tint30: "#a79cf1",
  tint40: "#d2ccf8",
  tint50: "#e7e4fb",
  tint60: "#f9f8fe"
};
var purple = {
  shade50: "#0f0717",
  shade40: "#1c0e2b",
  shade30: "#341a51",
  shade20: "#46236e",
  shade10: "#532982",
  primary: "#5c2e91",
  tint10: "#6b3f9e",
  tint20: "#7c52ab",
  tint30: "#9470bd",
  tint40: "#c6b1de",
  tint50: "#e0d3ed",
  tint60: "#f7f4fb"
};
var grape = {
  shade50: "#160418",
  shade40: "#29072e",
  shade30: "#4c0d55",
  shade20: "#671174",
  shade10: "#7a1589",
  primary: "#881798",
  tint10: "#952aa4",
  tint20: "#a33fb1",
  tint30: "#b55fc1",
  tint40: "#d9a7e0",
  tint50: "#eaceef",
  tint60: "#faf2fb"
};
var berry = {
  shade50: "#1f091d",
  shade40: "#3a1136",
  shade30: "#6d2064",
  shade20: "#932b88",
  shade10: "#af33a1",
  primary: "#c239b3",
  tint10: "#c94cbc",
  tint20: "#d161c4",
  tint30: "#da7ed0",
  tint40: "#edbbe7",
  tint50: "#f5daf2",
  tint60: "#fdf5fc"
};
var lilac = {
  shade50: "#1c0b1f",
  shade40: "#35153a",
  shade30: "#63276d",
  shade20: "#863593",
  shade10: "#9f3faf",
  primary: "#b146c2",
  tint10: "#ba58c9",
  tint20: "#c36bd1",
  tint30: "#cf87da",
  tint40: "#e6bfed",
  tint50: "#f2dcf5",
  tint60: "#fcf6fd"
};
var pink = {
  shade50: "#24091b",
  shade40: "#441232",
  shade30: "#80215d",
  shade20: "#ad2d7e",
  shade10: "#cd3595",
  primary: "#e43ba6",
  tint10: "#e750b0",
  tint20: "#ea66ba",
  tint30: "#ef85c8",
  tint40: "#f7c0e3",
  tint50: "#fbddf0",
  tint60: "#fef6fb"
};
var magenta = {
  shade50: "#1f0013",
  shade40: "#390024",
  shade30: "#6b0043",
  shade20: "#91005a",
  shade10: "#ac006b",
  primary: "#bf0077",
  tint10: "#c71885",
  tint20: "#ce3293",
  tint30: "#d957a8",
  tint40: "#eca5d1",
  tint50: "#f5cee6",
  tint60: "#fcf2f9"
};
var plum = {
  shade50: "#13000c",
  shade40: "#240017",
  shade30: "#43002b",
  shade20: "#5a003b",
  shade10: "#6b0045",
  primary: "#77004d",
  tint10: "#87105d",
  tint20: "#98246f",
  tint30: "#ad4589",
  tint40: "#d696c0",
  tint50: "#e9c4dc",
  tint60: "#faf0f6"
};
var beige = {
  shade50: "#141313",
  shade40: "#252323",
  shade30: "#444241",
  shade20: "#5d5958",
  shade10: "#6e6968",
  primary: "#7a7574",
  tint10: "#8a8584",
  tint20: "#9a9594",
  tint30: "#afabaa",
  tint40: "#d7d4d4",
  tint50: "#eae8e8",
  tint60: "#faf9f9"
};
var mink = {
  shade50: "#0f0e0e",
  shade40: "#1c1b1a",
  shade30: "#343231",
  shade20: "#474443",
  shade10: "#54514f",
  primary: "#5d5a58",
  tint10: "#706d6b",
  tint20: "#84817e",
  tint30: "#9e9b99",
  tint40: "#cecccb",
  tint50: "#e5e4e3",
  tint60: "#f8f8f8"
};
var platinum = {
  shade50: "#111314",
  shade40: "#1f2426",
  shade30: "#3b4447",
  shade20: "#505c60",
  shade10: "#5f6d71",
  primary: "#69797e",
  tint10: "#79898d",
  tint20: "#89989d",
  tint30: "#a0adb2",
  tint40: "#cdd6d8",
  tint50: "#e4e9ea",
  tint60: "#f8f9fa"
};
var anchor = {
  shade50: "#090a0b",
  shade40: "#111315",
  shade30: "#202427",
  shade20: "#2b3135",
  shade10: "#333a3f",
  primary: "#394146",
  tint10: "#4d565c",
  tint20: "#626c72",
  tint30: "#808a90",
  tint40: "#bcc3c7",
  tint50: "#dbdfe1",
  tint60: "#f6f7f8"
};

// node_modules/@fluentui/tokens/lib/global/colorPalette.js
var statusSharedColors = {
  red,
  green,
  darkOrange,
  yellow,
  berry,
  lightGreen,
  marigold
};
var personaSharedColors = {
  darkRed,
  cranberry,
  pumpkin,
  peach,
  gold,
  brass,
  brown,
  forest,
  seafoam,
  darkGreen,
  lightTeal,
  teal,
  steel,
  blue,
  royalBlue,
  cornflower,
  navy,
  lavender,
  purple,
  grape,
  lilac,
  pink,
  magenta,
  plum,
  beige,
  mink,
  platinum,
  anchor
};
var mappedStatusColors = {
  cranberry,
  green,
  orange
};

// node_modules/@fluentui/tokens/lib/sharedColorNames.js
var statusSharedColorNames = [
  "red",
  "green",
  "darkOrange",
  "yellow",
  "berry",
  "lightGreen",
  "marigold"
];
var personaSharedColorNames = [
  "darkRed",
  "cranberry",
  "pumpkin",
  "peach",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "darkGreen",
  "lightTeal",
  "teal",
  "steel",
  "blue",
  "royalBlue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];

// node_modules/@fluentui/tokens/lib/statusColorMapping.js
var statusColorMapping = {
  success: "green",
  warning: "orange",
  danger: "cranberry"
};

// node_modules/@fluentui/tokens/lib/alias/lightColorPalette.js
var statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].tint60,
    [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].shade10,
    [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
var personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].primary
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens = {
  ...statusColorPaletteTokens,
  ...personaColorPaletteTokens
};
var colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].tint60,
    [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].primary
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
colorStatusTokens.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
colorStatusTokens.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
colorStatusTokens.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/lightColor.js
var generateColorTokens = (brand) => ({
  colorNeutralForeground1: grey[14],
  colorNeutralForeground1Hover: grey[14],
  colorNeutralForeground1Pressed: grey[14],
  colorNeutralForeground1Selected: grey[14],
  colorNeutralForeground2: grey[26],
  colorNeutralForeground2Hover: grey[14],
  colorNeutralForeground2Pressed: grey[14],
  colorNeutralForeground2Selected: grey[14],
  colorNeutralForeground2BrandHover: brand[80],
  colorNeutralForeground2BrandPressed: brand[70],
  colorNeutralForeground2BrandSelected: brand[80],
  colorNeutralForeground3: grey[38],
  colorNeutralForeground3Hover: grey[26],
  colorNeutralForeground3Pressed: grey[26],
  colorNeutralForeground3Selected: grey[26],
  colorNeutralForeground3BrandHover: brand[80],
  colorNeutralForeground3BrandPressed: brand[70],
  colorNeutralForeground3BrandSelected: brand[80],
  colorNeutralForeground4: grey[44],
  colorNeutralForeground5: grey[38],
  colorNeutralForeground5Hover: grey[14],
  colorNeutralForeground5Pressed: grey[14],
  colorNeutralForeground5Selected: grey[14],
  colorNeutralForegroundDisabled: grey[74],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[70],
  colorBrandForegroundLinkHover: brand[60],
  colorBrandForegroundLinkPressed: brand[40],
  colorBrandForegroundLinkSelected: brand[70],
  colorNeutralForeground2Link: grey[26],
  colorNeutralForeground2LinkHover: grey[14],
  colorNeutralForeground2LinkPressed: grey[14],
  colorNeutralForeground2LinkSelected: grey[14],
  colorCompoundBrandForeground1: brand[80],
  colorCompoundBrandForeground1Hover: brand[70],
  colorCompoundBrandForeground1Pressed: brand[60],
  colorBrandForeground1: brand[80],
  colorBrandForeground2: brand[70],
  colorBrandForeground2Hover: brand[60],
  colorBrandForeground2Pressed: brand[30],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: white,
  colorNeutralForegroundInvertedHover: white,
  colorNeutralForegroundInvertedPressed: white,
  colorNeutralForegroundInvertedSelected: white,
  colorNeutralForegroundInverted2: white,
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[100],
  colorBrandForegroundInvertedHover: brand[110],
  colorBrandForegroundInvertedPressed: brand[100],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: white,
  colorNeutralBackground1Hover: grey[96],
  colorNeutralBackground1Pressed: grey[88],
  colorNeutralBackground1Selected: grey[92],
  colorNeutralBackground2: grey[98],
  colorNeutralBackground2Hover: grey[94],
  colorNeutralBackground2Pressed: grey[86],
  colorNeutralBackground2Selected: grey[90],
  colorNeutralBackground3: grey[96],
  colorNeutralBackground3Hover: grey[92],
  colorNeutralBackground3Pressed: grey[84],
  colorNeutralBackground3Selected: grey[88],
  colorNeutralBackground4: grey[94],
  colorNeutralBackground4Hover: grey[98],
  colorNeutralBackground4Pressed: grey[96],
  colorNeutralBackground4Selected: white,
  colorNeutralBackground5: grey[92],
  colorNeutralBackground5Hover: grey[96],
  colorNeutralBackground5Pressed: grey[94],
  colorNeutralBackground5Selected: grey[98],
  colorNeutralBackground6: grey[90],
  colorNeutralBackground7: "#00000000",
  colorNeutralBackground7Hover: grey[92],
  colorNeutralBackground7Pressed: grey[84],
  colorNeutralBackground7Selected: "#00000000",
  colorNeutralBackground8: grey[99],
  colorNeutralBackgroundInverted: grey[16],
  colorNeutralBackgroundInvertedHover: grey[24],
  colorNeutralBackgroundInvertedPressed: grey[12],
  colorNeutralBackgroundInvertedSelected: grey[22],
  colorNeutralBackgroundStatic: grey[20],
  colorNeutralBackgroundAlpha: whiteAlpha[50],
  colorNeutralBackgroundAlpha2: whiteAlpha[80],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[96],
  colorSubtleBackgroundPressed: grey[88],
  colorSubtleBackgroundSelected: grey[92],
  colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
  colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[94],
  colorNeutralBackgroundDisabled2: white,
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[90],
  colorNeutralStencil2: grey[98],
  colorNeutralStencil1Alpha: blackAlpha[10],
  colorNeutralStencil2Alpha: blackAlpha[5],
  colorBackgroundOverlay: blackAlpha[40],
  colorScrollbarOverlay: blackAlpha[50],
  colorBrandBackground: brand[80],
  colorBrandBackgroundHover: brand[70],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[80],
  colorCompoundBrandBackgroundHover: brand[70],
  colorCompoundBrandBackgroundPressed: brand[60],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[160],
  colorBrandBackground2Hover: brand[150],
  colorBrandBackground2Pressed: brand[130],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[98],
  colorNeutralCardBackgroundHover: white,
  colorNeutralCardBackgroundPressed: grey[96],
  colorNeutralCardBackgroundSelected: grey[92],
  colorNeutralCardBackgroundDisabled: grey[94],
  colorNeutralStrokeAccessible: grey[38],
  colorNeutralStrokeAccessibleHover: grey[34],
  colorNeutralStrokeAccessiblePressed: grey[30],
  colorNeutralStrokeAccessibleSelected: brand[80],
  colorNeutralStroke1: grey[82],
  colorNeutralStroke1Hover: grey[78],
  colorNeutralStroke1Pressed: grey[70],
  colorNeutralStroke1Selected: grey[74],
  colorNeutralStroke2: grey[88],
  colorNeutralStroke3: grey[94],
  colorNeutralStroke4: grey[92],
  colorNeutralStroke4Hover: grey[88],
  colorNeutralStroke4Pressed: grey[84],
  colorNeutralStroke4Selected: grey[92],
  colorNeutralStrokeSubtle: grey[88],
  colorNeutralStrokeOnBrand: white,
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[80],
  colorBrandStroke2: brand[140],
  colorBrandStroke2Hover: brand[120],
  colorBrandStroke2Pressed: brand[80],
  colorBrandStroke2Contrast: brand[140],
  colorCompoundBrandStroke: brand[80],
  colorCompoundBrandStrokeHover: brand[70],
  colorCompoundBrandStrokePressed: brand[60],
  colorNeutralStrokeDisabled: grey[88],
  colorNeutralStrokeDisabled2: grey[92],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: blackAlpha[5],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: white,
  colorStrokeFocus2: black,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
  colorNeutralShadowKey: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/global/borderRadius.js
var borderRadius = {
  borderRadiusNone: "0",
  borderRadiusSmall: "2px",
  borderRadiusMedium: "4px",
  borderRadiusLarge: "6px",
  borderRadiusXLarge: "8px",
  borderRadius2XLarge: "12px",
  borderRadius3XLarge: "16px",
  borderRadius4XLarge: "24px",
  borderRadius5XLarge: "32px",
  borderRadius6XLarge: "40px",
  borderRadiusCircular: "10000px"
};

// node_modules/@fluentui/tokens/lib/global/curves.js
var curves = {
  curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
  curveAccelerateMid: "cubic-bezier(1,0,1,1)",
  curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
  curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
  curveDecelerateMid: "cubic-bezier(0,0,0,1)",
  curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
  curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
  curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
  curveLinear: "cubic-bezier(0,0,1,1)"
};

// node_modules/@fluentui/tokens/lib/global/durations.js
var durations = {
  durationUltraFast: "50ms",
  durationFaster: "100ms",
  durationFast: "150ms",
  durationNormal: "200ms",
  durationGentle: "250ms",
  durationSlow: "300ms",
  durationSlower: "400ms",
  durationUltraSlow: "500ms"
};

// node_modules/@fluentui/tokens/lib/global/fonts.js
var fontSizes = {
  fontSizeBase100: "10px",
  fontSizeBase200: "12px",
  fontSizeBase300: "14px",
  fontSizeBase400: "16px",
  fontSizeBase500: "20px",
  fontSizeBase600: "24px",
  fontSizeHero700: "28px",
  fontSizeHero800: "32px",
  fontSizeHero900: "40px",
  fontSizeHero1000: "68px"
};
var lineHeights = {
  lineHeightBase100: "14px",
  lineHeightBase200: "16px",
  lineHeightBase300: "20px",
  lineHeightBase400: "22px",
  lineHeightBase500: "28px",
  lineHeightBase600: "32px",
  lineHeightHero700: "36px",
  lineHeightHero800: "40px",
  lineHeightHero900: "52px",
  lineHeightHero1000: "92px"
};
var fontWeights = {
  fontWeightRegular: 400,
  fontWeightMedium: 500,
  fontWeightSemibold: 600,
  fontWeightBold: 700
};
var fontFamilies = {
  fontFamilyBase: "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif",
  fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
  fontFamilyNumeric: "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
};

// node_modules/@fluentui/tokens/lib/global/spacings.js
var spacings = {
  none: "0",
  xxs: "2px",
  xs: "4px",
  sNudge: "6px",
  s: "8px",
  mNudge: "10px",
  m: "12px",
  l: "16px",
  xl: "20px",
  xxl: "24px",
  xxxl: "32px"
};
var horizontalSpacings = {
  spacingHorizontalNone: spacings.none,
  spacingHorizontalXXS: spacings.xxs,
  spacingHorizontalXS: spacings.xs,
  spacingHorizontalSNudge: spacings.sNudge,
  spacingHorizontalS: spacings.s,
  spacingHorizontalMNudge: spacings.mNudge,
  spacingHorizontalM: spacings.m,
  spacingHorizontalL: spacings.l,
  spacingHorizontalXL: spacings.xl,
  spacingHorizontalXXL: spacings.xxl,
  spacingHorizontalXXXL: spacings.xxxl
};
var verticalSpacings = {
  spacingVerticalNone: spacings.none,
  spacingVerticalXXS: spacings.xxs,
  spacingVerticalXS: spacings.xs,
  spacingVerticalSNudge: spacings.sNudge,
  spacingVerticalS: spacings.s,
  spacingVerticalMNudge: spacings.mNudge,
  spacingVerticalM: spacings.m,
  spacingVerticalL: spacings.l,
  spacingVerticalXL: spacings.xl,
  spacingVerticalXXL: spacings.xxl,
  spacingVerticalXXXL: spacings.xxxl
};

// node_modules/@fluentui/tokens/lib/global/strokeWidths.js
var strokeWidths = {
  strokeWidthThin: "1px",
  strokeWidthThick: "2px",
  strokeWidthThicker: "3px",
  strokeWidthThickest: "4px"
};

// node_modules/@fluentui/tokens/lib/tokens.js
var tokens = {
  // Color tokens
  colorNeutralForeground1: "var(--colorNeutralForeground1)",
  colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
  colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
  colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
  colorNeutralForeground2: "var(--colorNeutralForeground2)",
  colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
  colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
  colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
  colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
  colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
  colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
  colorNeutralForeground3: "var(--colorNeutralForeground3)",
  colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
  colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
  colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
  colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
  colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
  colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
  colorNeutralForeground4: "var(--colorNeutralForeground4)",
  colorNeutralForeground5: "var(--colorNeutralForeground5)",
  colorNeutralForeground5Hover: "var(--colorNeutralForeground5Hover)",
  colorNeutralForeground5Pressed: "var(--colorNeutralForeground5Pressed)",
  colorNeutralForeground5Selected: "var(--colorNeutralForeground5Selected)",
  colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
  colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
  colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
  colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
  colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
  colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
  colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
  colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
  colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
  colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
  colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
  colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
  colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
  colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
  colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
  colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
  colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
  colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
  colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
  colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
  colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
  colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
  colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
  colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
  colorBrandForeground1: "var(--colorBrandForeground1)",
  colorBrandForeground2: "var(--colorBrandForeground2)",
  colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
  colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
  colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
  colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
  colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
  colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
  colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
  colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
  colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
  colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
  colorNeutralBackground1: "var(--colorNeutralBackground1)",
  colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
  colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
  colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
  colorNeutralBackground2: "var(--colorNeutralBackground2)",
  colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
  colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
  colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
  colorNeutralBackground3: "var(--colorNeutralBackground3)",
  colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
  colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
  colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
  colorNeutralBackground4: "var(--colorNeutralBackground4)",
  colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
  colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
  colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
  colorNeutralBackground5: "var(--colorNeutralBackground5)",
  colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
  colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
  colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
  colorNeutralBackground6: "var(--colorNeutralBackground6)",
  colorNeutralBackground7: "var(--colorNeutralBackground7)",
  colorNeutralBackground7Hover: "var(--colorNeutralBackground7Hover)",
  colorNeutralBackground7Pressed: "var(--colorNeutralBackground7Pressed)",
  colorNeutralBackground7Selected: "var(--colorNeutralBackground7Selected)",
  colorNeutralBackground8: "var(--colorNeutralBackground8)",
  colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
  colorNeutralBackgroundInvertedHover: "var(--colorNeutralBackgroundInvertedHover)",
  colorNeutralBackgroundInvertedPressed: "var(--colorNeutralBackgroundInvertedPressed)",
  colorNeutralBackgroundInvertedSelected: "var(--colorNeutralBackgroundInvertedSelected)",
  colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
  colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
  colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
  colorSubtleBackground: "var(--colorSubtleBackground)",
  colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
  colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
  colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
  colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
  colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
  colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
  colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
  colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
  colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
  colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
  colorTransparentBackground: "var(--colorTransparentBackground)",
  colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
  colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
  colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
  colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
  colorNeutralBackgroundDisabled2: "var(--colorNeutralBackgroundDisabled2)",
  colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
  colorNeutralStencil1: "var(--colorNeutralStencil1)",
  colorNeutralStencil2: "var(--colorNeutralStencil2)",
  colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
  colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
  colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
  colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
  colorBrandBackground: "var(--colorBrandBackground)",
  colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
  colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
  colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
  colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
  colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
  colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
  colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
  colorBrandBackground2: "var(--colorBrandBackground2)",
  colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
  colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
  colorBrandBackground3Static: "var(--colorBrandBackground3Static)",
  colorBrandBackground4Static: "var(--colorBrandBackground4Static)",
  colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
  colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
  colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
  colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
  colorNeutralCardBackground: "var(--colorNeutralCardBackground)",
  colorNeutralCardBackgroundHover: "var(--colorNeutralCardBackgroundHover)",
  colorNeutralCardBackgroundPressed: "var(--colorNeutralCardBackgroundPressed)",
  colorNeutralCardBackgroundSelected: "var(--colorNeutralCardBackgroundSelected)",
  colorNeutralCardBackgroundDisabled: "var(--colorNeutralCardBackgroundDisabled)",
  colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
  colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
  colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
  colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
  colorNeutralStroke1: "var(--colorNeutralStroke1)",
  colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
  colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
  colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
  colorNeutralStroke2: "var(--colorNeutralStroke2)",
  colorNeutralStroke3: "var(--colorNeutralStroke3)",
  colorNeutralStroke4: "var(--colorNeutralStroke4)",
  colorNeutralStroke4Hover: "var(--colorNeutralStroke4Hover)",
  colorNeutralStroke4Pressed: "var(--colorNeutralStroke4Pressed)",
  colorNeutralStroke4Selected: "var(--colorNeutralStroke4Selected)",
  colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
  colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
  colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
  colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
  colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
  colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
  colorBrandStroke1: "var(--colorBrandStroke1)",
  colorBrandStroke2: "var(--colorBrandStroke2)",
  colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
  colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
  colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
  colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
  colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
  colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
  colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
  colorNeutralStrokeDisabled2: "var(--colorNeutralStrokeDisabled2)",
  colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
  colorTransparentStroke: "var(--colorTransparentStroke)",
  colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
  colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
  colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
  colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
  colorStrokeFocus1: "var(--colorStrokeFocus1)",
  colorStrokeFocus2: "var(--colorStrokeFocus2)",
  colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
  colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
  colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
  colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
  colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
  colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
  colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
  colorBrandShadowKey: "var(--colorBrandShadowKey)",
  // Color palette tokens
  // Color palette red tokens
  colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
  colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
  colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
  colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
  colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
  colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
  colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
  colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
  colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
  colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
  // Color palette green tokens
  colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
  colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
  colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
  colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
  colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
  colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
  colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
  colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
  colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
  colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
  // Color palette dark orange tokens
  colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
  colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
  colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
  colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
  colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
  colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
  colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
  colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
  colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
  // Color palette yellow tokens
  colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
  colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
  colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
  colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
  colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
  colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
  colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
  colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
  colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
  colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
  // Color palette berry tokens
  colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
  colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
  colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
  colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
  colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
  colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
  colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
  colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
  colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
  // Color palette marigold tokens
  colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
  colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
  colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
  colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
  colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
  colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
  colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
  colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
  colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
  // Color palette light green tokens
  colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
  colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
  colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
  colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
  colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
  colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
  colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
  colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
  colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
  // Color palette anchor tokens
  colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
  colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
  colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
  // Color palette beige tokens
  colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
  colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
  colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
  // Color palette blue tokens
  colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
  colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
  colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
  // Color palette brass tokens
  colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
  colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
  colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
  // Color palette brown tokens
  colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
  colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
  colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
  // Color palette cornflower tokens
  colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
  colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
  colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
  // Color palette cranberry tokens
  colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
  colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
  colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
  // Color palette dark green tokens
  colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
  colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
  colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
  // Color palette dark red tokens
  colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
  colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
  colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
  // Color palette forest tokens
  colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
  colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
  colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
  // Color palette gold tokens
  colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
  colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
  colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
  // Color palette grape tokens
  colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
  colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
  colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
  // Color palette lavender tokens
  colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
  colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
  colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
  // Color palette light teal tokens
  colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
  colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
  colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
  // Color palette lilac tokens
  colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
  colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
  colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
  // Color palette magenta tokens
  colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
  colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
  colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
  // Color palette mink tokens
  colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
  colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
  colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
  // Color palette navy tokens
  colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
  colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
  colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
  // Color palette peach tokens
  colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
  colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
  colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
  // Color palette pink tokens
  colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
  colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
  colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
  // Color palette platinum tokens
  colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
  colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
  colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
  // Color palette plum tokens
  colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
  colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
  colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
  // Color palette pumpkin tokens
  colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
  colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
  colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
  // Color palette purple tokens
  colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
  colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
  colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
  // Color palette royal blue tokens
  colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
  colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
  colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
  // Color palette seafoam tokens
  colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
  colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
  colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
  // Color palette steel tokens
  colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
  colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
  colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
  // Color palette teal tokens
  colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
  colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
  colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
  // Color status success tokens
  colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
  colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
  colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
  colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
  colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
  colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
  colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
  colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
  colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
  colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
  // Color status warning tokens
  colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
  colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
  colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
  colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
  colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
  colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
  colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
  colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
  colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
  colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
  // Color status danger tokens
  colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
  colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
  colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
  colorStatusDangerBackground3Hover: "var(--colorStatusDangerBackground3Hover)",
  colorStatusDangerBackground3Pressed: "var(--colorStatusDangerBackground3Pressed)",
  colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
  colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
  colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
  colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
  colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
  colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
  colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
  // Border radius tokens
  borderRadiusNone: "var(--borderRadiusNone)",
  borderRadiusSmall: "var(--borderRadiusSmall)",
  borderRadiusMedium: "var(--borderRadiusMedium)",
  borderRadiusLarge: "var(--borderRadiusLarge)",
  borderRadiusXLarge: "var(--borderRadiusXLarge)",
  borderRadius2XLarge: "var(--borderRadius2XLarge)",
  borderRadius3XLarge: "var(--borderRadius3XLarge)",
  borderRadius4XLarge: "var(--borderRadius4XLarge)",
  borderRadius5XLarge: "var(--borderRadius5XLarge)",
  borderRadius6XLarge: "var(--borderRadius6XLarge)",
  borderRadiusCircular: "var(--borderRadiusCircular)",
  // Font family tokens
  fontFamilyBase: "var(--fontFamilyBase)",
  fontFamilyMonospace: "var(--fontFamilyMonospace)",
  fontFamilyNumeric: "var(--fontFamilyNumeric)",
  // Font size tokens
  fontSizeBase100: "var(--fontSizeBase100)",
  fontSizeBase200: "var(--fontSizeBase200)",
  fontSizeBase300: "var(--fontSizeBase300)",
  fontSizeBase400: "var(--fontSizeBase400)",
  fontSizeBase500: "var(--fontSizeBase500)",
  fontSizeBase600: "var(--fontSizeBase600)",
  fontSizeHero700: "var(--fontSizeHero700)",
  fontSizeHero800: "var(--fontSizeHero800)",
  fontSizeHero900: "var(--fontSizeHero900)",
  fontSizeHero1000: "var(--fontSizeHero1000)",
  // Font weight tokens
  fontWeightRegular: "var(--fontWeightRegular)",
  fontWeightMedium: "var(--fontWeightMedium)",
  fontWeightSemibold: "var(--fontWeightSemibold)",
  fontWeightBold: "var(--fontWeightBold)",
  // Line height tokens
  lineHeightBase100: "var(--lineHeightBase100)",
  lineHeightBase200: "var(--lineHeightBase200)",
  lineHeightBase300: "var(--lineHeightBase300)",
  lineHeightBase400: "var(--lineHeightBase400)",
  lineHeightBase500: "var(--lineHeightBase500)",
  lineHeightBase600: "var(--lineHeightBase600)",
  lineHeightHero700: "var(--lineHeightHero700)",
  lineHeightHero800: "var(--lineHeightHero800)",
  lineHeightHero900: "var(--lineHeightHero900)",
  lineHeightHero1000: "var(--lineHeightHero1000)",
  // Shadow tokens
  shadow2: "var(--shadow2)",
  shadow4: "var(--shadow4)",
  shadow8: "var(--shadow8)",
  shadow16: "var(--shadow16)",
  shadow28: "var(--shadow28)",
  shadow64: "var(--shadow64)",
  // Shadow brand tokens
  shadow2Brand: "var(--shadow2Brand)",
  shadow4Brand: "var(--shadow4Brand)",
  shadow8Brand: "var(--shadow8Brand)",
  shadow16Brand: "var(--shadow16Brand)",
  shadow28Brand: "var(--shadow28Brand)",
  shadow64Brand: "var(--shadow64Brand)",
  // Stroke width tokens
  strokeWidthThin: "var(--strokeWidthThin)",
  strokeWidthThick: "var(--strokeWidthThick)",
  strokeWidthThicker: "var(--strokeWidthThicker)",
  strokeWidthThickest: "var(--strokeWidthThickest)",
  // Spacings
  spacingHorizontalNone: "var(--spacingHorizontalNone)",
  spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
  spacingHorizontalXS: "var(--spacingHorizontalXS)",
  spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
  spacingHorizontalS: "var(--spacingHorizontalS)",
  spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
  spacingHorizontalM: "var(--spacingHorizontalM)",
  spacingHorizontalL: "var(--spacingHorizontalL)",
  spacingHorizontalXL: "var(--spacingHorizontalXL)",
  spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
  spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
  spacingVerticalNone: "var(--spacingVerticalNone)",
  spacingVerticalXXS: "var(--spacingVerticalXXS)",
  spacingVerticalXS: "var(--spacingVerticalXS)",
  spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
  spacingVerticalS: "var(--spacingVerticalS)",
  spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
  spacingVerticalM: "var(--spacingVerticalM)",
  spacingVerticalL: "var(--spacingVerticalL)",
  spacingVerticalXL: "var(--spacingVerticalXL)",
  spacingVerticalXXL: "var(--spacingVerticalXXL)",
  spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
  // Durations
  durationUltraFast: "var(--durationUltraFast)",
  durationFaster: "var(--durationFaster)",
  durationFast: "var(--durationFast)",
  durationNormal: "var(--durationNormal)",
  durationGentle: "var(--durationGentle)",
  durationSlow: "var(--durationSlow)",
  durationSlower: "var(--durationSlower)",
  durationUltraSlow: "var(--durationUltraSlow)",
  // Curves
  curveAccelerateMax: "var(--curveAccelerateMax)",
  curveAccelerateMid: "var(--curveAccelerateMid)",
  curveAccelerateMin: "var(--curveAccelerateMin)",
  curveDecelerateMax: "var(--curveDecelerateMax)",
  curveDecelerateMid: "var(--curveDecelerateMid)",
  curveDecelerateMin: "var(--curveDecelerateMin)",
  curveEasyEaseMax: "var(--curveEasyEaseMax)",
  curveEasyEase: "var(--curveEasyEase)",
  curveLinear: "var(--curveLinear)",
  /**
  * ZIndexes
  * Special case where the tokens contain default values
  * ZIndexes are not mandatory, so they are not included in the theme, but can be used as tokens with default values
  */
  /**
  * Elevation 0
  * Can be used for background elements, like surfaces
  */
  zIndexBackground: "var(--zIndexBackground, 0)",
  /**
  * Elevation 2
  * Can be used content that is on top of the background, like cards
  */
  zIndexContent: "var(--zIndexContent, 1)",
  /**
  * Elevation 4
  * Can be used for overlays, like the backdrop of a modal
  */
  zIndexOverlay: "var(--zIndexOverlay, 1000)",
  /**
  * Elevation 8
  * Can be used for popups, like modals and drawers
  */
  zIndexPopup: "var(--zIndexPopup, 2000)",
  /**
  * Elevation 16
  * Can be used for messages, like snackbars and toasts
  */
  zIndexMessages: "var(--zIndexMessages, 3000)",
  /**
  * Elevation 28
  * Can be used for floating elements, like dropdowns
  */
  zIndexFloating: "var(--zIndexFloating, 4000)",
  /**
  * Elevation 64
  * Can be used for high priority floating elements, like tooltips
  */
  zIndexPriority: "var(--zIndexPriority, 5000)",
  /**
  * Special elevation
  * Can be used for elements that need to be above everything else, like debug overlays
  */
  zIndexDebug: "var(--zIndexDebug, 6000)"
};

// node_modules/@fluentui/tokens/lib/global/typographyStyles.js
var typographyStyles = {
  body1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase300
  },
  body1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase300
  },
  body1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase300,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase300
  },
  body2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase400
  },
  caption1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase200
  },
  caption1Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase200,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase200
  },
  caption2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightRegular,
    lineHeight: tokens.lineHeightBase100
  },
  caption2Strong: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase100,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase100
  },
  subtitle1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase500,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase500
  },
  subtitle2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase400
  },
  subtitle2Stronger: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase400,
    fontWeight: tokens.fontWeightBold,
    lineHeight: tokens.lineHeightBase400
  },
  title1: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero800,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero800
  },
  title2: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero700,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero700
  },
  title3: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeBase600,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightBase600
  },
  largeTitle: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero900,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero900
  },
  display: {
    fontFamily: tokens.fontFamilyBase,
    fontSize: tokens.fontSizeHero1000,
    fontWeight: tokens.fontWeightSemibold,
    lineHeight: tokens.lineHeightHero1000
  }
};

// node_modules/@fluentui/tokens/lib/utils/shadows.js
function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
  return {
    [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
    [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
    [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
    [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
    [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
    [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
  };
}

// node_modules/@fluentui/tokens/lib/utils/createLightTheme.js
var createLightTheme = (brand) => {
  const colorTokens = generateColorTokens(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens,
    ...colorStatusTokens,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/global/brandColors.js
var brandWeb = {
  10: `#061724`,
  20: `#082338`,
  30: `#0a2e4a`,
  40: `#0c3b5e`,
  50: `#0e4775`,
  60: `#0f548c`,
  70: `#115ea3`,
  80: `#0f6cbd`,
  90: `#2886de`,
  100: `#479ef5`,
  110: `#62abf5`,
  120: `#77b7f7`,
  130: `#96c6fa`,
  140: `#b4d6fa`,
  150: `#cfe4fa`,
  160: `#ebf3fc`
};
var brandTeams = {
  10: `#2b2b40`,
  20: `#2f2f4a`,
  30: `#333357`,
  40: `#383966`,
  50: `#3d3e78`,
  60: `#444791`,
  70: `#4f52b2`,
  80: `#5b5fc7`,
  90: `#7579eb`,
  100: `#7f85f5`,
  110: `#9299f7`,
  120: `#aab1fa`,
  130: `#b6bcfa`,
  140: `#c5cbfa`,
  150: `#dce0fa`,
  160: `#e8ebfa`
};
var brandTeamsV21 = {
  10: `#29274f`,
  20: `#2f2a5e`,
  30: `#352e70`,
  40: `#3b3185`,
  50: `#44359e`,
  60: `#4d3aba`,
  70: `#5a40db`,
  80: `#654cf5`,
  90: `#7769fa`,
  100: `#887dff`,
  110: `#9791ff`,
  120: `#aba8ff`,
  130: `#bab8ff`,
  140: `#c8c7ff`,
  150: `#dcdbff`,
  160: `#e8e8ff`
};

// node_modules/@fluentui/tokens/lib/alias/teamsFontFamilies.js
var fontFamilies2 = {
  ...fontFamilies,
  fontFamilyBase: '-apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, "Apple Color Emoji", "Segoe UI Emoji", sans-serif'
};

// node_modules/@fluentui/tokens/lib/themes/teams/lightTheme.js
var teamsLightTheme = {
  ...createLightTheme(brandTeams),
  ...fontFamilies2
};
var teamsLightV21Theme = {
  ...createLightTheme(brandTeamsV21),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/alias/darkColorPalette.js
var statusColorPaletteTokens2 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].shade40,
    [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].tint40,
    [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].tint20,
    [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].tint30,
    [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].primary,
    [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].tint20
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens2.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
statusColorPaletteTokens2.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
statusColorPaletteTokens2.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
statusColorPaletteTokens2.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
statusColorPaletteTokens2.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
statusColorPaletteTokens2.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
var personaColorPaletteTokens2 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].shade30,
    [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].tint40,
    [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].tint30
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
personaColorPaletteTokens2.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
personaColorPaletteTokens2.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
var colorPaletteTokens2 = {
  ...statusColorPaletteTokens2,
  ...personaColorPaletteTokens2
};
var colorStatusTokens2 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].shade40,
    [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].shade30,
    [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].tint40,
    [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].tint20,
    [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].tint30,
    [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
    [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].primary,
    [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].tint20
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens2.colorStatusDangerBackground3Hover = mappedStatusColors[statusColorMapping.danger].shade10;
colorStatusTokens2.colorStatusDangerBackground3Pressed = mappedStatusColors[statusColorMapping.danger].shade20;
colorStatusTokens2.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint40;
colorStatusTokens2.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
colorStatusTokens2.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
colorStatusTokens2.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;

// node_modules/@fluentui/tokens/lib/alias/teamsDarkColor.js
var generateColorTokens2 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForeground5: grey[68],
  colorNeutralForeground5Hover: white,
  colorNeutralForeground5Pressed: white,
  colorNeutralForeground5Selected: white,
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[120],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[14],
  colorNeutralBackground2Hover: grey[22],
  colorNeutralBackground2Pressed: grey[10],
  colorNeutralBackground2Selected: grey[20],
  colorNeutralBackground3: grey[12],
  colorNeutralBackground3Hover: grey[20],
  colorNeutralBackground3Pressed: grey[8],
  colorNeutralBackground3Selected: grey[18],
  colorNeutralBackground4: grey[8],
  colorNeutralBackground4Hover: grey[16],
  colorNeutralBackground4Pressed: grey[4],
  colorNeutralBackground4Selected: grey[14],
  colorNeutralBackground5: grey[4],
  colorNeutralBackground5Hover: grey[12],
  colorNeutralBackground5Pressed: black,
  colorNeutralBackground5Selected: grey[10],
  colorNeutralBackground6: grey[20],
  colorNeutralBackground7: "#00000000",
  colorNeutralBackground7Hover: grey[10],
  colorNeutralBackground7Pressed: grey[4],
  colorNeutralBackground7Selected: "#00000000",
  colorNeutralBackground8: grey[16],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundInvertedHover: grey[96],
  colorNeutralBackgroundInvertedPressed: grey[88],
  colorNeutralBackgroundInvertedSelected: grey[92],
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundDisabled2: grey[16],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[20],
  colorNeutralCardBackgroundHover: grey[24],
  colorNeutralCardBackgroundPressed: grey[18],
  colorNeutralCardBackgroundSelected: grey[22],
  colorNeutralCardBackgroundDisabled: grey[8],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStroke4: grey[24],
  colorNeutralStroke4Hover: grey[18],
  colorNeutralStroke4Pressed: grey[14],
  colorNeutralStroke4Selected: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[90],
  colorCompoundBrandStrokeHover: brand[100],
  colorCompoundBrandStrokePressed: brand[80],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeDisabled2: grey[24],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createTeamsDarkTheme.js
var createTeamsDarkTheme = (brand) => {
  const colorTokens = generateColorTokens2(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/darkTheme.js
var teamsDarkTheme = {
  ...createTeamsDarkTheme(brandTeams),
  ...fontFamilies2
};
var teamsDarkV21Theme = {
  ...createTeamsDarkTheme(brandTeamsV21),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/alias/highContrastColorPalette.js
var statusColorPaletteTokens3 = statusSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background1`]: hcCanvas,
    [`colorPalette${color2}Background2`]: hcCanvas,
    [`colorPalette${color2}Background3`]: hcCanvasText,
    [`colorPalette${color2}Foreground1`]: hcCanvasText,
    [`colorPalette${color2}Foreground2`]: hcCanvasText,
    [`colorPalette${color2}Foreground3`]: hcCanvasText,
    [`colorPalette${color2}BorderActive`]: hcHighlight,
    [`colorPalette${color2}Border1`]: hcCanvasText,
    [`colorPalette${color2}Border2`]: hcCanvasText
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
statusColorPaletteTokens3.colorPaletteRedForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteGreenForegroundInverted = hcCanvasText;
statusColorPaletteTokens3.colorPaletteYellowForegroundInverted = hcCanvasText;
var personaColorPaletteTokens3 = personaSharedColorNames.reduce((acc, sharedColor) => {
  const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
  const sharedColorTokens = {
    [`colorPalette${color2}Background2`]: hcCanvas,
    [`colorPalette${color2}Foreground2`]: hcCanvasText,
    [`colorPalette${color2}BorderActive`]: hcHighlight
  };
  return Object.assign(acc, sharedColorTokens);
}, {});
var colorPaletteTokens3 = {
  ...statusColorPaletteTokens3,
  ...personaColorPaletteTokens3
};
var colorStatusTokens3 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
  const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
  const statusColorTokens = {
    [`colorStatus${color2}Background1`]: hcCanvas,
    [`colorStatus${color2}Background2`]: hcCanvas,
    [`colorStatus${color2}Background3`]: hcCanvasText,
    [`colorStatus${color2}Foreground1`]: hcCanvasText,
    [`colorStatus${color2}Foreground2`]: hcCanvasText,
    [`colorStatus${color2}Foreground3`]: hcCanvasText,
    [`colorStatus${color2}BorderActive`]: hcHighlight,
    [`colorStatus${color2}ForegroundInverted`]: hcCanvasText,
    [`colorStatus${color2}Border1`]: hcCanvasText,
    [`colorStatus${color2}Border2`]: hcCanvasText
  };
  return Object.assign(acc, statusColorTokens);
}, {});
colorStatusTokens3.colorStatusDangerBackground3Hover = hcHighlight;
colorStatusTokens3.colorStatusDangerBackground3Pressed = hcHighlight;

// node_modules/@fluentui/tokens/lib/alias/highContrastColor.js
var generateColorTokens3 = () => ({
  colorNeutralForeground1: hcCanvasText,
  colorNeutralForeground1Hover: hcHighlightText,
  colorNeutralForeground1Pressed: hcHighlightText,
  colorNeutralForeground1Selected: hcHighlightText,
  colorNeutralForeground2: hcCanvasText,
  colorNeutralForeground2Hover: hcHighlightText,
  colorNeutralForeground2Pressed: hcHighlightText,
  colorNeutralForeground2Selected: hcHighlightText,
  colorNeutralForeground2BrandHover: hcHighlightText,
  colorNeutralForeground2BrandPressed: hcHighlightText,
  colorNeutralForeground2BrandSelected: hcHighlightText,
  colorNeutralForeground3: hcCanvasText,
  colorNeutralForeground3Hover: hcHighlightText,
  colorNeutralForeground3Pressed: hcHighlightText,
  colorNeutralForeground3Selected: hcHighlightText,
  colorNeutralForeground3BrandHover: hcHighlightText,
  colorNeutralForeground3BrandPressed: hcHighlightText,
  colorNeutralForeground3BrandSelected: hcHighlightText,
  colorNeutralForeground4: hcCanvasText,
  colorNeutralForeground5: hcCanvasText,
  colorNeutralForeground5Hover: hcHighlightText,
  colorNeutralForeground5Pressed: hcHighlightText,
  colorNeutralForeground5Selected: hcHighlightText,
  colorNeutralForegroundDisabled: hcDisabled,
  colorNeutralForegroundInvertedDisabled: hcDisabled,
  colorBrandForegroundLink: hcHyperlink,
  colorBrandForegroundLinkHover: hcHyperlink,
  colorBrandForegroundLinkPressed: hcHyperlink,
  colorBrandForegroundLinkSelected: hcHyperlink,
  colorNeutralForeground2Link: hcHyperlink,
  colorNeutralForeground2LinkHover: hcHyperlink,
  colorNeutralForeground2LinkPressed: hcHyperlink,
  colorNeutralForeground2LinkSelected: hcHyperlink,
  colorCompoundBrandForeground1: hcHighlight,
  colorCompoundBrandForeground1Hover: hcHighlight,
  colorCompoundBrandForeground1Pressed: hcHighlight,
  colorBrandForeground1: hcCanvasText,
  colorBrandForeground2: hcCanvasText,
  colorBrandForeground2Hover: hcCanvasText,
  colorBrandForeground2Pressed: hcCanvasText,
  colorNeutralForeground1Static: hcCanvas,
  colorNeutralForegroundStaticInverted: hcCanvasText,
  colorNeutralForegroundInverted: hcHighlightText,
  colorNeutralForegroundInvertedHover: hcHighlightText,
  colorNeutralForegroundInvertedPressed: hcHighlightText,
  colorNeutralForegroundInvertedSelected: hcHighlightText,
  colorNeutralForegroundInverted2: hcCanvasText,
  colorNeutralForegroundOnBrand: hcButtonText,
  colorNeutralForegroundInvertedLink: hcHyperlink,
  colorNeutralForegroundInvertedLinkHover: hcHyperlink,
  colorNeutralForegroundInvertedLinkPressed: hcHyperlink,
  colorNeutralForegroundInvertedLinkSelected: hcHyperlink,
  colorBrandForegroundInverted: hcCanvasText,
  colorBrandForegroundInvertedHover: hcHighlightText,
  colorBrandForegroundInvertedPressed: hcHighlightText,
  colorBrandForegroundOnLight: hcButtonText,
  colorBrandForegroundOnLightHover: hcHighlightText,
  colorBrandForegroundOnLightPressed: hcHighlightText,
  colorBrandForegroundOnLightSelected: hcHighlightText,
  colorNeutralBackground1: hcCanvas,
  colorNeutralBackground1Hover: hcHighlight,
  colorNeutralBackground1Pressed: hcHighlight,
  colorNeutralBackground1Selected: hcHighlight,
  colorNeutralBackground2: hcCanvas,
  colorNeutralBackground2Hover: hcHighlight,
  colorNeutralBackground2Pressed: hcHighlight,
  colorNeutralBackground2Selected: hcHighlight,
  colorNeutralBackground3: hcCanvas,
  colorNeutralBackground3Hover: hcHighlight,
  colorNeutralBackground3Pressed: hcHighlight,
  colorNeutralBackground3Selected: hcHighlight,
  colorNeutralBackground4: hcCanvas,
  colorNeutralBackground4Hover: hcHighlight,
  colorNeutralBackground4Pressed: hcHighlight,
  colorNeutralBackground4Selected: hcHighlight,
  colorNeutralBackground5: hcCanvas,
  colorNeutralBackground5Hover: hcHighlight,
  colorNeutralBackground5Pressed: hcHighlight,
  colorNeutralBackground5Selected: hcHighlight,
  colorNeutralBackground6: hcCanvas,
  colorNeutralBackground7: hcCanvas,
  colorNeutralBackground7Hover: hcHighlight,
  colorNeutralBackground7Pressed: hcHighlight,
  colorNeutralBackground7Selected: hcHighlight,
  colorNeutralBackground8: hcCanvas,
  colorNeutralBackgroundInverted: hcCanvas,
  colorNeutralBackgroundInvertedHover: hcHighlight,
  colorNeutralBackgroundInvertedPressed: hcHighlight,
  colorNeutralBackgroundInvertedSelected: hcHighlight,
  colorNeutralBackgroundStatic: hcCanvas,
  colorNeutralBackgroundAlpha: hcCanvas,
  colorNeutralBackgroundAlpha2: hcCanvas,
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: hcHighlight,
  colorSubtleBackgroundPressed: hcHighlight,
  colorSubtleBackgroundSelected: hcHighlight,
  colorSubtleBackgroundLightAlphaHover: hcHighlight,
  colorSubtleBackgroundLightAlphaPressed: hcHighlight,
  colorSubtleBackgroundLightAlphaSelected: hcHighlight,
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: hcHighlight,
  colorSubtleBackgroundInvertedPressed: hcHighlight,
  colorSubtleBackgroundInvertedSelected: hcHighlight,
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: hcHighlight,
  colorTransparentBackgroundPressed: hcHighlight,
  colorTransparentBackgroundSelected: hcHighlight,
  colorNeutralBackgroundDisabled: hcCanvas,
  colorNeutralBackgroundDisabled2: hcDisabled,
  colorNeutralBackgroundInvertedDisabled: hcCanvas,
  colorNeutralStencil1: hcCanvasText,
  colorNeutralStencil2: hcCanvasText,
  colorNeutralStencil1Alpha: hcCanvasText,
  colorNeutralStencil2Alpha: hcCanvasText,
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: hcButtonFace,
  colorBrandBackground: hcButtonFace,
  colorBrandBackgroundHover: hcHighlight,
  colorBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundSelected: hcHighlight,
  colorCompoundBrandBackground: hcHighlight,
  colorCompoundBrandBackgroundHover: hcHighlight,
  colorCompoundBrandBackgroundPressed: hcHighlight,
  colorBrandBackgroundStatic: hcCanvas,
  colorBrandBackground2: hcCanvas,
  colorBrandBackground2Hover: hcCanvas,
  colorBrandBackground2Pressed: hcCanvas,
  colorBrandBackground3Static: hcCanvas,
  colorBrandBackground4Static: hcCanvas,
  colorBrandBackgroundInverted: hcButtonFace,
  colorBrandBackgroundInvertedHover: hcHighlight,
  colorBrandBackgroundInvertedPressed: hcHighlight,
  colorBrandBackgroundInvertedSelected: hcHighlight,
  colorNeutralCardBackground: hcCanvas,
  colorNeutralCardBackgroundHover: hcHighlight,
  colorNeutralCardBackgroundPressed: hcHighlight,
  colorNeutralCardBackgroundSelected: hcHighlight,
  colorNeutralCardBackgroundDisabled: hcCanvas,
  colorNeutralStrokeAccessible: hcCanvasText,
  colorNeutralStrokeAccessibleHover: hcHighlight,
  colorNeutralStrokeAccessiblePressed: hcHighlight,
  colorNeutralStrokeAccessibleSelected: hcHighlight,
  colorNeutralStroke1: hcCanvasText,
  colorNeutralStroke1Hover: hcHighlight,
  colorNeutralStroke1Pressed: hcHighlight,
  colorNeutralStroke1Selected: hcHighlight,
  colorNeutralStroke2: hcCanvasText,
  colorNeutralStroke3: hcCanvasText,
  colorNeutralStroke4: hcCanvasText,
  colorNeutralStroke4Hover: hcHighlight,
  colorNeutralStroke4Pressed: hcHighlight,
  colorNeutralStroke4Selected: hcHighlight,
  colorNeutralStrokeSubtle: hcCanvasText,
  colorNeutralStrokeOnBrand: hcCanvas,
  colorNeutralStrokeOnBrand2: hcCanvasText,
  colorNeutralStrokeOnBrand2Hover: hcCanvasText,
  colorNeutralStrokeOnBrand2Pressed: hcCanvasText,
  colorNeutralStrokeOnBrand2Selected: hcCanvasText,
  colorBrandStroke1: hcCanvasText,
  colorBrandStroke2: hcCanvasText,
  colorBrandStroke2Hover: hcHighlight,
  colorBrandStroke2Pressed: hcHighlight,
  colorBrandStroke2Contrast: hcCanvas,
  colorCompoundBrandStroke: hcHighlight,
  colorCompoundBrandStrokeHover: hcHighlight,
  colorCompoundBrandStrokePressed: hcHighlight,
  colorNeutralStrokeDisabled: hcDisabled,
  colorNeutralStrokeDisabled2: hcDisabled,
  colorNeutralStrokeInvertedDisabled: hcDisabled,
  colorTransparentStroke: hcCanvasText,
  colorTransparentStrokeInteractive: hcHighlight,
  colorTransparentStrokeDisabled: hcDisabled,
  colorNeutralStrokeAlpha: hcCanvasText,
  colorNeutralStrokeAlpha2: hcCanvas,
  colorStrokeFocus1: hcCanvas,
  colorStrokeFocus2: hcHighlight,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createHighContrastTheme.js
var createHighContrastTheme = () => {
  const colorTokens = generateColorTokens3();
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens3,
    ...colorStatusTokens3,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/teams/highContrastTheme.js
var teamsHighContrastTheme = {
  ...createHighContrastTheme(),
  ...fontFamilies2
};

// node_modules/@fluentui/tokens/lib/themes/web/lightTheme.js
var webLightTheme = createLightTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/alias/darkColor.js
var generateColorTokens4 = (brand) => ({
  colorNeutralForeground1: white,
  colorNeutralForeground1Hover: white,
  colorNeutralForeground1Pressed: white,
  colorNeutralForeground1Selected: white,
  colorNeutralForeground2: grey[84],
  colorNeutralForeground2Hover: white,
  colorNeutralForeground2Pressed: white,
  colorNeutralForeground2Selected: white,
  colorNeutralForeground2BrandHover: brand[100],
  colorNeutralForeground2BrandPressed: brand[90],
  colorNeutralForeground2BrandSelected: brand[100],
  colorNeutralForeground3: grey[68],
  colorNeutralForeground3Hover: grey[84],
  colorNeutralForeground3Pressed: grey[84],
  colorNeutralForeground3Selected: grey[84],
  colorNeutralForeground3BrandHover: brand[100],
  colorNeutralForeground3BrandPressed: brand[90],
  colorNeutralForeground3BrandSelected: brand[100],
  colorNeutralForeground4: grey[60],
  colorNeutralForeground5: grey[68],
  colorNeutralForeground5Hover: white,
  colorNeutralForeground5Pressed: white,
  colorNeutralForeground5Selected: white,
  colorNeutralForegroundDisabled: grey[36],
  colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
  colorBrandForegroundLink: brand[100],
  colorBrandForegroundLinkHover: brand[110],
  colorBrandForegroundLinkPressed: brand[90],
  colorBrandForegroundLinkSelected: brand[100],
  colorNeutralForeground2Link: grey[84],
  colorNeutralForeground2LinkHover: white,
  colorNeutralForeground2LinkPressed: white,
  colorNeutralForeground2LinkSelected: white,
  colorCompoundBrandForeground1: brand[100],
  colorCompoundBrandForeground1Hover: brand[110],
  colorCompoundBrandForeground1Pressed: brand[90],
  colorBrandForeground1: brand[100],
  colorBrandForeground2: brand[110],
  colorBrandForeground2Hover: brand[130],
  colorBrandForeground2Pressed: brand[160],
  colorNeutralForeground1Static: grey[14],
  colorNeutralForegroundStaticInverted: white,
  colorNeutralForegroundInverted: grey[14],
  colorNeutralForegroundInvertedHover: grey[14],
  colorNeutralForegroundInvertedPressed: grey[14],
  colorNeutralForegroundInvertedSelected: grey[14],
  colorNeutralForegroundInverted2: grey[14],
  colorNeutralForegroundOnBrand: white,
  colorNeutralForegroundInvertedLink: white,
  colorNeutralForegroundInvertedLinkHover: white,
  colorNeutralForegroundInvertedLinkPressed: white,
  colorNeutralForegroundInvertedLinkSelected: white,
  colorBrandForegroundInverted: brand[80],
  colorBrandForegroundInvertedHover: brand[70],
  colorBrandForegroundInvertedPressed: brand[60],
  colorBrandForegroundOnLight: brand[80],
  colorBrandForegroundOnLightHover: brand[70],
  colorBrandForegroundOnLightPressed: brand[50],
  colorBrandForegroundOnLightSelected: brand[60],
  colorNeutralBackground1: grey[16],
  colorNeutralBackground1Hover: grey[24],
  colorNeutralBackground1Pressed: grey[12],
  colorNeutralBackground1Selected: grey[22],
  colorNeutralBackground2: grey[12],
  colorNeutralBackground2Hover: grey[20],
  colorNeutralBackground2Pressed: grey[8],
  colorNeutralBackground2Selected: grey[18],
  colorNeutralBackground3: grey[8],
  colorNeutralBackground3Hover: grey[16],
  colorNeutralBackground3Pressed: grey[4],
  colorNeutralBackground3Selected: grey[14],
  colorNeutralBackground4: grey[4],
  colorNeutralBackground4Hover: grey[12],
  colorNeutralBackground4Pressed: black,
  colorNeutralBackground4Selected: grey[10],
  colorNeutralBackground5: black,
  colorNeutralBackground5Hover: grey[8],
  colorNeutralBackground5Pressed: grey[2],
  colorNeutralBackground5Selected: grey[6],
  colorNeutralBackground6: grey[20],
  colorNeutralBackground7: "#00000000",
  colorNeutralBackground7Hover: grey[10],
  colorNeutralBackground7Pressed: grey[4],
  colorNeutralBackground7Selected: "#00000000",
  colorNeutralBackground8: grey[16],
  colorNeutralBackgroundInverted: white,
  colorNeutralBackgroundInvertedHover: grey[96],
  colorNeutralBackgroundInvertedPressed: grey[88],
  colorNeutralBackgroundInvertedSelected: grey[92],
  colorNeutralBackgroundStatic: grey[24],
  colorNeutralBackgroundAlpha: grey10Alpha[50],
  colorNeutralBackgroundAlpha2: grey12Alpha[70],
  colorSubtleBackground: "transparent",
  colorSubtleBackgroundHover: grey[22],
  colorSubtleBackgroundPressed: grey[18],
  colorSubtleBackgroundSelected: grey[20],
  colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
  colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
  colorSubtleBackgroundLightAlphaSelected: "transparent",
  colorSubtleBackgroundInverted: "transparent",
  colorSubtleBackgroundInvertedHover: blackAlpha[10],
  colorSubtleBackgroundInvertedPressed: blackAlpha[30],
  colorSubtleBackgroundInvertedSelected: blackAlpha[20],
  colorTransparentBackground: "transparent",
  colorTransparentBackgroundHover: "transparent",
  colorTransparentBackgroundPressed: "transparent",
  colorTransparentBackgroundSelected: "transparent",
  colorNeutralBackgroundDisabled: grey[8],
  colorNeutralBackgroundDisabled2: grey[16],
  colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
  colorNeutralStencil1: grey[34],
  colorNeutralStencil2: grey[20],
  colorNeutralStencil1Alpha: whiteAlpha[10],
  colorNeutralStencil2Alpha: whiteAlpha[5],
  colorBackgroundOverlay: blackAlpha[50],
  colorScrollbarOverlay: whiteAlpha[60],
  colorBrandBackground: brand[70],
  colorBrandBackgroundHover: brand[80],
  colorBrandBackgroundPressed: brand[40],
  colorBrandBackgroundSelected: brand[60],
  colorCompoundBrandBackground: brand[100],
  colorCompoundBrandBackgroundHover: brand[110],
  colorCompoundBrandBackgroundPressed: brand[90],
  colorBrandBackgroundStatic: brand[80],
  colorBrandBackground2: brand[20],
  colorBrandBackground2Hover: brand[40],
  colorBrandBackground2Pressed: brand[10],
  colorBrandBackground3Static: brand[60],
  colorBrandBackground4Static: brand[40],
  colorBrandBackgroundInverted: white,
  colorBrandBackgroundInvertedHover: brand[160],
  colorBrandBackgroundInvertedPressed: brand[140],
  colorBrandBackgroundInvertedSelected: brand[150],
  colorNeutralCardBackground: grey[20],
  colorNeutralCardBackgroundHover: grey[24],
  colorNeutralCardBackgroundPressed: grey[18],
  colorNeutralCardBackgroundSelected: grey[22],
  colorNeutralCardBackgroundDisabled: grey[8],
  colorNeutralStrokeAccessible: grey[68],
  colorNeutralStrokeAccessibleHover: grey[74],
  colorNeutralStrokeAccessiblePressed: grey[70],
  colorNeutralStrokeAccessibleSelected: brand[100],
  colorNeutralStroke1: grey[40],
  colorNeutralStroke1Hover: grey[46],
  colorNeutralStroke1Pressed: grey[42],
  colorNeutralStroke1Selected: grey[44],
  colorNeutralStroke2: grey[32],
  colorNeutralStroke3: grey[24],
  colorNeutralStroke4: grey[24],
  colorNeutralStroke4Hover: grey[18],
  colorNeutralStroke4Pressed: grey[14],
  colorNeutralStroke4Selected: grey[24],
  colorNeutralStrokeSubtle: grey[4],
  colorNeutralStrokeOnBrand: grey[16],
  colorNeutralStrokeOnBrand2: white,
  colorNeutralStrokeOnBrand2Hover: white,
  colorNeutralStrokeOnBrand2Pressed: white,
  colorNeutralStrokeOnBrand2Selected: white,
  colorBrandStroke1: brand[100],
  colorBrandStroke2: brand[50],
  colorBrandStroke2Hover: brand[50],
  colorBrandStroke2Pressed: brand[30],
  colorBrandStroke2Contrast: brand[50],
  colorCompoundBrandStroke: brand[100],
  colorCompoundBrandStrokeHover: brand[110],
  colorCompoundBrandStrokePressed: brand[90],
  colorNeutralStrokeDisabled: grey[26],
  colorNeutralStrokeDisabled2: grey[24],
  colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
  colorTransparentStroke: "transparent",
  colorTransparentStrokeInteractive: "transparent",
  colorTransparentStrokeDisabled: "transparent",
  colorNeutralStrokeAlpha: whiteAlpha[10],
  colorNeutralStrokeAlpha2: whiteAlpha[20],
  colorStrokeFocus1: black,
  colorStrokeFocus2: white,
  colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
  colorNeutralShadowKey: "rgba(0,0,0,0.28)",
  colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
  colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
  colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
  colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
  colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
  colorBrandShadowKey: "rgba(0,0,0,0.25)"
});

// node_modules/@fluentui/tokens/lib/utils/createDarkTheme.js
var createDarkTheme = (brand) => {
  const colorTokens = generateColorTokens4(brand);
  return {
    ...borderRadius,
    ...fontSizes,
    ...lineHeights,
    ...fontFamilies,
    ...fontWeights,
    ...strokeWidths,
    ...horizontalSpacings,
    ...verticalSpacings,
    ...durations,
    ...curves,
    ...colorTokens,
    ...colorPaletteTokens2,
    ...colorStatusTokens2,
    ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
    ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
  };
};

// node_modules/@fluentui/tokens/lib/themes/web/darkTheme.js
var webDarkTheme = createDarkTheme(brandWeb);

// node_modules/@fluentui/tokens/lib/themeToTokensObject.js
function themeToTokensObject(theme) {
  const tokens2 = {};
  const keys = Object.keys(theme);
  for (const key of keys) {
    tokens2[key] = `var(--${String(key)})`;
  }
  return tokens2;
}

// node_modules/@fluentui/react-tabster/lib/focus/createFocusOutlineStyle.js
function getOutlinePosition({ outlineWidth, outlineOffset }, position) {
  const offsetValue = (outlineOffset === null || outlineOffset === void 0 ? void 0 : outlineOffset[position]) || outlineOffset;
  if (!outlineOffset) {
    return `calc(${outlineWidth} * -1)`;
  }
  return `calc(0px - ${outlineWidth} - ${offsetValue})`;
}
var getFocusOutlineStyles = (options) => {
  const { outlineRadius, outlineColor, outlineWidth } = options;
  return {
    ...shorthands.borderColor("transparent"),
    "@media (forced-colors: active)": {
      "::after": {
        ...shorthands.borderColor("Highlight")
      }
    },
    "::after": {
      content: '""',
      position: "absolute",
      pointerEvents: "none",
      zIndex: 1,
      border: `${outlineWidth} solid ${outlineColor}`,
      borderRadius: outlineRadius,
      top: getOutlinePosition(options, "top"),
      right: getOutlinePosition(options, "right"),
      bottom: getOutlinePosition(options, "bottom"),
      left: getOutlinePosition(options, "left")
    }
  };
};
var createFocusOutlineStyle = ({ enableOutline = false, selector = defaultOptions.selector, customizeSelector, style = defaultOptions.style } = defaultOptions) => ({
  ":focus": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ":focus-visible": {
    outlineStyle: enableOutline ? void 0 : "none"
  },
  ...createCustomFocusIndicatorStyle(getFocusOutlineStyles({
    outlineColor: tokens.colorStrokeFocus2,
    outlineRadius: tokens.borderRadiusMedium,
    // FIXME: tokens.strokeWidthThick causes some weird bugs
    outlineWidth: "2px",
    ...style
  }), {
    selector,
    customizeSelector
  })
});

// node_modules/@fluentui/react-tabster/lib/tabster-types-6.0.1-do-not-use.js
var FocusableSelector = [
  "a[href]",
  "button:not([disabled])",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "*[tabindex]",
  "*[contenteditable]"
].join(", ");

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
var React57 = __toESM(require_react());

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
var React56 = __toESM(require_react());

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderStyles.styles.js
var fluentProviderClassNames = {
  root: "fui-FluentProvider"
};
var useStyles = __styles({
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    fsow6f: ["f1o700av", "fes3tcz"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useFluentProviderStyles_unstable = (state) => {
  "use no memo";
  const renderer = useRenderer();
  const styles = useStyles({
    dir: state.dir,
    renderer
  });
  state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderThemeStyleTag.js
var useInsertionEffect2 = React56["useInsertionEffect"] ? React56["useInsertionEffect"] : useIsomorphicLayoutEffect;
var createStyleTag = (target, elementAttributes) => {
  if (!(target === null || target === void 0 ? void 0 : target.head)) {
    return void 0;
  }
  const tag = target.createElement("style");
  Object.keys(elementAttributes).forEach((attrName) => {
    tag.setAttribute(attrName, elementAttributes[attrName]);
  });
  target.head.appendChild(tag);
  return tag;
};
var insertSheet = (tag, rule) => {
  const sheet = tag.sheet;
  if (sheet) {
    if (sheet.cssRules.length > 0) {
      sheet.deleteRule(0);
    }
    sheet.insertRule(rule, 0);
  } else if (true) {
    console.error("FluentProvider: No sheet available on styleTag, styles will not be inserted into DOM.");
  }
};
var useFluentProviderThemeStyleTag = (options) => {
  "use no memo";
  const { targetDocument, theme, rendererAttributes } = options;
  const styleTag = React56.useRef(void 0);
  const styleTagId = useId2(fluentProviderClassNames.root);
  const styleElementAttributes = rendererAttributes;
  const rule = React56.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [
    theme,
    styleTagId
  ]);
  if (true) {
    React56.useMemo(() => {
      if (targetDocument) {
        var _styleElement_textContent;
        const providerElementSelector = `.${fluentProviderClassNames.root}.${styleTagId}`;
        const providerElements = targetDocument.querySelectorAll(providerElementSelector);
        const styleElementSelector = `style[id="${styleTagId}"]`;
        const styleElements = targetDocument.querySelectorAll(styleElementSelector);
        if (styleElements.length > 1) {
          console.error([
            "@fluentui/react-provider: We found multiple <style> elements with same IDs in your DOM.",
            "Please make sure that you configured your application properly.",
            "\n",
            "\n",
            "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
          ].join(" "));
          return;
        }
        const styleElement = styleElements.item(0);
        var _styleElement_textContent_length;
        const isSSR = ((_styleElement_textContent_length = styleElement === null || styleElement === void 0 ? void 0 : (_styleElement_textContent = styleElement.textContent) === null || _styleElement_textContent === void 0 ? void 0 : _styleElement_textContent.length) !== null && _styleElement_textContent_length !== void 0 ? _styleElement_textContent_length : 0) > 0;
        const elementsCount = isSSR ? 1 : 0;
        if (providerElements.length > elementsCount) {
          console.error([
            "@fluentui/react-provider: There are conflicting ids in your DOM.",
            "Please make sure that you configured your application properly.",
            "\n",
            "\n",
            "Configuration guide: https://aka.ms/fluentui-conflicting-ids"
          ].join(" "));
        }
      }
    }, []);
  }
  useHandleSSRStyleElements(targetDocument, styleTagId);
  useInsertionEffect2(() => {
    const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
    if (ssrStyleElement) {
      styleTag.current = ssrStyleElement;
    } else {
      styleTag.current = createStyleTag(targetDocument, {
        ...styleElementAttributes,
        id: styleTagId
      });
      if (styleTag.current) {
        insertSheet(styleTag.current, rule);
      }
    }
    return () => {
      var _styleTag_current;
      (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
    };
  }, [
    styleTagId,
    targetDocument,
    rule,
    styleElementAttributes
  ]);
  return {
    styleTagId,
    rule
  };
};
function useHandleSSRStyleElements(targetDocument, styleTagId) {
  React56.useState(() => {
    if (!targetDocument) {
      return;
    }
    const themeStyleElement = targetDocument.getElementById(styleTagId);
    if (themeStyleElement) {
      targetDocument.head.append(themeStyleElement);
    }
  });
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProvider.js
var DEFAULT_STYLE_HOOKS = {};
var DEFAULT_RENDERER_ATTRIBUTES = {};
var useFluentProvider_unstable = (props, ref) => {
  "use no memo";
  const parentContext = useFluent();
  const parentTheme = useTheme();
  const parentOverrides = useOverrides();
  const parentCustomStyleHooks = React57.useContext(CustomStyleHooksContext) || DEFAULT_STYLE_HOOKS;
  const {
    applyStylesToPortals = true,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    dir = parentContext.dir,
    targetDocument = parentContext.targetDocument,
    theme,
    overrides_unstable: overrides = {}
  } = props;
  const mergedTheme = shallowMerge(parentTheme, theme);
  const mergedOverrides = shallowMerge(parentOverrides, overrides);
  const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
  const renderer = useRenderer();
  var _renderer_styleElementAttributes;
  const { styleTagId, rule } = useFluentProviderThemeStyleTag({
    theme: mergedTheme,
    targetDocument,
    rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : DEFAULT_RENDERER_ATTRIBUTES
  });
  if (true) {
    React57.useEffect(() => {
      if (mergedTheme === void 0) {
        console.warn([
          '@fluentui/react-provider: FluentProvider does not have your "theme" defined.',
          "Make sure that your top-level FluentProvider has set a `theme` prop or you're setting the theme in your child FluentProvider."
        ].join(" "));
      }
    }, []);
  }
  return {
    applyStylesToPortals,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable: mergedCustomStyleHooks,
    dir,
    targetDocument,
    theme: mergedTheme,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable: mergedOverrides,
    themeClassName: styleTagId,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      dir,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, useFocusVisible({
        targetDocument
      }))
    }), {
      elementType: "div"
    }),
    serverStyleProps: {
      cssRule: rule,
      attributes: {
        ...renderer.styleElementAttributes,
        id: styleTagId
      }
    }
  };
};
function shallowMerge(a, b) {
  if (a && b) {
    return {
      ...a,
      ...b
    };
  }
  if (a) {
    return a;
  }
  return b;
}
function useTheme() {
  return React57.useContext(ThemeContext);
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/useFluentProviderContextValues.js
var React58 = __toESM(require_react());
function useFluentProviderContextValues_unstable(state) {
  const {
    applyStylesToPortals,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    dir,
    root,
    targetDocument,
    theme,
    themeClassName,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable
  } = state;
  const provider = React58.useMemo(() => ({
    dir,
    targetDocument
  }), [
    dir,
    targetDocument
  ]);
  const [tooltip] = React58.useState(() => ({}));
  const iconDirection = React58.useMemo(() => ({
    textDirection: dir
  }), [
    dir
  ]);
  return {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    customStyleHooks_unstable,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    overrides_unstable,
    provider,
    textDirection: dir,
    iconDirection,
    tooltip,
    theme,
    themeClassName: applyStylesToPortals ? root.className : themeClassName
  };
}

// node_modules/@fluentui/react-provider/lib/components/FluentProvider/FluentProvider.js
var FluentProvider = React59.forwardRef((props, ref) => {
  const state = useFluentProvider_unstable(props, ref);
  useFluentProviderStyles_unstable(state);
  const contextValues = useFluentProviderContextValues_unstable(state);
  return renderFluentProvider_unstable(state, contextValues);
});
FluentProvider.displayName = "FluentProvider";

// node_modules/@fluentui/react-accordion/lib/components/Accordion/Accordion.js
var React64 = __toESM(require_react());

// node_modules/@fluentui/react-context-selector/lib/createContext.js
var React60 = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var createProvider = (Original) => {
  const Provider2 = (props) => {
    const valueRef = React60.useRef(props.value);
    const versionRef = React60.useRef(0);
    const contextValue = React60.useRef(null);
    if (!contextValue.current) {
      contextValue.current = {
        value: valueRef,
        version: versionRef,
        listeners: []
      };
    }
    useIsomorphicLayoutEffect(() => {
      valueRef.current = props.value;
      versionRef.current += 1;
      (0, import_scheduler.unstable_runWithPriority)(import_scheduler.unstable_NormalPriority, () => {
        contextValue.current.listeners.forEach((listener) => {
          listener([
            versionRef.current,
            props.value
          ]);
        });
      });
    }, [
      props.value
    ]);
    return React60.createElement(Original, {
      value: contextValue.current
    }, props.children);
  };
  if (true) {
    Provider2.displayName = "ContextSelector.Provider";
  }
  return Provider2;
};
var createContext13 = (defaultValue) => {
  const context = React60.createContext({
    value: {
      current: defaultValue
    },
    version: {
      current: -1
    },
    listeners: []
  });
  context.Provider = createProvider(context.Provider);
  delete context.Consumer;
  return context;
};

// node_modules/@fluentui/react-context-selector/lib/useContextSelector.js
var React61 = __toESM(require_react());
var useContextSelector = (context, selector) => {
  const contextValue = React61.useContext(context);
  const { value: { current: value }, version: { current: version2 }, listeners } = contextValue;
  const selected = selector(value);
  const [state, setState] = React61.useState([
    value,
    selected
  ]);
  const dispatch = (payload) => {
    setState((prevState) => {
      if (!payload) {
        return [
          value,
          selected
        ];
      }
      if (payload[0] <= version2) {
        if (Object.is(prevState[1], selected)) {
          return prevState;
        }
        return [
          value,
          selected
        ];
      }
      try {
        if (Object.is(prevState[0], payload[1])) {
          return prevState;
        }
        const nextSelected = selector(payload[1]);
        if (Object.is(prevState[1], nextSelected)) {
          return prevState;
        }
        return [
          payload[1],
          nextSelected
        ];
      } catch (e) {
      }
      return [
        prevState[0],
        prevState[1]
      ];
    });
  };
  if (!Object.is(state[1], selected)) {
    dispatch(void 0);
  }
  const stableDispatch = useEventCallback(dispatch);
  useIsomorphicLayoutEffect(() => {
    listeners.push(stableDispatch);
    return () => {
      const index = listeners.indexOf(stableDispatch);
      listeners.splice(index, 1);
    };
  }, [
    stableDispatch,
    listeners
  ]);
  return state[1];
};

// node_modules/@fluentui/react-context-selector/lib/useHasParentContext.js
var React62 = __toESM(require_react());
function useHasParentContext(context) {
  const contextValue = React62.useContext(context);
  if (contextValue.version) {
    return contextValue.version.current !== -1;
  }
  return false;
}

// node_modules/@fluentui/react-accordion/lib/contexts/accordion.js
var AccordionContext = createContext13(void 0);
var accordionContextDefaultValue = {
  openItems: [],
  collapsible: false,
  multiple: false,
  navigation: void 0,
  requestToggle() {
  }
};
var { Provider: AccordionProvider } = AccordionContext;
var useAccordionContext_unstable = (selector) => useContextSelector(AccordionContext, (ctx = accordionContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-accordion/lib/components/Accordion/renderAccordion.js
var renderAccordion_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(AccordionProvider, {
      value: contextValues.accordion,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordion.js
var React63 = __toESM(require_react());
var useAccordion_unstable = (props, ref) => {
  const {
    openItems: controlledOpenItems,
    defaultOpenItems,
    multiple = false,
    collapsible = false,
    onToggle,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    navigation,
    ...rest
  } = props;
  const [openItems, setOpenItems] = useControllableState({
    state: React63.useMemo(() => normalizeValues(controlledOpenItems), [
      controlledOpenItems
    ]),
    defaultState: defaultOpenItems && (() => initializeUncontrolledOpenItems({
      defaultOpenItems,
      multiple
    })),
    initialState: []
  });
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: navigation === "circular",
    tabbable: true
  });
  const requestToggle = useEventCallback((data) => {
    const nextOpenItems = updateOpenItems(data.value, openItems, multiple, collapsible);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle(data.event, {
      value: data.value,
      openItems: nextOpenItems
    });
    setOpenItems(nextOpenItems);
  });
  return {
    collapsible,
    multiple,
    navigation,
    openItems,
    requestToggle,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...rest,
      ...navigation ? arrowNavigationProps : void 0,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref
    }), {
      elementType: "div"
    })
  };
};
function initializeUncontrolledOpenItems({ defaultOpenItems, multiple }) {
  if (defaultOpenItems !== void 0) {
    if (Array.isArray(defaultOpenItems)) {
      return multiple ? defaultOpenItems : [
        defaultOpenItems[0]
      ];
    }
    return [
      defaultOpenItems
    ];
  }
  return [];
}
function updateOpenItems(value, previousOpenItems, multiple, collapsible) {
  if (multiple) {
    if (previousOpenItems.includes(value)) {
      if (previousOpenItems.length > 1 || collapsible) {
        return previousOpenItems.filter((i) => i !== value);
      }
    } else {
      return [
        ...previousOpenItems,
        value
      ].sort();
    }
  } else {
    return previousOpenItems[0] === value && collapsible ? [] : [
      value
    ];
  }
  return previousOpenItems;
}
function normalizeValues(index) {
  if (index === void 0) {
    return void 0;
  }
  return Array.isArray(index) ? index : [
    index
  ];
}

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionContextValues.js
function useAccordionContextValues_unstable(state) {
  const { navigation, openItems, requestToggle, multiple, collapsible } = state;
  const accordion = {
    navigation,
    openItems,
    requestToggle,
    collapsible,
    multiple
  };
  return {
    accordion
  };
}

// node_modules/@fluentui/react-accordion/lib/components/Accordion/useAccordionStyles.styles.js
var accordionClassNames = {
  root: "fui-Accordion"
};
var useAccordionStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(accordionClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/Accordion/Accordion.js
var Accordion = React64.forwardRef((props, ref) => {
  const state = useAccordion_unstable(props, ref);
  const contextValues = useAccordionContextValues_unstable(state);
  useAccordionStyles_unstable(state);
  useCustomStyleHook("useAccordionStyles_unstable")(state);
  return renderAccordion_unstable(state, contextValues);
});
Accordion.displayName = "Accordion";

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/AccordionItem.js
var React68 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItem.js
var React65 = __toESM(require_react());
var useAccordionItem_unstable = (props, ref) => {
  const { value, disabled = false } = props;
  const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
  const open = useAccordionContext_unstable((ctx) => ctx.openItems.includes(value));
  const onAccordionHeaderClick = useEventCallback((event) => requestToggle({
    event,
    value
  }));
  return {
    open,
    value,
    disabled,
    onHeaderClick: onAccordionHeaderClick,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemContextValues.js
var React66 = __toESM(require_react());
function useAccordionItemContextValues_unstable(state) {
  const { disabled, open, value, onHeaderClick } = state;
  const accordionItem = React66.useMemo(() => ({
    disabled,
    open,
    value,
    onHeaderClick
  }), [
    disabled,
    open,
    value,
    onHeaderClick
  ]);
  return {
    accordionItem
  };
}

// node_modules/@fluentui/react-accordion/lib/contexts/accordionItem.js
var React67 = __toESM(require_react());
var AccordionItemContext = React67.createContext(void 0);
var accordionItemContextDefaultValue = {
  open: false,
  disabled: false,
  value: void 0,
  onHeaderClick() {
  }
};
var { Provider: AccordionItemProvider } = AccordionItemContext;
var useAccordionItemContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React67.useContext(AccordionItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : accordionItemContextDefaultValue;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/renderAccordionItem.js
var renderAccordionItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(AccordionItemProvider, {
      value: contextValues.accordionItem,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/useAccordionItemStyles.styles.js
var accordionItemClassNames = {
  root: "fui-AccordionItem"
};
var useAccordionItemStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(accordionItemClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionItem/AccordionItem.js
var AccordionItem = React68.forwardRef((props, ref) => {
  const state = useAccordionItem_unstable(props, ref);
  const contextValues = useAccordionItemContextValues_unstable(state);
  useAccordionItemStyles_unstable(state);
  useCustomStyleHook("useAccordionItemStyles_unstable")(state);
  return renderAccordionItem_unstable(state, contextValues);
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/AccordionHeader.js
var React96 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeader.js
var React93 = __toESM(require_react());

// node_modules/@fluentui/keyboard-keys/lib/keys.js
var Shift = "Shift";
var Enter = "Enter";
var Space = " ";
var Tab = "Tab";
var ArrowDown = "ArrowDown";
var ArrowLeft = "ArrowLeft";
var ArrowRight = "ArrowRight";
var ArrowUp = "ArrowUp";
var End = "End";
var Home = "Home";
var PageDown = "PageDown";
var PageUp = "PageUp";
var Backspace = "Backspace";
var Delete = "Delete";
var Escape = "Escape";

// node_modules/@fluentui/react-aria/lib/button/useARIAButtonProps.js
var React69 = __toESM(require_react());
function useARIAButtonProps(type, props) {
  const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
  const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
  const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
  const handleClick = useEventCallback((ev) => {
    if (isDisabled) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      onClick === null || onClick === void 0 ? void 0 : onClick(ev);
    }
  });
  const handleKeyDown = useEventCallback((ev) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter || key === Space)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space) {
      ev.preventDefault();
      return;
    } else if (key === Enter) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  const handleKeyUp = useEventCallback((ev) => {
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
    if (ev.isDefaultPrevented()) {
      return;
    }
    const key = ev.key;
    if (isDisabled && (key === Enter || key === Space)) {
      ev.preventDefault();
      ev.stopPropagation();
      return;
    }
    if (key === Space) {
      ev.preventDefault();
      ev.currentTarget.click();
    }
  });
  if (type === "button" || type === void 0) {
    return {
      ...rest,
      disabled: disabled && !disabledFocusable,
      "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
      // onclick should still use internal handler to ensure prevention if disabled
      // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
      onClick: disabledFocusable ? void 0 : handleClick,
      onKeyUp: disabledFocusable ? void 0 : onKeyUp,
      onKeyDown: disabledFocusable ? void 0 : onKeyDown
    };
  } else {
    const isLink = !!rest.href;
    let roleOverride = isLink ? void 0 : "button";
    if (!roleOverride && isDisabled) {
      roleOverride = "link";
    }
    const resultProps = {
      role: roleOverride,
      tabIndex: disabledFocusable || !isLink && !disabled ? 0 : void 0,
      ...rest,
      // If it's not a <button> than listeners are required even with disabledFocusable
      // Since you cannot assure the default behavior of the element
      // E.g: <a> will redirect on click
      onClick: handleClick,
      onKeyUp: handleKeyUp,
      onKeyDown: handleKeyDown,
      "aria-disabled": isDisabled
    };
    if (type === "a" && isDisabled) {
      resultProps.href = void 0;
    }
    return resultProps;
  }
}

// node_modules/@fluentui/react-aria/lib/activedescendant/ActiveDescendantContext.js
var React70 = __toESM(require_react());
var noop2 = () => void 0;
var activeDescendantContextDefaultValue = {
  controller: {
    active: noop2,
    blur: noop2,
    find: noop2,
    first: noop2,
    focus: noop2,
    focusLastActive: noop2,
    scrollActiveIntoView: noop2,
    last: noop2,
    next: noop2,
    prev: noop2,
    showAttributes: noop2,
    hideAttributes: noop2,
    showFocusVisibleAttributes: noop2,
    hideFocusVisibleAttributes: noop2
  }
};
var ActiveDescendantContext = React70.createContext(void 0);
var ActiveDescendantContextProvider = ActiveDescendantContext.Provider;
var useActiveDescendantContext = () => {
  var _React_useContext;
  return (_React_useContext = React70.useContext(ActiveDescendantContext)) !== null && _React_useContext !== void 0 ? _React_useContext : activeDescendantContextDefaultValue;
};
var useHasParentActiveDescendantContext = () => !!React70.useContext(ActiveDescendantContext);

// node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
var React72 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/activedescendant/useOptionWalker.js
var React71 = __toESM(require_react());
function useOptionWalker(options) {
  const { matchOption } = options;
  const { targetDocument } = useFluent();
  const treeWalkerRef = React71.useRef(null);
  const listboxRef = React71.useRef(null);
  const optionFilter = React71.useCallback((node) => {
    if (isHTMLElement(node) && matchOption(node)) {
      return NodeFilter.FILTER_ACCEPT;
    }
    return NodeFilter.FILTER_SKIP;
  }, [
    matchOption
  ]);
  const setListbox = React71.useCallback((el) => {
    if (el && targetDocument) {
      listboxRef.current = el;
      treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, optionFilter);
    } else {
      listboxRef.current = null;
      treeWalkerRef.current = null;
    }
  }, [
    targetDocument,
    optionFilter
  ]);
  const optionWalker = React71.useMemo(() => ({
    first: () => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      treeWalkerRef.current.currentNode = listboxRef.current;
      return treeWalkerRef.current.firstChild();
    },
    last: () => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      treeWalkerRef.current.currentNode = listboxRef.current;
      return treeWalkerRef.current.lastChild();
    },
    next: () => {
      if (!treeWalkerRef.current) {
        return null;
      }
      return treeWalkerRef.current.nextNode();
    },
    prev: () => {
      if (!treeWalkerRef.current) {
        return null;
      }
      return treeWalkerRef.current.previousNode();
    },
    find: (predicate, startFrom) => {
      if (!treeWalkerRef.current || !listboxRef.current) {
        return null;
      }
      const start = startFrom ? targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(startFrom) : null;
      treeWalkerRef.current.currentNode = start !== null && start !== void 0 ? start : listboxRef.current;
      let cur = treeWalkerRef.current.currentNode;
      while (cur && !predicate(cur.id)) {
        cur = treeWalkerRef.current.nextNode();
      }
      return cur;
    },
    setCurrent: (el) => {
      if (!treeWalkerRef.current) {
        return;
      }
      treeWalkerRef.current.currentNode = el;
    }
  }), [
    targetDocument
  ]);
  return {
    optionWalker,
    listboxCallbackRef: setListbox
  };
}

// node_modules/@fluentui/react-aria/lib/activedescendant/constants.js
var ACTIVEDESCENDANT_ATTRIBUTE = "data-activedescendant";
var ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE = "data-activedescendant-focusvisible";

// node_modules/@fluentui/react-aria/lib/activedescendant/scrollIntoView.js
var scrollIntoView2 = (target) => {
  if (!target) {
    return;
  }
  const scrollParent = findScrollableParent(target.parentElement);
  if (!scrollParent) {
    return;
  }
  const { offsetHeight } = target;
  const offsetTop = getTotalOffsetTop(target, scrollParent);
  const { scrollMarginTop, scrollMarginBottom } = getScrollMargins(target);
  const { offsetHeight: parentOffsetHeight, scrollTop } = scrollParent;
  const isAbove = offsetTop - scrollMarginTop < scrollTop;
  const isBelow = offsetTop + offsetHeight + scrollMarginBottom > scrollTop + parentOffsetHeight;
  const buffer = 2;
  if (isAbove) {
    scrollParent.scrollTo(0, offsetTop - scrollMarginTop - buffer);
  } else if (isBelow) {
    scrollParent.scrollTo(0, offsetTop + offsetHeight + scrollMarginBottom - parentOffsetHeight + buffer);
  }
};
var findScrollableParent = (element) => {
  if (!element) {
    return null;
  }
  if (element.scrollHeight > element.offsetHeight) {
    return element;
  }
  return findScrollableParent(element.parentElement);
};
var getTotalOffsetTop = (element, scrollParent) => {
  if (!element || element === scrollParent) {
    return 0;
  }
  if (element.contains(scrollParent)) {
    return scrollParent.offsetTop * -1;
  }
  return element.offsetTop + getTotalOffsetTop(element.offsetParent, scrollParent);
};
var getScrollMargins = (element) => {
  var _element_ownerDocument;
  const win = (_element_ownerDocument = element.ownerDocument) === null || _element_ownerDocument === void 0 ? void 0 : _element_ownerDocument.defaultView;
  if (!win) {
    return {
      scrollMarginTop: 0,
      scrollMarginBottom: 0
    };
  }
  const computedStyles = win.getComputedStyle(element);
  var _getIntValueOfComputedStyle;
  const scrollMarginTop = (_getIntValueOfComputedStyle = getIntValueOfComputedStyle(computedStyles.scrollMarginTop)) !== null && _getIntValueOfComputedStyle !== void 0 ? _getIntValueOfComputedStyle : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockStart);
  var _getIntValueOfComputedStyle1;
  const scrollMarginBottom = (_getIntValueOfComputedStyle1 = getIntValueOfComputedStyle(computedStyles.scrollMarginBottom)) !== null && _getIntValueOfComputedStyle1 !== void 0 ? _getIntValueOfComputedStyle1 : getIntValueOfComputedStyle(computedStyles.scrollMarginBlockEnd);
  return {
    scrollMarginTop,
    scrollMarginBottom
  };
};
var getIntValueOfComputedStyle = (computedStyle) => {
  return computedStyle ? parseInt(computedStyle, 10) : 0;
};

// node_modules/@fluentui/react-aria/lib/activedescendant/useActiveDescendant.js
var createActiveDescendantChangeEvent = (detail) => new CustomEvent("activedescendantchange", {
  bubbles: true,
  cancelable: false,
  composed: true,
  detail
});
function useActiveDescendant(options) {
  const { imperativeRef, matchOption: matchOptionUnstable } = options;
  const focusVisibleRef = React72.useRef(false);
  const shouldShowFocusVisibleAttrRef = React72.useRef(true);
  const activeIdRef = React72.useRef(null);
  const lastActiveIdRef = React72.useRef(null);
  const activeParentRef = React72.useRef(null);
  const attributeVisibilityRef = React72.useRef(true);
  const removeAttribute = React72.useCallback(() => {
    var _activeParentRef_current;
    (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.removeAttribute("aria-activedescendant");
  }, []);
  const setAttribute = React72.useCallback((id) => {
    if (id) {
      activeIdRef.current = id;
    }
    if (attributeVisibilityRef.current && activeIdRef.current) {
      var _activeParentRef_current;
      (_activeParentRef_current = activeParentRef.current) === null || _activeParentRef_current === void 0 ? void 0 : _activeParentRef_current.setAttribute("aria-activedescendant", activeIdRef.current);
    }
  }, []);
  useOnKeyboardNavigationChange((isNavigatingWithKeyboard) => {
    focusVisibleRef.current = isNavigatingWithKeyboard;
    const active = getActiveDescendant();
    if (!active) {
      return;
    }
    if (isNavigatingWithKeyboard && shouldShowFocusVisibleAttrRef.current) {
      active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    } else {
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
  });
  const matchOption = useEventCallback(matchOptionUnstable);
  const listboxRef = React72.useRef(null);
  const { optionWalker, listboxCallbackRef } = useOptionWalker({
    matchOption
  });
  const getActiveDescendant = React72.useCallback(() => {
    var _listboxRef_current;
    return (_listboxRef_current = listboxRef.current) === null || _listboxRef_current === void 0 ? void 0 : _listboxRef_current.querySelector(`#${activeIdRef.current}`);
  }, [
    listboxRef
  ]);
  const setShouldShowFocusVisibleAttribute = React72.useCallback((shouldShow) => {
    shouldShowFocusVisibleAttrRef.current = shouldShow;
    const active = getActiveDescendant();
    if (!active) {
      return;
    }
    if (shouldShow && focusVisibleRef.current) {
      active.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    } else {
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
  }, [
    getActiveDescendant
  ]);
  const blurActiveDescendant = React72.useCallback(() => {
    const active = getActiveDescendant();
    if (active) {
      active.removeAttribute(ACTIVEDESCENDANT_ATTRIBUTE);
      active.removeAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE);
    }
    removeAttribute();
    lastActiveIdRef.current = activeIdRef.current;
    activeIdRef.current = null;
    var _active_id;
    return (_active_id = active === null || active === void 0 ? void 0 : active.id) !== null && _active_id !== void 0 ? _active_id : null;
  }, [
    getActiveDescendant,
    removeAttribute
  ]);
  const focusActiveDescendant = React72.useCallback((nextActive) => {
    if (!nextActive) {
      return;
    }
    const previousActiveId = blurActiveDescendant();
    scrollIntoView2(nextActive);
    setAttribute(nextActive.id);
    nextActive.setAttribute(ACTIVEDESCENDANT_ATTRIBUTE, "");
    if (focusVisibleRef.current && shouldShowFocusVisibleAttrRef.current) {
      nextActive.setAttribute(ACTIVEDESCENDANT_FOCUSVISIBLE_ATTRIBUTE, "");
    }
    const event = createActiveDescendantChangeEvent({
      id: nextActive.id,
      previousId: previousActiveId
    });
    nextActive.dispatchEvent(event);
  }, [
    blurActiveDescendant,
    setAttribute
  ]);
  const controller = React72.useMemo(() => ({
    first: ({ passive } = {}) => {
      const first = optionWalker.first();
      if (!passive) {
        focusActiveDescendant(first);
      }
      return first === null || first === void 0 ? void 0 : first.id;
    },
    last: ({ passive } = {}) => {
      const last = optionWalker.last();
      if (!passive) {
        focusActiveDescendant(last);
      }
      return last === null || last === void 0 ? void 0 : last.id;
    },
    next: ({ passive } = {}) => {
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      optionWalker.setCurrent(active);
      const next = optionWalker.next();
      if (!passive) {
        focusActiveDescendant(next);
      }
      return next === null || next === void 0 ? void 0 : next.id;
    },
    prev: ({ passive } = {}) => {
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      optionWalker.setCurrent(active);
      const next = optionWalker.prev();
      if (!passive) {
        focusActiveDescendant(next);
      }
      return next === null || next === void 0 ? void 0 : next.id;
    },
    blur: () => {
      blurActiveDescendant();
    },
    active: () => {
      var _getActiveDescendant;
      return (_getActiveDescendant = getActiveDescendant()) === null || _getActiveDescendant === void 0 ? void 0 : _getActiveDescendant.id;
    },
    focus: (id) => {
      if (!listboxRef.current) {
        return;
      }
      const target = listboxRef.current.querySelector(`#${id}`);
      if (target) {
        focusActiveDescendant(target);
      }
    },
    focusLastActive: () => {
      if (!listboxRef.current || !lastActiveIdRef.current) {
        return;
      }
      const target = listboxRef.current.querySelector(`#${lastActiveIdRef.current}`);
      if (target) {
        focusActiveDescendant(target);
        return true;
      }
    },
    find(predicate, { passive, startFrom } = {}) {
      const target = optionWalker.find(predicate, startFrom);
      if (!passive) {
        focusActiveDescendant(target);
      }
      return target === null || target === void 0 ? void 0 : target.id;
    },
    scrollActiveIntoView: () => {
      if (!listboxRef.current) {
        return;
      }
      const active = getActiveDescendant();
      if (!active) {
        return;
      }
      scrollIntoView2(active);
    },
    showAttributes() {
      attributeVisibilityRef.current = true;
      setAttribute();
    },
    hideAttributes() {
      attributeVisibilityRef.current = false;
      removeAttribute();
    },
    showFocusVisibleAttributes() {
      setShouldShowFocusVisibleAttribute(true);
    },
    hideFocusVisibleAttributes() {
      setShouldShowFocusVisibleAttribute(false);
    }
  }), [
    optionWalker,
    listboxRef,
    setAttribute,
    removeAttribute,
    focusActiveDescendant,
    blurActiveDescendant,
    getActiveDescendant,
    setShouldShowFocusVisibleAttribute
  ]);
  React72.useImperativeHandle(imperativeRef, () => controller);
  return {
    listboxRef: useMergedRefs(listboxRef, listboxCallbackRef),
    activeParentRef,
    controller
  };
}

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/AriaLiveAnnouncer.js
var React78 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/renderAriaLiveAnnouncer.js
var React73 = __toESM(require_react());
var renderAriaLiveAnnouncer_unstable = (state, contextValues) => {
  return React73.createElement(AnnounceProvider, {
    value: contextValues.announce
  }, state.children);
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncer.js
var React76 = __toESM(require_react());

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useDomAnnounce.js
var React74 = __toESM(require_react());
var MESSAGE_DURATION = 500;
var VISUALLY_HIDDEN_STYLES = {
  clip: "rect(0px, 0px, 0px, 0px)",
  height: "1px",
  margin: "-1px",
  width: "1px",
  position: "absolute",
  overflow: "hidden",
  textWrap: "nowrap"
};
var useDomAnnounce_unstable = () => {
  const { targetDocument } = useFluent();
  const timeoutRef = React74.useRef(void 0);
  const [setAnnounceTimeout, clearAnnounceTimeout] = useTimeout();
  const tabsterNeverHiddenAttributes = useDangerousNeverHidden_unstable();
  const elementRef = React74.useRef(null);
  const order = React74.useRef(0);
  const batchMessages = React74.useRef([]);
  const [messageQueue] = React74.useState(() => createPriorityQueue((a, b) => {
    if (a.priority !== b.priority) {
      return b.priority - a.priority;
    }
    return a.createdAt - b.createdAt;
  }));
  const queueMessage = React74.useCallback(() => {
    if (timeoutRef.current || !elementRef.current) {
      return;
    }
    const runCycle = () => {
      if (!elementRef.current) {
        return;
      }
      if (targetDocument && messageQueue.peek()) {
        const wrappingEl = targetDocument.createElement("span");
        wrappingEl.innerText = messageQueue.all().filter((msg) => msg.message.trim().length > 0).reduce((prevText, currMsg) => prevText + currMsg.message + ". ", "");
        elementRef.current.innerText = "";
        elementRef.current.appendChild(wrappingEl);
        messageQueue.clear();
        batchMessages.current = [];
        timeoutRef.current = setAnnounceTimeout(() => {
          runCycle();
        }, MESSAGE_DURATION);
      } else {
        elementRef.current.textContent = "";
        clearAnnounceTimeout();
        timeoutRef.current = void 0;
      }
    };
    timeoutRef.current = setAnnounceTimeout(() => {
      runCycle();
    }, 0);
  }, [
    clearAnnounceTimeout,
    messageQueue,
    setAnnounceTimeout,
    targetDocument
  ]);
  const announce = React74.useCallback((message, options = {}) => {
    const { alert = false, priority = 0, batchId } = options;
    if (alert) {
    }
    const liveMessage = {
      message,
      createdAt: order.current++,
      priority,
      batchId
    };
    if (batchId) {
      const batchMessage = batchMessages.current.find((msg) => msg.batchId === batchId);
      if (batchMessage) {
        messageQueue.remove(batchMessage.message);
        batchMessage.message = liveMessage;
      } else {
        batchMessages.current = [
          ...batchMessages.current,
          {
            batchId,
            message: liveMessage
          }
        ];
      }
    }
    messageQueue.enqueue(liveMessage);
    queueMessage();
  }, [
    messageQueue,
    queueMessage
  ]);
  React74.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    const element = targetDocument.createElement("div");
    element.setAttribute("aria-live", "assertive");
    Object.entries(tabsterNeverHiddenAttributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });
    Object.assign(element.style, VISUALLY_HIDDEN_STYLES);
    targetDocument.body.append(element);
    elementRef.current = element;
    return () => {
      element.remove();
      elementRef.current = null;
      clearAnnounceTimeout();
      timeoutRef.current = void 0;
    };
  }, [
    clearAnnounceTimeout,
    tabsterNeverHiddenAttributes,
    targetDocument
  ]);
  return announce;
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaNotifyAnnounce.js
var React75 = __toESM(require_react());
var useAriaNotifyAnnounce_unstable = () => {
  const { targetDocument } = useFluent();
  const announce = React75.useCallback((message, options = {}) => {
    if (!targetDocument) {
      return;
    }
    const { alert = false, polite } = options;
    const defaultPriority = polite ? 0 : alert ? 2 : 1;
    var _options_priority;
    const priority = (_options_priority = options.priority) !== null && _options_priority !== void 0 ? _options_priority : defaultPriority;
    const ariaNotifyOptions = {
      priority: priority > 1 ? "high" : "normal"
    };
    targetDocument.ariaNotify(message, ariaNotifyOptions);
  }, [
    targetDocument
  ]);
  return announce;
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncer.js
var useAriaLiveAnnouncer_unstable = (props) => {
  const { targetDocument } = useFluent();
  const domAnnounce = useDomAnnounce_unstable();
  const ariaNotifyAnnounce = useAriaNotifyAnnounce_unstable();
  const announce = React76.useMemo(() => {
    const supportsAriaNotify = typeof (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.ariaNotify) === "function";
    return supportsAriaNotify ? ariaNotifyAnnounce : domAnnounce;
  }, [
    targetDocument,
    ariaNotifyAnnounce,
    domAnnounce
  ]);
  return {
    announce,
    children: props.children
  };
};

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/useAriaLiveAnnouncerContextValues.js
var React77 = __toESM(require_react());
function useAriaLiveAnnouncerContextValues_unstable(state) {
  const { announce } = state;
  return React77.useMemo(() => ({
    announce: {
      announce
    }
  }), [
    announce
  ]);
}

// node_modules/@fluentui/react-aria/lib/AriaLiveAnnouncer/AriaLiveAnnouncer.js
var AriaLiveAnnouncer = (props) => {
  const state = useAriaLiveAnnouncer_unstable(props);
  const contextValues = useAriaLiveAnnouncerContextValues_unstable(state);
  return renderAriaLiveAnnouncer_unstable(state, contextValues);
};
AriaLiveAnnouncer.displayName = "AriaLiveAnnouncer";

// node_modules/@fluentui/react-aria/lib/useTypingAnnounce/useTypingAnnounce.js
var React79 = __toESM(require_react());
var valueMutationOptions = {
  attributes: true,
  subtree: true,
  characterData: true,
  attributeFilter: [
    "value"
  ]
};
function useTypingAnnounce() {
  const { targetDocument } = useFluent();
  const { announce } = useAnnounce();
  const inputRef = React79.useRef(null);
  const observer = React79.useRef(void 0);
  const [setTypingTimeout, clearTypingTimeout] = useTimeout();
  const messageQueue = React79.useRef([]);
  const callback = React79.useCallback((mutationList, mutationObserver) => {
    setTypingTimeout(() => {
      messageQueue.current.forEach(({ message, options }) => {
        announce(message, options);
      });
      messageQueue.current.length = 0;
      mutationObserver.disconnect();
    }, 500);
  }, [
    announce,
    setTypingTimeout
  ]);
  const typingAnnounce = React79.useCallback((message, options = {}) => {
    messageQueue.current.push({
      message,
      options
    });
    if (inputRef.current && observer.current) {
      observer.current.observe(inputRef.current, valueMutationOptions);
    }
    setTypingTimeout(() => {
      observer.current && callback([], observer.current);
    }, 500);
  }, [
    callback,
    inputRef,
    setTypingTimeout
  ]);
  React79.useEffect(() => {
    const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (!win) {
      return;
    }
    if (!observer.current) {
      observer.current = new win.MutationObserver(callback);
    }
    return () => {
      if (observer.current) {
        observer.current.disconnect();
        clearTypingTimeout();
      }
    };
  }, [
    callback,
    clearTypingTimeout,
    targetDocument
  ]);
  return {
    typingAnnounce,
    inputRef
  };
}

// node_modules/@fluentui/react-motion/lib/motions/motionTokens.js
var durations2 = {
  durationUltraFast: 50,
  durationFaster: 100,
  durationFast: 150,
  durationNormal: 200,
  durationGentle: 250,
  durationSlow: 300,
  durationSlower: 400,
  durationUltraSlow: 500
};
var curves2 = {
  curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
  curveAccelerateMid: "cubic-bezier(1,0,1,1)",
  curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
  curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
  curveDecelerateMid: "cubic-bezier(0,0,0,1)",
  curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
  curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
  curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
  curveLinear: "cubic-bezier(0,0,1,1)"
};
var motionTokens = {
  ...durations2,
  ...curves2
};

// node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
var React85 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
var React80 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/utils/isAnimationRunning.js
function isAnimationRunning(animation) {
  if (animation.playState === "running") {
    var _animation_effect;
    if (animation.overallProgress !== void 0) {
      var _animation_overallProgress;
      const overallProgress = (_animation_overallProgress = animation.overallProgress) !== null && _animation_overallProgress !== void 0 ? _animation_overallProgress : 0;
      return overallProgress > 0 && overallProgress < 1;
    }
    var _animation_currentTime;
    const currentTime = Number((_animation_currentTime = animation.currentTime) !== null && _animation_currentTime !== void 0 ? _animation_currentTime : 0);
    var _animation_effect_getTiming_duration;
    const totalTime = Number((_animation_effect_getTiming_duration = (_animation_effect = animation.effect) === null || _animation_effect === void 0 ? void 0 : _animation_effect.getTiming().duration) !== null && _animation_effect_getTiming_duration !== void 0 ? _animation_effect_getTiming_duration : 0);
    return currentTime > 0 && currentTime < totalTime;
  }
  return false;
}

// node_modules/@fluentui/react-motion/lib/hooks/useAnimateAtoms.js
var DEFAULT_ANIMATION_OPTIONS = {
  fill: "forwards"
};
var DEFAULT_REDUCED_MOTION_ATOM = {
  duration: 1
};
function createHandle(animations) {
  return {
    set playbackRate(rate) {
      animations.forEach((animation) => {
        animation.playbackRate = rate;
      });
    },
    setMotionEndCallbacks(onfinish, oncancel) {
      const promises = animations.map((animation) => {
        return new Promise((resolve, reject) => {
          animation.onfinish = () => resolve();
          animation.oncancel = () => reject();
        });
      });
      Promise.all(promises).then(() => {
        onfinish();
      }).catch(() => {
        oncancel();
      });
    },
    isRunning() {
      return animations.some((animation) => isAnimationRunning(animation));
    },
    dispose: () => {
      animations.length = 0;
    },
    cancel: () => {
      animations.forEach((animation) => {
        animation.cancel();
      });
    },
    pause: () => {
      animations.forEach((animation) => {
        animation.pause();
      });
    },
    play: () => {
      animations.forEach((animation) => {
        animation.play();
      });
    },
    finish: () => {
      animations.forEach((animation) => {
        animation.finish();
      });
    },
    reverse: () => {
      animations.forEach((animation) => {
        animation.reverse();
      });
    }
  };
}
function useAnimateAtomsInSupportedEnvironment() {
  var _window_Animation;
  const SUPPORTS_PERSIST = typeof window !== "undefined" && typeof ((_window_Animation = window.Animation) === null || _window_Animation === void 0 ? void 0 : _window_Animation.prototype.persist) === "function";
  return React80.useCallback((element, value, options) => {
    const atoms = Array.isArray(value) ? value : [
      value
    ];
    const { isReducedMotion } = options;
    const animations = atoms.map((motion) => {
      const { keyframes: motionKeyframes, reducedMotion = DEFAULT_REDUCED_MOTION_ATOM, ...params } = motion;
      const { keyframes: reducedMotionKeyframes = motionKeyframes, ...reducedMotionParams } = reducedMotion;
      const animationKeyframes = isReducedMotion ? reducedMotionKeyframes : motionKeyframes;
      const animationParams = {
        ...DEFAULT_ANIMATION_OPTIONS,
        ...params,
        // Use reduced motion overrides (e.g. duration, easing) when reduced motion is enabled
        ...isReducedMotion && reducedMotionParams
      };
      try {
        const animation = element.animate(animationKeyframes, animationParams);
        if (SUPPORTS_PERSIST) {
          animation === null || animation === void 0 ? void 0 : animation.persist();
        } else {
          const resultKeyframe = animationKeyframes[animationKeyframes.length - 1];
          var _element_style;
          Object.assign((_element_style = element.style) !== null && _element_style !== void 0 ? _element_style : {}, resultKeyframe);
        }
        return animation;
      } catch (e) {
        return null;
      }
    }).filter((animation) => !!animation);
    return createHandle(animations);
  }, [
    SUPPORTS_PERSIST
  ]);
}
function useAnimateAtoms() {
  "use no memo";
  if (false) {
    return useAnimateAtomsInTestEnvironment();
  }
  return useAnimateAtomsInSupportedEnvironment();
}

// node_modules/@fluentui/react-motion/lib/hooks/useMotionImperativeRef.js
var React81 = __toESM(require_react());
function useMotionImperativeRef(imperativeRef) {
  const animationRef = React81.useRef(void 0);
  React81.useImperativeHandle(imperativeRef, () => ({
    setPlayState: (state) => {
      if (state === "running") {
        var _animationRef_current;
        (_animationRef_current = animationRef.current) === null || _animationRef_current === void 0 ? void 0 : _animationRef_current.play();
      }
      if (state === "paused") {
        var _animationRef_current1;
        (_animationRef_current1 = animationRef.current) === null || _animationRef_current1 === void 0 ? void 0 : _animationRef_current1.pause();
      }
    },
    setPlaybackRate: (rate) => {
      if (animationRef.current) {
        animationRef.current.playbackRate = rate;
      }
    }
  }));
  return animationRef;
}

// node_modules/@fluentui/react-motion/lib/hooks/useIsReducedMotion.js
var React82 = __toESM(require_react());
var REDUCED_MEDIA_QUERY = "screen and (prefers-reduced-motion: reduce)";
function useIsReducedMotion() {
  const { targetDocument } = useFluent();
  var _targetDocument_defaultView;
  const targetWindow = (_targetDocument_defaultView = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) !== null && _targetDocument_defaultView !== void 0 ? _targetDocument_defaultView : null;
  const queryValue = React82.useRef(false);
  const isEnabled = React82.useCallback(() => queryValue.current, []);
  useIsomorphicLayoutEffect(() => {
    if (targetWindow === null || typeof targetWindow.matchMedia !== "function") {
      return;
    }
    const queryMatch = targetWindow.matchMedia(REDUCED_MEDIA_QUERY);
    if (queryMatch.matches) {
      queryValue.current = true;
    }
    const matchListener = (e) => {
      queryValue.current = e.matches;
    };
    queryMatch.addEventListener("change", matchListener);
    return () => {
      queryMatch.removeEventListener("change", matchListener);
    };
  }, [
    targetWindow
  ]);
  return isEnabled;
}

// node_modules/@fluentui/react-motion/lib/utils/useChildElement.js
var React83 = __toESM(require_react());
var CHILD_ERROR_MESSAGE = [
  "@fluentui/react-motion: Invalid child element.",
  "\n",
  "Motion factories require a single child element to be passed. ",
  "That element element should support ref forwarding i.e. it should be either an intrinsic element (e.g. div) or a component that uses React.forwardRef()."
].join("");
function useChildElement(children, mounted = true) {
  const childRef = React83.useRef(null);
  React83.useEffect(() => {
    if (true) {
      if (mounted && !childRef.current) {
        console.error(CHILD_ERROR_MESSAGE);
      }
    }
  }, [
    mounted
  ]);
  try {
    const child = React83.Children.only(children);
    if (React83.isValidElement(child)) {
      return [
        React83.cloneElement(child, {
          ref: useMergedRefs(childRef, getReactElementRef(child))
        }),
        childRef
      ];
    }
  } catch {
  }
  throw new Error(CHILD_ERROR_MESSAGE);
}

// node_modules/@fluentui/react-motion/lib/contexts/MotionBehaviourContext.js
var React84 = __toESM(require_react());
var MotionBehaviourContext = React84.createContext(void 0);
var MotionBehaviourProvider = MotionBehaviourContext.Provider;
var useMotionBehaviourContext = () => {
  var _React_useContext;
  return (_React_useContext = React84.useContext(MotionBehaviourContext)) !== null && _React_useContext !== void 0 ? _React_useContext : "default";
};

// node_modules/@fluentui/react-motion/lib/factories/createMotionComponent.js
var MOTION_DEFINITION = Symbol("MOTION_DEFINITION");
function createMotionComponent(value) {
  const Atom = (props) => {
    "use no memo";
    const { children, imperativeRef, onMotionFinish: onMotionFinishProp, onMotionStart: onMotionStartProp, onMotionCancel: onMotionCancelProp, ..._rest } = props;
    const params = _rest;
    const [child, childRef] = useChildElement(children);
    const handleRef = useMotionImperativeRef(imperativeRef);
    const skipMotions = useMotionBehaviourContext() === "skip";
    const optionsRef = React85.useRef({
      skipMotions,
      params
    });
    const animateAtoms = useAnimateAtoms();
    const isReducedMotion = useIsReducedMotion();
    const onMotionStart = useEventCallback(() => {
      onMotionStartProp === null || onMotionStartProp === void 0 ? void 0 : onMotionStartProp(null);
    });
    const onMotionFinish = useEventCallback(() => {
      onMotionFinishProp === null || onMotionFinishProp === void 0 ? void 0 : onMotionFinishProp(null);
    });
    const onMotionCancel = useEventCallback(() => {
      onMotionCancelProp === null || onMotionCancelProp === void 0 ? void 0 : onMotionCancelProp(null);
    });
    useIsomorphicLayoutEffect(() => {
      optionsRef.current = {
        skipMotions,
        params
      };
    });
    useIsomorphicLayoutEffect(() => {
      const element = childRef.current;
      if (element) {
        const atoms = typeof value === "function" ? value({
          element,
          ...optionsRef.current.params
        }) : value;
        onMotionStart();
        const handle = animateAtoms(element, atoms, {
          isReducedMotion: isReducedMotion()
        });
        handleRef.current = handle;
        handle.setMotionEndCallbacks(onMotionFinish, onMotionCancel);
        if (optionsRef.current.skipMotions) {
          handle.finish();
        }
        return () => {
          handle.cancel();
        };
      }
    }, [
      animateAtoms,
      childRef,
      handleRef,
      isReducedMotion,
      onMotionFinish,
      onMotionStart,
      onMotionCancel
    ]);
    return child;
  };
  return Object.assign(Atom, {
    // Heads up!
    // Always normalize it to a function to simplify types
    [MOTION_DEFINITION]: typeof value === "function" ? value : () => value
  });
}

// node_modules/@fluentui/react-motion/lib/factories/createMotionComponentVariant.js
function createMotionFnVariant(motionFn, variantParams) {
  const variantFn = (runtimeParams) => motionFn({
    ...variantParams,
    ...runtimeParams
  });
  return variantFn;
}
function createMotionComponentVariant(component, variantParams) {
  const originalFn = component[MOTION_DEFINITION];
  const variantFn = createMotionFnVariant(originalFn, variantParams);
  return createMotionComponent(variantFn);
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
var React88 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/contexts/PresenceGroupChildContext.js
var React86 = __toESM(require_react());
var PresenceGroupChildContext = React86.createContext(void 0);
var PresenceGroupChildProvider = PresenceGroupChildContext.Provider;

// node_modules/@fluentui/react-motion/lib/hooks/useMountedState.js
var React87 = __toESM(require_react());
function useMountedState(visible = false, unmountOnExit = false) {
  const mountedRef = React87.useRef(unmountOnExit ? visible : true);
  const forceUpdate = useForceUpdate();
  const setMounted = React87.useCallback((newValue) => {
    if (mountedRef.current !== newValue) {
      mountedRef.current = newValue;
      forceUpdate();
    }
  }, [
    forceUpdate
  ]);
  React87.useEffect(() => {
    if (visible) {
      mountedRef.current = visible;
    }
  });
  return [
    visible || mountedRef.current,
    setMounted
  ];
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponent.js
var PRESENCE_MOTION_DEFINITION = Symbol("PRESENCE_MOTION_DEFINITION");
var INTERRUPTABLE_MOTION_SYMBOL = Symbol.for("interruptablePresence");
function createPresenceComponent(value) {
  return Object.assign((props) => {
    "use no memo";
    const itemContext = React88.useContext(PresenceGroupChildContext);
    const merged = {
      ...itemContext,
      ...props
    };
    const skipMotions = useMotionBehaviourContext() === "skip";
    const { appear, children, imperativeRef, onExit, onMotionFinish, onMotionStart, onMotionCancel, visible, unmountOnExit, ..._rest } = merged;
    const params = _rest;
    const [mounted, setMounted] = useMountedState(visible, unmountOnExit);
    const [child, childRef] = useChildElement(children, mounted);
    const handleRef = useMotionImperativeRef(imperativeRef);
    const optionsRef = React88.useRef({
      appear,
      params,
      skipMotions
    });
    const animateAtoms = useAnimateAtoms();
    const isFirstMount = useFirstMount();
    const isReducedMotion = useIsReducedMotion();
    const handleMotionStart = useEventCallback((direction) => {
      onMotionStart === null || onMotionStart === void 0 ? void 0 : onMotionStart(null, {
        direction
      });
    });
    const handleMotionFinish = useEventCallback((direction) => {
      onMotionFinish === null || onMotionFinish === void 0 ? void 0 : onMotionFinish(null, {
        direction
      });
      if (direction === "exit" && unmountOnExit) {
        setMounted(false);
        onExit === null || onExit === void 0 ? void 0 : onExit();
      }
    });
    const handleMotionCancel = useEventCallback((direction) => {
      onMotionCancel === null || onMotionCancel === void 0 ? void 0 : onMotionCancel(null, {
        direction
      });
    });
    useIsomorphicLayoutEffect(() => {
      optionsRef.current = {
        appear,
        params,
        skipMotions
      };
    });
    useIsomorphicLayoutEffect(
      () => {
        const element = childRef.current;
        if (!element) {
          return;
        }
        let handle;
        function cleanup() {
          if (!handle) {
            return;
          }
          if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION && handle.isRunning()) {
            return;
          }
          handle.cancel();
          handleRef.current = void 0;
        }
        const presenceMotion = typeof value === "function" ? value({
          element,
          ...optionsRef.current.params
        }) : value;
        const IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION = presenceMotion[INTERRUPTABLE_MOTION_SYMBOL];
        if (IS_EXPERIMENTAL_INTERRUPTIBLE_MOTION) {
          handle = handleRef.current;
          if (handle && handle.isRunning()) {
            handle.reverse();
            return cleanup;
          }
        }
        const atoms = visible ? presenceMotion.enter : presenceMotion.exit;
        const direction = visible ? "enter" : "exit";
        const applyInitialStyles = !optionsRef.current.appear && isFirstMount;
        const skipAnimationByConfig = optionsRef.current.skipMotions;
        if (!applyInitialStyles) {
          handleMotionStart(direction);
        }
        handle = animateAtoms(element, atoms, {
          isReducedMotion: isReducedMotion()
        });
        if (applyInitialStyles) {
          handle.finish();
          return cleanup;
        }
        handleRef.current = handle;
        handle.setMotionEndCallbacks(() => handleMotionFinish(direction), () => handleMotionCancel(direction));
        if (skipAnimationByConfig) {
          handle.finish();
        }
        return cleanup;
      },
      // Excluding `isFirstMount` from deps to prevent re-triggering the animation on subsequent renders
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        animateAtoms,
        childRef,
        handleRef,
        isReducedMotion,
        handleMotionFinish,
        handleMotionStart,
        handleMotionCancel,
        visible
      ]
    );
    React88.useEffect(() => {
      if (unmountOnExit && !mounted) {
        var _handleRef_current;
        (_handleRef_current = handleRef.current) === null || _handleRef_current === void 0 ? void 0 : _handleRef_current.dispose();
      }
    }, [
      handleRef,
      unmountOnExit,
      mounted
    ]);
    if (mounted) {
      return child;
    }
    return null;
  }, {
    // Heads up!
    // Always normalize it to a function to simplify types
    [PRESENCE_MOTION_DEFINITION]: typeof value === "function" ? value : () => value
  }, {
    // Wrap `enter` in its own motion component as a static method, e.g. <Fade.In>
    In: createMotionComponent(
      // If we have a motion function, wrap it to forward the runtime params and pick `enter`.
      // Otherwise, pass the `enter` motion object directly.
      typeof value === "function" ? (...args) => value(...args).enter : value.enter
    ),
    // Wrap `exit` in its own motion component as a static method, e.g. <Fade.Out>
    Out: createMotionComponent(
      // If we have a motion function, wrap it to forward the runtime params and pick `exit`.
      // Otherwise, pass the `exit` motion object directly.
      typeof value === "function" ? (...args) => value(...args).exit : value.exit
    )
  });
}

// node_modules/@fluentui/react-motion/lib/factories/createPresenceComponentVariant.js
function createPresenceFnVariant(presenceFn, variantParams) {
  const variantFn = (runtimeParams) => presenceFn({
    ...variantParams,
    ...runtimeParams
  });
  return variantFn;
}
function createPresenceComponentVariant(component, variantParams) {
  const originalFn = component[PRESENCE_MOTION_DEFINITION];
  const variantFn = createPresenceFnVariant(originalFn, variantParams);
  return createPresenceComponent(variantFn);
}

// node_modules/@swc/helpers/esm/_define_property.js
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else obj[key] = value;
  return obj;
}

// node_modules/@fluentui/react-motion/lib/components/PresenceGroup.js
var React91 = __toESM(require_react());

// node_modules/@fluentui/react-motion/lib/utils/groups/mergeChildMappings.js
function mergeChildMappings(prevMapping, nextMapping) {
  function getValueForKey(key) {
    return key in nextMapping ? nextMapping[key] : prevMapping[key];
  }
  const nextKeysPending = {};
  let pendingKeys = [];
  for (const prevKey in prevMapping) {
    if (prevKey in nextMapping) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
      continue;
    }
    pendingKeys.push(prevKey);
  }
  const childMapping = {};
  for (const nextKey in nextMapping) {
    if (nextKeysPending[nextKey]) {
      for (const pendingNextKey of nextKeysPending[nextKey]) {
        childMapping[pendingNextKey] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (const pendingKey of pendingKeys) {
    childMapping[pendingKey] = getValueForKey(pendingKey);
  }
  return childMapping;
}

// node_modules/@fluentui/react-motion/lib/utils/groups/getNextChildMapping.js
function getNextChildMapping(prevChildMapping, nextChildMapping) {
  const childrenMapping = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.entries(childrenMapping).forEach(([key, childDefinition]) => {
    const hasPrev = key in prevChildMapping;
    const hasNext = key in nextChildMapping;
    if (hasNext) {
      if (hasPrev) {
        childrenMapping[key] = {
          ...childDefinition
        };
        return;
      }
      childrenMapping[key] = {
        ...childDefinition,
        appear: true,
        visible: true
      };
      return;
    }
    childrenMapping[key] = {
      ...childDefinition,
      visible: false
    };
  });
  return childrenMapping;
}

// node_modules/@fluentui/react-motion/lib/utils/groups/getChildMapping.js
var React89 = __toESM(require_react());
function getChildMapping(children) {
  const childMapping = {};
  if (children) {
    React89.Children.toArray(children).forEach((child) => {
      if (React89.isValidElement(child)) {
        var _child_key;
        childMapping[(_child_key = child.key) !== null && _child_key !== void 0 ? _child_key : ""] = {
          appear: false,
          element: child,
          visible: true,
          unmountOnExit: true
        };
      }
    });
  }
  return childMapping;
}

// node_modules/@fluentui/react-motion/lib/components/PresenceGroupItemProvider.js
var React90 = __toESM(require_react());
var PresenceGroupItemProvider = (props) => {
  const { appear, childKey, onExit, visible, unmountOnExit } = props;
  const contextValue = React90.useMemo(() => ({
    appear,
    visible,
    onExit: () => onExit(childKey),
    unmountOnExit
  }), [
    appear,
    childKey,
    onExit,
    visible,
    unmountOnExit
  ]);
  return React90.createElement(PresenceGroupChildContext.Provider, {
    value: contextValue
  }, props.children);
};

// node_modules/@fluentui/react-motion/lib/components/PresenceGroup.js
var PresenceGroup = class extends React91.Component {
  static getDerivedStateFromProps(nextProps, { childMapping: prevChildMapping, firstRender }) {
    const nextChildMapping = getChildMapping(nextProps.children);
    return {
      childMapping: firstRender ? nextChildMapping : getNextChildMapping(prevChildMapping, nextChildMapping),
      firstRender: false
    };
  }
  componentDidMount() {
    this.mounted = true;
  }
  componentWillUnmount() {
    this.mounted = false;
  }
  render() {
    return React91.createElement(React91.Fragment, null, Object.entries(this.state.childMapping).map(([childKey, childProps]) => React91.createElement(PresenceGroupItemProvider, {
      ...childProps,
      childKey,
      key: childKey,
      onExit: this.handleExit
    }, childProps.element)));
  }
  constructor(props, context) {
    super(props, context), _define_property(this, "mounted", false), _define_property(this, "handleExit", (childKey) => {
      const currentChildMapping = getChildMapping(this.props.children);
      if (childKey in currentChildMapping) {
        return;
      }
      if (this.mounted) {
        this.setState((state) => {
          const childMapping = {
            ...state.childMapping
          };
          delete childMapping[childKey];
          return {
            childMapping
          };
        });
      }
    });
    this.state = {
      childMapping: {},
      firstRender: true
    };
  }
};

// node_modules/@fluentui/react-motion/lib/slots/presenceMotionSlot.js
var React92 = __toESM(require_react());
function presenceMotionSlot(motion, options) {
  const { as, children, ...rest } = motion !== null && motion !== void 0 ? motion : {};
  if (true) {
    if (typeof as !== "undefined") {
      throw new Error(`@fluentui/react-motion: "as" property is not supported on motion slots.`);
    }
  }
  if (motion === null) {
    const isUnmounted = !options.defaultProps.visible && options.defaultProps.unmountOnExit;
    const renderFn = (_, props) => isUnmounted ? null : React92.createElement(React92.Fragment, null, props.children);
    return {
      [SLOT_RENDER_FUNCTION_SYMBOL]: renderFn,
      [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
    };
  }
  const propsWithMetadata = {
    ...options.defaultProps,
    ...rest,
    [SLOT_ELEMENT_TYPE_SYMBOL]: options.elementType
  };
  if (typeof children === "function") {
    propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = children;
  }
  return propsWithMetadata;
}

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeader.js
var useAccordionHeader_unstable = (props, ref) => {
  const { icon, button, expandIcon, inline: inline2 = false, size: size3 = "medium", expandIconPosition = "start" } = props;
  const { value, disabled, open } = useAccordionItemContext_unstable();
  const requestToggle = useAccordionContext_unstable((ctx) => ctx.requestToggle);
  const disabledFocusable = useAccordionContext_unstable((ctx) => !ctx.collapsible && ctx.openItems.length === 1 && open);
  const { dir } = useFluent();
  let expandIconRotation;
  if (expandIconPosition === "end") {
    expandIconRotation = open ? -90 : 90;
  } else {
    expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
  }
  const buttonSlot = slot_exports.always(button, {
    elementType: "button",
    defaultProps: {
      disabled,
      disabledFocusable,
      "aria-expanded": open,
      type: "button"
    }
  });
  buttonSlot.onClick = useEventCallback((event) => {
    if (isResolvedShorthand(button)) {
      var _button_onClick;
      (_button_onClick = button.onClick) === null || _button_onClick === void 0 ? void 0 : _button_onClick.call(button, event);
    }
    if (!event.defaultPrevented) {
      requestToggle({
        value,
        event
      });
    }
  });
  return {
    disabled,
    open,
    size: size3,
    inline: inline2,
    expandIconPosition,
    components: {
      root: "div",
      button: "button",
      expandIcon: "span",
      icon: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      elementType: "div"
    }),
    expandIcon: slot_exports.optional(expandIcon, {
      renderByDefault: true,
      defaultProps: {
        children: React93.createElement(ChevronRightRegular, {
          style: {
            transform: `rotate(${expandIconRotation}deg)`,
            transition: `transform ${motionTokens.durationNormal}ms ease-out`
          }
        }),
        "aria-hidden": true
      },
      elementType: "span"
    }),
    button: useARIAButtonProps(buttonSlot.as, buttonSlot)
  };
};

// node_modules/@fluentui/react-accordion/lib/contexts/accordionHeader.js
var React94 = __toESM(require_react());
var AccordionHeaderContext = React94.createContext(void 0);
var { Provider: AccordionHeaderProvider } = AccordionHeaderContext;

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/renderAccordionHeader.js
var renderAccordionHeader_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(AccordionHeaderProvider, {
    value: contextValues.accordionHeader,
    children: jsx(state.root, {
      children: jsxs(state.button, {
        children: [
          state.expandIconPosition === "start" && state.expandIcon && jsx(state.expandIcon, {}),
          state.icon && jsx(state.icon, {}),
          state.root.children,
          state.expandIconPosition === "end" && state.expandIcon && jsx(state.expandIcon, {})
        ]
      })
    })
  });
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderStyles.styles.js
var accordionHeaderClassNames = {
  root: "fui-AccordionHeader",
  button: "fui-AccordionHeader__button",
  expandIcon: "fui-AccordionHeader__expandIcon",
  icon: "fui-AccordionHeader__icon"
};
var useStyles2 = __styles2({
  resetButton: {
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1u2r49w",
    sj55zd: "f1ym3bx4",
    Bahqtrf: "f1mo0ibp",
    Be2twd7: "fjoy568",
    Bg96gwp: "fytdu2e",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bv0vk6g: "f37px4s",
    fsow6f: "fgusgyc"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bqhya38: "f1j6vpng",
    Bwxa6fj: ["f1pniga2", "f1ffjurs"],
    Bdhvstf: "f987i1v",
    B7zbvrb: ["f1ffjurs", "f1pniga2"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "ffwy5si",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "f3znvyf",
    J0r882: "f57olzd",
    Bule8hv: ["f4stah7", "fs1por5"],
    Bjwuhne: "f480a47",
    Ghsupd: ["fs1por5", "f4stah7"]
  },
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "f1c21dwh",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  rootDisabled: {
    Bcmaq0h: "fwrgwhw",
    sj55zd: "f1s2aq7o"
  },
  rootInline: {
    mc9l5x: "f14t3ns0"
  },
  button: {
    qhf8xq: "f10pi13n",
    a9b677: "fly5x3f",
    B4j52fo: "fre7gi1",
    Bekrc4i: ["f1358rze", "f1rvrf73"],
    Bn0qgzm: "fqdk4by",
    ibv6hh: ["f1rvrf73", "f1358rze"],
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1rmphuq", "f26yw9j"],
    sshi5w: "f5pgtk9",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B7ck84d: "f1ewtqcl"
  },
  buttonSmall: {
    sshi5w: "f1nxs5xn",
    Be2twd7: "fy9rknc"
  },
  buttonLarge: {
    Bg96gwp: "faaz57k",
    Be2twd7: "fod5ikn"
  },
  buttonExtraLarge: {
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  },
  buttonInline: {
    mc9l5x: "ftuwxu6"
  },
  buttonExpandIconEndNoIcon: {
    uwmqm3: ["f1uw59to", "fw5db7e"]
  },
  buttonExpandIconEnd: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  buttonDisabled: {
    Bceei9c: "fdrzuqr"
  },
  expandIcon: {
    Bqenvij: "f1l02sjl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  },
  expandIconStart: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  expandIconEnd: {
    Bh6795r: "fqerorx",
    Bnnss6s: "f1neuvcm",
    xawz: "flqd7gy",
    mc9l5x: "f22iagw",
    Brf1p80: "f9c4gz4",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  icon: {
    Bqenvij: "f1l02sjl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    z189sj: ["f1vdfbxk", "f1f5gg8d"],
    Bg96gwp: "f106mvju",
    Be2twd7: "f1pp30po"
  }
}, {
  d: [".f1e4lqlz{box-sizing:content-box;}", ".f1u2r49w{background-color:inherit;}", ".f1ym3bx4{color:inherit;}", ".f1mo0ibp{font-family:inherit;}", ".fjoy568{font-size:inherit;}", ".fytdu2e{line-height:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f37px4s{-webkit-appearance:button;}", ".fgusgyc{text-align:unset;}", ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}", ".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}", ".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}", ".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fwrgwhw{background-image:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f14t3ns0{display:inline-block;}", ".f10pi13n{position:relative;}", ".fly5x3f{width:100%;}", ".fre7gi1{border-top-width:0;}", ".f1358rze{border-right-width:0;}", ".f1rvrf73{border-left-width:0;}", ".fqdk4by{border-bottom-width:0;}", [".f1rmphuq{padding:0 var(--spacingHorizontalM) 0 var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f26yw9j{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalM);}", {
    p: -1
  }], ".f5pgtk9{min-height:44px;}", ".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1ewtqcl{box-sizing:border-box;}", ".f1nxs5xn{min-height:32px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".ftuwxu6{display:inline-flex;}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".fdrzuqr{cursor:not-allowed;}", ".f1l02sjl{height:100%;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fqerorx{flex-grow:1;}", ".f1neuvcm{flex-shrink:1;}", ".flqd7gy{flex-basis:0%;}", ".f9c4gz4{justify-content:flex-end;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useAccordionHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles2();
  state.root.className = mergeClasses(accordionHeaderClassNames.root, styles.root, state.inline && styles.rootInline, state.disabled && styles.rootDisabled, state.root.className);
  state.button.className = mergeClasses(accordionHeaderClassNames.button, styles.resetButton, styles.button, styles.focusIndicator, state.expandIconPosition === "end" && !state.icon && styles.buttonExpandIconEndNoIcon, state.expandIconPosition === "end" && styles.buttonExpandIconEnd, state.inline && styles.buttonInline, state.size === "small" && styles.buttonSmall, state.size === "large" && styles.buttonLarge, state.size === "extra-large" && styles.buttonExtraLarge, state.disabled && styles.buttonDisabled, state.button.className);
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(accordionHeaderClassNames.expandIcon, styles.expandIcon, state.expandIconPosition === "start" && styles.expandIconStart, state.expandIconPosition === "end" && styles.expandIconEnd, state.expandIcon.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(accordionHeaderClassNames.icon, styles.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/useAccordionHeaderContextValues.js
var React95 = __toESM(require_react());
function useAccordionHeaderContextValues_unstable(state) {
  const { disabled, expandIconPosition, open, size: size3 } = state;
  const accordionHeader = React95.useMemo(() => ({
    disabled,
    expandIconPosition,
    open,
    size: size3
  }), [
    disabled,
    expandIconPosition,
    open,
    size3
  ]);
  return {
    accordionHeader
  };
}

// node_modules/@fluentui/react-accordion/lib/components/AccordionHeader/AccordionHeader.js
var AccordionHeader = React96.forwardRef((props, ref) => {
  const state = useAccordionHeader_unstable(props, ref);
  const contextValues = useAccordionHeaderContextValues_unstable(state);
  useAccordionHeaderStyles_unstable(state);
  useCustomStyleHook("useAccordionHeaderStyles_unstable")(state);
  return renderAccordionHeader_unstable(state, contextValues);
});
AccordionHeader.displayName = "AccordionHeader";

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/AccordionPanel.js
var React102 = __toESM(require_react());

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanel.js
var React101 = __toESM(require_react());

// node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/collapse-atoms.js
var sizeValuesForOrientation = (orientation, element) => {
  const sizeName = orientation === "horizontal" ? "maxWidth" : "maxHeight";
  const overflowName = orientation === "horizontal" ? "overflowX" : "overflowY";
  const measuredSize = orientation === "horizontal" ? element.scrollWidth : element.scrollHeight;
  const toSize = `${measuredSize}px`;
  return {
    sizeName,
    overflowName,
    toSize
  };
};
var sizeEnterAtom = ({ orientation, duration, easing, element, outSize = "0", delay = 0 }) => {
  const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
  return {
    keyframes: [
      {
        [sizeName]: outSize,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: toSize,
        offset: 0.9999,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: "unset",
        [overflowName]: "unset"
      }
    ],
    duration,
    easing,
    delay,
    fill: "both"
  };
};
var sizeExitAtom = ({ orientation, duration, easing, element, delay = 0, outSize = "0" }) => {
  const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
  return {
    keyframes: [
      {
        [sizeName]: toSize,
        [overflowName]: "hidden"
      },
      {
        [sizeName]: outSize,
        [overflowName]: "hidden"
      }
    ],
    duration,
    easing,
    delay,
    fill: "both"
  };
};
var whitespaceValuesForOrientation = (orientation) => {
  if (orientation === "horizontal") {
    return {
      paddingStart: "paddingInlineStart",
      paddingEnd: "paddingInlineEnd",
      marginStart: "marginInlineStart",
      marginEnd: "marginInlineEnd"
    };
  }
  return {
    paddingStart: "paddingBlockStart",
    paddingEnd: "paddingBlockEnd",
    marginStart: "marginBlockStart",
    marginEnd: "marginBlockEnd"
  };
};
var whitespaceAtom = ({ direction, orientation, duration, easing, delay = 0 }) => {
  const { paddingStart, paddingEnd, marginStart, marginEnd } = whitespaceValuesForOrientation(orientation);
  const offset4 = direction === "enter" ? 0 : 1;
  const keyframes = [
    {
      [paddingStart]: "0",
      [paddingEnd]: "0",
      [marginStart]: "0",
      [marginEnd]: "0",
      offset: offset4
    }
  ];
  return {
    keyframes,
    duration,
    easing,
    delay,
    fill: "both"
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/fade-atom.js
var fadeAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, outOpacity = 0, inOpacity = 1 }) => {
  const keyframes = [
    {
      opacity: outOpacity
    },
    {
      opacity: inOpacity
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay,
    // Applying opacity backwards and forwards in time is important
    // to avoid a bug where a delayed animation is not hidden when it should be.
    fill: "both"
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Collapse/Collapse.js
var collapsePresenceFn = ({
  element,
  // Primary duration controls (simple API)
  duration = motionTokens.durationNormal,
  exitDuration = duration,
  // Granular duration controls with smart defaults (advanced API)
  sizeDuration = duration,
  opacityDuration = sizeDuration,
  exitSizeDuration = exitDuration,
  exitOpacityDuration = exitSizeDuration,
  // Other timing controls
  easing = motionTokens.curveEasyEaseMax,
  delay = 0,
  exitEasing = easing,
  exitDelay = delay,
  staggerDelay = 0,
  exitStaggerDelay = staggerDelay,
  // Animation controls
  animateOpacity = true,
  orientation = "vertical",
  outSize = "0px"
}) => {
  const enterAtoms = [
    // Apply global delay to size atom - size expansion starts first
    sizeEnterAtom({
      orientation,
      duration: sizeDuration,
      easing,
      element,
      outSize,
      delay
    }),
    whitespaceAtom({
      direction: "enter",
      orientation,
      duration: sizeDuration,
      easing,
      delay
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration: opacityDuration,
      easing,
      delay: delay + staggerDelay
    }));
  }
  const exitAtoms = [];
  if (animateOpacity) {
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitOpacityDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  exitAtoms.push(sizeExitAtom({
    orientation,
    duration: exitSizeDuration,
    easing: exitEasing,
    element,
    delay: exitDelay + exitStaggerDelay,
    outSize
  }), whitespaceAtom({
    direction: "exit",
    orientation,
    duration: exitSizeDuration,
    easing: exitEasing,
    delay: exitDelay + exitStaggerDelay
  }));
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Collapse = createPresenceComponent(collapsePresenceFn);
var CollapseSnappy = createPresenceComponentVariant(Collapse, {
  duration: motionTokens.durationFast
});
var CollapseRelaxed = createPresenceComponentVariant(Collapse, {
  duration: motionTokens.durationSlower
});
var CollapseDelayed = createPresenceComponentVariant(Collapse, {
  // Enter timing per motion design spec
  sizeDuration: motionTokens.durationNormal,
  opacityDuration: motionTokens.durationSlower,
  staggerDelay: motionTokens.durationNormal,
  // Exit timing per motion design spec
  exitSizeDuration: motionTokens.durationNormal,
  exitOpacityDuration: motionTokens.durationSlower,
  exitStaggerDelay: motionTokens.durationSlower,
  // Easing per motion design spec
  easing: motionTokens.curveEasyEase,
  exitEasing: motionTokens.curveEasyEase
});

// node_modules/@fluentui/react-motion-components-preview/lib/components/Fade/Fade.js
var fadePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveEasyEase, delay = 0, exitDuration = duration, exitEasing = easing, exitDelay = delay, outOpacity = 0, inOpacity = 1 }) => {
  return {
    enter: fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      outOpacity,
      inOpacity
    }),
    exit: fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      outOpacity,
      inOpacity
    })
  };
};
var Fade = createPresenceComponent(fadePresenceFn);
var FadeSnappy = createPresenceComponentVariant(Fade, {
  duration: motionTokens.durationFast
});
var FadeRelaxed = createPresenceComponentVariant(Fade, {
  duration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/scale-atom.js
var scaleAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, outScale = 0.9, inScale = 1 }) => {
  const keyframes = [
    {
      scale: outScale
    },
    {
      scale: inScale
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Scale/Scale.js
var scalePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = motionTokens.durationNormal, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, outScale = 0.9, inScale = 1, animateOpacity = true }) => {
  const enterAtoms = [
    scaleAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      outScale,
      inScale
    })
  ];
  const exitAtoms = [
    scaleAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      outScale,
      inScale
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Scale = createPresenceComponent(scalePresenceFn);
var ScaleSnappy = createPresenceComponentVariant(Scale, {
  duration: motionTokens.durationNormal,
  exitDuration: motionTokens.durationFast
});
var ScaleRelaxed = createPresenceComponentVariant(Scale, {
  duration: motionTokens.durationSlow,
  exitDuration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/slide-atom.js
var slideAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, outX = "0px", outY = "0px", inX = "0px", inY = "0px" }) => {
  const keyframes = [
    {
      translate: `${outX} ${outY}`
    },
    {
      translate: `${inX} ${inY}`
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Slide/Slide.js
var slidePresenceFn = ({ duration = motionTokens.durationNormal, easing = motionTokens.curveDecelerateMid, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMid, exitDelay = delay, outX = "0px", outY = "0px", inX = "0px", inY = "0px", animateOpacity = true }) => {
  const enterAtoms = [
    slideAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      outX,
      outY,
      inX,
      inY
    })
  ];
  const exitAtoms = [
    slideAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      outX,
      outY,
      inX,
      inY
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Slide = createPresenceComponent(slidePresenceFn);
var SlideSnappy = createPresenceComponentVariant(Slide, {
  easing: motionTokens.curveDecelerateMax,
  exitEasing: motionTokens.curveAccelerateMax
});
var SlideRelaxed = createPresenceComponentVariant(Slide, {
  duration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/blur-atom.js
var blurAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, outRadius = "10px", inRadius = "0px" }) => {
  const keyframes = [
    {
      filter: `blur(${outRadius})`
    },
    {
      filter: `blur(${inRadius})`
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Blur/Blur.js
var blurPresenceFn = ({ duration = motionTokens.durationSlow, easing = motionTokens.curveDecelerateMin, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMin, exitDelay = delay, outRadius = "10px", inRadius = "0px", animateOpacity = true }) => {
  const enterAtoms = [
    blurAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      outRadius,
      inRadius
    })
  ];
  const exitAtoms = [
    blurAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      outRadius,
      inRadius
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Blur = createPresenceComponent(blurPresenceFn);

// node_modules/@fluentui/react-motion-components-preview/lib/atoms/rotate-atom.js
var createRotateValue = (axis, angle) => {
  return `${axis.toLowerCase()} ${angle}deg`;
};
var rotateAtom = ({ direction, duration, easing = motionTokens.curveLinear, delay = 0, axis = "z", outAngle = -90, inAngle = 0 }) => {
  const keyframes = [
    {
      rotate: createRotateValue(axis, outAngle)
    },
    {
      rotate: createRotateValue(axis, inAngle)
    }
  ];
  if (direction === "exit") {
    keyframes.reverse();
  }
  return {
    keyframes,
    duration,
    easing,
    delay
  };
};

// node_modules/@fluentui/react-motion-components-preview/lib/components/Rotate/Rotate.js
var rotatePresenceFn = ({ duration = motionTokens.durationGentle, easing = motionTokens.curveDecelerateMax, delay = 0, exitDuration = duration, exitEasing = motionTokens.curveAccelerateMax, exitDelay = delay, axis = "z", outAngle = -90, inAngle = 0, animateOpacity = true }) => {
  const enterAtoms = [
    rotateAtom({
      direction: "enter",
      duration,
      easing,
      delay,
      axis,
      outAngle,
      inAngle
    })
  ];
  const exitAtoms = [
    rotateAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay,
      axis,
      outAngle,
      inAngle
    })
  ];
  if (animateOpacity) {
    enterAtoms.push(fadeAtom({
      direction: "enter",
      duration,
      easing,
      delay
    }));
    exitAtoms.push(fadeAtom({
      direction: "exit",
      duration: exitDuration,
      easing: exitEasing,
      delay: exitDelay
    }));
  }
  return {
    enter: enterAtoms,
    exit: exitAtoms
  };
};
var Rotate = createPresenceComponent(rotatePresenceFn);

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/Stagger.js
var React100 = __toESM(require_react());

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/useStaggerItemsVisibility.js
var React99 = __toESM(require_react());

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/utils/constants.js
var DEFAULT_ITEM_DELAY = motionTokens.durationFaster;
var DEFAULT_ITEM_DURATION = motionTokens.durationNormal;

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/utils/stagger-calculations.js
function getStaggerTotalDuration({ itemCount, itemDelay = DEFAULT_ITEM_DELAY, itemDuration = DEFAULT_ITEM_DURATION }) {
  if (itemCount <= 0) {
    return 0;
  }
  if (itemCount <= 1) {
    return Math.max(0, itemDuration);
  }
  const staggerDuration = itemDelay * (itemCount - 1);
  return Math.max(0, staggerDuration + itemDuration);
}
function staggerItemsVisibilityAtTime({ itemCount, elapsed, itemDelay = DEFAULT_ITEM_DELAY, itemDuration = DEFAULT_ITEM_DURATION, direction = "enter", reversed = false }) {
  if (itemCount <= 0) {
    return {
      itemsVisibility: [],
      totalDuration: 0
    };
  }
  const totalDuration = getStaggerTotalDuration({
    itemCount,
    itemDelay,
    itemDuration
  });
  let completedSteps;
  if (itemDelay <= 0) {
    completedSteps = itemCount;
  } else {
    if (elapsed === 0) {
      completedSteps = direction === "enter" ? 1 : 0;
    } else {
      const stepsFromElapsedTime = Math.floor(elapsed / itemDelay) + 1;
      completedSteps = Math.min(itemCount, stepsFromElapsedTime);
    }
  }
  const itemsVisibility = Array.from({
    length: itemCount
  }, (_, idx) => {
    const fromStart = idx < completedSteps;
    const fromEnd = idx >= itemCount - completedSteps;
    let itemVisible = reversed ? fromEnd : fromStart;
    if (direction === "exit") {
      itemVisible = !itemVisible;
    }
    return itemVisible;
  });
  return {
    itemsVisibility,
    totalDuration
  };
}

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/utils/motionComponentDetection.js
var React97 = __toESM(require_react());
function isMotionComponent(element) {
  if (!(element === null || element === void 0 ? void 0 : element.type) || typeof element.type !== "function") {
    return false;
  }
  const symbols = Object.getOwnPropertySymbols(element.type);
  return symbols.some((sym) => sym.description === "MOTION_DEFINITION");
}
function isPresenceComponent(element) {
  if (!(element === null || element === void 0 ? void 0 : element.type) || typeof element.type !== "function") {
    return false;
  }
  const symbols = Object.getOwnPropertySymbols(element.type);
  return symbols.some((sym) => sym.description === "PRESENCE_MOTION_DEFINITION");
}
function acceptsDelayProps(element) {
  return isPresenceComponent(element) || isMotionComponent(element);
}
function acceptsVisibleProp(element) {
  return isPresenceComponent(element);
}

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/utils/getStaggerChildMapping.js
var React98 = __toESM(require_react());
function getStaggerChildMapping(children) {
  const childMapping = {};
  if (children) {
    React98.Children.toArray(children).forEach((child, index) => {
      if (React98.isValidElement(child)) {
        var _child_key;
        childMapping[(_child_key = child.key) !== null && _child_key !== void 0 ? _child_key : ""] = {
          element: child,
          index
        };
      }
    });
  }
  return childMapping;
}

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/useStaggerItemsVisibility.js
function useStaggerItemsVisibility({ childMapping, itemDelay, itemDuration = DEFAULT_ITEM_DURATION, direction, reversed = false, onMotionFinish, hideMode = "visibleProp" }) {
  const [requestAnimationFrame2, cancelAnimationFrame2] = useAnimationFrame();
  const handleMotionFinish = useEventCallback(onMotionFinish !== null && onMotionFinish !== void 0 ? onMotionFinish : () => {
    return;
  });
  const [animationKey, setAnimationKey] = React99.useState(0);
  const prevDirection = React99.useRef(direction);
  React99.useEffect(() => {
    if (prevDirection.current !== direction) {
      setAnimationKey((prev) => prev + 1);
      prevDirection.current = direction;
    }
  }, [
    direction
  ]);
  const [itemsVisibility, setItemsVisibility] = React99.useState(() => {
    const initial = {};
    const initialState = direction === "enter";
    Object.keys(childMapping).forEach((key) => {
      initial[key] = initialState;
    });
    return initial;
  });
  React99.useEffect(() => {
    setItemsVisibility((prev) => {
      const next = {};
      const targetState = direction === "enter";
      Object.keys(childMapping).forEach((key) => {
        if (key in prev) {
          next[key] = prev[key];
        } else {
          next[key] = targetState;
        }
      });
      return next;
    });
  }, [
    childMapping,
    direction
  ]);
  const startTimeRef = React99.useRef(null);
  const frameRef = React99.useRef(null);
  const finishedRef = React99.useRef(false);
  const isFirstRender = React99.useRef(true);
  const childMappingRef = React99.useRef(childMapping);
  React99.useEffect(() => {
    childMappingRef.current = childMapping;
  }, [
    childMapping
  ]);
  const reversedRef = React99.useRef(reversed);
  React99.useEffect(() => {
    reversedRef.current = reversed;
  }, [
    reversed
  ]);
  React99.useEffect(() => {
    let cancelled = false;
    startTimeRef.current = null;
    finishedRef.current = false;
    if (isFirstRender.current) {
      isFirstRender.current = false;
      handleMotionFinish();
      return;
    }
    const startState = direction === "exit";
    const initialVisibility = {};
    Object.keys(childMappingRef.current).forEach((key) => {
      initialVisibility[key] = startState;
    });
    setItemsVisibility(initialVisibility);
    const tick = (now) => {
      if (cancelled) {
        return;
      }
      if (startTimeRef.current === null) {
        startTimeRef.current = now;
      }
      const elapsed = now - startTimeRef.current;
      const childKeys = Object.keys(childMappingRef.current);
      const itemCount = childKeys.length;
      const result = staggerItemsVisibilityAtTime({
        itemCount,
        elapsed,
        itemDelay,
        itemDuration,
        direction,
        reversed: reversedRef.current
      });
      const nextVisibility = {};
      childKeys.forEach((key, idx) => {
        nextVisibility[key] = result.itemsVisibility[idx];
      });
      setItemsVisibility(nextVisibility);
      if (elapsed < result.totalDuration) {
        frameRef.current = requestAnimationFrame2(tick);
      } else if (!finishedRef.current) {
        finishedRef.current = true;
        handleMotionFinish();
      }
    };
    frameRef.current = requestAnimationFrame2(tick);
    return () => {
      cancelled = true;
      if (frameRef.current) {
        cancelAnimationFrame2();
      }
    };
  }, [
    animationKey,
    itemDelay,
    itemDuration,
    direction,
    requestAnimationFrame2,
    cancelAnimationFrame2,
    handleMotionFinish
  ]);
  return {
    itemsVisibility
  };
}

// node_modules/@fluentui/react-motion-components-preview/lib/choreography/Stagger/Stagger.js
var detectStaggerModes = (children, options) => {
  const { hideMode, delayMode, fallbackHideMode = "visibilityStyle" } = options;
  const childMapping = getStaggerChildMapping(children);
  const elements = Object.values(childMapping).map((item) => item.element);
  const hasVisiblePropSupport = elements.every((child) => acceptsVisibleProp(child));
  const hasDelayPropSupport = elements.every((child) => acceptsDelayProps(child));
  return {
    hideMode: hideMode !== null && hideMode !== void 0 ? hideMode : hasVisiblePropSupport ? "visibleProp" : fallbackHideMode,
    delayMode: delayMode !== null && delayMode !== void 0 ? delayMode : hasDelayPropSupport ? "delayProp" : "timing"
  };
};
var StaggerOneWay = ({ children, direction, itemDelay = DEFAULT_ITEM_DELAY, itemDuration = DEFAULT_ITEM_DURATION, reversed = false, hideMode, delayMode = "timing", onMotionFinish }) => {
  const childMapping = React100.useMemo(() => getStaggerChildMapping(children), [
    children
  ]);
  const { itemsVisibility } = useStaggerItemsVisibility({
    childMapping,
    itemDelay,
    itemDuration,
    direction,
    reversed,
    onMotionFinish,
    hideMode
  });
  if (delayMode === "delayProp") {
    return React100.createElement(React100.Fragment, null, Object.entries(childMapping).map(([key, { element, index }]) => {
      const staggerIndex = reversed ? Object.keys(childMapping).length - 1 - index : index;
      const delay = staggerIndex * itemDelay;
      const delayProp = direction === "enter" ? {
        delay
      } : {
        exitDelay: delay
      };
      const visibleProp = acceptsVisibleProp(element) ? {
        visible: direction === "enter"
      } : {};
      return React100.cloneElement(element, {
        key,
        ...visibleProp,
        ...delayProp
      });
    }));
  }
  return React100.createElement(React100.Fragment, null, Object.entries(childMapping).map(([key, { element }]) => {
    if (hideMode === "visibleProp") {
      return React100.cloneElement(element, {
        key,
        visible: itemsVisibility[key]
      });
    } else if (hideMode === "visibilityStyle") {
      const childProps = element.props;
      const style = {
        ...childProps === null || childProps === void 0 ? void 0 : childProps.style,
        visibility: itemsVisibility[key] ? "visible" : "hidden"
      };
      return React100.cloneElement(element, {
        key,
        style
      });
    } else {
      return itemsVisibility[key] ? React100.cloneElement(element, {
        key
      }) : null;
    }
  }));
};
var createStaggerDirection = (direction) => {
  const StaggerDirection = ({ hideMode, delayMode, children, ...props }) => {
    const { hideMode: resolvedHideMode, delayMode: resolvedDelayMode } = detectStaggerModes(children, {
      hideMode,
      delayMode,
      // One-way stagger falls back to visibilityStyle if it doesn't detect visibleProp support
      fallbackHideMode: "visibilityStyle"
    });
    return React100.createElement(StaggerOneWay, {
      ...props,
      children,
      direction,
      hideMode: resolvedHideMode,
      delayMode: resolvedDelayMode
    });
  };
  return StaggerDirection;
};
var StaggerIn = createStaggerDirection("enter");
var StaggerOut = createStaggerDirection("exit");
var StaggerMain = (props) => {
  const { children, visible = false, hideMode, delayMode, ...rest } = props;
  const { hideMode: resolvedHideMode, delayMode: resolvedDelayMode } = detectStaggerModes(children, {
    hideMode,
    delayMode,
    // Bidirectional stagger falls back to visibilityStyle if it doesn't detect visibleProp support
    fallbackHideMode: "visibilityStyle"
  });
  const direction = visible ? "enter" : "exit";
  return React100.createElement(StaggerOneWay, {
    ...rest,
    children,
    hideMode: resolvedHideMode,
    delayMode: resolvedDelayMode,
    direction
  });
};
var Stagger = Object.assign(StaggerMain, {
  In: StaggerIn,
  Out: StaggerOut
});

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanel.js
var useAccordionPanel_unstable = (props, ref) => {
  const { open } = useAccordionItemContext_unstable();
  const focusableProps = useTabsterAttributes({
    focusable: {
      excludeFromMover: true
    }
  });
  const navigation = useAccordionContext_unstable((ctx) => ctx.navigation);
  return {
    open,
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props,
      ...navigation && focusableProps
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: Collapse,
      defaultProps: {
        visible: open,
        unmountOnExit: true
      }
    })
  };
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/renderAccordionPanel.js
var renderAccordionPanel_unstable = (state) => {
  assertSlots(state);
  return state.collapseMotion ? jsx(state.collapseMotion, {
    children: jsx(state.root, {})
  }) : jsx(state.root, {});
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/useAccordionPanelStyles.styles.js
var accordionPanelClassNames = {
  root: "fui-AccordionPanel"
};
var useStyles3 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1axvtxu"
  }
}, {
  d: [[".f1axvtxu{margin:0 var(--spacingHorizontalM);}", {
    p: -1
  }]]
});
var useAccordionPanelStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles3();
  state.root.className = mergeClasses(accordionPanelClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-accordion/lib/components/AccordionPanel/AccordionPanel.js
var AccordionPanel = React102.forwardRef((props, ref) => {
  const state = useAccordionPanel_unstable(props, ref);
  useAccordionPanelStyles_unstable(state);
  useCustomStyleHook("useAccordionPanelStyles_unstable")(state);
  return renderAccordionPanel_unstable(state);
});
AccordionPanel.displayName = "AccordionPanel";

// node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var React113 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/components/Avatar/renderAvatar.js
var renderAvatar_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.initials && jsx(state.initials, {}),
      state.icon && jsx(state.icon, {}),
      state.image && jsx(state.image, {}),
      state.badge && jsx(state.badge, {}),
      state.activeAriaLabelElement
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var React112 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/utils/getInitials.js
var UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
var UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
var PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
  let initials = "";
  const splits = displayName.split(" ");
  if (splits.length !== 0) {
    initials += splits[0].charAt(0).toUpperCase();
  }
  if (!firstInitialOnly) {
    if (splits.length === 2) {
      initials += splits[1].charAt(0).toUpperCase();
    } else if (splits.length === 3) {
      initials += splits[2].charAt(0).toUpperCase();
    }
  }
  if (isRtl && initials.length > 1) {
    return initials.charAt(1) + initials.charAt(0);
  }
  return initials;
}
function cleanupDisplayName(displayName) {
  displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
  displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
  displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
  displayName = displayName.trim();
  return displayName;
}
function getInitials(displayName, isRtl, options) {
  if (!displayName) {
    return "";
  }
  displayName = cleanupDisplayName(displayName);
  if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
    return "";
  }
  return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
}

// node_modules/@fluentui/react-avatar/lib/utils/partitionAvatarGroupItems.js
var partitionAvatarGroupItems = (options) => {
  const { items } = options;
  const isPie = options.layout === "pie";
  if (isPie) {
    return {
      inlineItems: items.slice(0, 3),
      overflowItems: items.length > 0 ? items : void 0
    };
  }
  var _options_maxInlineItems;
  const maxInlineItems = (_options_maxInlineItems = options.maxInlineItems) !== null && _options_maxInlineItems !== void 0 ? _options_maxInlineItems : 5;
  const inlineCount = -(maxInlineItems - (items.length > maxInlineItems ? 1 : 0));
  const overflowItems = items.slice(0, inlineCount);
  return {
    inlineItems: items.slice(inlineCount),
    overflowItems: overflowItems.length > 0 ? overflowItems : void 0
  };
};

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var React105 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadge.js
var React103 = __toESM(require_react());
var useBadge_unstable = (props, ref) => {
  const { shape = "circular", size: size3 = "medium", iconPosition = "before", appearance = "filled", color: color2 = "brand" } = props;
  const state = {
    shape,
    size: size3,
    iconPosition,
    appearance,
    color: color2,
    components: {
      root: "div",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    })
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/useBadgeStyles.styles.js
var React104 = __toESM(require_react());
var badgeClassNames = {
  root: "fui-Badge",
  icon: "fui-Badge__icon"
};
var textPadding = tokens.spacingHorizontalXXS;
var useRootClassName = __resetStyles("r1iycov", "r115jdol", [".r1iycov{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r1iycov::after{content:"";position:absolute;top:0;left:0;bottom:0;right:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}', ".r115jdol{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;position:relative;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase200);height:20px;min-width:20px;padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));border-radius:var(--borderRadiusCircular);border-color:var(--colorTransparentStroke);}", '.r115jdol::after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;border-style:solid;border-color:inherit;border-width:var(--strokeWidthThin);border-radius:inherit;}']);
var useRootStyles = __styles2({
  fontSmallToTiny: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  tiny: {
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    Be2twd7: "f130uwy9",
    Bg96gwp: "fod1mrr",
    Bf4jedk: "f18p0k4z",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf"
  },
  "extra-small": {
    a9b677: "fpd43o0",
    Bqenvij: "f30q22z",
    Be2twd7: "f1tccstq",
    Bg96gwp: "f1y3arg5",
    Bf4jedk: "f18p0k4z",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf"
  },
  small: {
    Bf4jedk: "fq2vo04",
    Bqenvij: "fd461yt",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fupdldz"
  },
  medium: {},
  large: {
    Bf4jedk: "f17fgpbq",
    Bqenvij: "frvgh55",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1996nqw"
  },
  "extra-large": {
    Bf4jedk: "fwbmr0d",
    Bqenvij: "f1d2rq10",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fty64o7"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  roundedSmallToTiny: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  circular: {},
  borderGhost: {
    ap17g6: "f10ludwy"
  },
  filled: {},
  "filled-brand": {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  "filled-danger": {
    De3pzq: "fdl5y0r",
    sj55zd: "f1phragk"
  },
  "filled-important": {
    De3pzq: "f1c73kur",
    sj55zd: "fr0bkrk"
  },
  "filled-informative": {
    De3pzq: "f3vzo32",
    sj55zd: "f11d4kpn"
  },
  "filled-severe": {
    De3pzq: "f1s438gw",
    sj55zd: "f1phragk"
  },
  "filled-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5"
  },
  "filled-success": {
    De3pzq: "flxk52p",
    sj55zd: "f1phragk"
  },
  "filled-warning": {
    De3pzq: "ffq97bm",
    sj55zd: "ff5vbop"
  },
  ghost: {},
  "ghost-brand": {
    sj55zd: "f16muhyy"
  },
  "ghost-danger": {
    sj55zd: "f1whyuy6"
  },
  "ghost-important": {
    sj55zd: "f19n0e5"
  },
  "ghost-informative": {
    sj55zd: "f11d4kpn"
  },
  "ghost-severe": {
    sj55zd: "f1l8vj45"
  },
  "ghost-subtle": {
    sj55zd: "fonrgv7"
  },
  "ghost-success": {
    sj55zd: "f1m7fhi8"
  },
  "ghost-warning": {
    sj55zd: "fpti2h4"
  },
  outline: {
    g2u3we: "f23ftbb",
    h3c5rm: ["f1gkuv52", "f1p1bl80"],
    B9xav0g: "fioka3i",
    zhjwy3: ["f1p1bl80", "f1gkuv52"]
  },
  "outline-brand": {
    sj55zd: "f16muhyy"
  },
  "outline-danger": {
    sj55zd: "f1whyuy6",
    g2u3we: "fyqpifd",
    h3c5rm: ["f3ukxca", "f1k7dugc"],
    B9xav0g: "f1njxb2b",
    zhjwy3: ["f1k7dugc", "f3ukxca"]
  },
  "outline-important": {
    sj55zd: "f11d4kpn",
    g2u3we: "fq0vr37",
    h3c5rm: ["f1byw159", "f11cr0be"],
    B9xav0g: "f1c1zstj",
    zhjwy3: ["f11cr0be", "f1byw159"]
  },
  "outline-informative": {
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "outline-severe": {
    sj55zd: "f1l8vj45"
  },
  "outline-subtle": {
    sj55zd: "fonrgv7"
  },
  "outline-success": {
    sj55zd: "f1m7fhi8",
    g2u3we: "f1mmhl11",
    h3c5rm: ["f1tjpp2f", "f1ocn5n7"],
    B9xav0g: "f1gjv25d",
    zhjwy3: ["f1ocn5n7", "f1tjpp2f"]
  },
  "outline-warning": {
    sj55zd: "fpti2h4"
  },
  tint: {},
  "tint-brand": {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    g2u3we: "f161y7kd",
    h3c5rm: ["f1c8dzaj", "f1sl6hi9"],
    B9xav0g: "f1619yhw",
    zhjwy3: ["f1sl6hi9", "f1c8dzaj"]
  },
  "tint-danger": {
    De3pzq: "ff0poqj",
    sj55zd: "f1hcrxcs",
    g2u3we: "f1oqjm8o",
    h3c5rm: ["fkgrb8g", "frb5wm0"],
    B9xav0g: "f1iai1ph",
    zhjwy3: ["frb5wm0", "fkgrb8g"]
  },
  "tint-important": {
    De3pzq: "f945g0u",
    sj55zd: "fr0bkrk",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"]
  },
  "tint-informative": {
    De3pzq: "f1ctqxl6",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-severe": {
    De3pzq: "f1xzsg4",
    sj55zd: "f1k5f75o",
    g2u3we: "fxy9dsj",
    h3c5rm: ["f54u6j2", "fcm23ze"],
    B9xav0g: "f4vf0uq",
    zhjwy3: ["fcm23ze", "f54u6j2"]
  },
  "tint-subtle": {
    De3pzq: "fxugw4r",
    sj55zd: "f11d4kpn",
    g2u3we: "f68mrw8",
    h3c5rm: ["f7pw515", "fw35ms5"],
    B9xav0g: "frpde29",
    zhjwy3: ["fw35ms5", "f7pw515"]
  },
  "tint-success": {
    De3pzq: "f2vsrz6",
    sj55zd: "ffmvakt",
    g2u3we: "fdmic9h",
    h3c5rm: ["f196y6m", "fetptd8"],
    B9xav0g: "f1pev5xq",
    zhjwy3: ["fetptd8", "f196y6m"]
  },
  "tint-warning": {
    De3pzq: "f10s6hli",
    sj55zd: "f42v8de",
    g2u3we: "fn9i3n",
    h3c5rm: ["f1aw8cx4", "f51if14"],
    B9xav0g: "fvq8iai",
    zhjwy3: ["f51if14", "f1aw8cx4"]
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", ".f130uwy9{font-size:4px;}", ".fod1mrr{line-height:4px;}", ".f18p0k4z{min-width:unset;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fpd43o0{width:10px;}", ".f30q22z{height:10px;}", ".f1tccstq{font-size:6px;}", ".f1y3arg5{line-height:6px;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fq2vo04{min-width:16px;}", ".fd461yt{height:16px;}", [".fupdldz{padding:0 calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f17fgpbq{min-width:24px;}", ".frvgh55{height:24px;}", [".f1996nqw{padding:0 calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".fwbmr0d{min-width:32px;}", ".f1d2rq10{height:32px;}", [".fty64o7{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f10ludwy::after{display:none;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1c73kur{background-color:var(--colorNeutralForeground1);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f3vzo32{background-color:var(--colorNeutralBackground5);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}", ".ffq97bm{background-color:var(--colorPaletteYellowBackground3);}", ".ff5vbop{color:var(--colorNeutralForeground1Static);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".f1l8vj45{color:var(--colorPaletteDarkOrangeForeground3);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1m7fhi8{color:var(--colorPaletteGreenForeground3);}", ".fpti2h4{color:var(--colorPaletteYellowForeground2);}", ".f23ftbb{border-top-color:currentColor;}", ".f1gkuv52{border-right-color:currentColor;}", ".f1p1bl80{border-left-color:currentColor;}", ".fioka3i{border-bottom-color:currentColor;}", ".fyqpifd{border-top-color:var(--colorPaletteRedBorder2);}", ".f3ukxca{border-right-color:var(--colorPaletteRedBorder2);}", ".f1k7dugc{border-left-color:var(--colorPaletteRedBorder2);}", ".f1njxb2b{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fq0vr37{border-top-color:var(--colorNeutralStrokeAccessible);}", ".f1byw159{border-right-color:var(--colorNeutralStrokeAccessible);}", ".f11cr0be{border-left-color:var(--colorNeutralStrokeAccessible);}", ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f68mrw8{border-top-color:var(--colorNeutralStroke2);}", ".f7pw515{border-right-color:var(--colorNeutralStroke2);}", ".fw35ms5{border-left-color:var(--colorNeutralStroke2);}", ".frpde29{border-bottom-color:var(--colorNeutralStroke2);}", ".f1mmhl11{border-top-color:var(--colorPaletteGreenBorder2);}", ".f1tjpp2f{border-right-color:var(--colorPaletteGreenBorder2);}", ".f1ocn5n7{border-left-color:var(--colorPaletteGreenBorder2);}", ".f1gjv25d{border-bottom-color:var(--colorPaletteGreenBorder2);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f161y7kd{border-top-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1619yhw{border-bottom-color:var(--colorBrandStroke2);}", ".ff0poqj{background-color:var(--colorPaletteRedBackground1);}", ".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1oqjm8o{border-top-color:var(--colorPaletteRedBorder1);}", ".fkgrb8g{border-right-color:var(--colorPaletteRedBorder1);}", ".frb5wm0{border-left-color:var(--colorPaletteRedBorder1);}", ".f1iai1ph{border-bottom-color:var(--colorPaletteRedBorder1);}", ".f945g0u{background-color:var(--colorNeutralForeground3);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f1xzsg4{background-color:var(--colorPaletteDarkOrangeBackground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".fxy9dsj{border-top-color:var(--colorPaletteDarkOrangeBorder1);}", ".f54u6j2{border-right-color:var(--colorPaletteDarkOrangeBorder1);}", ".fcm23ze{border-left-color:var(--colorPaletteDarkOrangeBorder1);}", ".f4vf0uq{border-bottom-color:var(--colorPaletteDarkOrangeBorder1);}", ".f2vsrz6{background-color:var(--colorPaletteGreenBackground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}", ".fdmic9h{border-top-color:var(--colorPaletteGreenBorder1);}", ".f196y6m{border-right-color:var(--colorPaletteGreenBorder1);}", ".fetptd8{border-left-color:var(--colorPaletteGreenBorder1);}", ".f1pev5xq{border-bottom-color:var(--colorPaletteGreenBorder1);}", ".f10s6hli{background-color:var(--colorPaletteYellowBackground1);}", ".f42v8de{color:var(--colorPaletteYellowForeground1);}", ".fn9i3n{border-top-color:var(--colorPaletteYellowBorder1);}", ".f1aw8cx4{border-right-color:var(--colorPaletteYellowBorder1);}", ".f51if14{border-left-color:var(--colorPaletteYellowBorder1);}", ".fvq8iai{border-bottom-color:var(--colorPaletteYellowBorder1);}"]
});
var useIconRootClassName = __resetStyles("rttl5z0", null, [".rttl5z0{display:flex;line-height:1;margin:0 calc(-1 * var(--spacingHorizontalXXS));font-size:12px;}"]);
var useIconStyles = __styles2({
  beforeText: {
    t21cq0: ["f1t8l4o1", "f11juvx6"]
  },
  afterText: {
    Frg6f3: ["f11juvx6", "f1t8l4o1"]
  },
  beforeTextXL: {
    t21cq0: ["f1rs9grm", "f1kwmkpi"]
  },
  afterTextXL: {
    Frg6f3: ["f1kwmkpi", "f1rs9grm"]
  },
  tiny: {
    Be2twd7: "f1tccstq"
  },
  "extra-small": {
    Be2twd7: "fnmn6fi"
  },
  small: {
    Be2twd7: "f1ugzwwg"
  },
  medium: {},
  large: {
    Be2twd7: "f4ybsrx"
  },
  "extra-large": {
    Be2twd7: "fe5j1ua"
  }
}, {
  d: [".f1t8l4o1{margin-right:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f11juvx6{margin-left:calc(var(--spacingHorizontalXXS) + var(--spacingHorizontalXXS));}", ".f1rs9grm{margin-right:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1kwmkpi{margin-left:calc(var(--spacingHorizontalXS) + var(--spacingHorizontalXXS));}", ".f1tccstq{font-size:6px;}", ".fnmn6fi{font-size:10px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
});
var useBadgeStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName();
  const rootStyles = useRootStyles();
  const smallToTiny = state.size === "small" || state.size === "extra-small" || state.size === "tiny";
  state.root.className = mergeClasses(badgeClassNames.root, rootClassName, smallToTiny && rootStyles.fontSmallToTiny, rootStyles[state.size], rootStyles[state.shape], state.shape === "rounded" && smallToTiny && rootStyles.roundedSmallToTiny, state.appearance === "ghost" && rootStyles.borderGhost, rootStyles[state.appearance], rootStyles[`${state.appearance}-${state.color}`], state.root.className);
  const iconRootClassName = useIconRootClassName();
  const iconStyles = useIconStyles();
  if (state.icon) {
    let iconPositionClass;
    if (React104.Children.toArray(state.root.children).length > 0) {
      if (state.size === "extra-large") {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterTextXL : iconStyles.beforeTextXL;
      } else {
        iconPositionClass = state.iconPosition === "after" ? iconStyles.afterText : iconStyles.beforeText;
      }
    }
    state.icon.className = mergeClasses(badgeClassNames.icon, iconRootClassName, iconPositionClass, iconStyles[state.size], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/Badge/renderBadge.js
var renderBadge_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.iconPosition === "before" && state.icon && jsx(state.icon, {}),
      state.root.children,
      state.iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-badge/lib/components/Badge/Badge.js
var Badge = React105.forwardRef((props, ref) => {
  const state = useBadge_unstable(props, ref);
  useBadgeStyles_unstable(state);
  useCustomStyleHook("useBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
Badge.displayName = "Badge";

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var React108 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var React107 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/presenceIcons.js
var React106 = __toESM(require_react());
var presenceAwayRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Regular,
  "extra-small": PresenceAway10Regular,
  small: PresenceAway12Regular,
  medium: PresenceAway16Regular,
  large: PresenceAway20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Regular
};
var presenceAwayFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAway10Filled,
  "extra-small": PresenceAway10Filled,
  small: PresenceAway12Filled,
  medium: PresenceAway16Filled,
  large: PresenceAway20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAway20Filled
};
var presenceAvailableRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Regular,
  "extra-small": PresenceAvailable10Regular,
  small: PresenceAvailable12Regular,
  medium: PresenceAvailable16Regular,
  large: PresenceAvailable20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Regular
};
var presenceAvailableFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceAvailable10Filled,
  "extra-small": PresenceAvailable10Filled,
  small: PresenceAvailable12Filled,
  medium: PresenceAvailable16Filled,
  large: PresenceAvailable20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceAvailable20Filled
};
var presenceBlockedRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBlocked10Regular,
  "extra-small": PresenceBlocked10Regular,
  small: PresenceBlocked12Regular,
  medium: PresenceBlocked16Regular,
  large: PresenceBlocked20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBlocked20Regular
};
var presenceBusyFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceBusy10Filled,
  "extra-small": PresenceBusy10Filled,
  small: PresenceBusy12Filled,
  medium: PresenceBusy16Filled,
  large: PresenceBusy20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceBusy20Filled
};
var presenceDndFilled = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Filled,
  "extra-small": PresenceDnd10Filled,
  small: PresenceDnd12Filled,
  medium: PresenceDnd16Filled,
  large: PresenceDnd20Filled,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Filled
};
var presenceDndRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceDnd10Regular,
  "extra-small": PresenceDnd10Regular,
  small: PresenceDnd12Regular,
  medium: PresenceDnd16Regular,
  large: PresenceDnd20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceDnd20Regular
};
var presenceOofRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOof10Regular,
  "extra-small": PresenceOof10Regular,
  small: PresenceOof12Regular,
  medium: PresenceOof16Regular,
  large: PresenceOof20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOof20Regular
};
var presenceOfflineRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceOffline10Regular,
  "extra-small": PresenceOffline10Regular,
  small: PresenceOffline12Regular,
  medium: PresenceOffline16Regular,
  large: PresenceOffline20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceOffline20Regular
};
var presenceUnknownRegular = {
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  tiny: PresenceUnknown10Regular,
  "extra-small": PresenceUnknown10Regular,
  small: PresenceUnknown12Regular,
  medium: PresenceUnknown16Regular,
  large: PresenceUnknown20Regular,
  // FIXME not all presence icon sizes are available
  // https://github.com/microsoft/fluentui/issues/20650
  "extra-large": PresenceUnknown20Regular
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadge.js
var iconMap = (status, outOfOffice, size3) => {
  switch (status) {
    case "available":
      return outOfOffice ? presenceAvailableRegular[size3] : presenceAvailableFilled[size3];
    case "away":
      return outOfOffice ? presenceOofRegular[size3] : presenceAwayFilled[size3];
    case "blocked":
      return presenceBlockedRegular[size3];
    case "busy":
      return outOfOffice ? presenceUnknownRegular[size3] : presenceBusyFilled[size3];
    case "do-not-disturb":
      return outOfOffice ? presenceDndRegular[size3] : presenceDndFilled[size3];
    case "offline":
      return outOfOffice ? presenceOofRegular[size3] : presenceOfflineRegular[size3];
    case "out-of-office":
      return presenceOofRegular[size3];
    case "unknown":
      return presenceUnknownRegular[size3];
  }
};
var DEFAULT_STRINGS = {
  busy: "busy",
  "out-of-office": "out of office",
  away: "away",
  available: "available",
  offline: "offline",
  "do-not-disturb": "do not disturb",
  unknown: "unknown",
  blocked: "blocked"
};
var usePresenceBadge_unstable = (props, ref) => {
  const { size: size3 = "medium", status = "available", outOfOffice = false } = props;
  const statusText = DEFAULT_STRINGS[status];
  const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS["out-of-office"]}` : "";
  const IconElement = iconMap(status, outOfOffice, size3);
  const state = {
    ...useBadge_unstable({
      "aria-label": statusText + oofText,
      role: "img",
      ...props,
      size: size3,
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: IconElement ? React107.createElement(IconElement, null) : null
        },
        renderByDefault: true,
        elementType: "span"
      })
    }, ref),
    status,
    outOfOffice
  };
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/usePresenceBadgeStyles.styles.js
var presenceBadgeClassNames = {
  root: "fui-PresenceBadge",
  icon: "fui-PresenceBadge__icon"
};
var getIsBusy = (status) => {
  if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
    return true;
  }
  return false;
};
var useRootClassName2 = __resetStyles("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
var useIconClassName = __resetStyles("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
var useStyles4 = __styles2({
  statusBusy: {
    sj55zd: "fvi85wt"
  },
  statusAway: {
    sj55zd: "f14k8a89"
  },
  statusAvailable: {
    sj55zd: "fqa5hgp"
  },
  statusOffline: {
    sj55zd: "f11d4kpn"
  },
  statusOutOfOffice: {
    sj55zd: "fdce8r3"
  },
  statusUnknown: {
    sj55zd: "f11d4kpn"
  },
  outOfOffice: {
    sj55zd: "fr0bkrk"
  },
  outOfOfficeAvailable: {
    sj55zd: "fqa5hgp"
  },
  outOfOfficeBusy: {
    sj55zd: "fvi85wt"
  },
  outOfOfficeUnknown: {
    sj55zd: "f11d4kpn"
  },
  tiny: {
    Bubjx69: "f9ikmtg",
    a9b677: "f16dn6v3",
    B2eet1l: "f1w2irj7",
    B5pe6w7: "fab5kbq",
    p4uzdd: "f1ms1d91"
  },
  large: {
    Bubjx69: "f9ikmtg",
    a9b677: "f64fuq3",
    B5pe6w7: "f1vfi1yj",
    p4uzdd: "f15s34gz"
  },
  extraLarge: {
    Bubjx69: "f9ikmtg",
    a9b677: "f1w9dchk",
    B5pe6w7: "f14efy9b",
    p4uzdd: "fhipgdu"
  }
}, {
  d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
});
var usePresenceBadgeStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName2();
  const iconClassName = useIconClassName();
  const styles = useStyles4();
  const isBusy = getIsBusy(state.status);
  state.root.className = mergeClasses(presenceBadgeClassNames.root, rootClassName, isBusy && styles.statusBusy, state.status === "away" && styles.statusAway, state.status === "available" && styles.statusAvailable, state.status === "offline" && styles.statusOffline, state.status === "out-of-office" && styles.statusOutOfOffice, state.status === "unknown" && styles.statusUnknown, state.outOfOffice && styles.outOfOffice, state.outOfOffice && state.status === "available" && styles.outOfOfficeAvailable, state.outOfOffice && isBusy && styles.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles.outOfOfficeUnknown, state.size === "tiny" && styles.tiny, state.size === "large" && styles.large, state.size === "extra-large" && styles.extraLarge, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/PresenceBadge/PresenceBadge.js
var PresenceBadge = React108.forwardRef((props, ref) => {
  const state = usePresenceBadge_unstable(props, ref);
  usePresenceBadgeStyles_unstable(state);
  useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
PresenceBadge.displayName = "PresenceBadge";

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var React110 = __toESM(require_react());

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadge.js
var React109 = __toESM(require_react());
var useCounterBadge_unstable = (props, ref) => {
  const { shape = "circular", appearance = "filled", showZero = false, overflowCount = 99, count = 0, dot = false } = props;
  const state = {
    ...useBadge_unstable(props, ref),
    shape,
    appearance,
    showZero,
    count,
    dot
  };
  if ((count !== 0 || showZero) && !dot && !state.root.children) {
    state.root.children = count > overflowCount ? `${overflowCount}+` : `${count}`;
  }
  return state;
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/useCounterBadgeStyles.styles.js
var counterBadgeClassNames = {
  root: "fui-CounterBadge",
  icon: "fui-CounterBadge__icon"
};
var useStyles5 = __styles2({
  dot: {
    Bf4jedk: "fgfkb25",
    a9b677: "f16dn6v3",
    Bqenvij: "f3mu39s",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai"
  },
  hide: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".fgfkb25{min-width:auto;}", ".f16dn6v3{width:6px;}", ".f3mu39s{height:6px;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".fjseox{display:none;}"]
});
var useCounterBadgeStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles5();
  state.root.className = mergeClasses(counterBadgeClassNames.root, state.dot && styles.dot, !state.root.children && !state.dot && styles.hide, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(counterBadgeClassNames.icon, state.icon.className);
  }
  return useBadgeStyles_unstable(state);
};

// node_modules/@fluentui/react-badge/lib/components/CounterBadge/CounterBadge.js
var CounterBadge = React110.forwardRef((props, ref) => {
  const state = useCounterBadge_unstable(props, ref);
  useCounterBadgeStyles_unstable(state);
  useCustomStyleHook("useCounterBadgeStyles_unstable")(state);
  return renderBadge_unstable(state);
});
CounterBadge.displayName = "CounterBadge";

// node_modules/@fluentui/react-avatar/lib/contexts/AvatarContext.js
var React111 = __toESM(require_react());
var avatarContext = React111.createContext(void 0);
var avatarContextDefaultValue = {};
var AvatarContextProvider = avatarContext.Provider;
var useAvatarContext = () => {
  var _React_useContext;
  return (_React_useContext = React111.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatar.js
var DEFAULT_STRINGS2 = {
  active: "active",
  inactive: "inactive"
};
var useAvatar_unstable = (props, ref) => {
  const { dir } = useFluent();
  const { shape: contextShape, size: contextSize } = useAvatarContext();
  const { name, size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
  let { color: color2 = "neutral" } = props;
  if (color2 === "colorful") {
    var _ref;
    color2 = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
  }
  const baseId = useId2("avatar-");
  const root = slot_exports.always(getIntrinsicElementProps(
    "span",
    {
      role: "img",
      id: baseId,
      // aria-label and/or aria-labelledby are resolved below
      ...props,
      ref
    },
    /* excludedPropNames: */
    [
      "name"
    ]
  ), {
    elementType: "span"
  });
  const [imageHidden, setImageHidden] = React112.useState(void 0);
  let image = slot_exports.optional(props.image, {
    defaultProps: {
      alt: "",
      role: "presentation",
      "aria-hidden": true,
      hidden: imageHidden
    },
    elementType: "img"
  });
  if (!(image === null || image === void 0 ? void 0 : image.src)) {
    image = void 0;
  }
  if (image) {
    image.onError = mergeCallbacks(image.onError, () => setImageHidden(true));
    image.onLoad = mergeCallbacks(image.onLoad, () => setImageHidden(void 0));
  }
  let initials = slot_exports.optional(props.initials, {
    renderByDefault: true,
    defaultProps: {
      children: getInitials(name, dir === "rtl", {
        firstInitialOnly: size3 <= 16
      }),
      id: baseId + "__initials"
    },
    elementType: "span"
  });
  if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
    initials = void 0;
  }
  let icon = void 0;
  if (!initials && (!image || imageHidden)) {
    icon = slot_exports.optional(props.icon, {
      renderByDefault: true,
      defaultProps: {
        children: React112.createElement(PersonRegular, null),
        "aria-hidden": true
      },
      elementType: "span"
    });
  }
  const badge = slot_exports.optional(props.badge, {
    defaultProps: {
      size: getBadgeSize(size3),
      id: baseId + "__badge"
    },
    elementType: PresenceBadge
  });
  let activeAriaLabelElement;
  if (!root["aria-label"] && !root["aria-labelledby"]) {
    if (name) {
      root["aria-label"] = name;
      if (badge) {
        root["aria-labelledby"] = root.id + " " + badge.id;
      }
    } else if (initials) {
      root["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
    }
    if (active === "active" || active === "inactive") {
      const activeText = DEFAULT_STRINGS2[active];
      if (root["aria-labelledby"]) {
        const activeId = baseId + "__active";
        root["aria-labelledby"] += " " + activeId;
        activeAriaLabelElement = React112.createElement("span", {
          hidden: true,
          id: activeId
        }, activeText);
      } else if (root["aria-label"]) {
        root["aria-label"] += " " + activeText;
      }
    }
  }
  return {
    size: size3,
    shape,
    active,
    activeAppearance,
    activeAriaLabelElement,
    color: color2,
    components: {
      root: "span",
      initials: "span",
      icon: "span",
      image: "img",
      badge: PresenceBadge
    },
    root,
    initials,
    icon,
    image,
    badge
  };
};
var getBadgeSize = (size3) => {
  if (size3 >= 96) {
    return "extra-large";
  } else if (size3 >= 64) {
    return "large";
  } else if (size3 >= 56) {
    return "medium";
  } else if (size3 >= 40) {
    return "small";
  } else if (size3 >= 28) {
    return "extra-small";
  } else {
    return "tiny";
  }
};
var avatarColors = [
  "dark-red",
  "cranberry",
  "red",
  "pumpkin",
  "peach",
  "marigold",
  "gold",
  "brass",
  "brown",
  "forest",
  "seafoam",
  "dark-green",
  "light-teal",
  "teal",
  "steel",
  "blue",
  "royal-blue",
  "cornflower",
  "navy",
  "lavender",
  "purple",
  "grape",
  "lilac",
  "pink",
  "magenta",
  "plum",
  "beige",
  "mink",
  "platinum",
  "anchor"
];
var getHashCode = (str) => {
  let hashCode = 0;
  for (let len = str.length - 1; len >= 0; len--) {
    const ch = str.charCodeAt(len);
    const shift4 = len % 8;
    hashCode ^= (ch << shift4) + (ch >> 8 - shift4);
  }
  return hashCode;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/useAvatarStyles.styles.js
var avatarClassNames = {
  root: "fui-Avatar",
  image: "fui-Avatar__image",
  initials: "fui-Avatar__initials",
  icon: "fui-Avatar__icon",
  badge: "fui-Avatar__badge"
};
var useRootClassName3 = __resetStyles("r81b29z", "r1aatmv", {
  r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
});
var useImageClassName = __resetStyles("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
var useIconInitialsClassName = __resetStyles("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:inherit;}"]);
var useStyles6 = __styles2({
  textCaption2Strong: {
    Be2twd7: "f13mqy1h"
  },
  textCaption1Strong: {
    Be2twd7: "fy9rknc"
  },
  textSubtitle2: {
    Be2twd7: "fod5ikn"
  },
  textSubtitle1: {
    Be2twd7: "f1pp30po"
  },
  textTitle3: {
    Be2twd7: "f1x0m3f5"
  },
  squareSmall: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  squareMedium: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  squareLarge: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1o0qvyv"
  },
  squareXLarge: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu"
  },
  activeOrInactive: {
    Bz10aip: "ftfx35i",
    Bmy1vo4: "fv0atk9",
    B3o57yi: "f1iry5bo",
    Bkqvd7p: "f15n41j8",
    Bg24rqe: "f9ttr0w"
  },
  ring: {
    Ftih45: "f1wl9k8s"
  },
  ringBadgeCutout: {
    f4a502: "fp2gujx"
  },
  ringThick: {
    of393c: "fq1w1vq"
  },
  ringThicker: {
    of393c: "fzg6ace"
  },
  ringThickest: {
    of393c: "f1nu8p71"
  },
  shadow: {
    Bsft5z2: "f13zj6fq"
  },
  shadow4: {
    Be6vj1x: "fcjn15l"
  },
  shadow8: {
    Be6vj1x: "f1tm8t9f"
  },
  shadow16: {
    Be6vj1x: "f1a1aohj"
  },
  shadow28: {
    Be6vj1x: "fond6v5"
  },
  inactive: {
    abs64n: "fp25eh",
    Bz10aip: "f1clczzi",
    Bkqvd7p: "f1l3s34x",
    Bfgortx: 0,
    Bnvr3x9: 0,
    b2tv09: 0,
    Bucmhp4: 0,
    iayac2: "flkahu5",
    b6ubon: "fw457kn",
    Bqinb2h: "f1wmllxl"
  },
  badge: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1yab3r1",
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  badgeCutout: {
    btxmck: "f1eugkqs"
  },
  badgeAlign: {
    Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
  },
  tiny: {
    Bdjeniz: "f1uwoubl",
    niu6jh: "fid048z"
  },
  "extra-small": {
    Bdjeniz: "f13ar0e0",
    niu6jh: "fid048z"
  },
  small: {
    Bdjeniz: "fwwuruf",
    niu6jh: "fid048z"
  },
  medium: {
    Bdjeniz: "f1af27q5",
    niu6jh: "fid048z"
  },
  large: {
    Bdjeniz: "f18yy57a",
    niu6jh: "f924bxt"
  },
  "extra-large": {
    Bdjeniz: "f2jg042",
    niu6jh: "f924bxt"
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  }
}, {
  d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1o0qvyv{border-radius:var(--borderRadiusLarge);}", {
    p: -1
  }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", [".flkahu5::before,.flkahu5::after{margin:0;}", {
    p: -1
  }], ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f9ttr0w{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]]
});
var useSizeStyles = __styles2({
  "16": {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  "20": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "24": {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  "28": {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  "32": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  },
  "36": {
    a9b677: "fpdz1er",
    Bqenvij: "f8ljn23"
  },
  "40": {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac"
  },
  "48": {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  },
  "56": {
    a9b677: "f1u66zr1",
    Bqenvij: "fzki0ko"
  },
  "64": {
    a9b677: "fa9ln6p",
    Bqenvij: "f16k9i2m"
  },
  "72": {
    a9b677: "fhcae8x",
    Bqenvij: "f1shusfg"
  },
  "96": {
    a9b677: "f1kyr2gn",
    Bqenvij: "fypu0ge"
  },
  "120": {
    a9b677: "fwfqyga",
    Bqenvij: "fjr5b71"
  },
  "128": {
    a9b677: "f1iksgmy",
    Bqenvij: "fele2au"
  }
}, {
  d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
});
var useColorStyles = __styles2({
  neutral: {
    sj55zd: "f11d4kpn",
    De3pzq: "f18f03hv"
  },
  brand: {
    sj55zd: "fonrgv7",
    De3pzq: "f1blnnmj"
  },
  "dark-red": {
    sj55zd: "fqjd1y1",
    De3pzq: "f1vq2oo4"
  },
  cranberry: {
    sj55zd: "fg9gses",
    De3pzq: "f1lwxszt"
  },
  red: {
    sj55zd: "f23f7i0",
    De3pzq: "f1q9qhfq"
  },
  pumpkin: {
    sj55zd: "fjnan08",
    De3pzq: "fz91bi3"
  },
  peach: {
    sj55zd: "fknu15p",
    De3pzq: "f1b9nr51"
  },
  marigold: {
    sj55zd: "f9603vw",
    De3pzq: "f3z4w6d"
  },
  gold: {
    sj55zd: "fmq0uwp",
    De3pzq: "fg50kya"
  },
  brass: {
    sj55zd: "f28g5vo",
    De3pzq: "f4w2gd0"
  },
  brown: {
    sj55zd: "ftl572b",
    De3pzq: "f14wu1f4"
  },
  forest: {
    sj55zd: "f1gymlvd",
    De3pzq: "f19ut4y6"
  },
  seafoam: {
    sj55zd: "fnnb6wn",
    De3pzq: "f1n057jc"
  },
  "dark-green": {
    sj55zd: "ff58qw8",
    De3pzq: "f11t05wk"
  },
  "light-teal": {
    sj55zd: "f1up9qbj",
    De3pzq: "f42feg1"
  },
  teal: {
    sj55zd: "f135dsb4",
    De3pzq: "f6hvv1p"
  },
  steel: {
    sj55zd: "f151dlcp",
    De3pzq: "f1lnp8zf"
  },
  blue: {
    sj55zd: "f1rjv50u",
    De3pzq: "f1ggcpy6"
  },
  "royal-blue": {
    sj55zd: "f1emykk5",
    De3pzq: "f12rj61f"
  },
  cornflower: {
    sj55zd: "fqsigj7",
    De3pzq: "f8k7hur"
  },
  navy: {
    sj55zd: "f1nj97xi",
    De3pzq: "f19gw0ux"
  },
  lavender: {
    sj55zd: "fwctg0i",
    De3pzq: "ff379vm"
  },
  purple: {
    sj55zd: "fjrsgpu",
    De3pzq: "f1mzf1e1"
  },
  grape: {
    sj55zd: "f1fiiydq",
    De3pzq: "f1o4k8oy"
  },
  lilac: {
    sj55zd: "f1res9jt",
    De3pzq: "f1x6mz1o"
  },
  pink: {
    sj55zd: "fv3fbbi",
    De3pzq: "fydlv6t"
  },
  magenta: {
    sj55zd: "f1f1fwnz",
    De3pzq: "f4xb6j5"
  },
  plum: {
    sj55zd: "f8ptl6j",
    De3pzq: "fqo8e26"
  },
  beige: {
    sj55zd: "f1ntv3ld",
    De3pzq: "f101elhj"
  },
  mink: {
    sj55zd: "f1fscmp",
    De3pzq: "f13g8o5c"
  },
  platinum: {
    sj55zd: "f1dr00v2",
    De3pzq: "fkh7blw"
  },
  anchor: {
    sj55zd: "f1f3ti53",
    De3pzq: "fu4yj0j"
  }
}, {
  d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
});
var useRingColorStyles = __styles2({
  neutral: {
    Bic5iru: "f1uuiafn"
  },
  brand: {
    Bic5iru: "f1uuiafn"
  },
  "dark-red": {
    Bic5iru: "f1t2x9on"
  },
  cranberry: {
    Bic5iru: "f1pvshc9"
  },
  red: {
    Bic5iru: "f1ectbk9"
  },
  pumpkin: {
    Bic5iru: "fvzpl0b"
  },
  peach: {
    Bic5iru: "fwj2kd7"
  },
  marigold: {
    Bic5iru: "fr120vy"
  },
  gold: {
    Bic5iru: "f8xmmar"
  },
  brass: {
    Bic5iru: "f1hbety2"
  },
  brown: {
    Bic5iru: "f1vg3s4g"
  },
  forest: {
    Bic5iru: "f1m3olm5"
  },
  seafoam: {
    Bic5iru: "f17xiqtr"
  },
  "dark-green": {
    Bic5iru: "fx32vyh"
  },
  "light-teal": {
    Bic5iru: "f1mkihwv"
  },
  teal: {
    Bic5iru: "fecnooh"
  },
  steel: {
    Bic5iru: "f15hfgzm"
  },
  blue: {
    Bic5iru: "fqproka"
  },
  "royal-blue": {
    Bic5iru: "f17v2w59"
  },
  cornflower: {
    Bic5iru: "fp0q1mo"
  },
  navy: {
    Bic5iru: "f1nlym55"
  },
  lavender: {
    Bic5iru: "f62vk8h"
  },
  purple: {
    Bic5iru: "f15zl69q"
  },
  grape: {
    Bic5iru: "f53w4j7"
  },
  lilac: {
    Bic5iru: "fu2771t"
  },
  pink: {
    Bic5iru: "fzflscs"
  },
  magenta: {
    Bic5iru: "fb6rmqc"
  },
  plum: {
    Bic5iru: "f1a4gm5b"
  },
  beige: {
    Bic5iru: "f1qpf9z1"
  },
  mink: {
    Bic5iru: "f1l7or83"
  },
  platinum: {
    Bic5iru: "fzrj0iu"
  },
  anchor: {
    Bic5iru: "f8oz6wf"
  }
}, {
  d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
});
var useAvatarStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    shape,
    active,
    activeAppearance,
    color: color2
  } = state;
  const rootClassName = useRootClassName3();
  const imageClassName = useImageClassName();
  const iconInitialsClassName = useIconInitialsClassName();
  const styles = useStyles6();
  const sizeStyles = useSizeStyles();
  const colorStyles = useColorStyles();
  const ringColorStyles = useRingColorStyles();
  const rootClasses = [rootClassName, size3 !== 32 && sizeStyles[size3]];
  if (state.badge) {
    rootClasses.push(styles.badgeAlign, styles[state.badge.size || "medium"]);
  }
  if (size3 <= 24) {
    rootClasses.push(styles.textCaption2Strong);
  } else if (size3 <= 28) {
    rootClasses.push(styles.textCaption1Strong);
  } else if (size3 <= 40) {
  } else if (size3 <= 56) {
    rootClasses.push(styles.textSubtitle2);
  } else if (size3 <= 96) {
    rootClasses.push(styles.textSubtitle1);
  } else {
    rootClasses.push(styles.textTitle3);
  }
  if (shape === "square") {
    if (size3 <= 24) {
      rootClasses.push(styles.squareSmall);
    } else if (size3 <= 48) {
      rootClasses.push(styles.squareMedium);
    } else if (size3 <= 72) {
      rootClasses.push(styles.squareLarge);
    } else {
      rootClasses.push(styles.squareXLarge);
    }
  }
  if (active === "active" || active === "inactive") {
    rootClasses.push(styles.activeOrInactive);
    if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.ring, ringColorStyles[color2]);
      if (state.badge) {
        rootClasses.push(styles.ringBadgeCutout);
      }
      if (size3 <= 48) {
        rootClasses.push(styles.ringThick);
      } else if (size3 <= 64) {
        rootClasses.push(styles.ringThicker);
      } else {
        rootClasses.push(styles.ringThickest);
      }
    }
    if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
      rootClasses.push(styles.shadow);
      if (size3 <= 28) {
        rootClasses.push(styles.shadow4);
      } else if (size3 <= 48) {
        rootClasses.push(styles.shadow8);
      } else if (size3 <= 64) {
        rootClasses.push(styles.shadow16);
      } else {
        rootClasses.push(styles.shadow28);
      }
    }
    if (active === "inactive") {
      rootClasses.push(styles.inactive);
    }
  }
  state.root.className = mergeClasses(avatarClassNames.root, ...rootClasses, state.root.className);
  if (state.badge) {
    state.badge.className = mergeClasses(avatarClassNames.badge, styles.badge, state.badge.className);
  }
  if (state.image) {
    state.image.className = mergeClasses(avatarClassNames.image, imageClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.image.className);
  }
  if (state.initials) {
    state.initials.className = mergeClasses(avatarClassNames.initials, iconInitialsClassName, colorStyles[color2], state.badge && styles.badgeCutout, state.initials.className);
  }
  if (state.icon) {
    let iconSizeClass;
    if (size3 <= 16) {
      iconSizeClass = styles.icon12;
    } else if (size3 <= 24) {
      iconSizeClass = styles.icon16;
    } else if (size3 <= 40) {
      iconSizeClass = styles.icon20;
    } else if (size3 <= 48) {
      iconSizeClass = styles.icon24;
    } else if (size3 <= 56) {
      iconSizeClass = styles.icon28;
    } else if (size3 <= 72) {
      iconSizeClass = styles.icon32;
    } else {
      iconSizeClass = styles.icon48;
    }
    state.icon.className = mergeClasses(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color2], state.badge && styles.badgeCutout, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/Avatar/Avatar.js
var Avatar = React113.forwardRef((props, ref) => {
  const state = useAvatar_unstable(props, ref);
  useAvatarStyles_unstable(state);
  useCustomStyleHook("useAvatarStyles_unstable")(state);
  return renderAvatar_unstable(state);
});
Avatar.displayName = "Avatar";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var React115 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/contexts/AvatarGroupContext.js
var AvatarGroupContext = createContext13(void 0);
var avatarGroupContextDefaultValue = {};
var AvatarGroupProvider = AvatarGroupContext.Provider;
var useAvatarGroupContext_unstable = (selector) => useContextSelector(AvatarGroupContext, (ctx = avatarGroupContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/renderAvatarGroup.js
var renderAvatarGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(AvatarGroupProvider, {
    value: contextValues.avatarGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroup.js
var React114 = __toESM(require_react());
var useAvatarGroup_unstable = (props, ref) => {
  const { layout = "spread", size: size3 = defaultAvatarGroupSize } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    role: "group",
    ...props,
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref
  }, [
    "size"
  ]), {
    elementType: "div"
  });
  return {
    layout,
    size: size3,
    components: {
      root: "div"
    },
    root
  };
};
var defaultAvatarGroupSize = 32;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupContextValues.js
var useAvatarGroupContextValues = (state) => {
  const { layout, size: size3 } = state;
  const avatarGroup = {
    layout,
    size: size3
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/useAvatarGroupStyles.styles.js
var avatarGroupClassNames = {
  root: "fui-AvatarGroup"
};
var useStyles7 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n"
  },
  pie: {
    Bgl5zvf: "f1uz6ud1",
    De3pzq: "f1ganh6p",
    By8wz76: "f1wgxgin"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".f1uz6ud1{clip-path:circle(50%);}", ".f1ganh6p{background-color:var(--colorTransparentStroke);}"],
  m: [["@media (forced-colors: active){.f1wgxgin{background-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useAvatarGroupStyles_unstable = (state) => {
  "use no memo";
  const {
    layout,
    size: size3
  } = state;
  const styles = useStyles7();
  const sizeStyles = useSizeStyles();
  state.root.className = mergeClasses(avatarGroupClassNames.root, styles.base, layout === "pie" && sizeStyles[size3], layout === "pie" && styles.pie, state.root.className);
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroup/AvatarGroup.js
var AvatarGroup = React115.forwardRef((props, ref) => {
  const state = useAvatarGroup_unstable(props, ref);
  const contextValues = useAvatarGroupContextValues(state);
  useAvatarGroupStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupStyles_unstable")(state);
  return renderAvatarGroup_unstable(state, contextValues);
});
AvatarGroup.displayName = "AvatarGroup";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var React117 = __toESM(require_react());

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/renderAvatarGroupItem.js
var renderAvatarGroupItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.avatar, {}),
      state.isOverflowItem && jsx(state.overflowLabel, {})
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItem.js
var React116 = __toESM(require_react());
var useAvatarGroupItem_unstable = (props, ref) => {
  const groupIsOverflow = useAvatarGroupContext_unstable((ctx) => ctx.isOverflow);
  const groupSize = useAvatarGroupContext_unstable((ctx) => ctx.size);
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { style, className, ...avatarSlotProps } = props;
  const size3 = groupSize !== null && groupSize !== void 0 ? groupSize : defaultAvatarGroupSize;
  const hasAvatarGroupContext = useHasParentContext(AvatarGroupContext);
  if (!hasAvatarGroupContext) {
    console.warn("AvatarGroupItem must only be used inside an AvatarGroup component.");
  }
  return {
    isOverflowItem: groupIsOverflow,
    layout,
    size: size3,
    components: {
      root: groupIsOverflow ? "li" : "div",
      avatar: Avatar,
      overflowLabel: "span"
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        style,
        className
      },
      elementType: groupIsOverflow ? "li" : "div"
    }),
    avatar: slot_exports.always(props.avatar, {
      defaultProps: {
        ref,
        size: size3,
        color: "colorful",
        ...avatarSlotProps
      },
      elementType: Avatar
    }),
    overflowLabel: slot_exports.always(props.overflowLabel, {
      defaultProps: {
        // Avatar already has its aria-label set to the name, this will prevent the name to be read twice.
        "aria-hidden": true,
        children: props.name
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/useAvatarGroupItemStyles.styles.js
var avatarGroupItemClassNames = {
  root: "fui-AvatarGroupItem",
  avatar: "fui-AvatarGroupItem__avatar",
  overflowLabel: "fui-AvatarGroupItem__overflowLabel"
};
var useRootStyles2 = __styles2({
  base: {
    Bt984gj: "f122n59",
    mc9l5x: "ftuwxu6",
    Bnnss6s: "fi64zpg",
    qhf8xq: "f10pi13n"
  },
  overflowItem: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd"
  },
  nonOverflowItem: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  }
}, {
  d: [".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fi64zpg{flex-shrink:0;}", ".f10pi13n{position:relative;}", [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useAvatarStyles = __styles2({
  nonOverflowItem: {
    qhf8xq: "f1euv43f"
  },
  pie: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  }
}, {
  d: [".f1euv43f{position:absolute;}", [".fokr779{border-radius:0;}", {
    p: -1
  }]]
});
var useOverflowLabelStyles = __styles2({
  base: {
    Frg6f3: ["foyynoy", "f1vcna3q"],
    sj55zd: "f19n0e5",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".foyynoy{margin-left:var(--spacingHorizontalS);}", ".f1vcna3q{margin-right:var(--spacingHorizontalS);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useStackStyles = __styles2({
  thick: {
    E5pizo: "foiuzp5"
  },
  thicker: {
    E5pizo: "f1x6o7w7"
  },
  thickest: {
    E5pizo: "f2aml1u"
  },
  xxs: {
    jhia2w: ["f1cjco14", "f13dxjc9"]
  },
  xs: {
    jhia2w: ["f15p6bln", "f1bab3ru"]
  },
  s: {
    jhia2w: ["f1v53ncc", "f17pu8r8"]
  },
  l: {
    jhia2w: ["flv48ch", "fnh1ydj"]
  }
}, {
  d: [".foiuzp5{box-shadow:0 0 0 var(--strokeWidthThick) var(--colorNeutralBackground2);}", ".f1x6o7w7{box-shadow:0 0 0 var(--strokeWidthThicker) var(--colorNeutralBackground2);}", ".f2aml1u{box-shadow:0 0 0 var(--strokeWidthThickest) var(--colorNeutralBackground2);}", ".f1cjco14:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXXS));}", ".f13dxjc9:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXXS));}", ".f15p6bln:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalXS));}", ".f1bab3ru:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalXS));}", ".f1v53ncc:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalS));}", ".f17pu8r8:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalS));}", ".flv48ch:not(:first-child){margin-left:calc(-1 * var(--spacingHorizontalL));}", ".fnh1ydj:not(:first-child){margin-right:calc(-1 * var(--spacingHorizontalL));}"]
});
var useSpreadStyles = __styles2({
  s: {
    jhia2w: ["f7lhxv7", "f6ou2b0"]
  },
  mNudge: {
    jhia2w: ["f1h0okno", "fnnqava"]
  },
  m: {
    jhia2w: ["f1wkt588", "f1maio5g"]
  },
  l: {
    jhia2w: ["f1l333zn", "f1r41m4c"]
  },
  xl: {
    jhia2w: ["fahr13a", "f2n7rbo"]
  }
}, {
  d: [".f7lhxv7:not(:first-child){margin-left:var(--spacingHorizontalS);}", ".f6ou2b0:not(:first-child){margin-right:var(--spacingHorizontalS);}", ".f1h0okno:not(:first-child){margin-left:var(--spacingHorizontalMNudge);}", ".fnnqava:not(:first-child){margin-right:var(--spacingHorizontalMNudge);}", ".f1wkt588:not(:first-child){margin-left:var(--spacingHorizontalM);}", ".f1maio5g:not(:first-child){margin-right:var(--spacingHorizontalM);}", ".f1l333zn:not(:first-child){margin-left:var(--spacingHorizontalL);}", ".f1r41m4c:not(:first-child){margin-right:var(--spacingHorizontalL);}", ".fahr13a:not(:first-child){margin-left:var(--spacingHorizontalXL);}", ".f2n7rbo:not(:first-child){margin-right:var(--spacingHorizontalXL);}"]
});
var usePieStyles = __styles2({
  base: {
    qhf8xq: "f1euv43f"
  },
  slices: {
    B3gf25r: "f16m7w7k",
    Be2twx7: ["f1o4hhgz", "fb4gjrz"],
    Bvaow4n: "f1pgb5nx",
    Gpecfs: ["fugirid", "f4sk99m"],
    bhabj1: "fjreaf3",
    B7rc6i7: ["f1k4vw81", "f1w1xcy7"],
    Bwrfys5: "f1ef8vxk",
    Bwuzm9m: ["f1x2qbfv", "f1xwf4nz"],
    fflka: "ff6xuso",
    do7bja: "fzpvk6c",
    Be8zqhl: "f4onu7f",
    Bij0kh0: ["f1ydfez1", "fjensob"],
    Bwexnyt: "f1yv732j",
    Bhe5x6o: "fchq2fj",
    B3kv7bh: "ff5binh"
  },
  rtlSlices: {
    B3gf25r: "f5vdl61",
    Bvaow4n: "f1bnra92",
    bhabj1: "f4ibo7t",
    Bwrfys5: "f17heuis",
    Bwuzm9m: ["f64f2ud", "f1yjglu3"],
    Be8zqhl: "fa6l61x",
    Bij0kh0: ["f1w2396a", "f14ab3yo"]
  },
  thick: {
    uiicq7: "fnyfzln"
  },
  thicker: {
    uiicq7: "f1xdzzot"
  },
  thickest: {
    uiicq7: "f1auhru5"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f16m7w7k:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1o4hhgz:nth-of-type(1):nth-last-of-type(2){left:-25%;}", ".fb4gjrz:nth-of-type(1):nth-last-of-type(2){right:-25%;}", ".f1pgb5nx:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".fugirid:nth-of-type(2):nth-last-of-type(1){left:25%;}", ".f4sk99m:nth-of-type(2):nth-last-of-type(1){right:25%;}", ".fjreaf3:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f1k4vw81:nth-of-type(1):nth-last-of-type(3){left:-25%;}", ".f1w1xcy7:nth-of-type(1):nth-last-of-type(3){right:-25%;}", ".f1ef8vxk:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width));}", ".f1x2qbfv:nth-of-type(2):nth-last-of-type(2){left:50%;}", ".f1xwf4nz:nth-of-type(2):nth-last-of-type(2){right:50%;}", ".ff6xuso:nth-of-type(2):nth-last-of-type(2){transform:scale(0.5);}", ".fzpvk6c:nth-of-type(2):nth-last-of-type(2){transform-origin:0 0;}", ".f4onu7f:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) 0 0 var(--fuiAvatarGroupItem__divider--width));}", ".f1ydfez1:nth-of-type(3):nth-last-of-type(1){left:50%;}", ".fjensob:nth-of-type(3):nth-last-of-type(1){right:50%;}", ".f1yv732j:nth-of-type(3):nth-last-of-type(1){top:50%;}", ".fchq2fj:nth-of-type(3):nth-last-of-type(1){transform:scale(0.5);}", ".ff5binh:nth-of-type(3):nth-last-of-type(1){transform-origin:0 0;}", ".f5vdl61:nth-of-type(1):nth-last-of-type(2){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f1bnra92:nth-of-type(2):nth-last-of-type(1){clip-path:inset(0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)) 0 25%);}", ".f4ibo7t:nth-of-type(1):nth-last-of-type(3){clip-path:inset(0 25% 0 calc(25% + (var(--fuiAvatarGroupItem__divider--width) / 2)));}", ".f17heuis:nth-of-type(2):nth-last-of-type(2){clip-path:inset(0 var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0);}", ".f64f2ud:nth-of-type(2):nth-last-of-type(2){left:0;}", ".f1yjglu3:nth-of-type(2):nth-last-of-type(2){right:0;}", ".fa6l61x:nth-of-type(3):nth-last-of-type(1){clip-path:inset(var(--fuiAvatarGroupItem__divider--width) var(--fuiAvatarGroupItem__divider--width) 0 0);}", ".f1w2396a:nth-of-type(3):nth-last-of-type(1){left:0;}", ".f14ab3yo:nth-of-type(3):nth-last-of-type(1){right:0;}", ".fnyfzln{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThick);}", ".f1xdzzot{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThicker);}", ".f1auhru5{--fuiAvatarGroupItem__divider--width:var(--strokeWidthThickest);}"]
});
var useAvatarGroupItemStyles_unstable = (state) => {
  "use no memo";
  const {
    isOverflowItem,
    layout,
    size: size3
  } = state;
  const {
    dir
  } = useFluent();
  const avatarStyles = useAvatarStyles();
  const overflowLabelStyles = useOverflowLabelStyles();
  const pieStyles = usePieStyles();
  const rootStyles = useRootStyles2();
  const sizeStyles = useSizeStyles();
  const groupChildClassName = useGroupChildClassName(layout, size3);
  const rootClasses = [rootStyles.base];
  if (!isOverflowItem) {
    rootClasses.push(rootStyles.nonOverflowItem);
    rootClasses.push(groupChildClassName);
    rootClasses.push(sizeStyles[size3]);
    if (layout === "pie") {
      rootClasses.push(pieStyles.base);
      if (size3 < 56) {
        rootClasses.push(pieStyles.thick);
      } else if (size3 < 72) {
        rootClasses.push(pieStyles.thicker);
      } else {
        rootClasses.push(pieStyles.thickest);
      }
      rootClasses.push(pieStyles.slices);
      if (dir === "rtl") {
        rootClasses.push(pieStyles.rtlSlices);
      }
    }
  } else {
    rootClasses.push(rootStyles.overflowItem);
  }
  state.root.className = mergeClasses(avatarGroupItemClassNames.root, ...rootClasses, state.root.className);
  state.avatar.className = mergeClasses(avatarGroupItemClassNames.avatar, !isOverflowItem && avatarStyles.nonOverflowItem, layout === "pie" && avatarStyles.pie, state.avatar.className);
  if (state.overflowLabel) {
    state.overflowLabel.className = mergeClasses(avatarGroupItemClassNames.overflowLabel, overflowLabelStyles.base, state.overflowLabel.className);
  }
  return state;
};
var useGroupChildClassName = (layout, size3) => {
  const stackStyles = useStackStyles();
  const spreadStyles = useSpreadStyles();
  const layoutClasses = [];
  if (size3) {
    if (layout === "stack") {
      if (size3 < 56) {
        layoutClasses.push(stackStyles.thick);
      } else if (size3 < 72) {
        layoutClasses.push(stackStyles.thicker);
      } else {
        layoutClasses.push(stackStyles.thickest);
      }
      if (size3 < 24) {
        layoutClasses.push(stackStyles.xxs);
      } else if (size3 < 48) {
        layoutClasses.push(stackStyles.xs);
      } else if (size3 < 96) {
        layoutClasses.push(stackStyles.s);
      } else {
        layoutClasses.push(stackStyles.l);
      }
    } else if (layout === "spread") {
      if (size3 < 20) {
        layoutClasses.push(spreadStyles.s);
      } else if (size3 < 32) {
        layoutClasses.push(spreadStyles.mNudge);
      } else if (size3 < 64) {
        layoutClasses.push(spreadStyles.l);
      } else {
        layoutClasses.push(spreadStyles.xl);
      }
    }
  }
  return mergeClasses(...layoutClasses);
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupItem/AvatarGroupItem.js
var AvatarGroupItem = React117.forwardRef((props, ref) => {
  const state = useAvatarGroupItem_unstable(props, ref);
  useAvatarGroupItemStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupItemStyles_unstable")(state);
  return renderAvatarGroupItem_unstable(state);
});
AvatarGroupItem.displayName = "AvatarGroupItem";

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var React141 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var React134 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var React132 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/createVirtualElementFromClick.js
function createVirtualElementFromClick(nativeEvent) {
  const left2 = nativeEvent.clientX;
  const top = nativeEvent.clientY;
  const right2 = left2 + 1;
  const bottom = top + 1;
  function getBoundingClientRect2() {
    return {
      left: left2,
      top,
      right: right2,
      bottom,
      x: left2,
      y: top,
      height: 1,
      width: 1
    };
  }
  return {
    getBoundingClientRect: getBoundingClientRect2
  };
}

// node_modules/@fluentui/react-positioning/lib/constants.js
var DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
var DATA_POSITIONING_ESCAPED = "data-popper-escaped";
var DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
var DATA_POSITIONING_PLACEMENT = "data-popper-placement";
var POSITIONING_END_EVENT = "fui-positioningend";

// node_modules/@fluentui/react-positioning/lib/PositioningConfigurationContext.js
var React118 = __toESM(require_react());
var DEFAULT_CONFIGURATION = ({ options }) => {
  return options;
};
var PositioningConfigurationContext = React118.createContext(void 0);
var PositioningConfigurationProvider = PositioningConfigurationContext.Provider;
var usePositioningConfiguration = () => {
  var _React_useContext;
  return (_React_useContext = React118.useContext(PositioningConfigurationContext)) !== null && _React_useContext !== void 0 ? _React_useContext : DEFAULT_CONFIGURATION;
};

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
var React122 = __toESM(require_react());

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    var _platform$detectOverf;
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: {
        ...platform2,
        detectOverflow: (_platform$detectOverf = platform2.detectOverflow) != null ? _platform$detectOverf : detectOverflow
      },
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp2(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects,
        platform: platform2
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await platform2.detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement,
        platform: platform2
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement3(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache3) {
  const cachedResult = cache3.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache3.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement3(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement3(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var detectOverflow2 = detectOverflow;
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache3 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache3
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@fluentui/react-positioning/lib/utils/parseFloatingUIPlacement.js
function parseFloatingUIPlacement(placement) {
  const tokens2 = placement.split("-");
  return {
    side: tokens2[0],
    alignment: tokens2[1]
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/getScrollParent.js
var getParentNode3 = (node) => {
  if (node.nodeName === "HTML") {
    return node;
  }
  return node.parentNode || node.host;
};
var getStyleComputedProperty = (node) => {
  var _node_ownerDocument;
  if (node.nodeType !== 1) {
    return {};
  }
  const targetWindow = (_node_ownerDocument = node.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
  if (targetWindow) {
    return targetWindow.getComputedStyle(node, null);
  }
  return {};
};
var getScrollParent = (node) => {
  const parentNode = node && getParentNode3(node);
  if (!parentNode) return document.body;
  switch (parentNode.nodeName) {
    case "HTML":
    case "BODY":
      return parentNode.ownerDocument.body;
    case "#document":
      return parentNode.body;
  }
  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return parentNode;
  }
  return getScrollParent(parentNode);
};
var hasScrollParent = (node) => {
  var _scrollParentElement_ownerDocument;
  const scrollParentElement = getScrollParent(node);
  return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
};

// node_modules/@fluentui/react-positioning/lib/utils/getBoundary.js
function getBoundary(element, boundary) {
  if (boundary === "window") {
    return element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
  }
  if (boundary === "clippingParents") {
    return "clippingAncestors";
  }
  if (boundary === "scrollParent") {
    let boundariesNode = getScrollParent(element);
    if (boundariesNode.nodeName === "BODY") {
      boundariesNode = element === null || element === void 0 ? void 0 : element.ownerDocument.documentElement;
    }
    return boundariesNode;
  }
  return boundary;
}

// node_modules/@fluentui/react-positioning/lib/utils/getReactFiberFromNode.js
var React119 = __toESM(require_react());
var WorkTag = function(WorkTag2) {
  WorkTag2[WorkTag2["FunctionComponent"] = 0] = "FunctionComponent";
  WorkTag2[WorkTag2["ClassComponent"] = 1] = "ClassComponent";
  WorkTag2[WorkTag2["IndeterminateComponent"] = 2] = "IndeterminateComponent";
  WorkTag2[WorkTag2["HostRoot"] = 3] = "HostRoot";
  WorkTag2[WorkTag2["HostPortal"] = 4] = "HostPortal";
  WorkTag2[WorkTag2["HostComponent"] = 5] = "HostComponent";
  WorkTag2[WorkTag2["HostText"] = 6] = "HostText";
  WorkTag2[WorkTag2["Fragment"] = 7] = "Fragment";
  WorkTag2[WorkTag2["Mode"] = 8] = "Mode";
  WorkTag2[WorkTag2["ContextConsumer"] = 9] = "ContextConsumer";
  WorkTag2[WorkTag2["ContextProvider"] = 10] = "ContextProvider";
  WorkTag2[WorkTag2["ForwardRef"] = 11] = "ForwardRef";
  WorkTag2[WorkTag2["Profiler"] = 12] = "Profiler";
  WorkTag2[WorkTag2["SuspenseComponent"] = 13] = "SuspenseComponent";
  WorkTag2[WorkTag2["MemoComponent"] = 14] = "MemoComponent";
  WorkTag2[WorkTag2["SimpleMemoComponent"] = 15] = "SimpleMemoComponent";
  WorkTag2[WorkTag2["LazyComponent"] = 16] = "LazyComponent";
  WorkTag2[WorkTag2["IncompleteClassComponent"] = 17] = "IncompleteClassComponent";
  WorkTag2[WorkTag2["DehydratedFragment"] = 18] = "DehydratedFragment";
  WorkTag2[WorkTag2["SuspenseListComponent"] = 19] = "SuspenseListComponent";
  WorkTag2[WorkTag2["FundamentalComponent"] = 20] = "FundamentalComponent";
  WorkTag2[WorkTag2["ScopeComponent"] = 21] = "ScopeComponent";
  return WorkTag2;
}(WorkTag || {});
function getReactFiberFromNode(elm) {
  if (!elm) {
    return null;
  }
  for (const k in elm) {
    if (k.indexOf("__reactInternalInstance$") === 0 || k.indexOf("__reactFiber$") === 0) {
      return elm[k];
    }
  }
  throw new Error("getReactFiber(): Failed to find a React Fiber on a node");
}

// node_modules/@fluentui/react-positioning/lib/utils/mergeArrowOffset.js
function mergeArrowOffset(userOffset, arrowHeight2) {
  if (typeof userOffset === "number") {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "object" && userOffset !== null) {
    return addArrowOffset(userOffset, arrowHeight2);
  }
  if (typeof userOffset === "function") {
    return (offsetParams) => {
      const offset4 = userOffset(offsetParams);
      return addArrowOffset(offset4, arrowHeight2);
    };
  }
  return {
    mainAxis: arrowHeight2
  };
}
var addArrowOffset = (offset4, arrowHeight2) => {
  if (typeof offset4 === "number") {
    return {
      mainAxis: offset4 + arrowHeight2
    };
  }
  var _offset_mainAxis;
  return {
    ...offset4,
    mainAxis: ((_offset_mainAxis = offset4.mainAxis) !== null && _offset_mainAxis !== void 0 ? _offset_mainAxis : 0) + arrowHeight2
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPadding.js
function toFloatingUIPadding(padding, isRtl) {
  if (typeof padding === "number") {
    return padding;
  }
  const { start, end, ...verticalPadding } = padding;
  const paddingObject = verticalPadding;
  const left2 = isRtl ? "end" : "start";
  const right2 = isRtl ? "start" : "end";
  if (padding[left2]) {
    paddingObject.left = padding[left2];
  }
  if (padding[right2]) {
    paddingObject.right = padding[right2];
  }
  return paddingObject;
}

// node_modules/@fluentui/react-positioning/lib/utils/toFloatingUIPlacement.js
var getPositionMap = (rtl) => ({
  above: "top",
  below: "bottom",
  before: rtl ? "right" : "left",
  after: rtl ? "left" : "right"
});
var getAlignmentMap = () => ({
  start: "start",
  end: "end",
  top: "start",
  bottom: "end",
  center: void 0
});
var shouldAlignToCenter = (p, a) => {
  const positionedVertically = p === "above" || p === "below";
  const alignedVertically = a === "top" || a === "bottom";
  return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
};
var toFloatingUIPlacement = (align, position, rtl) => {
  const alignment = shouldAlignToCenter(position, align) ? "center" : align;
  const computedPosition = position && getPositionMap(rtl)[position];
  const computedAlignment = alignment && getAlignmentMap()[alignment];
  if (computedPosition && computedAlignment) {
    return `${computedPosition}-${computedAlignment}`;
  }
  return computedPosition;
};

// node_modules/@fluentui/react-positioning/lib/utils/fromFloatingUIPlacement.js
var getPositionMap2 = () => ({
  top: "above",
  bottom: "below",
  right: "after",
  left: "before"
});
var getAlignmentMap2 = (position) => {
  if (position === "above" || position === "below") {
    return {
      start: "start",
      end: "end"
    };
  }
  return {
    start: "top",
    end: "bottom"
  };
};
var fromFloatingUIPlacement = (placement) => {
  const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
  const position = getPositionMap2()[side];
  const alignment = floatingUIAlignment && getAlignmentMap2(position)[floatingUIAlignment];
  return {
    position,
    alignment
  };
};

// node_modules/@fluentui/react-positioning/lib/utils/resolvePositioningShorthand.js
var shorthandLookup = {
  above: {
    position: "above",
    align: "center"
  },
  "above-start": {
    position: "above",
    align: "start"
  },
  "above-end": {
    position: "above",
    align: "end"
  },
  below: {
    position: "below",
    align: "center"
  },
  "below-start": {
    position: "below",
    align: "start"
  },
  "below-end": {
    position: "below",
    align: "end"
  },
  before: {
    position: "before",
    align: "center"
  },
  "before-top": {
    position: "before",
    align: "top"
  },
  "before-bottom": {
    position: "before",
    align: "bottom"
  },
  after: {
    position: "after",
    align: "center"
  },
  "after-top": {
    position: "after",
    align: "top"
  },
  "after-bottom": {
    position: "after",
    align: "bottom"
  }
};
function resolvePositioningShorthand(shorthand) {
  if (shorthand === void 0 || shorthand === null) {
    return {};
  }
  if (typeof shorthand === "string") {
    return shorthandLookup[shorthand];
  }
  return shorthand;
}

// node_modules/@fluentui/react-positioning/lib/utils/useCallbackRef.js
var React120 = __toESM(require_react());
function useCallbackRef(initialValue, callback, skipInitialResolve) {
  const isFirst = React120.useRef(true);
  const [ref] = React120.useState(() => ({
    // value
    value: initialValue,
    // last callback
    callback,
    // "memoized" public interface
    facade: {
      get current() {
        return ref.value;
      },
      set current(value) {
        const last = ref.value;
        if (last !== value) {
          ref.value = value;
          if (skipInitialResolve && isFirst.current) {
            return;
          }
          ref.callback(value, last);
        }
      }
    }
  }));
  useIsomorphicLayoutEffect(() => {
    isFirst.current = false;
  }, []);
  ref.callback = callback;
  return ref.facade;
}

// node_modules/@fluentui/react-positioning/lib/utils/debounce.js
function debounce(fn) {
  let pending;
  return () => {
    if (!pending) {
      pending = new Promise((resolve) => {
        Promise.resolve().then(() => {
          pending = void 0;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/hasAutoFocusFilter.js
function hasAutofocusProp(node) {
  const isAutoFocusableElement = node.nodeName === "BUTTON" || node.nodeName === "INPUT" || node.nodeName === "SELECT" || node.nodeName === "TEXTAREA";
  if (isAutoFocusableElement) {
    var _getReactFiberFromNode;
    return !!((_getReactFiberFromNode = getReactFiberFromNode(node)) === null || _getReactFiberFromNode === void 0 ? void 0 : _getReactFiberFromNode.pendingProps.autoFocus);
  }
  return false;
}
function hasAutofocusFilter(node) {
  return hasAutofocusProp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}

// node_modules/@fluentui/react-positioning/lib/utils/writeArrowUpdates.js
function writeArrowUpdates(options) {
  const { arrow: arrow3, middlewareData } = options;
  if (!middlewareData.arrow || !arrow3) {
    return;
  }
  const { x: arrowX, y: arrowY } = middlewareData.arrow;
  Object.assign(arrow3.style, {
    left: arrowX !== null && arrowX !== void 0 ? `${arrowX}px` : "",
    top: arrowY !== null && arrowY !== void 0 ? `${arrowY}px` : ""
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/writeContainerupdates.js
function writeContainerUpdates(options) {
  var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
  const { container, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
  if (!container) {
    return;
  }
  container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
  container.removeAttribute(DATA_POSITIONING_INTERSECTING);
  if (middlewareData.intersectionObserver.intersecting) {
    container.setAttribute(DATA_POSITIONING_INTERSECTING, "");
  }
  container.removeAttribute(DATA_POSITIONING_ESCAPED);
  if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) {
    container.setAttribute(DATA_POSITIONING_ESCAPED, "");
  }
  container.removeAttribute(DATA_POSITIONING_HIDDEN);
  if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) {
    container.setAttribute(DATA_POSITIONING_HIDDEN, "");
  }
  const devicePixelRatio = ((_container_ownerDocument_defaultView = container.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
  const x = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
  const y = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
  Object.assign(container.style, {
    position: strategy
  });
  if (useTransform) {
    Object.assign(container.style, {
      transform: lowPPI ? `translate(${x}px, ${y}px)` : `translate3d(${x}px, ${y}px, 0)`
    });
    return;
  }
  Object.assign(container.style, {
    left: `${x}px`,
    top: `${y}px`
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/normalizeAutoSize.js
var normalizeAutoSize = (autoSize) => {
  switch (autoSize) {
    case "always":
    case true:
      return {
        applyMaxWidth: true,
        applyMaxHeight: true
      };
    case "width-always":
    case "width":
      return {
        applyMaxWidth: true,
        applyMaxHeight: false
      };
    case "height-always":
    case "height":
      return {
        applyMaxWidth: false,
        applyMaxHeight: true
      };
    default:
      return false;
  }
};

// node_modules/@fluentui/react-positioning/lib/utils/listScrollParents.js
function listScrollParents(node) {
  const scrollParents = [];
  let cur = node;
  while (cur) {
    const scrollParent = getScrollParent(cur);
    if (node.ownerDocument.body === scrollParent) {
      scrollParents.push(scrollParent);
      break;
    }
    if (scrollParent.nodeName === "BODY" && scrollParent !== node.ownerDocument.body) {
      if (true) {
        console.error("@fluentui/react-positioning: You are comparing two different documents! This is an unexpected error, please report this as a bug to the Fluent UI team ");
      }
      break;
    }
    scrollParents.push(scrollParent);
    cur = scrollParent;
  }
  return scrollParents;
}

// node_modules/@fluentui/react-positioning/lib/utils/createResizeObserver.js
function createResizeObserver(targetWindow, callback) {
  if (false) {
    targetWindow.ResizeObserver = class ResizeObserver {
      observe() {
      }
      unobserve() {
      }
      disconnect() {
      }
    };
  }
  return new targetWindow.ResizeObserver(callback);
}

// node_modules/@fluentui/react-positioning/lib/createPositionManager.js
function createPositionManager(options) {
  let isDestroyed = false;
  const { container, target, arrow: arrow3, strategy, middleware, placement, useTransform = true, disableUpdateOnResize = false } = options;
  const targetWindow = container.ownerDocument.defaultView;
  if (!target || !container || !targetWindow) {
    return {
      updatePosition: () => void 0,
      dispose: () => void 0
    };
  }
  const resizeObserver = disableUpdateOnResize ? null : createResizeObserver(targetWindow, (entries) => {
    const shouldUpdateOnResize = entries.every((entry) => {
      return entry.contentRect.width > 0 && entry.contentRect.height > 0;
    });
    if (shouldUpdateOnResize) {
      updatePosition();
    }
  });
  let isFirstUpdate = true;
  const scrollParents = /* @__PURE__ */ new Set();
  Object.assign(container.style, {
    position: "fixed",
    left: 0,
    top: 0,
    margin: 0
  });
  const forceUpdate = () => {
    if (isDestroyed) {
      return;
    }
    if (isFirstUpdate) {
      listScrollParents(container).forEach((scrollParent) => scrollParents.add(scrollParent));
      if (isHTMLElement(target)) {
        listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
      }
      scrollParents.forEach((scrollParent) => {
        scrollParent.addEventListener("scroll", updatePosition, {
          passive: true
        });
      });
      resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(container);
      if (isHTMLElement(target)) {
        resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.observe(target);
      }
      isFirstUpdate = false;
    }
    Object.assign(container.style, {
      position: strategy
    });
    computePosition2(target, container, {
      placement,
      middleware,
      strategy
    }).then(({ x, y, middlewareData, placement: computedPlacement }) => {
      if (isDestroyed) {
        return;
      }
      writeArrowUpdates({
        arrow: arrow3,
        middlewareData
      });
      writeContainerUpdates({
        container,
        middlewareData,
        placement: computedPlacement,
        coordinates: {
          x,
          y
        },
        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
        strategy,
        useTransform
      });
      container.dispatchEvent(new CustomEvent(POSITIONING_END_EVENT));
    }).catch((err) => {
      if (true) {
        console.error("[usePositioning]: Failed to calculate position", err);
      }
    });
  };
  const updatePosition = debounce(() => forceUpdate());
  const dispose = () => {
    isDestroyed = true;
    if (targetWindow) {
      targetWindow.removeEventListener("scroll", updatePosition);
      targetWindow.removeEventListener("resize", updatePosition);
    }
    scrollParents.forEach((scrollParent) => {
      scrollParent.removeEventListener("scroll", updatePosition);
    });
    scrollParents.clear();
    resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
  };
  if (targetWindow) {
    targetWindow.addEventListener("scroll", updatePosition, {
      passive: true
    });
    targetWindow.addEventListener("resize", updatePosition);
  }
  updatePosition();
  return {
    updatePosition,
    dispose
  };
}

// node_modules/@floating-ui/devtools/dist/floating-ui.devtools.mjs
var CONTROLLER = "__FUIDT_CONTROLLER__";
var ELEMENT_METADATA = "__FUIDT_ELEMENT_METADATA__";
var HTML_ELEMENT_REFERENCE = "__FUIDT_HTML_ELEMENT_REFERENCE__";
var SERIALIZED_DATA_CHANGE = "__FUIDT_SERIALIZED_DATA_CHANGE__";
function isHTMLElement4(element, options) {
  var _typedElement$ownerDo, _options$constructorN;
  const typedElement = element;
  return Boolean((typedElement == null || (_typedElement$ownerDo = typedElement.ownerDocument) == null ? void 0 : _typedElement$ownerDo.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options$constructorN = void 0) != null ? _options$constructorN : "HTMLElement"]);
}
var isHTMLElementWithMetadata = (element) => Boolean(isHTMLElement4(element) && ELEMENT_METADATA in element && element.parentElement !== null);
var createController = (defaultView) => {
  let selectedElement = null;
  const observer = new MutationObserver((mutations) => {
    if (!selectedElement) {
      return;
    }
    for (const mutation of mutations) {
      if (mutation.type === "childList" && Array.from(mutation.removedNodes).includes(selectedElement)) {
        controller.withdraw();
      }
    }
  });
  const controller = {
    get selectedElement() {
      return selectedElement;
    },
    select: (nextSelectedElement) => {
      if (isHTMLElementWithMetadata(nextSelectedElement)) {
        selectedElement = nextSelectedElement;
        observer.observe(nextSelectedElement.parentElement, {
          childList: true,
          subtree: false
        });
      }
      if (selectedElement && nextSelectedElement) {
        const metadata = selectedElement[ELEMENT_METADATA];
        if (metadata.references.has(nextSelectedElement)) {
          return selectedElement;
        }
      }
      controller.withdraw();
      return selectedElement;
    },
    withdraw: () => {
      selectedElement = null;
      observer.disconnect();
      defaultView.postMessage(SERIALIZED_DATA_CHANGE);
    }
  };
  return controller;
};
var injectController = (_ref) => {
  let {
    defaultView
  } = _ref;
  if (!defaultView) {
    return;
  }
  if (!defaultView[CONTROLLER]) {
    defaultView[CONTROLLER] = createController(defaultView);
  }
};
var getController = (targetDocument) => {
  var _targetDocument$defau, _targetDocument$defau2;
  injectController(targetDocument);
  return (_targetDocument$defau = (_targetDocument$defau2 = targetDocument.defaultView) == null ? void 0 : _targetDocument$defau2[CONTROLLER]) != null ? _targetDocument$defau : null;
};
var serialize = (data, references) => {
  const serializedData = JSON.parse(JSON.stringify(data, (_, value) => {
    if (isHTMLElement4(value)) return references.add(value);
    if (typeof value === "object" && value && Object.getPrototypeOf(value) !== Object.prototype && Object.getPrototypeOf(value) !== Array.prototype) {
      if ("toString" in value) {
        return value.toString();
      }
      return void 0;
    }
    return value;
  }));
  return serializedData;
};
var counter = 0;
var generateReferenceId = () => HTML_ELEMENT_REFERENCE + ":" + counter++;
var createReferences = () => {
  const map = /* @__PURE__ */ new Map();
  const weakMap = /* @__PURE__ */ new WeakMap();
  const references = {
    add: (element) => {
      if (weakMap.has(element)) {
        return weakMap.get(element);
      }
      const id = generateReferenceId();
      map.set(id, element);
      weakMap.set(element, id);
      return id;
    },
    get: (id) => {
      const element = map.get(id);
      if (element && weakMap.has(element)) {
        return element;
      }
    },
    has: (element) => {
      return weakMap.has(element);
    }
  };
  return references;
};
var devtools = function(targetDocument, middlewareDataCallback) {
  if (targetDocument === void 0) {
    targetDocument = document;
  }
  if (middlewareDataCallback === void 0) {
    middlewareDataCallback = floatingUIMiddlewareDataCallback;
  }
  return {
    name: "@floating-ui/devtools",
    fn: (state) => {
      const {
        [ELEMENT_METADATA]: metadata
      } = isHTMLElementWithMetadata(state.elements.floating) ? state.elements.floating : Object.assign(state.elements.floating, {
        [ELEMENT_METADATA]: {
          references: createReferences(),
          serializedData: []
        }
      });
      const serializedData = serialize(middlewareDataCallback(state), metadata.references);
      metadata.serializedData.unshift(serializedData);
      const controller = getController(targetDocument);
      if (metadata.serializedData.length > 1 && state.elements.floating === (controller == null ? void 0 : controller.selectedElement)) {
        var _targetDocument$defau;
        (_targetDocument$defau = targetDocument.defaultView) == null || _targetDocument$defau.postMessage(SERIALIZED_DATA_CHANGE);
      }
      return {};
    }
  };
};
var floatingUIMiddlewareDataCallback = (state) => ({
  ...state,
  type: "FloatingUIMiddleware"
});

// node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
var React121 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/middleware/coverTarget.js
function coverTarget() {
  return {
    name: "coverTarget",
    fn: (middlewareArguments) => {
      const { placement, rects, x, y } = middlewareArguments;
      const basePlacement = parseFloatingUIPlacement(placement).side;
      const newCoords = {
        x,
        y
      };
      switch (basePlacement) {
        case "bottom":
          newCoords.y -= rects.reference.height;
          break;
        case "top":
          newCoords.y += rects.reference.height;
          break;
        case "left":
          newCoords.x += rects.reference.width;
          break;
        case "right":
          newCoords.x -= rects.reference.width;
          break;
      }
      return newCoords;
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/flip.js
function flip3(options) {
  const { hasScrollableElement, flipBoundary, container, fallbackPositions: fallbackPositions2 = [], isRtl } = options;
  const fallbackPlacements = fallbackPositions2.reduce((acc, shorthand) => {
    const { position, align } = resolvePositioningShorthand(shorthand);
    const placement = toFloatingUIPlacement(align, position, isRtl);
    if (placement) {
      acc.push(placement);
    }
    return acc;
  }, []);
  return flip2({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...flipBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, flipBoundary)
    },
    fallbackStrategy: "bestFit",
    ...fallbackPlacements.length && {
      fallbackPlacements
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/intersecting.js
function intersecting() {
  return {
    name: "intersectionObserver",
    fn: async (middlewareArguments) => {
      const floatingRect = middlewareArguments.rects.floating;
      const altOverflow = await detectOverflow2(middlewareArguments, {
        altBoundary: true
      });
      const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
      const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
      const isIntersecting = isIntersectingTop || isIntersectingBottom;
      return {
        data: {
          intersecting: isIntersecting
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/maxSize.js
var resetMaxSize = (autoSize) => ({
  name: "resetMaxSize",
  fn({ middlewareData, elements }) {
    var _middlewareData_resetMaxSize;
    if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) {
      return {};
    }
    const { applyMaxWidth, applyMaxHeight } = autoSize;
    if (applyMaxWidth) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-width");
      elements.floating.style.removeProperty("width");
    }
    if (applyMaxHeight) {
      elements.floating.style.removeProperty("box-sizing");
      elements.floating.style.removeProperty("max-height");
      elements.floating.style.removeProperty("height");
    }
    return {
      data: {
        maxSizeAlreadyReset: true
      },
      reset: {
        rects: true
      }
    };
  }
});
function maxSize(autoSize, options) {
  const { container, overflowBoundary, overflowBoundaryPadding, isRtl } = options;
  return size2({
    ...overflowBoundaryPadding && {
      padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
    },
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    },
    apply({ availableHeight, availableWidth, elements, rects }) {
      const applyMaxSizeStyles = (apply, dimension, availableSize) => {
        if (!apply) {
          return;
        }
        elements.floating.style.setProperty("box-sizing", "border-box");
        elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
        if (rects.floating[dimension] > availableSize) {
          elements.floating.style.setProperty(dimension, `${availableSize}px`);
          const axis = dimension === "width" ? "x" : "y";
          if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) {
            elements.floating.style.setProperty(`overflow-${axis}`, "auto");
          }
        }
      };
      const { applyMaxWidth, applyMaxHeight } = autoSize;
      applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
      applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/utils/getFloatingUIOffset.js
function getFloatingUIOffset(rawOffset) {
  if (!rawOffset) {
    return rawOffset;
  }
  if (typeof rawOffset === "number" || typeof rawOffset === "object") {
    return rawOffset;
  }
  return ({ rects: { floating, reference }, placement }) => {
    const { position, alignment } = fromFloatingUIPlacement(placement);
    return rawOffset({
      positionedRect: floating,
      targetRect: reference,
      position,
      alignment
    });
  };
}

// node_modules/@fluentui/react-positioning/lib/middleware/offset.js
function offset3(offsetValue) {
  const floatingUIOffset = getFloatingUIOffset(offsetValue);
  return offset2(floatingUIOffset);
}

// node_modules/@fluentui/react-positioning/lib/middleware/shift.js
function shift3(options) {
  const { hasScrollableElement, shiftToCoverTarget, disableTether, overflowBoundary, container, overflowBoundaryPadding, isRtl } = options;
  return shift2({
    ...hasScrollableElement && {
      boundary: "clippingAncestors"
    },
    ...shiftToCoverTarget && {
      crossAxis: true,
      limiter: limitShift2({
        crossAxis: true,
        mainAxis: false
      })
    },
    ...disableTether && {
      crossAxis: disableTether === "all",
      limiter: limitShift2({
        crossAxis: disableTether !== "all",
        mainAxis: false
      })
    },
    ...overflowBoundaryPadding && {
      padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
    },
    ...overflowBoundary && {
      altBoundary: true,
      boundary: getBoundary(container, overflowBoundary)
    }
  });
}

// node_modules/@fluentui/react-positioning/lib/middleware/matchTargetSize.js
var matchTargetSizeCssVar = "--fui-match-target-size";
function matchTargetSize() {
  return {
    name: "matchTargetSize",
    fn: async (middlewareArguments) => {
      const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
      if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) {
        return {};
      }
      const { width } = referenceRect;
      floatingElement.style.setProperty(matchTargetSizeCssVar, `${width}px`);
      if (!floatingElement.style.width) {
        floatingElement.style.width = `var(${matchTargetSizeCssVar})`;
      }
      return {
        data: {
          matchTargetSizeAttempt: true
        },
        reset: {
          rects: true
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/utils/devtools.js
var devtoolsCallback = (options) => (middlewareState) => {
  const { elements: { floating, reference } } = middlewareState;
  const scrollParentsSet = /* @__PURE__ */ new Set();
  if (isHTMLElement(reference)) {
    listScrollParents(reference).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  }
  listScrollParents(floating).forEach((scrollParent) => scrollParentsSet.add(scrollParent));
  const flipBoundaries = Array.isArray(options.flipBoundary) ? options.flipBoundary : isHTMLElement(options.flipBoundary) ? [
    options.flipBoundary
  ] : [];
  const overflowBoundaries = Array.isArray(options.overflowBoundary) ? options.overflowBoundary : isHTMLElement(options.overflowBoundary) ? [
    options.overflowBoundary
  ] : [];
  return {
    type: "FluentUIMiddleware",
    middlewareState,
    options,
    initialPlacement: fromFloatingUIPlacement(middlewareState.initialPlacement),
    placement: fromFloatingUIPlacement(middlewareState.placement),
    flipBoundaries,
    overflowBoundaries,
    scrollParents: Array.from(scrollParentsSet)
  };
};

// node_modules/@fluentui/react-positioning/lib/usePositioningOptions.js
function usePositioningConfigFn(configFn, options) {
  const {
    align,
    arrowPadding,
    autoSize,
    coverTarget: coverTarget2,
    disableUpdateOnResize,
    flipBoundary,
    offset: offset4,
    overflowBoundary,
    pinned,
    position,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_disableTether,
    strategy,
    overflowBoundaryPadding,
    fallbackPositions: fallbackPositions2,
    useTransform,
    matchTargetSize: matchTargetSize2,
    shiftToCoverTarget
  } = options;
  return React121.useCallback((container, arrow3) => {
    return configFn({
      container,
      arrow: arrow3,
      options: {
        autoSize,
        disableUpdateOnResize,
        matchTargetSize: matchTargetSize2,
        offset: offset4,
        strategy,
        coverTarget: coverTarget2,
        flipBoundary,
        overflowBoundary,
        useTransform,
        overflowBoundaryPadding,
        pinned,
        arrowPadding,
        align,
        fallbackPositions: fallbackPositions2,
        shiftToCoverTarget,
        position,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_disableTether
      }
    });
  }, [
    autoSize,
    disableUpdateOnResize,
    matchTargetSize2,
    offset4,
    strategy,
    coverTarget2,
    flipBoundary,
    overflowBoundary,
    useTransform,
    overflowBoundaryPadding,
    pinned,
    arrowPadding,
    align,
    fallbackPositions2,
    shiftToCoverTarget,
    position,
    unstable_disableTether,
    configFn
  ]);
}
function usePositioningOptions(options) {
  const { dir, targetDocument } = useFluent();
  const isRtl = dir === "rtl";
  const configFn = usePositioningConfigFn(usePositioningConfiguration(), options);
  const {
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    positionFixed
  } = options;
  return React121.useCallback((container, arrow3) => {
    const hasScrollableElement = hasScrollParent(container);
    const optionsAfterEnhancement = configFn(container, arrow3);
    const {
      autoSize,
      disableUpdateOnResize,
      matchTargetSize: matchTargetSize2,
      offset: offset4,
      coverTarget: coverTarget2,
      flipBoundary,
      overflowBoundary,
      useTransform,
      overflowBoundaryPadding,
      pinned,
      position,
      arrowPadding,
      strategy,
      align,
      fallbackPositions: fallbackPositions2,
      shiftToCoverTarget,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      unstable_disableTether
    } = optionsAfterEnhancement;
    const normalizedAutoSize = normalizeAutoSize(autoSize);
    const middleware = [
      normalizedAutoSize && resetMaxSize(normalizedAutoSize),
      matchTargetSize2 && matchTargetSize(),
      offset4 && offset3(offset4),
      coverTarget2 && coverTarget(),
      !pinned && flip3({
        container,
        flipBoundary,
        hasScrollableElement,
        isRtl,
        fallbackPositions: fallbackPositions2
      }),
      shift3({
        container,
        hasScrollableElement,
        overflowBoundary,
        disableTether: unstable_disableTether,
        overflowBoundaryPadding,
        isRtl,
        shiftToCoverTarget
      }),
      normalizedAutoSize && maxSize(normalizedAutoSize, {
        container,
        overflowBoundary,
        overflowBoundaryPadding,
        isRtl
      }),
      intersecting(),
      arrow3 && arrow2({
        element: arrow3,
        padding: arrowPadding
      }),
      hide2({
        strategy: "referenceHidden"
      }),
      hide2({
        strategy: "escaped"
      }),
      targetDocument && devtools(targetDocument, devtoolsCallback(optionsAfterEnhancement))
    ].filter(Boolean);
    const placement = toFloatingUIPlacement(align, position, isRtl);
    return {
      placement,
      middleware,
      strategy: (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute",
      disableUpdateOnResize,
      useTransform
    };
  }, [
    configFn,
    isRtl,
    targetDocument,
    positionFixed
  ]);
}

// node_modules/@fluentui/react-positioning/lib/usePositioning.js
function usePositioning(options) {
  "use no memo";
  const managerRef = React122.useRef(null);
  const targetRef = React122.useRef(null);
  const overrideTargetRef = React122.useRef(null);
  const containerRef = React122.useRef(null);
  const arrowRef = React122.useRef(null);
  const { enabled = true } = options;
  const resolvePositioningOptions = usePositioningOptions(options);
  const updatePositionManager = React122.useCallback(() => {
    if (managerRef.current) {
      managerRef.current.dispose();
    }
    managerRef.current = null;
    var _overrideTargetRef_current;
    const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
    if (enabled && canUseDOM() && target && containerRef.current) {
      managerRef.current = createPositionManager({
        container: containerRef.current,
        target,
        arrow: arrowRef.current,
        ...resolvePositioningOptions(containerRef.current, arrowRef.current)
      });
    }
  }, [
    enabled,
    resolvePositioningOptions
  ]);
  const setOverrideTarget = useEventCallback((target) => {
    overrideTargetRef.current = target;
    updatePositionManager();
  });
  React122.useImperativeHandle(options.positioningRef, () => ({
    updatePosition: () => {
      var _managerRef_current;
      return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
    },
    setTarget: (target) => {
      if (options.target && true) {
        const err = new Error();
        console.warn("Imperative setTarget should not be used at the same time as target option");
        console.warn(err.stack);
      }
      setOverrideTarget(target);
    }
  }), [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    var _options_target;
    setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
  }, [
    options.target,
    setOverrideTarget
  ]);
  useIsomorphicLayoutEffect(() => {
    updatePositionManager();
  }, [
    updatePositionManager
  ]);
  if (true) {
    React122.useEffect(() => {
      if (containerRef.current) {
        var _contentNode_ownerDocument;
        const contentNode = containerRef.current;
        const treeWalker = (_contentNode_ownerDocument = contentNode.ownerDocument) === null || _contentNode_ownerDocument === void 0 ? void 0 : _contentNode_ownerDocument.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
          acceptNode: hasAutofocusFilter
        });
        while (treeWalker.nextNode()) {
          const node = treeWalker.currentNode;
          console.warn("usePositioning():", node);
          console.warn([
            'usePositioning(): ^ this node contains "autoFocus" prop on a React element. This can break the initial',
            "positioning of an element and cause a window jump effect. This issue occurs because React polyfills",
            '"autoFocus" behavior to solve inconsistencies between different browsers:',
            "https://github.com/facebook/react/issues/11851#issuecomment-351787078",
            "\n",
            'However, ".focus()" in this case occurs before any other React effects will be executed',
            "(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really",
            'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
            '"Popper".',
            `In general, it's not recommended to use "autoFocus" as it may break accessibility aspects:`,
            "https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md",
            "\n",
            'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
            '"ref.current.focus" in React.useEffect():',
            "https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element"
          ].join(" "));
        }
      }
    }, []);
  }
  const setTarget = useCallbackRef(null, (target) => {
    if (targetRef.current !== target) {
      targetRef.current = target;
      updatePositionManager();
    }
  });
  const onPositioningEnd = useEventCallback(() => {
    var _options_onPositioningEnd;
    return (_options_onPositioningEnd = options.onPositioningEnd) === null || _options_onPositioningEnd === void 0 ? void 0 : _options_onPositioningEnd.call(options);
  });
  const setContainer = useCallbackRef(null, (container) => {
    if (containerRef.current !== container) {
      var _containerRef_current;
      (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.removeEventListener(POSITIONING_END_EVENT, onPositioningEnd);
      container === null || container === void 0 ? void 0 : container.addEventListener(POSITIONING_END_EVENT, onPositioningEnd);
      containerRef.current = container;
      updatePositionManager();
    }
  });
  const setArrow = useCallbackRef(null, (arrow3) => {
    if (arrowRef.current !== arrow3) {
      arrowRef.current = arrow3;
      updatePositionManager();
    }
  });
  return {
    targetRef: setTarget,
    containerRef: setContainer,
    arrowRef: setArrow
  };
}

// node_modules/@fluentui/react-positioning/lib/usePositioningMouseTarget.js
var React123 = __toESM(require_react());
var usePositioningMouseTarget = (initialState) => {
  const [virtualElement, setVirtualElement] = React123.useState(initialState);
  const setVirtualMouseTarget = (event) => {
    if (event === void 0 || event === null) {
      setVirtualElement(void 0);
      return;
    }
    let mouseevent;
    if (!(event instanceof MouseEvent)) {
      mouseevent = event.nativeEvent;
    } else {
      mouseevent = event;
    }
    if (!(mouseevent instanceof MouseEvent) && true) {
      console.error("usePositioningMouseTarget should only be used with MouseEvent");
    }
    const contextTarget = createVirtualElementFromClick(mouseevent);
    setVirtualElement(contextTarget);
  };
  return [
    virtualElement,
    setVirtualMouseTarget
  ];
};

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/useSafeZoneArea.js
var React125 = __toESM(require_react());

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/createSafeZoneAreaStateStore.js
function createSafeZoneAreaStateStore() {
  let isActive = false;
  const listeners = [];
  return {
    isActive() {
      return isActive;
    },
    toggleActive(newIsActive) {
      if (isActive === newIsActive) {
        return;
      }
      isActive = newIsActive;
      listeners.forEach((listener) => listener(isActive));
    },
    subscribe(listener) {
      listeners.push(listener);
      return () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      };
    }
  };
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.js
var React124 = __toESM(require_react());
var import_shim = __toESM(require_shim());

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getRectCorners.js
function getRectCorners(rect, offset4) {
  return {
    topLeft: [
      rect.left - offset4[0],
      rect.top - offset4[1]
    ],
    topRight: [
      rect.right - offset4[0],
      rect.top - offset4[1]
    ],
    bottomRight: [
      rect.right - offset4[0],
      rect.bottom - offset4[1]
    ],
    bottomLeft: [
      rect.left - offset4[0],
      rect.bottom - offset4[1]
    ]
  };
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/getMouseAnchor.js
var OFFSET_DISTANCE = 20;
function measureDistance(a, b) {
  return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
}
function getUnitVector(a, b) {
  const distance = measureDistance(a, b);
  if (distance === 0) {
    return [
      0,
      0
    ];
  }
  return [
    (a[0] - b[0]) / distance,
    (a[1] - b[1]) / distance
  ];
}
function getMouseAnchor(topLeftCorner, bottomRightCorner, mouseCoordinates) {
  const containerCenter = [
    (topLeftCorner[0] + bottomRightCorner[0]) / 2,
    (topLeftCorner[1] + bottomRightCorner[1]) / 2
  ];
  const unitVector = getUnitVector([
    mouseCoordinates[0],
    mouseCoordinates[1]
  ], [
    containerCenter[0],
    containerCenter[1]
  ]);
  const distance = measureDistance([
    containerCenter[0],
    containerCenter[1]
  ], [
    mouseCoordinates[0],
    mouseCoordinates[1]
  ]);
  return [
    containerCenter[0] + unitVector[0] * (distance + OFFSET_DISTANCE),
    containerCenter[1] + unitVector[1] * (distance + OFFSET_DISTANCE)
  ];
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/pointsToSvgPath.js
function pointsToSvgPath(points) {
  return `M ${points} z`;
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.styles.js
var useStyles8 = __styles2({
  wrapper: {
    mc9l5x: "fjseox",
    Bqenvij: "fniina8",
    a9b677: "f3tsq5r",
    Bkecrkj: "f1aehjj5"
  },
  wrapperActive: {
    mc9l5x: "ftgm304"
  },
  svg: {
    Bkfmm31: "f1au8mb3",
    Bkecrkj: "f1aehjj5",
    qhf8xq: "f19dog8a",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"]
  },
  triangle: {
    Bkecrkj: "f1cguypg"
  },
  triangleDebug: {
    Bceei9c: "f7116n6",
    Bkfmm31: "f1xab38x"
  },
  rectDebug: {
    Bkfmm31: "fyegryc"
  }
}, {
  d: [".fjseox{display:none;}", ".fniina8{height:0;}", ".f3tsq5r{width:0;}", ".f1aehjj5{pointer-events:none;}", ".ftgm304{display:block;}", ".f1au8mb3{fill:transparent;}", ".f19dog8a{position:fixed;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f1cguypg{pointer-events:auto;}", ".f7116n6{cursor:crosshair;}", ".f1xab38x{fill:color-mix(in srgb, var(--colorPaletteGreenBackground3) 20%, transparent);}", ".fyegryc{fill:color-mix(in srgb, var(--colorPaletteRedBackground3) 20%, transparent);}"]
});

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/computeOutsideClipPath.js
function drawRectangle(rect) {
  if (rect.width <= 0 || rect.height <= 0) {
    return "";
  }
  let pathData = "";
  pathData += `M ${rect.x},${rect.y} `;
  pathData += `V ${rect.y + rect.height} `;
  pathData += `H ${rect.x + rect.width} `;
  pathData += `V ${rect.y} `;
  pathData += `H ${rect.x} `;
  pathData += `Z `;
  return pathData;
}
function computeOutsideClipPath(svgWidth, svgHeight, targetRect, containerRect) {
  let pathData = `M 0,0 H ${svgWidth} V ${svgHeight} H 0 Z `;
  pathData += drawRectangle(targetRect);
  pathData += drawRectangle(containerRect);
  return pathData;
}

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/SafeZoneArea.js
var EMPTY_RECT = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  width: 0,
  height: 0,
  x: 0,
  y: 0,
  toJSON() {
    return "";
  }
};
function isSameRect(a, b) {
  return a.top === b.top && a.right === b.right && a.bottom === b.bottom && a.left === b.left && a.width === b.width && a.height === b.height;
}
function isSameCoordinates(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
var SafeZoneArea = React124.memo((props) => {
  const { debug, onMouseEnter, onMouseMove, onMouseLeave, stateStore } = props;
  const clipPathId = useId2();
  const styles = useStyles8();
  const active = (0, import_shim.useSyncExternalStore)(stateStore.subscribe, stateStore.isActive);
  const svgRef = React124.useRef(null);
  const [state, setState] = React124.useState(() => ({
    containerRect: EMPTY_RECT,
    targetRect: EMPTY_RECT,
    mouseCoordinates: [
      0,
      0
    ]
  }));
  React124.useImperativeHandle(props.imperativeRef, () => ({
    updateSVG(newState) {
      setState((prevState) => {
        if (isSameRect(prevState.containerRect, newState.containerRect) && isSameRect(prevState.targetRect, newState.targetRect) && isSameCoordinates(prevState.mouseCoordinates, newState.mouseCoordinates)) {
          return prevState;
        }
        return newState;
      });
    }
  }), []);
  const { containerRect, targetRect, mouseCoordinates } = state;
  const topOffset = Math.min(targetRect.top, containerRect.top);
  const leftOffset = Math.min(targetRect.left, containerRect.left);
  const bottomOffset = Math.max(targetRect.bottom, containerRect.bottom);
  const rightOffset = Math.max(targetRect.right, containerRect.right);
  const containerCorners = getRectCorners(containerRect, [
    leftOffset,
    topOffset
  ]);
  const targetCorners = getRectCorners(targetRect, [
    leftOffset,
    topOffset
  ]);
  const relativeMouseCoordinates = [
    mouseCoordinates[0] - leftOffset,
    mouseCoordinates[1] - topOffset
  ];
  const mouseAnchor = getMouseAnchor(containerCorners.topLeft, containerCorners.bottomRight, relativeMouseCoordinates);
  const triangleA = [
    mouseAnchor,
    containerCorners.topLeft,
    containerCorners.topRight
  ];
  const triangleB = [
    mouseAnchor,
    containerCorners.topRight,
    containerCorners.bottomRight
  ];
  const triangleC = [
    mouseAnchor,
    containerCorners.bottomRight,
    containerCorners.bottomLeft
  ];
  const triangleD = [
    mouseAnchor,
    containerCorners.bottomLeft,
    containerCorners.topLeft
  ];
  const svgWidth = rightOffset - leftOffset;
  const svgHeight = bottomOffset - topOffset;
  const clipPath = computeOutsideClipPath(svgWidth, svgHeight, {
    x: targetCorners.topLeft[0],
    y: targetCorners.topLeft[1],
    width: targetRect.width,
    height: targetRect.height
  }, {
    x: containerCorners.topLeft[0],
    y: containerCorners.topLeft[1],
    width: containerRect.width,
    height: containerRect.height
  });
  return React124.createElement("div", {
    className: mergeClasses(styles.wrapper, active && styles.wrapperActive),
    "data-safe-zone": ""
  }, active ? React124.createElement("svg", {
    "aria-hidden": true,
    className: styles.svg,
    xmlns: "http://www.w3.org/2000/svg",
    ref: svgRef,
    style: {
      width: `${svgWidth}px`,
      height: `${svgHeight}px`,
      transform: `translate(${leftOffset}px, ${topOffset}px)`
    }
  }, React124.createElement("g", {
    className: mergeClasses(styles.triangle, debug && styles.triangleDebug),
    clipPath: `url(#${clipPathId})`,
    onMouseEnter,
    onMouseMove,
    onMouseLeave
  }, React124.createElement("path", {
    d: pointsToSvgPath(triangleA)
  }), React124.createElement("path", {
    d: pointsToSvgPath(triangleB)
  }), React124.createElement("path", {
    d: pointsToSvgPath(triangleC)
  }), React124.createElement("path", {
    d: pointsToSvgPath(triangleD)
  })), React124.createElement("clipPath", {
    id: clipPathId
  }, React124.createElement("path", {
    d: clipPath
  })), debug && React124.createElement("path", {
    className: styles.rectDebug,
    d: clipPath
  })) : null);
});

// node_modules/@fluentui/react-positioning/lib/hooks/useSafeZoneArea/useSafeZoneArea.js
var MOUSE_MOVE_TARGET_POLLING_TIMEOUT = 2e3;
function useSafeZoneArea({ debug = false, disabled = false, onSafeZoneEnter, onSafeZoneMove, onSafeZoneLeave, onSafeZoneTimeout, timeout = 1500 } = {}) {
  const [stateStore] = React125.useState(createSafeZoneAreaStateStore);
  const safeZoneAreaRef = React125.useRef(null);
  const containerRef = React125.useRef(null);
  const targetRef = React125.useRef(null);
  const [setSafeZoneCloseTimeout, clearSafeZoneCloseTimeout] = useTimeout();
  const [requestUpdateFrame, clearUpdateFrame] = useAnimationFrame();
  const mouseCoordinatesRef = React125.useRef({
    x: 0,
    y: 0
  });
  const containerListenerRef = React125.useMemo(() => {
    if (disabled) {
      return () => {
      };
    }
    let containerEl = null;
    function onContainerMouseEnter() {
      clearSafeZoneCloseTimeout();
      stateStore.toggleActive(false);
    }
    return (el) => {
      if (el === null) {
        containerEl === null || containerEl === void 0 ? void 0 : containerEl.removeEventListener("mouseenter", onContainerMouseEnter);
      }
      containerEl = el;
      el === null || el === void 0 ? void 0 : el.addEventListener("mouseenter", onContainerMouseEnter);
    };
  }, [
    clearSafeZoneCloseTimeout,
    disabled,
    stateStore
  ]);
  const targetListenerRef = React125.useMemo(() => {
    if (disabled) {
      return () => {
      };
    }
    let targetEl = null;
    function onTargetMouseMove(e) {
      mouseCoordinatesRef.current = {
        x: e.clientX,
        y: e.clientY
      };
      if (!stateStore.isActive()) {
        stateStore.toggleActive(true);
      }
      setSafeZoneCloseTimeout(() => {
        stateStore.toggleActive(false);
      }, MOUSE_MOVE_TARGET_POLLING_TIMEOUT);
    }
    return (el) => {
      if (el === null) {
        clearUpdateFrame();
        clearSafeZoneCloseTimeout();
        targetEl === null || targetEl === void 0 ? void 0 : targetEl.removeEventListener("mousemove", onTargetMouseMove);
      }
      targetEl = el;
      el === null || el === void 0 ? void 0 : el.addEventListener("mousemove", onTargetMouseMove);
    };
  }, [
    clearUpdateFrame,
    clearSafeZoneCloseTimeout,
    disabled,
    stateStore,
    setSafeZoneCloseTimeout
  ]);
  const onSvgMouseEnter = useEventCallback((e) => {
    onSafeZoneEnter === null || onSafeZoneEnter === void 0 ? void 0 : onSafeZoneEnter(e);
    setSafeZoneCloseTimeout(() => {
      stateStore.toggleActive(false);
      onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 ? void 0 : onSafeZoneTimeout();
    }, timeout);
  });
  const onSvgMouseMove = useEventCallback((e) => {
    setSafeZoneCloseTimeout(() => {
      stateStore.toggleActive(false);
      onSafeZoneTimeout === null || onSafeZoneTimeout === void 0 ? void 0 : onSafeZoneTimeout();
    }, timeout);
    onSafeZoneMove === null || onSafeZoneMove === void 0 ? void 0 : onSafeZoneMove(e);
  });
  const onSvgMouseLeave = useEventCallback((e) => {
    onSafeZoneLeave === null || onSafeZoneLeave === void 0 ? void 0 : onSafeZoneLeave(e);
  });
  React125.useEffect(() => {
    return stateStore.subscribe((isActive) => {
      if (isActive) {
        let updateSVGs = function() {
          const containerEl = containerRef.current;
          const targetEl = targetRef.current;
          if (containerEl && targetEl) {
            var _safeZoneAreaRef_current;
            (_safeZoneAreaRef_current = safeZoneAreaRef.current) === null || _safeZoneAreaRef_current === void 0 ? void 0 : _safeZoneAreaRef_current.updateSVG({
              containerRect: containerEl.getBoundingClientRect(),
              mouseCoordinates: [
                mouseCoordinatesRef.current.x,
                mouseCoordinatesRef.current.y
              ],
              targetRect: targetEl.getBoundingClientRect()
            });
          }
          requestUpdateFrame(updateSVGs);
        };
        updateSVGs();
        return;
      }
      clearUpdateFrame();
    });
  }, [
    clearUpdateFrame,
    requestUpdateFrame,
    stateStore
  ]);
  return {
    containerRef: useMergedRefs(containerRef, containerListenerRef),
    targetRef: useMergedRefs(targetRef, targetListenerRef),
    elementToRender: React125.useMemo(() => disabled ? null : React125.createElement(SafeZoneArea, {
      debug,
      onMouseEnter: onSvgMouseEnter,
      onMouseMove: onSvgMouseMove,
      onMouseLeave: onSvgMouseLeave,
      imperativeRef: safeZoneAreaRef,
      stateStore
    }), [
      disabled,
      debug,
      onSvgMouseEnter,
      onSvgMouseMove,
      onSvgMouseLeave,
      stateStore
    ])
  };
}

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var React131 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var React126 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/popoverContext.js
var PopoverContext = createContext13(void 0);
var popoverContextDefaultValue = {
  open: false,
  setOpen: () => null,
  toggleOpen: () => null,
  triggerRef: {
    current: null
  },
  contentRef: {
    current: null
  },
  arrowRef: {
    current: null
  },
  openOnContext: false,
  openOnHover: false,
  size: "medium",
  trapFocus: false,
  inline: false
};
var PopoverProvider = PopoverContext.Provider;
var usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurface.js
var usePopoverSurface_unstable = (props, ref) => {
  const size3 = usePopoverContext_unstable((context) => context.size);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const state = usePopoverSurfaceBase_unstable(props, ref);
  return {
    appearance,
    size: size3,
    ...state
  };
};
var usePopoverSurfaceBase_unstable = (props, ref) => {
  const contentRef = usePopoverContext_unstable((context) => context.contentRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const mountNode = usePopoverContext_unstable((context) => context.mountNode);
  const arrowRef = usePopoverContext_unstable((context) => context.arrowRef);
  const withArrow = usePopoverContext_unstable((context) => context.withArrow);
  const trapFocus = usePopoverContext_unstable((context) => context.trapFocus);
  const inertTrapFocus = usePopoverContext_unstable((context) => context.inertTrapFocus);
  const inline2 = usePopoverContext_unstable((context) => context.inline);
  const { modalAttributes } = useModalAttributes({
    trapFocus,
    legacyTrapFocus: !inertTrapFocus,
    alwaysFocusable: !trapFocus
  });
  const state = {
    inline: inline2,
    withArrow,
    arrowRef,
    mountNode,
    components: {
      root: "div"
    },
    root: slot_exports.always({
      ref: useMergedRefs(ref, contentRef),
      role: trapFocus ? "dialog" : "group",
      "aria-modal": trapFocus ? true : void 0,
      ...modalAttributes,
      ...props
    }, {
      elementType: "div"
    })
  };
  const { onMouseEnter: onMouseEnterOriginal, onMouseLeave: onMouseLeaveOriginal, onKeyDown: onKeyDownOriginal } = state.root;
  state.root.onMouseEnter = (e) => {
    if (openOnHover) {
      setOpen(e, true);
    }
    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(e);
  };
  state.root.onMouseLeave = (e) => {
    if (openOnHover) {
      setOpen(e, false);
    }
    onMouseLeaveOriginal === null || onMouseLeaveOriginal === void 0 ? void 0 : onMouseLeaveOriginal(e);
  };
  state.root.onKeyDown = (e) => {
    var _contentRef_current;
    if (e.key === "Escape" && ((_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.contains(e.target))) {
      e.preventDefault();
      setOpen(e, false);
    }
    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(e);
  };
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var React130 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var React128 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/utils/toMountNodeProps.js
function toMountNodeProps(mountNode) {
  if (isHTMLElement(mountNode)) {
    return {
      element: mountNode
    };
  }
  if (typeof mountNode === "object") {
    if (mountNode === null) {
      return {
        element: null
      };
    }
    return mountNode;
  }
  return {};
}

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var React127 = __toESM(require_react());

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNodeStyles.styles.js
var usePortalMountNodeStylesStyles = __styles2({
  root: {
    qhf8xq: "f1euv43f",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bj3rh1h: "f494woh"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
});

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortalMountNode.js
var useInsertionEffect4 = React127["useInsertionEffect"];
var useLegacyElementFactory = (options) => {
  "use no memo";
  const { className, dir, focusVisibleRef, targetNode } = options;
  const targetElement = React127.useMemo(() => {
    if (targetNode === void 0 || options.disabled) {
      return null;
    }
    const element = targetNode.ownerDocument.createElement("div");
    targetNode.appendChild(element);
    return element;
  }, [
    targetNode,
    options.disabled
  ]);
  React127.useMemo(() => {
    if (!targetElement) {
      return;
    }
    targetElement.className = className;
    targetElement.setAttribute("dir", dir);
    targetElement.setAttribute("data-portal-node", "true");
    focusVisibleRef.current = targetElement;
  }, [
    className,
    dir,
    targetElement,
    focusVisibleRef
  ]);
  React127.useEffect(() => {
    return () => {
      targetElement === null || targetElement === void 0 ? void 0 : targetElement.remove();
    };
  }, [
    targetElement
  ]);
  return targetElement;
};
var initializeElementFactory = () => {
  let currentElement = void 0;
  function get(targetRoot, forceCreation) {
    if (currentElement) {
      return currentElement;
    }
    if (forceCreation) {
      currentElement = targetRoot.ownerDocument.createElement("div");
      targetRoot.appendChild(currentElement);
    }
    return currentElement;
  }
  function dispose() {
    if (currentElement) {
      currentElement.remove();
      currentElement = void 0;
    }
  }
  return {
    get,
    dispose
  };
};
var useModernElementFactory = (options) => {
  "use no memo";
  const { className, dir, focusVisibleRef, targetNode } = options;
  const [elementFactory] = React127.useState(initializeElementFactory);
  const elementProxy = React127.useMemo(() => {
    if (targetNode === void 0 || options.disabled) {
      return null;
    }
    return new Proxy({}, {
      get(_, property) {
        if (property === "nodeType") {
          return 1;
        }
        if (property === "remove") {
          const targetElement2 = elementFactory.get(targetNode, false);
          if (targetElement2) {
            const portalHasNoChildren = targetElement2.childNodes.length === 0;
            if (portalHasNoChildren) {
              elementFactory.dispose();
            }
          }
          return () => {
          };
        }
        const targetElement = elementFactory.get(targetNode, true);
        const targetProperty = targetElement ? targetElement[property] : void 0;
        if (typeof targetProperty === "function") {
          return targetProperty.bind(targetElement);
        }
        return targetProperty;
      },
      set(_, property, value) {
        const ignoredProperty = property === "_virtual" || property === "focusVisible";
        const targetElement = ignoredProperty ? elementFactory.get(targetNode, false) : elementFactory.get(targetNode, true);
        if (ignoredProperty && !targetElement) {
          return true;
        }
        if (targetElement) {
          Object.assign(targetElement, {
            [property]: value
          });
          return true;
        }
        return false;
      }
    });
  }, [
    elementFactory,
    targetNode,
    options.disabled
  ]);
  useInsertionEffect4(() => {
    if (!elementProxy) {
      return;
    }
    const classesToApply = className.split(" ").filter(Boolean);
    elementProxy.classList.add(...classesToApply);
    elementProxy.setAttribute("dir", dir);
    elementProxy.setAttribute("data-portal-node", "true");
    focusVisibleRef.current = elementProxy;
    return () => {
      elementProxy.classList.remove(...classesToApply);
      elementProxy.removeAttribute("dir");
    };
  }, [
    className,
    dir,
    elementProxy,
    focusVisibleRef
  ]);
  React127.useEffect(() => {
    return () => {
      elementProxy === null || elementProxy === void 0 ? void 0 : elementProxy.remove();
    };
  }, [
    elementProxy
  ]);
  return elementProxy;
};
var useElementFactory = useInsertionEffect4 ? useModernElementFactory : useLegacyElementFactory;
var usePortalMountNode2 = (options) => {
  "use no memo";
  const { targetDocument, dir } = useFluent();
  const mountNode = usePortalMountNode();
  const focusVisibleRef = useFocusVisible();
  const classes = usePortalMountNodeStylesStyles();
  const themeClassName = useThemeClassName();
  const factoryOptions = {
    dir,
    disabled: options.disabled,
    focusVisibleRef,
    className: mergeClasses(themeClassName, classes.root, options.className),
    targetNode: mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body
  };
  return useElementFactory(factoryOptions);
};

// node_modules/@fluentui/react-portal/lib/components/Portal/usePortal.js
var usePortal_unstable = (props) => {
  const { element, className } = toMountNodeProps(props.mountNode);
  const virtualParentRootRef = React128.useRef(null);
  const fallbackElement = usePortalMountNode2({
    disabled: !!element,
    className
  });
  const mountNode = element !== null && element !== void 0 ? element : fallbackElement;
  const state = {
    children: props.children,
    mountNode,
    virtualParentRootRef
  };
  React128.useEffect(() => {
    if (!mountNode) {
      return;
    }
    const virtualParent = virtualParentRootRef.current;
    const isVirtualParentInsideChild = mountNode.contains(virtualParent);
    if (virtualParent && !isVirtualParentInsideChild) {
      setVirtualParent(mountNode, virtualParent);
      return () => {
        setVirtualParent(mountNode, void 0);
      };
    }
  }, [
    virtualParentRootRef,
    mountNode
  ]);
  return state;
};

// node_modules/@fluentui/react-portal/lib/components/Portal/renderPortal.js
var ReactDOM = __toESM(require_react_dom());
var React129 = __toESM(require_react());
var renderPortal_unstable = (state) => {
  return React129.createElement("span", {
    hidden: true,
    ref: state.virtualParentRootRef
  }, state.mountNode && ReactDOM.createPortal(React129.createElement(React129.Fragment, null, state.children, React129.createElement("span", {
    hidden: true
  })), state.mountNode));
};

// node_modules/@fluentui/react-portal/lib/components/Portal/Portal.js
var Portal = (props) => {
  const state = usePortal_unstable(props);
  return renderPortal_unstable(state);
};
Portal.displayName = "Portal";

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/renderPopoverSurface.js
var renderPopoverSurface_unstable = (state) => {
  assertSlots(state);
  const surface = jsxs(state.root, {
    children: [
      state.withArrow && jsx("div", {
        ref: state.arrowRef,
        className: state.arrowClassName
      }),
      state.root.children
    ]
  });
  if (state.inline) {
    return surface;
  }
  return jsx(Portal, {
    mountNode: state.mountNode,
    children: surface
  });
};

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/usePopoverSurfaceStyles.styles.js
var popoverSurfaceClassNames = {
  root: "fui-PopoverSurface"
};
var arrowHeights = {
  small: 6,
  medium: 8,
  large: 8
};
var useStyles9 = __styles2({
  root: {
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B93otf3: "f18k4bn6",
    vin17d: "fo1kyvf",
    Ezkn3b: "fetxo7e",
    nyiy2g: "f8x1vz1",
    swvrvq: "f8g0anz",
    Bkovbt3: "fezwn9i",
    hgjdhn: "fz5efge",
    fsy9dk: "f1ydixl4",
    B3ogreh: "f8dgqj5",
    jv49x5: "fnyfnr8",
    Bk7o48c: "fgw77r4",
    Bv12yb3: "f1noc5he",
    i09l9u: "f1k46bua",
    Bcrj8ia: "f1lhuzxm",
    Bmmhre5: "f1f9qikc",
    Bhu2qc9: "fymb6k8"
  },
  inline: {
    Bj3rh1h: "f19g0ac"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  brand: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk"
  },
  smallPadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1sy4kr4"
  },
  mediumPadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f4zyqsv"
  },
  largePadding: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fop8ug2"
  },
  smallArrow: {
    rhnwrx: "f1s3jn22",
    Bdy53xb: "fv40uqz"
  },
  mediumLargeArrow: {
    rhnwrx: "f1f72gjr",
    Bdy53xb: "f69yoe5"
  },
  arrow: {
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f1euv43f",
    Bj3rh1h: "f1bsuimh",
    De3pzq: "f1u2r49w",
    B2eet1l: "fqhgnl",
    Beyfa6y: "f17bz04i",
    Bz10aip: "f36o3x3",
    Bqenvij: "fzofk8q",
    a9b677: "f1wbx1ie",
    Ftih45: "f1wl9k8s",
    Br0sdwz: "f1aocrix",
    cmx5o7: "f1ljr5q2",
    susq4k: 0,
    Biibvgv: 0,
    Bicfajf: 0,
    qehafq: 0,
    Brs5u8j: "f155f1qt",
    Ccq8qp: "f9mhzq7",
    Baz25je: "fr6rhvx",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4",
    r59vdv: "fgq90dz",
    Bkw5xw4: "fq0y47f",
    hl6cv3: "f1pwrbz6",
    aea9ga: "f1hxxcvm",
    yayu3t: "fw8rgyo",
    Bhsv975: "f1wnzycx",
    rhl9o9: "f1730wal",
    B7gxrvb: "f1fy4ixr",
    B6q6orb: "fobkauc",
    B0lu1f8: "f16bqv1l"
  }
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".f8x1vz1{--fui-positioning-slide-distance-x:0px;}", ".f8g0anz{--fui-positioning-slide-distance-y:10px;}", ".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}", ".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}", ".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}", ".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}", ".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}", ".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}", ".f1noc5he{animation-name:f1m0q9mo,f79suad;}", ".fymb6k8{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 8px 16px var(--colorNeutralShadowKey));}", ".f19g0ac{z-index:1;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", [".f1sy4kr4{padding:12px;}", {
    p: -1
  }], [".f4zyqsv{padding:16px;}", {
    p: -1
  }], [".fop8ug2{padding:20px;}", {
    p: -1
  }], ".f1s3jn22{--fui-positioning-arrow-height:8.484px;}", ".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}", ".f1f72gjr{--fui-positioning-arrow-height:11.312px;}", ".f69yoe5{--fui-positioning-arrow-offset:-5.656px;}", ".f1ewtqcl{box-sizing:border-box;}", ".f1euv43f{position:absolute;}", ".f1bsuimh{z-index:-1;}", ".f1u2r49w{background-color:inherit;}", ".fqhgnl{background-clip:content-box;}", ".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}", ".fzofk8q{height:var(--fui-positioning-arrow-height);}", ".f1wbx1ie{width:var(--fui-positioning-arrow-height);}", '.f1wl9k8s::before{content:"";}', ".f1aocrix::before{display:block;}", ".f1ljr5q2::before{background-color:inherit;}", [".f155f1qt::before{margin:-1px;}", {
    p: -1
  }], ".f9mhzq7::before{width:100%;}", ".fr6rhvx::before{height:100%;}", [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}", '[data-popper-placement^="top"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="top"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}', '[data-popper-placement^="right"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="right"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}', '[data-popper-placement^="bottom"] .f1730wal{top:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="bottom"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}', '[data-popper-placement^="left"] .fobkauc{right:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="left"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}'],
  k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
  m: [["@media (prefers-reduced-motion){.f1k46bua[data-popper-placement]{animation-duration:1ms;}}", {
    m: "(prefers-reduced-motion)"
  }], ["@media (prefers-reduced-motion){.f1lhuzxm[data-popper-placement]{animation-name:f1m0q9mo;}}", {
    m: "(prefers-reduced-motion)"
  }]],
  t: ["@supports not (animation-composition: accumulate){.f1f9qikc[data-popper-placement]{animation-name:f1m0q9mo;}}"]
});
var usePopoverSurfaceStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles9();
  state.root.className = mergeClasses(popoverSurfaceClassNames.root, styles.root, state.inline && styles.inline, state.size === "small" && styles.smallPadding, state.size === "medium" && styles.mediumPadding, state.size === "large" && styles.largePadding, state.appearance === "inverted" && styles.inverted, state.appearance === "brand" && styles.brand, state.root.className);
  state.arrowClassName = mergeClasses(styles.arrow, state.size === "small" ? styles.smallArrow : styles.mediumLargeArrow);
  return state;
};

// node_modules/@fluentui/react-popover/lib/components/PopoverSurface/PopoverSurface.js
var PopoverSurface = React131.forwardRef((props, ref) => {
  const state = usePopoverSurface_unstable(props, ref);
  usePopoverSurfaceStyles_unstable(state);
  useCustomStyleHook("usePopoverSurfaceStyles_unstable")(state);
  return renderPopoverSurface_unstable(state);
});
PopoverSurface.displayName = "PopoverSurface";

// node_modules/@fluentui/react-popover/lib/components/Popover/constants.js
var popoverSurfaceBorderRadius = 4;

// node_modules/@fluentui/react-popover/lib/components/Popover/usePopover.js
var usePopover_unstable = (props) => {
  const { appearance, size: size3 = "medium" } = props;
  const positioning = resolvePositioningShorthand(props.positioning);
  const withArrow = props.withArrow && !positioning.coverTarget;
  const state = usePopoverBase_unstable({
    ...props,
    positioning: {
      ...positioning,
      // Update the offset with the arrow size only when it's available
      ...withArrow ? {
        offset: mergeArrowOffset(positioning.offset, arrowHeights[size3])
      } : {}
    }
  });
  return {
    appearance,
    size: size3,
    ...state
  };
};
var usePopoverBase_unstable = (props) => {
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const initialState = {
    contextTarget,
    setContextTarget,
    ...props
  };
  const children = React132.Children.toArray(props.children);
  if (true) {
    if (children.length === 0) {
      console.warn("Popover must contain at least one child");
    }
    if (children.length > 2) {
      console.warn("Popover must contain at most two children");
    }
  }
  let popoverTrigger = void 0;
  let popoverSurface = void 0;
  if (children.length === 2) {
    popoverTrigger = children[0];
    popoverSurface = children[1];
  } else if (children.length === 1) {
    popoverSurface = children[0];
  }
  const [open, setOpenState] = useOpenState(initialState);
  const [setOpenTimeout, clearOpenTimeout] = useTimeout();
  const setOpen = useEventCallback((e, shouldOpen) => {
    clearOpenTimeout();
    if (!(e instanceof Event) && e.persist) {
      e.persist();
    }
    if (e.type === "mouseleave") {
      var _props_mouseLeaveDelay;
      setOpenTimeout(() => {
        setOpenState(e, shouldOpen);
      }, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
    } else {
      setOpenState(e, shouldOpen);
    }
  });
  const toggleOpen = React132.useCallback((e) => {
    setOpen(e, !open);
  }, [
    setOpen,
    open
  ]);
  const positioningRefs = usePopoverRefs(initialState);
  const { targetDocument } = useFluent();
  var _props_closeOnIframeFocus;
  useOnClickOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open,
    disabledFocusOnIframe: !((_props_closeOnIframeFocus = props.closeOnIframeFocus) !== null && _props_closeOnIframeFocus !== void 0 ? _props_closeOnIframeFocus : true)
  });
  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (ev) => setOpen(ev, false),
    refs: [
      positioningRefs.triggerRef,
      positioningRefs.contentRef
    ],
    disabled: !open || !closeOnScroll
  });
  const { findFirstFocusable } = useFocusFinders();
  const activateModal = useActivateModal();
  React132.useEffect(() => {
    if (props.unstable_disableAutoFocus) {
      return;
    }
    const contentElement = positioningRefs.contentRef.current;
    if (open && contentElement) {
      var _contentElement_getAttribute;
      const shouldFocusContainer = !isNaN((_contentElement_getAttribute = contentElement.getAttribute("tabIndex")) !== null && _contentElement_getAttribute !== void 0 ? _contentElement_getAttribute : void 0);
      const firstFocusable = shouldFocusContainer ? contentElement : findFirstFocusable(contentElement);
      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
      if (shouldFocusContainer) {
        activateModal(contentElement);
      }
    }
  }, [
    findFirstFocusable,
    activateModal,
    open,
    positioningRefs.contentRef,
    props.unstable_disableAutoFocus
  ]);
  var _props_inertTrapFocus, _props_inline;
  return {
    ...initialState,
    ...positioningRefs,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    inertTrapFocus: (_props_inertTrapFocus = props.inertTrapFocus) !== null && _props_inertTrapFocus !== void 0 ? _props_inertTrapFocus : props.legacyTrapFocus === void 0 ? false : !props.legacyTrapFocus,
    popoverTrigger,
    popoverSurface,
    open,
    setOpen,
    toggleOpen,
    setContextTarget,
    contextTarget,
    inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
  };
};
function useOpenState(state) {
  "use no memo";
  const onOpenChange = useEventCallback((e, data) => {
    var _state_onOpenChange;
    return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
  });
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  state.open = open !== void 0 ? open : state.open;
  const setContextTarget = state.setContextTarget;
  const setOpen = React132.useCallback((e, shouldOpen) => {
    if (shouldOpen && e.type === "contextmenu") {
      setContextTarget(e);
    }
    if (!shouldOpen) {
      setContextTarget(void 0);
    }
    setOpenState(shouldOpen);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {
      open: shouldOpen
    });
  }, [
    setOpenState,
    onOpenChange,
    setContextTarget
  ]);
  return [
    open,
    setOpen
  ];
}
function usePopoverRefs(state) {
  "use no memo";
  const positioningOptions = {
    position: "above",
    align: "center",
    arrowPadding: 2 * popoverSurfaceBorderRadius,
    target: state.openOnContext ? state.contextTarget : void 0,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (positioningOptions.coverTarget) {
    state.withArrow = false;
  }
  const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);
  return {
    triggerRef,
    contentRef,
    arrowRef
  };
}

// node_modules/@fluentui/react-popover/lib/components/Popover/renderPopover.js
var React133 = __toESM(require_react());
var renderPopover_unstable = (state) => {
  const { appearance, arrowRef, contentRef, inline: inline2, mountNode, open, openOnContext, openOnHover, setOpen, size: size3, toggleOpen, trapFocus, triggerRef, withArrow, inertTrapFocus } = state;
  return React133.createElement(PopoverContext.Provider, {
    value: {
      appearance,
      arrowRef,
      contentRef,
      inline: inline2,
      mountNode,
      open,
      openOnContext,
      openOnHover,
      setOpen,
      toggleOpen,
      triggerRef,
      size: size3,
      trapFocus,
      inertTrapFocus,
      withArrow
    }
  }, state.popoverTrigger, state.open && state.popoverSurface);
};

// node_modules/@fluentui/react-popover/lib/components/Popover/Popover.js
var Popover = (props) => {
  const state = usePopover_unstable(props);
  return renderPopover_unstable(state);
};
Popover.displayName = "Popover";

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var React136 = __toESM(require_react());

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/usePopoverTrigger.js
var React135 = __toESM(require_react());
var usePopoverTrigger_unstable = (props) => {
  const { children, disableButtonEnhancement = false } = props;
  const child = getTriggerChild(children);
  const open = usePopoverContext_unstable((context) => context.open);
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
  const openOnContext = usePopoverContext_unstable((context) => context.openOnContext);
  const { triggerAttributes } = useModalAttributes();
  const onContextMenu = (e) => {
    if (openOnContext) {
      e.preventDefault();
      setOpen(e, true);
    }
  };
  const onClick = (e) => {
    if (!openOnContext) {
      toggleOpen(e);
    }
  };
  const onKeyDown = (e) => {
    if (e.key === Escape && open && !e.isDefaultPrevented()) {
      setOpen(e, false);
      e.preventDefault();
    }
  };
  const onMouseEnter = (e) => {
    if (openOnHover) {
      setOpen(e, true);
    }
  };
  const onMouseLeave = (e) => {
    if (openOnHover) {
      setOpen(e, false);
    }
  };
  const contextMenuProps = {
    ...triggerAttributes,
    "aria-expanded": `${open}`,
    ...child === null || child === void 0 ? void 0 : child.props,
    onMouseEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    ref: useMergedRefs(triggerRef, getReactElementRef(child))
  };
  const triggerChildProps = {
    ...contextMenuProps,
    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
  return {
    children: applyTriggerPropsToChildren(props.children, useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps))
  };
};

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/renderPopoverTrigger.js
var renderPopoverTrigger_unstable = (state) => {
  return state.children;
};

// node_modules/@fluentui/react-popover/lib/components/PopoverTrigger/PopoverTrigger.js
var PopoverTrigger = (props) => {
  const state = usePopoverTrigger_unstable(props);
  return renderPopoverTrigger_unstable(state);
};
PopoverTrigger.displayName = "PopoverTrigger";
PopoverTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/renderAvatarGroupPopover.js
var renderAvatarGroupPopover_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(PopoverTrigger, {
        disableButtonEnhancement: true,
        children: jsx(state.tooltip, {
          children: jsx(state.triggerButton, {})
        })
      }),
      jsx(state.popoverSurface, {
        children: jsx(AvatarGroupProvider, {
          value: contextValues.avatarGroup,
          children: jsx(state.content, {})
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverContextValues.js
var useAvatarGroupPopoverContextValues_unstable = (state) => {
  const avatarGroup = {
    isOverflow: true,
    size: 24
  };
  return {
    avatarGroup
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var React140 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var React139 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipBase.js
var React138 = __toESM(require_react());

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/constants.js
var arrowHeight = 6;
var tooltipBorderRadius = 4;

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/private/useTooltipTimeout.js
var React137 = __toESM(require_react());
var setTimeoutNoop2 = (_callback) => -1;
var clearTimeoutNoop2 = (_handle) => void 0;
function useTooltipTimeout(triggerElementRef) {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const setTimerFn = win ? win.setTimeout : setTimeoutNoop2;
  const clearTimerFn = win ? win.clearTimeout : clearTimeoutNoop2;
  const id = React137.useRef(void 0);
  const set = React137.useCallback((fn, delay) => {
    if (id.current !== void 0) {
      clearTimerFn(id.current);
    }
    id.current = setTimerFn(fn, delay !== null && delay !== void 0 ? delay : 0);
    return id.current;
  }, [
    clearTimerFn,
    setTimerFn
  ]);
  const cancel = React137.useCallback(() => {
    if (id.current !== void 0) {
      clearTimerFn(id.current);
      id.current = void 0;
    }
  }, [
    clearTimerFn
  ]);
  React137.useEffect(() => {
    const el = triggerElementRef.current;
    return () => {
      const isRealUnmount = !el || !el.isConnected;
      if (isRealUnmount) {
        cancel();
      }
    };
  }, [
    cancel,
    triggerElementRef
  ]);
  return [
    set,
    cancel
  ];
}

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipBase.js
var useTooltipBase_unstable = (props) => {
  "use no memo";
  var _child_props, _child_props1, _child_props2, _child_props3, _child_props4, _child_props5, _child_props6;
  const context = useTooltipVisibility();
  const isServerSideRender = useIsSSR();
  const { targetDocument } = useFluent();
  const [visible, setVisibleInternal] = useControllableState({
    state: props.visible,
    initialState: false
  });
  const { children, content, withArrow = false, positioning = "above", onVisibleChange, relationship, showDelay = 250, hideDelay = 250, mountNode } = props;
  const state = {
    withArrow,
    positioning,
    showDelay,
    hideDelay,
    relationship,
    visible,
    shouldRenderTooltip: visible,
    mountNode,
    // Slots
    components: {
      content: "div"
    },
    content: slot_exports.always(content, {
      defaultProps: {
        role: "tooltip"
      },
      elementType: "div"
    })
  };
  state.content.id = useId2("tooltip-", state.content.id);
  const positioningOptions = {
    enabled: state.visible,
    arrowPadding: 2 * tooltipBorderRadius,
    position: "above",
    align: "center",
    offset: 4,
    ...resolvePositioningShorthand(state.positioning)
  };
  if (state.withArrow) {
    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
  }
  const { targetRef, containerRef, arrowRef } = usePositioning(positioningOptions);
  const [setDelayTimeout, clearDelayTimeout] = useTooltipTimeout(containerRef);
  const setVisible = React138.useCallback((ev, data) => {
    clearDelayTimeout();
    setVisibleInternal((oldVisible) => {
      if (data.visible !== oldVisible) {
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, data);
      }
      return data.visible;
    });
  }, [
    clearDelayTimeout,
    setVisibleInternal,
    onVisibleChange
  ]);
  state.content.ref = useMergedRefs(state.content.ref, containerRef);
  state.arrowRef = arrowRef;
  useIsomorphicLayoutEffect(() => {
    if (visible) {
      var _context_visibleTooltip;
      const thisTooltip = {
        hide: (ev) => setVisible(void 0, {
          visible: false,
          documentKeyboardEvent: ev
        })
      };
      (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();
      context.visibleTooltip = thisTooltip;
      const onDocumentKeyDown = (ev) => {
        if (ev.key === Escape && !ev.defaultPrevented) {
          thisTooltip.hide(ev);
          ev.preventDefault();
        }
      };
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("keydown", onDocumentKeyDown, {
        // As this event is added at targeted document,
        // we need to capture the event to be sure keydown handling from tooltip happens first
        capture: true
      });
      return () => {
        if (context.visibleTooltip === thisTooltip) {
          context.visibleTooltip = void 0;
        }
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("keydown", onDocumentKeyDown, {
          capture: true
        });
      };
    }
  }, [
    context,
    targetDocument,
    visible,
    setVisible
  ]);
  const ignoreNextFocusEventRef = React138.useRef(false);
  const onEnterTrigger = React138.useCallback((ev) => {
    if (ev.type === "focus" && ignoreNextFocusEventRef.current) {
      ignoreNextFocusEventRef.current = false;
      return;
    }
    const delay = context.visibleTooltip ? 0 : state.showDelay;
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: true
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.showDelay,
    context
  ]);
  const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
  const [keyborgListenerCallbackRef] = React138.useState(() => {
    const onKeyborgFocusIn = (ev) => {
      var _ev_detail;
      if (((_ev_detail = ev.detail) === null || _ev_detail === void 0 ? void 0 : _ev_detail.isFocusedProgrammatically) && !isNavigatingWithKeyboard()) {
        ignoreNextFocusEventRef.current = true;
      }
    };
    let current = null;
    return (element) => {
      current === null || current === void 0 ? void 0 : current.removeEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      element === null || element === void 0 ? void 0 : element.addEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
      current = element;
    };
  });
  const onLeaveTrigger = React138.useCallback((ev) => {
    let delay = state.hideDelay;
    if (ev.type === "blur") {
      delay = 0;
      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
    }
    setDelayTimeout(() => {
      setVisible(ev, {
        visible: false
      });
    }, delay);
    ev.persist();
  }, [
    setDelayTimeout,
    setVisible,
    state.hideDelay,
    targetDocument
  ]);
  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
  const child = getTriggerChild(children);
  const triggerAriaProps = {};
  const isPopupExpanded = (child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props["aria-haspopup"]) && ((child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1["aria-expanded"]) === true || (child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2["aria-expanded"]) === "true");
  if (relationship === "label") {
    if (typeof state.content.children === "string") {
      triggerAriaProps["aria-label"] = state.content.children;
    } else {
      triggerAriaProps["aria-labelledby"] = state.content.id;
      state.shouldRenderTooltip = true;
    }
  } else if (relationship === "description") {
    triggerAriaProps["aria-describedby"] = state.content.id;
    state.shouldRenderTooltip = true;
  }
  if (isServerSideRender || isPopupExpanded) {
    state.shouldRenderTooltip = false;
  }
  state.children = applyTriggerPropsToChildren(children, {
    ...triggerAriaProps,
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: useMergedRefs(
      getReactElementRef(child),
      keyborgListenerCallbackRef,
      // If the target prop is not provided, attach targetRef to the trigger element's ref prop
      positioningOptions.target === void 0 ? targetRef : void 0
    ),
    onPointerEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onPointerEnter, onEnterTrigger)),
    onPointerLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props4 = child.props) === null || _child_props4 === void 0 ? void 0 : _child_props4.onPointerLeave, onLeaveTrigger)),
    onFocus: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props5 = child.props) === null || _child_props5 === void 0 ? void 0 : _child_props5.onFocus, onEnterTrigger)),
    onBlur: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props6 = child.props) === null || _child_props6 === void 0 ? void 0 : _child_props6.onBlur, onLeaveTrigger))
  });
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltip.js
var useTooltip_unstable = (props) => {
  "use no memo";
  const { appearance = "normal" } = props;
  const state = useTooltipBase_unstable(props);
  return {
    appearance,
    ...state
  };
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/renderTooltip.js
var renderTooltip_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      state.children,
      state.shouldRenderTooltip && jsx(Portal, {
        mountNode: state.mountNode,
        children: jsxs(state.content, {
          children: [
            state.withArrow && jsx("div", {
              ref: state.arrowRef,
              className: state.arrowClassName
            }),
            state.content.children
          ]
        })
      })
    ]
  });
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/useTooltipStyles.styles.js
var tooltipClassNames = {
  content: "fui-Tooltip__content"
};
var useStyles10 = __styles2({
  root: {
    mc9l5x: "fjseox",
    B7ck84d: "f1ewtqcl",
    B2u0y6b: "f132xexn",
    Bceei9c: "f158kwzp",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    Btd35i7: "fokg9q4",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bzqsji",
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5",
    Bhu2qc9: "fxeb0a7"
  },
  visible: {
    mc9l5x: "ftgm304"
  },
  inverted: {
    De3pzq: "fg3r6xk",
    sj55zd: "fonrgv7"
  },
  arrow: {
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f1euv43f",
    Bj3rh1h: "f1bsuimh",
    rhnwrx: "f1s3jn22",
    Bdy53xb: "fv40uqz",
    De3pzq: "f1u2r49w",
    B2eet1l: "fqhgnl",
    Beyfa6y: "f17bz04i",
    Bz10aip: "f36o3x3",
    Bqenvij: "fzofk8q",
    a9b677: "f1wbx1ie",
    Ftih45: "f1wl9k8s",
    Br0sdwz: "f1aocrix",
    cmx5o7: "f1ljr5q2",
    susq4k: 0,
    Biibvgv: 0,
    Bicfajf: 0,
    qehafq: 0,
    Brs5u8j: "f155f1qt",
    Ccq8qp: "f9mhzq7",
    Baz25je: "fr6rhvx",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4",
    r59vdv: "fgq90dz",
    Bkw5xw4: "fq0y47f",
    hl6cv3: "f1pwrbz6",
    aea9ga: "f1hxxcvm",
    yayu3t: "fw8rgyo",
    Bhsv975: "f1wnzycx",
    rhl9o9: "f1730wal",
    B7gxrvb: "f1fy4ixr",
    B6q6orb: "fobkauc",
    B0lu1f8: "f16bqv1l"
  }
}, {
  d: [".fjseox{display:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f132xexn{max-width:240px;}", ".f158kwzp{cursor:default;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fokg9q4{overflow-wrap:break-word;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], [".f1bzqsji{padding:4px 11px 6px 11px;}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxeb0a7{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 4px 8px var(--colorNeutralShadowKey));}", ".ftgm304{display:block;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1euv43f{position:absolute;}", ".f1bsuimh{z-index:-1;}", ".f1s3jn22{--fui-positioning-arrow-height:8.484px;}", ".fv40uqz{--fui-positioning-arrow-offset:-4.242px;}", ".f1u2r49w{background-color:inherit;}", ".fqhgnl{background-clip:content-box;}", ".f17bz04i{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f36o3x3{transform:rotate(var(--fui-positioning-arrow-angle));}", ".fzofk8q{height:var(--fui-positioning-arrow-height);}", ".f1wbx1ie{width:var(--fui-positioning-arrow-height);}", '.f1wl9k8s::before{content:"";}', ".f1aocrix::before{display:block;}", ".f1ljr5q2::before{background-color:inherit;}", [".f155f1qt::before{margin:-1px;}", {
    p: -1
  }], ".f9mhzq7::before{width:100%;}", ".fr6rhvx::before{height:100%;}", [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fgq90dz::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".fq0y47f::before{clip-path:polygon(0% 0%, 100% 100%, 0% 100%);}", '[data-popper-placement^="top"] .f1pwrbz6{bottom:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="top"] .f1hxxcvm{--fui-positioning-arrow-angle:-45deg;}', '[data-popper-placement^="right"] .fw8rgyo{left:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="right"] .f1wnzycx{--fui-positioning-arrow-angle:45deg;}', '[data-popper-placement^="bottom"] .f1730wal{top:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="bottom"] .f1fy4ixr{--fui-positioning-arrow-angle:135deg;}', '[data-popper-placement^="left"] .fobkauc{right:var(--fui-positioning-arrow-offset);}', '[data-popper-placement^="left"] .f16bqv1l{--fui-positioning-arrow-angle:225deg;}']
});
var useTooltipStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles10();
  state.content.className = mergeClasses(tooltipClassNames.content, styles.root, state.appearance === "inverted" && styles.inverted, state.visible && styles.visible, state.content.className);
  state.arrowClassName = styles.arrow;
  return state;
};

// node_modules/@fluentui/react-tooltip/lib/components/Tooltip/Tooltip.js
var Tooltip = (props) => {
  const state = useTooltip_unstable(props);
  useTooltipStyles_unstable(state);
  useCustomStyleHook("useTooltipStyles_unstable")(state);
  return renderTooltip_unstable(state);
};
Tooltip.displayName = "Tooltip";
Tooltip.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopover.js
var useAvatarGroupPopover_unstable = (props) => {
  var _useAvatarGroupContext_unstable;
  const size3 = (_useAvatarGroupContext_unstable = useAvatarGroupContext_unstable((ctx) => ctx.size)) !== null && _useAvatarGroupContext_unstable !== void 0 ? _useAvatarGroupContext_unstable : defaultAvatarGroupSize;
  const layout = useAvatarGroupContext_unstable((ctx) => ctx.layout);
  const { indicator = size3 < 24 ? "icon" : "count", count = React140.Children.count(props.children), children, ...restOfProps } = props;
  const [popoverOpen, setPopoverOpen] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const handleOnPopoverChange = (e, data) => {
    var _restOfProps_onOpenChange;
    (_restOfProps_onOpenChange = restOfProps.onOpenChange) === null || _restOfProps_onOpenChange === void 0 ? void 0 : _restOfProps_onOpenChange.call(restOfProps, e, data);
    setPopoverOpen(data.open);
  };
  let triggerButtonChildren;
  if (layout === "pie") {
    triggerButtonChildren = null;
  } else if (indicator === "icon") {
    triggerButtonChildren = React140.createElement(MoreHorizontalRegular, null);
  } else {
    triggerButtonChildren = count > 99 ? "99+" : `+${count}`;
  }
  return {
    count,
    indicator,
    layout,
    popoverOpen,
    size: size3,
    components: {
      root: Popover,
      triggerButton: "button",
      content: "ul",
      popoverSurface: PopoverSurface,
      tooltip: Tooltip
    },
    root: slot_exports.always({
      // Popover expects a child for its children. The children are added in the renderAvatarGroupPopover.
      children: React140.createElement(React140.Fragment, null),
      size: "small",
      trapFocus: true,
      ...restOfProps,
      open: popoverOpen,
      onOpenChange: handleOnPopoverChange
    }, {
      elementType: Popover
    }),
    triggerButton: slot_exports.always(props.triggerButton, {
      defaultProps: {
        children: triggerButtonChildren,
        type: "button"
      },
      elementType: "button"
    }),
    content: slot_exports.always(props.content, {
      defaultProps: {
        children,
        role: "list"
      },
      elementType: "ul"
    }),
    popoverSurface: slot_exports.always(props.popoverSurface, {
      defaultProps: {
        "aria-label": "Overflow",
        tabIndex: 0
      },
      elementType: PopoverSurface
    }),
    tooltip: slot_exports.always(props.tooltip, {
      defaultProps: {
        content: "View more people.",
        relationship: "label"
      },
      elementType: Tooltip
    })
  };
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/useAvatarGroupPopoverStyles.styles.js
var avatarGroupPopoverClassNames = {
  root: "fui-AvatarGroupPopover",
  content: "fui-AvatarGroupPopover__content",
  popoverSurface: "fui-AvatarGroupPopover__popoverSurface",
  tooltip: "fui-AvatarGroupPopover__tooltip",
  triggerButton: "fui-AvatarGroupPopover__triggerButton"
};
var useContentStyles = __styles2({
  base: {
    dclx09: "ftrb29c",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".ftrb29c{list-style-type:none;}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"]
});
var usePopoverSurfaceStyles = __styles2({
  base: {
    Bxyxcbc: "fopcw2o",
    sshi5w: "f1n5o1gx",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f19r5mr9",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8",
    a9b677: "f13dwy2t"
  }
}, {
  d: [".fopcw2o{max-height:220px;}", ".f1n5o1gx{min-height:80px;}", [".f19r5mr9{overflow:hidden scroll;}", {
    p: -1
  }], [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f13dwy2t{width:220px;}"]
});
var useTriggerButtonStyles = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    qhf8xq: "f10pi13n",
    Bnnss6s: "fi64zpg",
    Brf1p80: "f4d9j23",
    Bt984gj: "f122n59",
    sj55zd: "f19n0e5",
    De3pzq: "fxugw4r",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bcq6wej: "fx5js7k",
    Jcjdmf: ["f17aelzi", "f2tn0l4"],
    sc4o1m: "f14ood81",
    Bosien3: ["f2tn0l4", "f17aelzi"]
  },
  pie: {
    De3pzq: "f1c21dwh",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    sj55zd: "f44pa96"
  },
  focusIndicator: {
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    g9k6zt: "f1nev41a"
  },
  states: {
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1knas48",
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1xlaoq0",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    lj723h: "f1g4hkjv",
    ecr2s2: "fb40n2d",
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fumykes",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  selected: {
    sj55zd: "f14nttnl",
    De3pzq: "f1nfm20t",
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"]
  },
  icon12: {
    Be2twd7: "f1ugzwwg"
  },
  icon16: {
    Be2twd7: "f4ybsrx"
  },
  icon20: {
    Be2twd7: "fe5j1ua"
  },
  icon24: {
    Be2twd7: "f1rt2boy"
  },
  icon28: {
    Be2twd7: "f24l1pt"
  },
  icon32: {
    Be2twd7: "ffl51b"
  },
  icon48: {
    Be2twd7: "f18m8u13"
  },
  caption2Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  },
  caption1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  },
  body1Strong: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  subtitle2: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  subtitle1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  },
  title3: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1x0m3f5",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fb86gi6"
  },
  borderThin: {
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"]
  },
  borderThick: {
    B4j52fo: "f18zi460",
    Bekrc4i: ["f1wpluaz", "fsfsuhs"],
    Bn0qgzm: "fmklw6v",
    ibv6hh: ["fsfsuhs", "f1wpluaz"]
  },
  borderThicker: {
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"]
  },
  borderThickest: {
    B4j52fo: "fwn6jck",
    Bekrc4i: ["figl7jc", "f1g0iy8l"],
    Bn0qgzm: "f1b8shu7",
    ibv6hh: ["f1g0iy8l", "figl7jc"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f10pi13n{position:relative;}", ".fi64zpg{flex-shrink:0;}", ".f4d9j23{justify-content:center;}", ".f122n59{align-items:center;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f44pa96{color:transparent;}", [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}", ".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}", ".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}", ".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fb86gi6{line-height:var(--lineHeightBase600);}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".f18zi460{border-top-width:var(--strokeWidthThick);}", ".f1wpluaz{border-right-width:var(--strokeWidthThick);}", ".fsfsuhs{border-left-width:var(--strokeWidthThick);}", ".fmklw6v{border-bottom-width:var(--strokeWidthThick);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".fwn6jck{border-top-width:var(--strokeWidthThickest);}", ".figl7jc{border-right-width:var(--strokeWidthThickest);}", ".f1g0iy8l{border-left-width:var(--strokeWidthThickest);}", ".f1b8shu7{border-bottom-width:var(--strokeWidthThickest);}"],
  m: [["@media (forced-colors: active){.fx5js7k{border-top-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f17aelzi{border-right-color:CanvasText;}.f2tn0l4{border-left-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14ood81{border-bottom-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}"],
  a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fumykes:active{border-bottom-color:var(--colorNeutralStroke1Pressed);}"]
});
var useAvatarGroupPopoverStyles_unstable = (state) => {
  "use no memo";
  const {
    indicator,
    size: size3,
    layout,
    popoverOpen
  } = state;
  const sizeStyles = useSizeStyles();
  const triggerButtonStyles = useTriggerButtonStyles();
  const contentStyles = useContentStyles();
  const popoverSurfaceStyles = usePopoverSurfaceStyles();
  const groupChildClassName = useGroupChildClassName(layout, size3);
  const triggerButtonClasses = [];
  if (size3 < 36) {
    triggerButtonClasses.push(triggerButtonStyles.borderThin);
  } else if (size3 < 56) {
    triggerButtonClasses.push(triggerButtonStyles.borderThick);
  } else if (size3 < 72) {
    triggerButtonClasses.push(triggerButtonStyles.borderThicker);
  } else {
    triggerButtonClasses.push(triggerButtonStyles.borderThickest);
  }
  if (indicator === "count") {
    if (size3 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.caption2Strong);
    } else if (size3 <= 28) {
      triggerButtonClasses.push(triggerButtonStyles.caption1Strong);
    } else if (size3 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.body1Strong);
    } else if (size3 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle2);
    } else if (size3 <= 96) {
      triggerButtonClasses.push(triggerButtonStyles.subtitle1);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.title3);
    }
  } else {
    if (size3 <= 16) {
      triggerButtonClasses.push(triggerButtonStyles.icon12);
    } else if (size3 <= 24) {
      triggerButtonClasses.push(triggerButtonStyles.icon16);
    } else if (size3 <= 40) {
      triggerButtonClasses.push(triggerButtonStyles.icon20);
    } else if (size3 <= 48) {
      triggerButtonClasses.push(triggerButtonStyles.icon24);
    } else if (size3 <= 56) {
      triggerButtonClasses.push(triggerButtonStyles.icon28);
    } else if (size3 <= 72) {
      triggerButtonClasses.push(triggerButtonStyles.icon32);
    } else {
      triggerButtonClasses.push(triggerButtonStyles.icon48);
    }
  }
  state.triggerButton.className = mergeClasses(avatarGroupPopoverClassNames.triggerButton, groupChildClassName, sizeStyles[size3], triggerButtonStyles.base, layout === "pie" && triggerButtonStyles.pie, triggerButtonStyles.focusIndicator, layout !== "pie" && triggerButtonStyles.states, layout !== "pie" && popoverOpen && triggerButtonStyles.selected, ...triggerButtonClasses, state.triggerButton.className);
  state.content.className = mergeClasses(avatarGroupPopoverClassNames.content, contentStyles.base, state.content.className);
  state.popoverSurface.className = mergeClasses(avatarGroupPopoverClassNames.popoverSurface, popoverSurfaceStyles.base, state.popoverSurface.className);
  return state;
};

// node_modules/@fluentui/react-avatar/lib/components/AvatarGroupPopover/AvatarGroupPopover.js
var AvatarGroupPopover = (props) => {
  const state = useAvatarGroupPopover_unstable(props);
  const contextValues = useAvatarGroupPopoverContextValues_unstable(state);
  useAvatarGroupPopoverStyles_unstable(state);
  useCustomStyleHook("useAvatarGroupPopoverStyles_unstable")(state);
  return renderAvatarGroupPopover_unstable(state, contextValues);
};
AvatarGroupPopover.displayName = "AvatarGroupPopover";

// node_modules/@fluentui/react-button/lib/components/Button/Button.js
var React145 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/Button/renderButton.js
var renderButton_unstable = (state) => {
  assertSlots(state);
  const { iconOnly, iconPosition } = state;
  return jsxs(state.root, {
    children: [
      iconPosition !== "after" && state.icon && jsx(state.icon, {}),
      !iconOnly && state.root.children,
      iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/Button/useButton.js
var React144 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/contexts/ButtonContext.js
var React142 = __toESM(require_react());
var buttonContext = React142.createContext(void 0);
var buttonContextDefaultValue = {};
var ButtonContextProvider = buttonContext.Provider;
var useButtonContext = () => {
  var _React_useContext;
  return (_React_useContext = React142.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
};

// node_modules/@fluentui/react-button/lib/components/Button/useButtonBase.js
var React143 = __toESM(require_react());
var useButtonBase_unstable = (props, ref) => {
  const { as = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before" } = props;
  const iconShorthand = slot_exports.optional(icon, {
    elementType: "span"
  });
  return {
    // Props passed at the top-level
    disabled,
    disabledFocusable,
    iconPosition,
    iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
    // Slots definition
    components: {
      root: "button",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
      elementType: "button",
      defaultProps: {
        ref,
        type: as === "button" ? "button" : void 0
      }
    }),
    icon: iconShorthand
  };
};

// node_modules/@fluentui/react-button/lib/components/Button/useButton.js
var useButton_unstable = (props, ref) => {
  const { size: contextSize } = useButtonContext();
  const { appearance = "secondary", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
  const state = useButtonBase_unstable(props, ref);
  return {
    // Props passed at the top-level
    appearance,
    shape,
    size: size3,
    ...state
  };
};

// node_modules/@fluentui/react-button/lib/components/Button/useButtonStyles.styles.js
var buttonClassNames = {
  root: "fui-Button",
  icon: "fui-Button__icon"
};
var boxShadowStrokeWidthThinMoz = `calc(${tokens.strokeWidthThin} + 0.25px)`;
var useRootBaseClassName = __resetStyles("r1f29ykk", null, {
  r: [".r1f29ykk{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}", ".r1f29ykk:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}", ".r1f29ykk:hover:active,.r1f29ykk:active:focus-visible{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}", ".r1f29ykk[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1f29ykk{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1f29ykk:focus{border-color:ButtonText;}.r1f29ykk:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1f29ykk:hover:active,.r1f29ykk:active:focus-visible{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}", "@supports (-moz-appearance:button){.r1f29ykk[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
});
var useIconBaseClassName = __resetStyles("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
var useRootStyles3 = __styles2({
  outline: {
    De3pzq: "f1c21dwh",
    Jwef8y: "fjxutwb",
    Bpjbzib: "fkoldzo"
  },
  primary: {
    De3pzq: "ffp7eso",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1phragk",
    Jwef8y: "f15wkkf3",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f1rq72xc",
    Bpjbzib: "f1ksv2xa",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "f1d6mv4x",
    By8wz76: "f1nz3ub2",
    Bcq6wej: "fag2qd2",
    Jcjdmf: ["fmvhcg7", "f14bpyus"],
    sc4o1m: "f1o3dhpw",
    Bosien3: ["f14bpyus", "fmvhcg7"],
    B7iucu3: "fqc85l4",
    B8gzw0y: "f1h3a8gf",
    Bbkh6qg: "fkiggi6",
    F230oe: "f8gmj8i",
    Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
    Bj1xduy: "f1igan7k",
    Bhh2cfd: ["fjag8bx", "f1ap8nzx"],
    Bahaeuw: "f1v3eptx",
    Bv2bamp: "f1ysmecq",
    vxuvv6: "faulsx",
    Bli9q98: ["f79t15f", "f8qmx7k"],
    Bx2tt8t: "fbtzoaq",
    yad0b3: ["f8qmx7k", "f79t15f"],
    j2fop7: "fd4bjan"
  },
  secondary: {},
  subtle: {
    De3pzq: "fhovq9v",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "fkfq4zb",
    Jwef8y: "f1t94bn6",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "fnwyq0v",
    Bk3fhr4: "ft1hn21",
    Bmfj8id: "fuxngvv",
    Bbdnnc7: "fy5bs14",
    Bpjbzib: "f1q1yqic",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "fwga7ee",
    Bqou3pl: "f1nhwcv0",
    Bsnehw8: "f1gm6xmp",
    wsxvnf: "f1xxsver",
    Bahaeuw: "f1v3eptx",
    Buhizc3: "fivsta0",
    j2fop7: "fd4bjan",
    Bqabnb4: "f3m6zum"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "fkfq4zb",
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f139oj5f",
    Bk3fhr4: "ft1hn21",
    Bmfj8id: "fuxngvv",
    Bpjbzib: "fkoldzo",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "f1l983o9",
    Bqou3pl: "f1nhwcv0",
    Bsnehw8: "f1gm6xmp",
    Bbkh6qg: "fxoo9op",
    Bahaeuw: "f1v3eptx",
    Bv2bamp: "f1i0gk12",
    j2fop7: "fd4bjan"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  rounded: {},
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  small: {
    Bf4jedk: "fh7ncta",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fneth5b",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  smallWithIcon: {
    Byoj8tv: "f1brlhvm",
    z8tnut: "f1sl3k7w"
  },
  medium: {},
  large: {
    Bf4jedk: "f14es27b",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f4db1ww",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  largeWithIcon: {
    Byoj8tv: "fy7v416",
    z8tnut: "f1a1bwwz"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".fh7ncta{min-width:64px;}", [".fneth5b{padding:3px var(--spacingHorizontalS);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1brlhvm{padding-bottom:1px;}", ".f1sl3k7w{padding-top:1px;}", ".f14es27b{min-width:96px;}", [".f4db1ww{padding:8px var(--spacingHorizontalL);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fy7v416{padding-bottom:7px;}", ".f1a1bwwz{padding-top:7px;}"],
  h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1ksv2xa:hover:active,.f1ksv2xa:active:focus-visible{background-color:var(--colorBrandBackgroundPressed);}", ".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}", ".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}", ".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}", ".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}", ".f1d6mv4x:hover:active,.f1d6mv4x:active:focus-visible{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}", ".f1q1yqic:hover:active,.f1q1yqic:active:focus-visible{background-color:var(--colorSubtleBackgroundPressed);}", ".fwga7ee:hover:active,.fwga7ee:active:focus-visible{color:var(--colorNeutralForeground2Pressed);}", ".f1nhwcv0:hover:active .fui-Icon-filled,.f1nhwcv0:active:focus-visible .fui-Icon-filled{display:inline;}", ".f1gm6xmp:hover:active .fui-Icon-regular,.f1gm6xmp:active:focus-visible .fui-Icon-regular{display:none;}", ".f1xxsver:hover:active .fui-Button__icon,.f1xxsver:active:focus-visible .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1l983o9:hover:active,.f1l983o9:active:focus-visible{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fag2qd2{border-top-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14bpyus{border-left-color:HighlightText;}.fmvhcg7{border-right-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1o3dhpw{border-bottom-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ysmecq:hover:active,.f1ysmecq:active:focus-visible{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.faulsx:hover:active,.faulsx:active:focus-visible{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f79t15f:hover:active,.f79t15f:active:focus-visible{border-right-color:Highlight;}.f8qmx7k:hover:active,.f8qmx7k:active:focus-visible{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbtzoaq:hover:active,.fbtzoaq:active:focus-visible{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fd4bjan:hover:active,.fd4bjan:active:focus-visible{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fivsta0:hover .fui-Button__icon{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3m6zum:hover:active .fui-Button__icon,.f3m6zum:active:focus-visible .fui-Button__icon{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fxoo9op:hover{background-color:var(--colorTransparentBackground);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1i0gk12:hover:active,.f1i0gk12:active:focus-visible{background-color:var(--colorTransparentBackground);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootDisabledStyles = __styles2({
  base: {
    De3pzq: "f1bg9a2p",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bfinmwp: "f15x8b5r",
    Jwef8y: "f1falr9n",
    Bgoe8wy: "f12mpcsy",
    Bwzppfd: ["f1gwvigk", "f18rmfxp"],
    oetu4i: "f1jnshp0",
    gg5e9n: ["f18rmfxp", "f1gwvigk"],
    Bi91k9c: "fvgxktp",
    eoavqd: "fphbwmw",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    Bbdnnc7: "f1al02dq",
    Bpjbzib: "f1jct5ie",
    im15vp: "f13txml0",
    Hjvxdg: ["f1ncddno", "f1axfvow"],
    Gpfmf1: "f1z04ada",
    ustxxc: ["f1axfvow", "f1ncddno"],
    Brsut9c: "f1uhomfy",
    Bses4qk: "fy9mucy",
    Bqou3pl: "f1g9va8i",
    Bsnehw8: "fwgvudy",
    wsxvnf: "fom6jww"
  },
  highContrast: {
    By8wz76: "f14ptb23",
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"],
    B7iucu3: "f1cyfu5x",
    Grqk0h: "f127ot8j",
    h3ptyc: "f19etb0b",
    Buw724y: ["f4f984j", "fw441p0"],
    Buk7464: "f3d22hf",
    Hwei09: ["fw441p0", "f4f984j"],
    Bbkh6qg: "fj8k9ua",
    F230oe: "fifrq0d",
    Bdw8ktp: ["f196mwp7", "fnekfq"],
    Bj1xduy: "f1l6uprw",
    Bhh2cfd: ["fnekfq", "f196mwp7"],
    Bahaeuw: "fa9u7a5",
    Buhizc3: "f1m71e0y",
    Bv2bamp: "fw24f3",
    vxuvv6: "f1nznrny",
    Bli9q98: ["fq8nxuu", "f1ao3jkc"],
    Bx2tt8t: "ftoixeo",
    yad0b3: ["f1ao3jkc", "fq8nxuu"],
    j2fop7: "fpmuzpx",
    Bqabnb4: "f168odog"
  },
  outline: {
    De3pzq: "f1c21dwh",
    Jwef8y: "f9ql6rf",
    Bpjbzib: "f9r0db0"
  },
  primary: {
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  },
  secondary: {},
  subtle: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "f9ql6rf",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bpjbzib: "f9r0db0",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "f9ql6rf",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bpjbzib: "f9r0db0",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  }
}, {
  d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}"],
  h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1jct5ie:hover:active,.f1jct5ie:active:focus-visible{background-color:var(--colorNeutralBackgroundDisabled);}", ".f13txml0:hover:active,.f13txml0:active:focus-visible{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ncddno:hover:active,.f1ncddno:active:focus-visible{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1axfvow:hover:active,.f1axfvow:active:focus-visible{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1z04ada:hover:active,.f1z04ada:active:focus-visible{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1uhomfy:hover:active,.f1uhomfy:active:focus-visible{color:var(--colorNeutralForegroundDisabled);}", ".fy9mucy:hover:active,.fy9mucy:active:focus-visible{cursor:not-allowed;}", ".f1g9va8i:hover:active .fui-Icon-filled,.f1g9va8i:active:focus-visible .fui-Icon-filled{display:none;}", ".fwgvudy:hover:active .fui-Icon-regular,.fwgvudy:active:focus-visible .fui-Icon-regular{display:inline;}", ".fom6jww:hover:active .fui-Button__icon,.fom6jww:active:focus-visible .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f9r0db0:hover:active,.f9r0db0:active:focus-visible{background-color:var(--colorTransparentBackground);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}", ".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}", ".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}", ".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}"],
  m: [["@media (forced-colors: active){.f14ptb23{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f127ot8j .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19etb0b:focus{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4f984j:focus{border-right-color:GrayText;}.fw441p0:focus{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3d22hf:focus{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fj8k9ua:hover{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fifrq0d:hover{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f196mwp7:hover{border-right-color:GrayText;}.fnekfq:hover{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1l6uprw:hover{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fa9u7a5:hover{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1m71e0y:hover .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fw24f3:hover:active,.fw24f3:active:focus-visible{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nznrny:hover:active,.f1nznrny:active:focus-visible{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ao3jkc:hover:active,.f1ao3jkc:active:focus-visible{border-left-color:GrayText;}.fq8nxuu:hover:active,.fq8nxuu:active:focus-visible{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.ftoixeo:hover:active,.ftoixeo:active:focus-visible{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fpmuzpx:hover:active,.fpmuzpx:active:focus-visible{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f168odog:hover:active .fui-Button__icon,.f168odog:active:focus-visible .fui-Button__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootFocusStyles = __styles2({
  circular: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  rounded: {},
  square: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  },
  primary: {
    B8q5s1w: "f17t0x8g",
    Bci5o5g: ["f194v5ow", "fk7jm04"],
    n8qw10: "f1qgg65p",
    Bdrgwmp: ["fk7jm04", "f194v5ow"],
    j6ew2k: ["fhgccpy", "fjo7pq6"],
    he4mth: "f32wu9k",
    Byr4aka: "fu5nqqq",
    lks7q5: ["f13prjl2", "f1nl83rv"],
    Bnan3qt: "f1czftr5",
    k1dn9: ["f1nl83rv", "f13prjl2"],
    Bqsb82s: ["fixhny3", "f18mfu3r"],
    jg1oma: "feygou5"
  },
  small: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fazmxh"
  },
  medium: {},
  large: {
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1b6alqh"
  }
}, {
  d: [[".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}", ".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}", ".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}", ".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}", ".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}", [".fazmxh[data-fui-focus-visible]{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], [".f1b6alqh[data-fui-focus-visible]{border-radius:var(--borderRadiusLarge);}", {
    p: -1
  }]],
  t: ["@supports (-moz-appearance:button){.f18mfu3r[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fixhny3[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.feygou5[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
});
var useRootIconOnlyStyles = __styles2({
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fu97m5z",
    Bf4jedk: "f17fgpbq",
    B2u0y6b: "f1jt17bm"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f18ktai2",
    Bf4jedk: "fwbmr0d",
    B2u0y6b: "f44c6la"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1hbd1aw",
    Bf4jedk: "f12clzc2",
    B2u0y6b: "fjy1crr"
  }
}, {
  d: [[".fu97m5z{padding:1px;}", {
    p: -1
  }], ".f17fgpbq{min-width:24px;}", ".f1jt17bm{max-width:24px;}", [".f18ktai2{padding:5px;}", {
    p: -1
  }], ".fwbmr0d{min-width:32px;}", ".f44c6la{max-width:32px;}", [".f1hbd1aw{padding:7px;}", {
    p: -1
  }], ".f12clzc2{min-width:40px;}", ".fjy1crr{max-width:40px;}"]
});
var useIconStyles2 = __styles2({
  small: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3",
    Bqrlyyl: "fbaiahx"
  },
  medium: {},
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun",
    Bqrlyyl: "f1exjqw5"
  },
  before: {
    t21cq0: ["f1nizpg2", "f1a695kz"]
  },
  after: {
    Frg6f3: ["f1a695kz", "f1nizpg2"]
  }
}, {
  d: [".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}", ".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}", ".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"]
});
var useButtonStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName();
  const iconBaseClassName = useIconBaseClassName();
  const rootStyles = useRootStyles3();
  const rootDisabledStyles = useRootDisabledStyles();
  const rootFocusStyles = useRootFocusStyles();
  const rootIconOnlyStyles = useRootIconOnlyStyles();
  const iconStyles = useIconStyles2();
  const {
    appearance,
    disabled,
    disabledFocusable,
    icon,
    iconOnly,
    iconPosition,
    shape,
    size: size3
  } = state;
  state.root.className = mergeClasses(
    buttonClassNames.root,
    rootBaseClassName,
    appearance && rootStyles[appearance],
    rootStyles[size3],
    icon && size3 === "small" && rootStyles.smallWithIcon,
    icon && size3 === "large" && rootStyles.largeWithIcon,
    rootStyles[shape],
    // Disabled styles
    (disabled || disabledFocusable) && rootDisabledStyles.base,
    (disabled || disabledFocusable) && rootDisabledStyles.highContrast,
    appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
    // Focus styles
    appearance === "primary" && rootFocusStyles.primary,
    rootFocusStyles[size3],
    rootFocusStyles[shape],
    // Icon-only styles
    iconOnly && rootIconOnlyStyles[size3],
    // User provided class name
    state.root.className
  );
  if (state.icon) {
    state.icon.className = mergeClasses(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-button/lib/components/Button/Button.js
var Button = React145.forwardRef((props, ref) => {
  const state = useButton_unstable(props, ref);
  useButtonStyles_unstable(state);
  useCustomStyleHook("useButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
Button.displayName = "Button";

// node_modules/@fluentui/react-button/lib/components/CompoundButton/CompoundButton.js
var React148 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/CompoundButton/renderCompoundButton.js
var renderCompoundButton_unstable = (state) => {
  assertSlots(state);
  const { iconOnly, iconPosition } = state;
  return jsxs(state.root, {
    children: [
      iconPosition !== "after" && state.icon && jsx(state.icon, {}),
      !iconOnly && jsxs(state.contentContainer, {
        children: [
          state.root.children,
          state.secondaryContent && jsx(state.secondaryContent, {})
        ]
      }),
      iconPosition === "after" && state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButton.js
var React147 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButtonBase.js
var React146 = __toESM(require_react());
var useCompoundButtonBase_unstable = ({ contentContainer, secondaryContent, ...props }, ref) => {
  var _state_icon, _state_secondaryContent;
  const state = {
    // Button state
    ...useButtonBase_unstable(props, ref),
    // Slots definition
    components: {
      root: "button",
      icon: "span",
      contentContainer: "span",
      secondaryContent: "span"
    },
    contentContainer: slot_exports.always(contentContainer, {
      elementType: "span"
    }),
    secondaryContent: slot_exports.optional(secondaryContent, {
      elementType: "span"
    })
  };
  state.iconOnly = Boolean(((_state_icon = state.icon) === null || _state_icon === void 0 ? void 0 : _state_icon.children) && !props.children && !((_state_secondaryContent = state.secondaryContent) === null || _state_secondaryContent === void 0 ? void 0 : _state_secondaryContent.children));
  return state;
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButton.js
var useCompoundButton_unstable = (props, ref) => {
  const { size: contextSize } = useButtonContext();
  const { appearance = "secondary", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
  const state = useCompoundButtonBase_unstable(props, ref);
  return {
    appearance,
    size: size3,
    shape,
    ...state
  };
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/useCompoundButtonStyles.styles.js
var compoundButtonClassNames = {
  root: "fui-CompoundButton",
  icon: "fui-CompoundButton__icon",
  contentContainer: "fui-CompoundButton__contentContainer",
  secondaryContent: "fui-CompoundButton__secondaryContent"
};
var useRootStyles4 = __styles2({
  base: {
    Bqenvij: "f11ysow2",
    J657lq: "f1um431h",
    Jlnjib: "fte7hqw",
    Bo7webf: "frw79jk"
  },
  highContrast: {
    m3fafd: "ffcivv0",
    pus4l6: "f1wchxtt"
  },
  outline: {},
  primary: {
    J657lq: "foe7gw6",
    Jlnjib: "fvxlz81",
    Bo7webf: "f16twlsn",
    D126e9: "fsglouz"
  },
  secondary: {},
  subtle: {
    J657lq: "f1um431h",
    Jlnjib: "fte7hqw",
    Bo7webf: "frw79jk",
    m3fafd: "f13lnigs",
    pus4l6: "f1ba77l5"
  },
  transparent: {
    J657lq: "f1um431h",
    Jlnjib: "f1wn9xqz",
    Bo7webf: "f1juxwb4"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ge6w2w",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fnnf4v2",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f14s4sho",
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k"
  },
  disabled: {
    J657lq: "f1rlv8bf",
    Jlnjib: "fd1dbtm",
    Bo7webf: "f1x3eb98"
  },
  disabledHighContrast: {
    D126e9: "fbqh1p7",
    m3fafd: "fu2tbix",
    pus4l6: "f1g2tosm"
  }
}, {
  d: [".f11ysow2{height:auto;}", ".f1um431h .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2);}", ".foe7gw6 .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", [".f1ge6w2w{padding:var(--spacingHorizontalS) var(--spacingHorizontalS) var(--spacingHorizontalMNudge) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fnnf4v2{padding:14px var(--spacingHorizontalM) var(--spacingHorizontalL) var(--spacingHorizontalM);}", {
    p: -1
  }], [".f14s4sho{padding:18px var(--spacingHorizontalL) var(--spacingHorizontalXL) var(--spacingHorizontalL);}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1rlv8bf .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"],
  h: [".fte7hqw:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Hover);}", ".frw79jk:hover:active .fui-CompoundButton__secondaryContent,.frw79jk:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2Pressed);}", ".fvxlz81:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", ".f16twlsn:hover:active .fui-CompoundButton__secondaryContent,.f16twlsn:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundOnBrand);}", ".f1wn9xqz:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandHover);}", ".f1juxwb4:hover:active .fui-CompoundButton__secondaryContent,.f1juxwb4:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForeground2BrandPressed);}", ".fd1dbtm:hover .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}", ".f1x3eb98:hover:active .fui-CompoundButton__secondaryContent,.f1x3eb98:active:focus-visible .fui-CompoundButton__secondaryContent{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.ffcivv0:hover .fui-CompoundButton__secondaryContent{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wchxtt:hover:active .fui-CompoundButton__secondaryContent,.f1wchxtt:active:focus-visible .fui-CompoundButton__secondaryContent{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fsglouz .fui-CompoundButton__secondaryContent{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f13lnigs:hover .fui-CompoundButton__secondaryContent{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ba77l5:hover:active .fui-CompoundButton__secondaryContent,.f1ba77l5:active:focus-visible .fui-CompoundButton__secondaryContent{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbqh1p7 .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fu2tbix:hover .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1g2tosm:hover:active .fui-CompoundButton__secondaryContent,.f1g2tosm:active:focus-visible .fui-CompoundButton__secondaryContent{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootIconOnlyStyles2 = __styles2({
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1t35pdg",
    B2u0y6b: "ft5vyj6",
    Bf4jedk: "f17suaiq"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6",
    B2u0y6b: "fdczgix",
    Bf4jedk: "fjdcg9m"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bnz8pu",
    B2u0y6b: "fww51uw",
    Bf4jedk: "f1qhsl2h"
  }
}, {
  d: [[".f1t35pdg{padding:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".ft5vyj6{max-width:48px;}", ".f17suaiq{min-width:48px;}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fdczgix{max-width:52px;}", ".fjdcg9m{min-width:52px;}", [".f1bnz8pu{padding:var(--spacingHorizontalS);}", {
    p: -1
  }], ".fww51uw{max-width:56px;}", ".f1qhsl2h{min-width:56px;}"]
});
var useIconStyles3 = __styles2({
  base: {
    Be2twd7: "fndrnj9",
    Bqenvij: "fbhnoac",
    a9b677: "feqmc2u"
  },
  before: {
    t21cq0: ["fkujibs", "f199hnxi"]
  },
  after: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  }
}, {
  d: [".fndrnj9{font-size:40px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}"]
});
var useContentContainerStyles = __styles2({
  base: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    fsow6f: ["f1o700av", "fes3tcz"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}"]
});
var useSecondaryContentStyles = __styles2({
  base: {
    Bg96gwp: "flkuc6h",
    Bhrd7zp: "figsok6"
  },
  small: {
    Be2twd7: "fy9rknc"
  },
  medium: {
    Be2twd7: "fy9rknc"
  },
  large: {
    Be2twd7: "fkhj508"
  }
}, {
  d: [".flkuc6h{line-height:100%;}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}"]
});
var useCompoundButtonStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles4();
  const rootIconOnlyStyles = useRootIconOnlyStyles2();
  const iconStyles = useIconStyles3();
  const contentContainerStyles = useContentContainerStyles();
  const secondaryContentStyles = useSecondaryContentStyles();
  const {
    appearance,
    disabled,
    disabledFocusable,
    iconOnly,
    iconPosition,
    size: size3
  } = state;
  state.root.className = mergeClasses(
    compoundButtonClassNames.root,
    // Root styles
    rootStyles.base,
    rootStyles.highContrast,
    appearance && rootStyles[appearance],
    rootStyles[size3],
    // Disabled styles
    (disabled || disabledFocusable) && rootStyles.disabled,
    (disabled || disabledFocusable) && rootStyles.disabledHighContrast,
    // Icon-only styles
    iconOnly && rootIconOnlyStyles[size3],
    // User provided class name
    state.root.className
  );
  state.contentContainer.className = mergeClasses(compoundButtonClassNames.contentContainer, contentContainerStyles.base, state.contentContainer.className);
  if (state.icon) {
    state.icon.className = mergeClasses(compoundButtonClassNames.icon, iconStyles.base, state.root.children !== void 0 && state.root.children !== null && iconStyles[iconPosition], state.icon.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(compoundButtonClassNames.secondaryContent, secondaryContentStyles.base, secondaryContentStyles[size3], state.secondaryContent.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-button/lib/components/CompoundButton/CompoundButton.js
var CompoundButton = React148.forwardRef((props, ref) => {
  const state = useCompoundButton_unstable(props, ref);
  useCompoundButtonStyles_unstable(state);
  useCustomStyleHook("useCompoundButtonStyles_unstable")(state);
  return renderCompoundButton_unstable(state);
});
CompoundButton.displayName = "CompoundButton";

// node_modules/@fluentui/react-button/lib/components/MenuButton/MenuButton.js
var React151 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/MenuButton/renderMenuButton.js
var renderMenuButton_unstable = (state) => {
  assertSlots(state);
  const { icon, iconOnly } = state;
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      !iconOnly && state.root.children,
      (!iconOnly || !(icon === null || icon === void 0 ? void 0 : icon.children)) && state.menuIcon && jsx(state.menuIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButton.js
var React150 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButtonBase.js
var React149 = __toESM(require_react());
var useMenuButtonBase_unstable = ({ menuIcon, ...props }, ref) => {
  "use no memo";
  const buttonState = useButtonBase_unstable(props, ref);
  buttonState.root["aria-expanded"] = props["aria-expanded"] ? props["aria-expanded"] === "true" || props["aria-expanded"] === true : false;
  return {
    ...buttonState,
    // State calculated from a set of props
    iconOnly: Boolean(!props.children),
    // Slots definition
    components: {
      root: "button",
      icon: "span",
      menuIcon: "span"
    },
    menuIcon: slot_exports.optional(menuIcon, {
      elementType: "span",
      renderByDefault: true
    })
  };
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButton.js
var useMenuButton_unstable = (props, ref) => {
  "use no memo";
  const { size: contextSize } = useButtonContext();
  const { appearance = "secondary", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
  const state = useMenuButtonBase_unstable(props, ref);
  return {
    appearance,
    size: size3,
    shape,
    ...state,
    menuIcon: {
      children: React150.createElement(ChevronDownRegular, null),
      ...state.menuIcon
    }
  };
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/useMenuButtonStyles.styles.js
var menuButtonClassNames = {
  root: "fui-MenuButton",
  icon: "fui-MenuButton__icon",
  menuIcon: "fui-MenuButton__menuIcon"
};
var useRootExpandedStyles = __styles2({
  base: {
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g"
  },
  outline: {
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"],
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"],
    sj55zd: "f14nttnl"
  },
  primary: {
    De3pzq: "f8w4g0q"
  },
  secondary: {
    De3pzq: "f1nfm20t",
    g2u3we: "f1ly1fcm",
    h3c5rm: ["fi8bssc", "fj6btzu"],
    B9xav0g: "f1s9tnsa",
    zhjwy3: ["fj6btzu", "fi8bssc"],
    sj55zd: "f14nttnl"
  },
  subtle: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  transparent: {
    De3pzq: "f1q9pm1r",
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f1ly1fcm{border-top-color:var(--colorNeutralStroke1Selected);}", ".fi8bssc{border-right-color:var(--colorNeutralStroke1Selected);}", ".fj6btzu{border-left-color:var(--colorNeutralStroke1Selected);}", ".f1s9tnsa{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useIconExpandedStyles = __styles2({
  outline: {
    sj55zd: "f14nttnl"
  },
  primary: {},
  secondary: {
    sj55zd: "f14nttnl"
  },
  subtle: {
    sj55zd: "f1qj7y59"
  },
  transparent: {
    sj55zd: "f1qj7y59"
  },
  highContrast: {
    Bahaeuw: "f1v3eptx"
  }
}, {
  d: [".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  m: [["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useMenuIconStyles = __styles2({
  base: {
    Bg96gwp: "fez10in"
  },
  small: {
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fvblgha",
    Bg96gwp: "fwrc4pm",
    a9b677: "frx94fk"
  },
  medium: {
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fvblgha",
    Bg96gwp: "fwrc4pm",
    a9b677: "frx94fk"
  },
  large: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fd461yt",
    Bg96gwp: "faaz57k",
    a9b677: "fjw5fx7"
  },
  notIconOnly: {
    Frg6f3: ["fbyavb5", "fm0x6gh"]
  }
}, {
  d: [".fez10in{line-height:0;}", ".f1ugzwwg{font-size:12px;}", ".fvblgha{height:12px;}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".frx94fk{width:12px;}", ".f4ybsrx{font-size:16px;}", ".fd461yt{height:16px;}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fjw5fx7{width:16px;}", ".fbyavb5{margin-left:var(--spacingHorizontalXS);}", ".fm0x6gh{margin-right:var(--spacingHorizontalXS);}"]
});
var useMenuButtonStyles_unstable = (state) => {
  "use no memo";
  const rootExpandedStyles = useRootExpandedStyles();
  const iconExpandedStyles = useIconExpandedStyles();
  const menuIconStyles = useMenuIconStyles();
  state.root.className = mergeClasses(menuButtonClassNames.root, state.root["aria-expanded"] && rootExpandedStyles.base, state.root["aria-expanded"] && rootExpandedStyles[state.appearance], state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(menuButtonClassNames.icon, state.root["aria-expanded"] && iconExpandedStyles[state.appearance] && iconExpandedStyles.highContrast, state.icon.className);
  }
  if (state.menuIcon) {
    state.menuIcon.className = mergeClasses(menuButtonClassNames.menuIcon, menuIconStyles.base, menuIconStyles[state.size], !state.iconOnly && menuIconStyles.notIconOnly, state.menuIcon.className);
  }
  useButtonStyles_unstable({
    ...state,
    iconPosition: "before"
  });
  return state;
};

// node_modules/@fluentui/react-button/lib/components/MenuButton/MenuButton.js
var MenuButton = React151.forwardRef((props, ref) => {
  const state = useMenuButton_unstable(props, ref);
  useMenuButtonStyles_unstable(state);
  useCustomStyleHook("useMenuButtonStyles_unstable")(state);
  return renderMenuButton_unstable(state);
});
MenuButton.displayName = "MenuButton";

// node_modules/@fluentui/react-button/lib/components/SplitButton/SplitButton.js
var React154 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/SplitButton/renderSplitButton.js
var renderSplitButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.primaryActionButton && jsx(state.primaryActionButton, {}),
      state.menuButton && jsx(state.menuButton, {})
    ]
  });
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButton.js
var React153 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButtonBase.js
var React152 = __toESM(require_react());
var useSplitButtonBase_unstable = (props, ref) => {
  const { children, disabled = false, disabledFocusable = false, icon, iconPosition = "before", menuButton: menuButton2, menuIcon, primaryActionButton } = props;
  const baseId = useId2("splitButton-");
  const menuButtonShorthand = slot_exports.optional(menuButton2, {
    defaultProps: {
      disabled,
      disabledFocusable,
      menuIcon
    },
    renderByDefault: true,
    elementType: MenuButton
  });
  const primaryActionButtonShorthand = slot_exports.optional(primaryActionButton, {
    defaultProps: {
      children,
      disabled,
      disabledFocusable,
      icon,
      iconPosition,
      id: baseId + "__primaryActionButton"
    },
    renderByDefault: true,
    elementType: Button
  });
  if (menuButtonShorthand && primaryActionButtonShorthand && !menuButtonShorthand["aria-label"] && !menuButtonShorthand["aria-labelledby"]) {
    menuButtonShorthand["aria-labelledby"] = primaryActionButtonShorthand.id;
  }
  return {
    // Props passed at the top-level
    disabled,
    disabledFocusable,
    iconPosition,
    components: {
      root: "div",
      menuButton: MenuButton,
      primaryActionButton: Button
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    menuButton: menuButtonShorthand,
    primaryActionButton: primaryActionButtonShorthand
  };
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButton.js
var useSplitButton_unstable = (props, ref) => {
  const { appearance = "secondary", shape = "rounded", size: size3 = "medium" } = props;
  const state = useSplitButtonBase_unstable(props, ref);
  return {
    appearance,
    shape,
    size: size3,
    ...state,
    menuButton: {
      appearance,
      shape,
      size: size3,
      ...state.menuButton
    },
    primaryActionButton: {
      appearance,
      shape,
      size: size3,
      ...state.primaryActionButton
    }
  };
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/useSplitButtonStyles.styles.js
var splitButtonClassNames = {
  root: "fui-SplitButton",
  menuButton: "fui-SplitButton__menuButton",
  primaryActionButton: "fui-SplitButton__primaryActionButton"
};
var useFocusStyles = __styles2({
  primaryActionButton: {
    B6xbmo0: ["f1x37qnr", "f1um7c6d"],
    kdpuga: ["fn4c73s", "f6pwzcr"]
  },
  menuButton: {
    lbo84a: ["frrbwxo", "f1rgcpbv"],
    dm238s: ["f1um7c6d", "f1x37qnr"],
    Bw81rd7: ["f6pwzcr", "fn4c73s"]
  }
}, {
  d: [".f1x37qnr[data-fui-focus-visible]{border-top-right-radius:0;}", ".f1um7c6d[data-fui-focus-visible]{border-top-left-radius:0;}", ".fn4c73s[data-fui-focus-visible]{border-bottom-right-radius:0;}", ".f6pwzcr[data-fui-focus-visible]{border-bottom-left-radius:0;}", ".frrbwxo[data-fui-focus-visible]{border-left-width:0;}", ".f1rgcpbv[data-fui-focus-visible]{border-right-width:0;}"]
});
var useRootStyles5 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    Brf1p80: "fsxf2b5",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    kn2xc0: ["f14uur2j", "fc1btbj"],
    Bs76p8a: ["fye5tvs", "fc597qq"],
    cuxpm9: ["f1e8brtx", "fr36rk3"],
    Biffepf: ["fxp12j1", "f1m6nt2y"],
    Defnvf: ["fr7y8no", "f1dn0c6m"],
    z0pv9t: "f1b65x5h"
  },
  outline: {},
  primary: {
    B1l9wao: ["f4rm5b0", "f1tuwo13"],
    lcnrd8: ["fdwdeeo", "f1ezdslh"],
    vlshuh: ["f1ju2vgk", "f1r6p88l"],
    B3s9tpx: ["f2z0mmn", "f12iqdwp"],
    rfylfo: ["f1btorfl", "fxofj4p"],
    k5lds2: ["f161sdhp", "f10m3pjc"]
  },
  secondary: {},
  subtle: {
    B1l9wao: ["f16kf41h", "fxiafvi"],
    lcnrd8: ["ffl6mx9", "f1t5sw6t"],
    vlshuh: ["f1mww3cx", "f1wtv0vd"]
  },
  transparent: {
    B1l9wao: ["f16kf41h", "fxiafvi"],
    lcnrd8: ["ffl6mx9", "f1t5sw6t"],
    vlshuh: ["f1mww3cx", "f1wtv0vd"]
  },
  circular: {},
  rounded: {},
  square: {},
  disabled: {
    B1l9wao: ["f10xrnr8", "f15nylwb"],
    lcnrd8: ["f11fwhjz", "f18vtcsx"],
    vlshuh: ["f12kx9re", "f1hyxdqk"]
  },
  disabledHighContrast: {
    B3s9tpx: ["fslo9ob", "ftovg2z"],
    rfylfo: ["f1fuq5cn", "f168zpha"],
    k5lds2: ["f1t6bo0o", "f1dnwhli"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".fsxf2b5{justify-content:stretch;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f14uur2j .fui-SplitButton__primaryActionButton{border-top-right-radius:0;}", ".fc1btbj .fui-SplitButton__primaryActionButton{border-top-left-radius:0;}", ".fye5tvs .fui-SplitButton__primaryActionButton{border-bottom-right-radius:0;}", ".fc597qq .fui-SplitButton__primaryActionButton{border-bottom-left-radius:0;}", ".f1e8brtx .fui-SplitButton__menuButton{border-left-width:0;}", ".fr36rk3 .fui-SplitButton__menuButton{border-right-width:0;}", ".fxp12j1 .fui-SplitButton__menuButton{border-top-left-radius:0;}", ".f1m6nt2y .fui-SplitButton__menuButton{border-top-right-radius:0;}", ".fr7y8no .fui-SplitButton__menuButton{border-bottom-left-radius:0;}", ".f1dn0c6m .fui-SplitButton__menuButton{border-bottom-right-radius:0;}", ".f1b65x5h .fui-SplitButton__menuButton{min-width:24px;}", ".f4rm5b0 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f1tuwo13 .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".f16kf41h .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackground);}", ".fxiafvi .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackground);}", ".f10xrnr8 .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f15nylwb .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"],
  h: [".fdwdeeo:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f1ezdslh:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".f1ju2vgk:hover:active .fui-SplitButton__primaryActionButton,.f1ju2vgk:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f1r6p88l:hover:active .fui-SplitButton__primaryActionButton,.f1r6p88l:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".ffl6mx9:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundHover);}", ".f1t5sw6t:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundHover);}", ".f1mww3cx:hover:active .fui-SplitButton__primaryActionButton,.f1mww3cx:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorTransparentBackgroundPressed);}", ".f1wtv0vd:hover:active .fui-SplitButton__primaryActionButton,.f1wtv0vd:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorTransparentBackgroundPressed);}", ".f11fwhjz:hover .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18vtcsx:hover .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12kx9re:hover:active .fui-SplitButton__primaryActionButton,.f12kx9re:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1hyxdqk:hover:active .fui-SplitButton__primaryActionButton,.f1hyxdqk:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:var(--colorNeutralStrokeDisabled);}"],
  m: [["@media (forced-colors: active){.f12iqdwp .fui-SplitButton__primaryActionButton{border-left-color:HighlightText;}.f2z0mmn .fui-SplitButton__primaryActionButton{border-right-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1btorfl:hover .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}.fxofj4p:hover .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f10m3pjc:hover:active .fui-SplitButton__primaryActionButton,.f10m3pjc:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:Highlight;}.f161sdhp:hover:active .fui-SplitButton__primaryActionButton,.f161sdhp:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fslo9ob .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}.ftovg2z .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f168zpha:hover .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.f1fuq5cn:hover .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1dnwhli:hover:active .fui-SplitButton__primaryActionButton,.f1dnwhli:active:focus-visible .fui-SplitButton__primaryActionButton{border-left-color:GrayText;}.f1t6bo0o:hover:active .fui-SplitButton__primaryActionButton,.f1t6bo0o:active:focus-visible .fui-SplitButton__primaryActionButton{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSplitButtonStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles5();
  const focusStyles = useFocusStyles();
  const {
    appearance,
    disabled,
    disabledFocusable
  } = state;
  state.root.className = mergeClasses(splitButtonClassNames.root, rootStyles.base, appearance && rootStyles[appearance], (disabled || disabledFocusable) && rootStyles.disabled, (disabled || disabledFocusable) && rootStyles.disabledHighContrast, state.root.className);
  if (state.menuButton) {
    state.menuButton.className = mergeClasses(splitButtonClassNames.menuButton, focusStyles.menuButton, state.menuButton.className);
  }
  if (state.primaryActionButton) {
    state.primaryActionButton.className = mergeClasses(splitButtonClassNames.primaryActionButton, focusStyles.primaryActionButton, state.primaryActionButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-button/lib/components/SplitButton/SplitButton.js
var SplitButton = React154.forwardRef((props, ref) => {
  const state = useSplitButton_unstable(props, ref);
  useSplitButtonStyles_unstable(state);
  useCustomStyleHook("useSplitButtonStyles_unstable")(state);
  return renderSplitButton_unstable(state);
});
SplitButton.displayName = "SplitButton";

// node_modules/@fluentui/react-button/lib/components/ToggleButton/ToggleButton.js
var React158 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButton.js
var React157 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButtonBase.js
var React156 = __toESM(require_react());

// node_modules/@fluentui/react-button/lib/utils/useToggleState.js
var React155 = __toESM(require_react());
function useToggleState(props, state) {
  const { checked, defaultChecked, disabled, disabledFocusable } = props;
  const { onClick, role } = state.root;
  const [checkedValue, setCheckedValue] = useControllableState({
    state: checked,
    defaultState: defaultChecked,
    initialState: false
  });
  const isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
  const onToggleClick = React155.useCallback((ev) => {
    if (!disabled && !disabledFocusable) {
      if (ev.defaultPrevented) {
        return;
      }
      setCheckedValue(!checkedValue);
    }
  }, [
    checkedValue,
    disabled,
    disabledFocusable,
    setCheckedValue
  ]);
  return {
    ...state,
    checked: checkedValue,
    root: {
      ...state.root,
      [isCheckboxTypeRole ? "aria-checked" : "aria-pressed"]: checkedValue,
      onClick: useEventCallback(mergeCallbacks(onClick, onToggleClick))
    }
  };
}

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButtonBase.js
var useToggleButtonBase_unstable = (props, ref) => {
  const buttonState = useButtonBase_unstable(props, ref);
  return useToggleState(props, buttonState);
};

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButton.js
var useToggleButton_unstable = (props, ref) => {
  "use no memo";
  const { size: contextSize } = useButtonContext();
  const { appearance = "secondary", shape = "rounded", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
  const buttonState = useToggleButtonBase_unstable(props, ref);
  return {
    appearance,
    shape,
    size: size3,
    ...buttonState
  };
};

// node_modules/@fluentui/react-button/lib/components/ToggleButton/useToggleButtonStyles.styles.js
var toggleButtonClassNames = {
  root: "fui-ToggleButton",
  icon: "fui-ToggleButton__icon"
};
var useRootCheckedStyles = __styles2({
  base: {
    De3pzq: "f1nfm20t",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    sj55zd: "f14nttnl",
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"],
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g",
    Jwef8y: "f1knas48",
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1xlaoq0",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    Bi91k9c: "feu1g3u",
    Bpjbzib: "f128kf1x",
    im15vp: "f1a38rnh",
    Hjvxdg: ["f1wvuwkr", "fbu0tau"],
    Gpfmf1: "f132k7zb",
    ustxxc: ["fbu0tau", "f1wvuwkr"],
    Brsut9c: "fggfoek"
  },
  highContrast: {
    By8wz76: "f1nz3ub2",
    Bcq6wej: "fjq791v",
    Jcjdmf: ["fkq2p2y", "f1sehlss"],
    sc4o1m: "f11odvng",
    Bosien3: ["f1sehlss", "fkq2p2y"],
    B7iucu3: "fqc85l4",
    B8gzw0y: "f1h3a8gf",
    Bbkh6qg: "fkiggi6",
    F230oe: "f8gmj8i",
    Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
    Bj1xduy: "f1igan7k",
    Bhh2cfd: ["fjag8bx", "f1ap8nzx"],
    Bahaeuw: "f1v3eptx",
    Bv2bamp: "f1ysmecq",
    vxuvv6: "faulsx",
    Bli9q98: ["f79t15f", "f8qmx7k"],
    Bx2tt8t: "fbtzoaq",
    yad0b3: ["f8qmx7k", "f79t15f"],
    j2fop7: "fd4bjan",
    B6rz4yo: 0,
    Buk7464: 0,
    Bqg8rp8: 0,
    pjr8j7: 0,
    Bgs2klq: 0,
    Hwei09: 0,
    Bi9aqk7: 0,
    Fihjvf: 0,
    nhyz0p: 0,
    Buw724y: 0,
    Bn7qjfh: 0,
    B0u7xl9: 0,
    md97jv: 0,
    h3ptyc: 0,
    s1kvfj: 0,
    kogrdj: 0,
    dqx2i2: "fdmpsdn",
    o0nolc: "fgjsukj"
  },
  outline: {
    De3pzq: "f1q9pm1r",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    B4j52fo: "fgx37oo",
    Bekrc4i: ["f130t4y6", "f1efpmoh"],
    Bn0qgzm: "fv51ejd",
    ibv6hh: ["f1efpmoh", "f130t4y6"],
    Jwef8y: "fjxutwb",
    Bpjbzib: "fkoldzo",
    B8q5s1w: "fcaw57c",
    Bci5o5g: ["fpwd27e", "f1999bjr"],
    n8qw10: "f1hi52o4",
    Bdrgwmp: ["f1999bjr", "fpwd27e"]
  },
  primary: {
    De3pzq: "f8w4g0q",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1phragk",
    Jwef8y: "f15wkkf3",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f1rq72xc",
    Bpjbzib: "f1ksv2xa",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "f1d6mv4x"
  },
  secondary: {},
  subtle: {
    De3pzq: "fq5gl1p",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1eryozh",
    Jwef8y: "f1t94bn6",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "fnwyq0v",
    Bpjbzib: "f1q1yqic",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "fwga7ee"
  },
  transparent: {
    De3pzq: "f1q9pm1r",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    sj55zd: "f1qj7y59",
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bi91k9c: "f139oj5f",
    Bpjbzib: "fkoldzo",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"],
    Brsut9c: "f1l983o9"
  }
}, {
  d: [".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f14nttnl{color:var(--colorNeutralForeground1Selected);}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".fgx37oo{border-top-width:var(--strokeWidthThicker);}", ".f130t4y6{border-right-width:var(--strokeWidthThicker);}", ".f1efpmoh{border-left-width:var(--strokeWidthThicker);}", ".fv51ejd{border-bottom-width:var(--strokeWidthThicker);}", ".fcaw57c[data-fui-focus-visible]{border-top-color:var(--colorNeutralStroke1);}", ".fpwd27e[data-fui-focus-visible]{border-right-color:var(--colorNeutralStroke1);}", ".f1999bjr[data-fui-focus-visible]{border-left-color:var(--colorNeutralStroke1);}", ".f1hi52o4[data-fui-focus-visible]{border-bottom-color:var(--colorNeutralStroke1);}", ".f8w4g0q{background-color:var(--colorBrandBackgroundSelected);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  h: [".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1xlaoq0:hover{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f128kf1x:hover:active,.f128kf1x:active:focus-visible{background-color:var(--colorNeutralBackground1Pressed);}", ".f1a38rnh:hover:active,.f1a38rnh:active:focus-visible{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1wvuwkr:hover:active,.f1wvuwkr:active:focus-visible{border-right-color:var(--colorNeutralStroke1Pressed);}", ".fbu0tau:hover:active,.fbu0tau:active:focus-visible{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f132k7zb:hover:active,.f132k7zb:active:focus-visible{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".fggfoek:hover:active,.fggfoek:active:focus-visible{color:var(--colorNeutralForeground1Pressed);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1ksv2xa:hover:active,.f1ksv2xa:active:focus-visible{background-color:var(--colorBrandBackgroundPressed);}", ".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}", ".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}", ".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}", ".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}", ".f1d6mv4x:hover:active,.f1d6mv4x:active:focus-visible{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1q1yqic:hover:active,.f1q1yqic:active:focus-visible{background-color:var(--colorSubtleBackgroundPressed);}", ".fwga7ee:hover:active,.fwga7ee:active:focus-visible{color:var(--colorNeutralForeground2Pressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1l983o9:hover:active,.f1l983o9:active:focus-visible{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fjq791v{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1sehlss{border-left-color:Highlight;}.fkq2p2y{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f11odvng{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ysmecq:hover:active,.f1ysmecq:active:focus-visible{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.faulsx:hover:active,.faulsx:active:focus-visible{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f79t15f:hover:active,.f79t15f:active:focus-visible{border-right-color:Highlight;}.f8qmx7k:hover:active,.f8qmx7k:active:focus-visible{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbtzoaq:hover:active,.fbtzoaq:active:focus-visible{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fd4bjan:hover:active,.fd4bjan:active:focus-visible{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fdmpsdn:focus{border:1px solid HighlightText;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fgjsukj:focus{outline-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootDisabledStyles2 = __styles2({
  base: {
    De3pzq: "f1bg9a2p",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Jwef8y: "f1falr9n",
    Bgoe8wy: "f12mpcsy",
    Bwzppfd: ["f1gwvigk", "f18rmfxp"],
    oetu4i: "f1jnshp0",
    gg5e9n: ["f18rmfxp", "f1gwvigk"],
    Bi91k9c: "fvgxktp",
    Bpjbzib: "f1jct5ie",
    im15vp: "f13txml0",
    Hjvxdg: ["f1ncddno", "f1axfvow"],
    Gpfmf1: "f1z04ada",
    ustxxc: ["f1axfvow", "f1ncddno"],
    Brsut9c: "f1uhomfy"
  },
  outline: {},
  primary: {
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  },
  secondary: {},
  subtle: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bpjbzib: "fkoldzo",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  },
  transparent: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1p3nwhy",
    h3c5rm: ["f11589ue", "f1pdflbu"],
    B9xav0g: "f1q5o8ev",
    zhjwy3: ["f1pdflbu", "f11589ue"],
    Jwef8y: "fjxutwb",
    Bgoe8wy: "f1s2uweq",
    Bwzppfd: ["fr80ssc", "fecsdlb"],
    oetu4i: "f1ukrpxl",
    gg5e9n: ["fecsdlb", "fr80ssc"],
    Bpjbzib: "fkoldzo",
    im15vp: "fhvnf4x",
    Hjvxdg: ["fb6swo4", "f232fm2"],
    Gpfmf1: "f1klyf7k",
    ustxxc: ["f232fm2", "fb6swo4"]
  }
}, {
  d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}"],
  h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1jct5ie:hover:active,.f1jct5ie:active:focus-visible{background-color:var(--colorNeutralBackgroundDisabled);}", ".f13txml0:hover:active,.f13txml0:active:focus-visible{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ncddno:hover:active,.f1ncddno:active:focus-visible{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1axfvow:hover:active,.f1axfvow:active:focus-visible{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1z04ada:hover:active,.f1z04ada:active:focus-visible{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1uhomfy:hover:active,.f1uhomfy:active:focus-visible{color:var(--colorNeutralForegroundDisabled);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".fhvnf4x:hover:active,.fhvnf4x:active:focus-visible{border-top-color:transparent;}", ".fb6swo4:hover:active,.fb6swo4:active:focus-visible{border-right-color:transparent;}", ".f232fm2:hover:active,.f232fm2:active:focus-visible{border-left-color:transparent;}", ".f1klyf7k:hover:active,.f1klyf7k:active:focus-visible{border-bottom-color:transparent;}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fkoldzo:hover:active,.fkoldzo:active:focus-visible{background-color:var(--colorTransparentBackgroundPressed);}"]
});
var useIconCheckedStyles = __styles2({
  subtleOrTransparent: {
    sj55zd: "f1qj7y59"
  },
  highContrast: {
    B8gzw0y: "f1dd5bof"
  }
}, {
  d: [".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"],
  m: [["@media (forced-colors: active){.f1dd5bof{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }]]
});
var usePrimaryHighContrastStyles = __styles2({
  base: {
    By8wz76: "f14ptb23",
    Bcq6wej: "fd7znuh",
    Jcjdmf: ["f1wh4a04", "f15h7fac"],
    sc4o1m: "f1f064oi",
    Bosien3: ["f15h7fac", "f1wh4a04"],
    B7iucu3: "f3ggph1",
    B8gzw0y: "f1dd5bof"
  },
  disabled: {
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"],
    B7iucu3: "f1cyfu5x",
    h3ptyc: "f19etb0b",
    Buw724y: ["f4f984j", "fw441p0"],
    Buk7464: "f3d22hf",
    Hwei09: ["fw441p0", "f4f984j"]
  }
}, {
  m: [["@media (forced-colors: active){.f14ptb23{background-color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fd7znuh{border-top-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f15h7fac{border-left-color:ButtonBorder;}.f1wh4a04{border-right-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1f064oi{border-bottom-color:ButtonBorder;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3ggph1{color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1dd5bof{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19etb0b:focus{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4f984j:focus{border-right-color:GrayText;}.fw441p0:focus{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3d22hf:focus{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useToggleButtonStyles_unstable = (state) => {
  "use no memo";
  const rootCheckedStyles = useRootCheckedStyles();
  const rootDisabledStyles = useRootDisabledStyles2();
  const iconCheckedStyles = useIconCheckedStyles();
  const primaryHighContrastStyles = usePrimaryHighContrastStyles();
  const {
    appearance,
    checked,
    disabled,
    disabledFocusable
  } = state;
  state.root.className = mergeClasses(
    toggleButtonClassNames.root,
    // Primary high contrast styles
    appearance === "primary" && primaryHighContrastStyles.base,
    appearance === "primary" && (disabled || disabledFocusable) && primaryHighContrastStyles.disabled,
    // Checked styles
    checked && rootCheckedStyles.base,
    checked && rootCheckedStyles.highContrast,
    appearance && checked && rootCheckedStyles[appearance],
    // Disabled styles
    (disabled || disabledFocusable) && rootDisabledStyles.base,
    appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
    // User provided class name
    state.root.className
  );
  if (state.icon) {
    state.icon.className = mergeClasses(toggleButtonClassNames.icon, checked && (appearance === "subtle" || appearance === "transparent") && iconCheckedStyles.subtleOrTransparent, iconCheckedStyles.highContrast, state.icon.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-button/lib/components/ToggleButton/ToggleButton.js
var ToggleButton = React158.forwardRef((props, ref) => {
  const state = useToggleButton_unstable(props, ref);
  useToggleButtonStyles_unstable(state);
  useCustomStyleHook("useToggleButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToggleButton.displayName = "ToggleButton";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var React166 = __toESM(require_react());

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var React165 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var React164 = __toESM(require_react());

// node_modules/@fluentui/react-field/lib/contexts/FieldContext.js
var React159 = __toESM(require_react());
var FieldContext = React159.createContext(void 0);
var FieldContextProvider = FieldContext.Provider;
var useFieldContext_unstable = () => React159.useContext(FieldContext);

// node_modules/@fluentui/react-field/lib/contexts/useFieldContextValues.js
var React160 = __toESM(require_react());
var useFieldContextValues_unstable = (state) => {
  var _state_label, _state_label1, _state_validationMessage, _state_hint;
  const { generatedControlId, orientation, required, size: size3, validationState } = state;
  const labelFor = (_state_label = state.label) === null || _state_label === void 0 ? void 0 : _state_label.htmlFor;
  const labelId = (_state_label1 = state.label) === null || _state_label1 === void 0 ? void 0 : _state_label1.id;
  const validationMessageId = (_state_validationMessage = state.validationMessage) === null || _state_validationMessage === void 0 ? void 0 : _state_validationMessage.id;
  const hintId = (_state_hint = state.hint) === null || _state_hint === void 0 ? void 0 : _state_hint.id;
  const field = React160.useMemo(() => ({
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size: size3,
    validationMessageId,
    validationState
  }), [
    generatedControlId,
    hintId,
    labelFor,
    labelId,
    orientation,
    required,
    size3,
    validationMessageId,
    validationState
  ]);
  return {
    field
  };
};

// node_modules/@fluentui/react-field/lib/contexts/useFieldControlProps.js
function useFieldControlProps_unstable(props, options) {
  return getFieldControlProps(useFieldContext_unstable(), props, options);
}
function getFieldControlProps(context, props, options) {
  if (!context) {
    return props;
  }
  props = {
    ...props
  };
  const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
  if (generatedControlId) {
    var _props;
    var _id;
    (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
  }
  if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
    var _props1, _arialabelledby;
    var _;
    (_ = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _props1[_arialabelledby] = labelId;
  }
  if (validationMessageId || hintId) {
    props["aria-describedby"] = [
      validationMessageId,
      hintId,
      props === null || props === void 0 ? void 0 : props["aria-describedby"]
    ].filter(Boolean).join(" ");
  }
  if (validationState === "error") {
    var _props2, _ariainvalid;
    var _1;
    (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
  }
  if (required) {
    if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
      var _props3;
      var _required;
      (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
    } else {
      var _props4, _ariarequired;
      var _2;
      (_2 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _2 !== void 0 ? _2 : _props4[_ariarequired] = true;
    }
  }
  if (options === null || options === void 0 ? void 0 : options.supportsSize) {
    var _props5;
    var _size;
    (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
  }
  return props;
}

// node_modules/@fluentui/react-field/lib/components/Field/renderField.js
var renderField_unstable = (state, contextValues) => {
  assertSlots(state);
  let { children } = state;
  if (typeof children === "function") {
    children = children(getFieldControlProps(contextValues.field) || {});
  }
  return jsx(FieldContextProvider, {
    value: contextValues === null || contextValues === void 0 ? void 0 : contextValues.field,
    children: jsxs(state.root, {
      children: [
        state.label && jsx(state.label, {}),
        children,
        state.validationMessage && jsxs(state.validationMessage, {
          children: [
            state.validationMessageIcon && jsx(state.validationMessageIcon, {}),
            state.validationMessage.children
          ]
        }),
        state.hint && jsx(state.hint, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var React163 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var React162 = __toESM(require_react());

// node_modules/@fluentui/react-label/lib/components/Label/useLabel.js
var React161 = __toESM(require_react());
var useLabel_unstable = (props, ref) => {
  const { disabled = false, required = false, weight = "regular", size: size3 = "medium" } = props;
  return {
    disabled,
    required: slot_exports.optional(required === true ? "*" : required || void 0, {
      defaultProps: {
        "aria-hidden": "true"
      },
      elementType: "span"
    }),
    weight,
    size: size3,
    components: {
      root: "label",
      required: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("label", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "label"
    })
  };
};

// node_modules/@fluentui/react-label/lib/components/Label/renderLabel.js
var renderLabel_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.required && jsx(state.required, {})
    ]
  });
};

// node_modules/@fluentui/react-label/lib/components/Label/useLabelStyles.styles.js
var labelClassNames = {
  root: "fui-Label",
  required: "fui-Label__required"
};
var useStyles11 = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    sj55zd: "f19n0e5"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    B7iucu3: "f1cyfu5x"
  },
  required: {
    sj55zd: "f1whyuy6",
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  small: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k",
    Bhrd7zp: "fl43uef"
  },
  semibold: {
    Bhrd7zp: "fl43uef"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useLabelStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles11();
  state.root.className = mergeClasses(labelClassNames.root, styles.root, state.disabled && styles.disabled, styles[state.size], state.weight === "semibold" && styles.semibold, state.root.className);
  if (state.required) {
    state.required.className = mergeClasses(labelClassNames.required, styles.required, state.disabled && styles.disabled, state.required.className);
  }
  return state;
};

// node_modules/@fluentui/react-label/lib/components/Label/Label.js
var Label = React162.forwardRef((props, ref) => {
  const state = useLabel_unstable(props, ref);
  useLabelStyles_unstable(state);
  useCustomStyleHook("useLabelStyles_unstable")(state);
  return renderLabel_unstable(state);
});
Label.displayName = "Label";

// node_modules/@fluentui/react-field/lib/components/Field/useField.js
var validationMessageIcons = {
  error: React163.createElement(ErrorCircle12Filled, null),
  warning: React163.createElement(Warning12Filled, null),
  success: React163.createElement(CheckmarkCircle12Filled, null),
  none: void 0
};
var useField_unstable = (props, ref) => {
  const { children, orientation = "vertical", required = false, validationState = props.validationMessage ? "error" : "none", size: size3 = "medium" } = props;
  const baseId = useId2("field-");
  const generatedControlId = baseId + "__control";
  const root = slot_exports.always(getIntrinsicElementProps(
    "div",
    {
      ...props,
      ref
    },
    /*excludedPropNames:*/
    [
      "children"
    ]
  ), {
    elementType: "div"
  });
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: generatedControlId,
      id: baseId + "__label",
      required,
      size: size3
    },
    elementType: Label
  });
  const validationMessage = slot_exports.optional(props.validationMessage, {
    defaultProps: {
      id: baseId + "__validationMessage",
      role: validationState === "error" || validationState === "warning" ? "alert" : void 0
    },
    elementType: "div"
  });
  const hint = slot_exports.optional(props.hint, {
    defaultProps: {
      id: baseId + "__hint"
    },
    elementType: "div"
  });
  const defaultIcon = validationMessageIcons[validationState];
  const validationMessageIcon = slot_exports.optional(props.validationMessageIcon, {
    renderByDefault: !!defaultIcon,
    defaultProps: {
      children: defaultIcon
    },
    elementType: "span"
  });
  return {
    children,
    generatedControlId,
    orientation,
    required,
    size: size3,
    validationState,
    components: {
      root: "div",
      label: Label,
      validationMessage: "div",
      validationMessageIcon: "span",
      hint: "div"
    },
    root,
    label,
    validationMessageIcon,
    validationMessage,
    hint
  };
};

// node_modules/@fluentui/react-field/lib/components/Field/useFieldStyles.styles.js
var fieldClassNames = {
  root: `fui-Field`,
  label: `fui-Field__label`,
  validationMessage: `fui-Field__validationMessage`,
  validationMessageIcon: `fui-Field__validationMessageIcon`,
  hint: `fui-Field__hint`
};
var useRootStyles6 = __styles2({
  base: {
    mc9l5x: "f13qh94s"
  },
  horizontal: {
    Budl1dq: "f2wwaib",
    wkccdc: "f1645dqt"
  },
  horizontalNoLabel: {
    uwmqm3: ["f15jqgz8", "fggqkej"],
    Budl1dq: "f1c2z91y"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".f2wwaib{grid-template-columns:33% 1fr;}", ".f1645dqt{grid-template-rows:auto auto auto 1fr;}", ".f15jqgz8{padding-left:33%;}", ".fggqkej{padding-right:33%;}", ".f1c2z91y{grid-template-columns:1fr;}"]
});
var useLabelStyles = __styles2({
  base: {
    B2u0y6b: "f6nezus",
    Bxyxcbc: "f1iqmcbn"
  },
  vertical: {
    z8tnut: "fclwglc",
    Byoj8tv: "fywfov9",
    jrapky: "fyacil5"
  },
  verticalLarge: {
    z8tnut: "f1sl3k7w",
    Byoj8tv: "f1brlhvm",
    jrapky: "f8l5zjj"
  },
  horizontal: {
    z8tnut: "fp2oml8",
    Byoj8tv: "f1tdddsa",
    t21cq0: ["fkujibs", "f199hnxi"],
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z"
  },
  horizontalSmall: {
    z8tnut: "f1ywm7hm",
    Byoj8tv: "f14wxoun"
  },
  horizontalLarge: {
    z8tnut: "f1hqyr95",
    Byoj8tv: "fm4hlj0"
  }
}, {
  d: [".f6nezus{max-width:max-content;}", ".f1iqmcbn{max-height:max-content;}", ".fclwglc{padding-top:var(--spacingVerticalXXS);}", ".fywfov9{padding-bottom:var(--spacingVerticalXXS);}", ".fyacil5{margin-bottom:var(--spacingVerticalXXS);}", ".f1sl3k7w{padding-top:1px;}", ".f1brlhvm{padding-bottom:1px;}", ".f8l5zjj{margin-bottom:var(--spacingVerticalXS);}", ".fp2oml8{padding-top:var(--spacingVerticalSNudge);}", ".f1tdddsa{padding-bottom:var(--spacingVerticalSNudge);}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".f1hqyr95{padding-top:9px;}", ".fm4hlj0{padding-bottom:9px;}"]
});
var useSecondaryTextBaseClassName = __resetStyles("r5c4z9l", null, [".r5c4z9l{margin-top:var(--spacingVerticalXXS);color:var(--colorNeutralForeground3);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useSecondaryTextStyles = __styles2({
  error: {
    sj55zd: "f1hcrxcs"
  },
  withIcon: {
    uwmqm3: ["frawy03", "fg4c52"]
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".frawy03{padding-left:calc(12px + var(--spacingHorizontalXS));}", ".fg4c52{padding-right:calc(12px + var(--spacingHorizontalXS));}"]
});
var useValidationMessageIconBaseClassName = __resetStyles("ra7h1uk", "r1rh6bd7", [".ra7h1uk{display:inline-block;font-size:12px;margin-left:calc(-12px - var(--spacingHorizontalXS));margin-right:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}", ".r1rh6bd7{display:inline-block;font-size:12px;margin-right:calc(-12px - var(--spacingHorizontalXS));margin-left:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}"]);
var useValidationMessageIconStyles = __styles2({
  error: {
    sj55zd: "f1hcrxcs"
  },
  warning: {
    sj55zd: "f1k5f75o"
  },
  success: {
    sj55zd: "ffmvakt"
  }
}, {
  d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}"]
});
var useFieldStyles_unstable = (state) => {
  "use no memo";
  const {
    validationState,
    size: size3
  } = state;
  const horizontal = state.orientation === "horizontal";
  const rootStyles = useRootStyles6();
  state.root.className = mergeClasses(fieldClassNames.root, rootStyles.base, horizontal && rootStyles.horizontal, horizontal && !state.label && rootStyles.horizontalNoLabel, state.root.className);
  const labelStyles = useLabelStyles();
  if (state.label) {
    state.label.className = mergeClasses(fieldClassNames.label, labelStyles.base, horizontal && labelStyles.horizontal, horizontal && size3 === "small" && labelStyles.horizontalSmall, horizontal && size3 === "large" && labelStyles.horizontalLarge, !horizontal && labelStyles.vertical, !horizontal && size3 === "large" && labelStyles.verticalLarge, state.label.className);
  }
  const validationMessageIconBaseClassName = useValidationMessageIconBaseClassName();
  const validationMessageIconStyles = useValidationMessageIconStyles();
  if (state.validationMessageIcon) {
    state.validationMessageIcon.className = mergeClasses(fieldClassNames.validationMessageIcon, validationMessageIconBaseClassName, validationState !== "none" && validationMessageIconStyles[validationState], state.validationMessageIcon.className);
  }
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
  const secondaryTextStyles = useSecondaryTextStyles();
  if (state.validationMessage) {
    state.validationMessage.className = mergeClasses(fieldClassNames.validationMessage, secondaryTextBaseClassName, validationState === "error" && secondaryTextStyles.error, !!state.validationMessageIcon && secondaryTextStyles.withIcon, state.validationMessage.className);
  }
  if (state.hint) {
    state.hint.className = mergeClasses(fieldClassNames.hint, secondaryTextBaseClassName, state.hint.className);
  }
  return state;
};

// node_modules/@fluentui/react-field/lib/components/Field/Field.js
var Field = React164.forwardRef((props, ref) => {
  const state = useField_unstable(props, ref);
  useFieldStyles_unstable(state);
  useCustomStyleHook("useFieldStyles_unstable")(state);
  const context = useFieldContextValues_unstable(state);
  return renderField_unstable(state, context);
});
Field.displayName = "Field";

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckbox.js
var useCheckbox_unstable = (props, ref) => {
  "use no memo";
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const { disabled = false, required, shape = "square", size: size3 = "medium", labelPosition = "after", onChange } = props;
  const [checked, setChecked] = useControllableState({
    defaultState: props.defaultChecked,
    state: props.checked,
    initialState: false
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "size",
      "onChange"
    ]
  });
  const mixed = checked === "mixed";
  const id = useId2("checkbox-", nativeProps.primary.id);
  let checkmarkIcon;
  if (mixed) {
    if (shape === "circular") {
      checkmarkIcon = React165.createElement(CircleFilled, null);
    } else {
      checkmarkIcon = size3 === "large" ? React165.createElement(Square16Filled, null) : React165.createElement(Square12Filled, null);
    }
  } else if (checked) {
    checkmarkIcon = size3 === "large" ? React165.createElement(Checkmark16Filled, null) : React165.createElement(Checkmark12Filled, null);
  }
  const state = {
    shape,
    checked,
    disabled,
    size: size3,
    labelPosition,
    components: {
      root: "span",
      input: "input",
      indicator: "div",
      label: Label
    },
    root: slot_exports.always(props.root, {
      defaultProps: {
        ref: useFocusWithin(),
        ...nativeProps.root
      },
      elementType: "span"
    }),
    input: slot_exports.always(props.input, {
      defaultProps: {
        type: "checkbox",
        id,
        ref,
        checked: checked === true,
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    label: slot_exports.optional(props.label, {
      defaultProps: {
        htmlFor: id,
        disabled,
        required,
        size: "medium"
      },
      elementType: Label
    }),
    indicator: slot_exports.optional(props.indicator, {
      renderByDefault: true,
      defaultProps: {
        "aria-hidden": true,
        children: checkmarkIcon
      },
      elementType: "div"
    })
  };
  state.input.onChange = useEventCallback((ev) => {
    const val = ev.currentTarget.indeterminate ? "mixed" : ev.currentTarget.checked;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: val
    });
    setChecked(val);
  });
  const inputRef = useMergedRefs(state.input.ref);
  state.input.ref = inputRef;
  useIsomorphicLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = mixed;
    }
  }, [
    inputRef,
    mixed
  ]);
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/renderCheckbox.js
var renderCheckbox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      state.labelPosition === "before" && state.label && jsx(state.label, {}),
      state.indicator && jsx(state.indicator, {}),
      state.labelPosition === "after" && state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/useCheckboxStyles.styles.js
var checkboxClassNames = {
  root: "fui-Checkbox",
  label: "fui-Checkbox__label",
  input: "fui-Checkbox__input",
  indicator: "fui-Checkbox__indicator"
};
var useRootBaseClassName2 = __resetStyles("r1nzur1d", "r128arqq", {
  r: [".r1nzur1d{position:relative;display:inline-flex;cursor:pointer;max-width:fit-content;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".r1nzur1d:focus{outline-style:none;}", ".r1nzur1d:focus-visible{outline-style:none;}", ".r1nzur1d[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1nzur1d[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r128arqq{position:relative;display:inline-flex;cursor:pointer;max-width:fit-content;vertical-align:middle;color:var(--colorNeutralForeground3);}", ".r128arqq:focus{outline-style:none;}", ".r128arqq:focus-visible{outline-style:none;}", ".r128arqq[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r128arqq[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1nzur1d[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r128arqq[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles7 = __styles2({
  unchecked: {
    Bi91k9c: "f3p8bqa",
    pv5h1i: "fium13f",
    lj723h: "f1r2dosr",
    Hnthvo: "f1729es6"
  },
  checked: {
    sj55zd: "f19n0e5",
    wkncrt: "f35ds98",
    zxk7z7: "f12mnkne",
    Hmsnfy: "fei9a8h",
    e6czan: "fix56y3",
    pv5h1i: "f1bcv2js",
    qbydtz: "f7dr4go",
    Hnthvo: "f1r5cpua"
  },
  mixed: {
    sj55zd: "f19n0e5",
    Hmsnfy: "f1l27tf0",
    zxk7z7: "fcilktj",
    pv5h1i: "f1lphd54",
    Bunfa6h: "f1obkvq7",
    Hnthvo: "f2gmbuh",
    B15ykmv: "f1oy4fa1"
  },
  disabled: {
    Bceei9c: "f158kwzp",
    sj55zd: "f1s2aq7o",
    Hmsnfy: "f1w7mfl5",
    zxk7z7: "fcoafq6",
    B7iucu3: "f1cyfu5x",
    Bptavk6: "f1lwde8o"
  }
}, {
  h: [".f3p8bqa:hover{color:var(--colorNeutralForeground2);}", ".fium13f:hover{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessibleHover);}", ".fix56y3:hover{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundHover);}", ".f1bcv2js:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundHover);}", ".f1lphd54:hover{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokeHover);}", ".f1obkvq7:hover{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Hover);}"],
  a: [".f1r2dosr:active{color:var(--colorNeutralForeground1);}", ".f1729es6:active{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeAccessiblePressed);}", ".f7dr4go:active{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackgroundPressed);}", ".f1r5cpua:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackgroundPressed);}", ".f2gmbuh:active{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStrokePressed);}", ".f1oy4fa1:active{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1Pressed);}"],
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f35ds98{--fui-Checkbox__indicator--backgroundColor:var(--colorCompoundBrandBackground);}", ".f12mnkne{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundInverted);}", ".fei9a8h{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandBackground);}", ".f1l27tf0{--fui-Checkbox__indicator--borderColor:var(--colorCompoundBrandStroke);}", ".fcilktj{--fui-Checkbox__indicator--color:var(--colorCompoundBrandForeground1);}", ".f158kwzp{cursor:default;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1w7mfl5{--fui-Checkbox__indicator--borderColor:var(--colorNeutralStrokeDisabled);}", ".fcoafq6{--fui-Checkbox__indicator--color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1lwde8o{--fui-Checkbox__indicator--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputBaseClassName = __resetStyles("ruo9svu", null, [".ruo9svu{box-sizing:border-box;cursor:inherit;height:100%;margin:0;opacity:0;position:absolute;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));}"]);
var useInputStyles = __styles2({
  before: {
    j35jbq: ["f1e31b4d", "f1vgc2s3"]
  },
  after: {
    oyh7mz: ["f1vgc2s3", "f1e31b4d"]
  },
  large: {
    a9b677: "f1mq5jt6"
  }
}, {
  d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1mq5jt6{width:calc(20px + 2 * var(--spacingHorizontalS));}"]
});
var useIndicatorBaseClassName = __resetStyles("rl7ci6d", null, [".rl7ci6d{align-self:flex-start;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;color:var(--fui-Checkbox__indicator--color);background-color:var(--fui-Checkbox__indicator--backgroundColor);border-color:var(--fui-Checkbox__indicator--borderColor, var(--colorNeutralStrokeAccessible));border-style:solid;border-width:var(--strokeWidthThin);border-radius:var(--borderRadiusSmall);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;font-size:12px;height:16px;width:16px;}"]);
var useIndicatorStyles = __styles2({
  large: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  }
}, {
  d: [".f4ybsrx{font-size:16px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useLabelStyles2 = __styles2({
  base: {
    qb2dma: "f7nlbp4",
    sj55zd: "f1ym3bx4",
    Bceei9c: "fpo1scq",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  before: {
    z189sj: ["f7x41pl", "fruq291"]
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  medium: {
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  large: {
    B6of3ja: "f1xlvstr",
    jrapky: "f49ad5g"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", ".f1ym3bx4{color:inherit;}", ".fpo1scq{cursor:inherit;}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}"]
});
var useCheckboxStyles_unstable = (state) => {
  "use no memo";
  const {
    checked,
    disabled,
    labelPosition,
    shape,
    size: size3
  } = state;
  const rootBaseClassName = useRootBaseClassName2();
  const rootStyles = useRootStyles7();
  state.root.className = mergeClasses(checkboxClassNames.root, rootBaseClassName, disabled ? rootStyles.disabled : checked === "mixed" ? rootStyles.mixed : checked ? rootStyles.checked : rootStyles.unchecked, state.root.className);
  const inputBaseClassName = useInputBaseClassName();
  const inputStyles = useInputStyles();
  state.input.className = mergeClasses(checkboxClassNames.input, inputBaseClassName, size3 === "large" && inputStyles.large, inputStyles[labelPosition], state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName();
  const indicatorStyles = useIndicatorStyles();
  if (state.indicator) {
    state.indicator.className = mergeClasses(checkboxClassNames.indicator, indicatorBaseClassName, size3 === "large" && indicatorStyles.large, shape === "circular" && indicatorStyles.circular, state.indicator.className);
  }
  const labelStyles = useLabelStyles2();
  if (state.label) {
    state.label.className = mergeClasses(checkboxClassNames.label, labelStyles.base, labelStyles[size3], labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-checkbox/lib/components/Checkbox/Checkbox.js
var Checkbox = React166.forwardRef((props, ref) => {
  const state = useCheckbox_unstable(props, ref);
  useCheckboxStyles_unstable(state);
  useCustomStyleHook("useCheckboxStyles_unstable")(state);
  return renderCheckbox_unstable(state);
});
Checkbox.displayName = "Checkbox";

// node_modules/@fluentui/react-combobox/lib/contexts/ComboboxContext.js
var ComboboxContext = createContext13({
  activeOption: void 0,
  appearance: "outline",
  focusVisible: false,
  open: false,
  registerOption() {
    return () => void 0;
  },
  selectedOptions: [],
  selectOption() {
  },
  setActiveOption() {
  },
  setOpen() {
  },
  size: "medium"
});
var ComboboxProvider = ComboboxContext.Provider;

// node_modules/@fluentui/react-combobox/lib/contexts/ListboxContext.js
var React167 = __toESM(require_react());
var listboxContextDefaultValue = {
  activeOption: void 0,
  focusVisible: false,
  multiselect: false,
  getOptionById() {
    return void 0;
  },
  getOptionsMatchingValue() {
    return [];
  },
  registerOption() {
    return () => void 0;
  },
  selectedOptions: [],
  onOptionClick() {
  },
  onActiveDescendantChange() {
  },
  selectOption() {
  },
  setActiveOption() {
  }
};
var ListboxContext = createContext13(void 0);
var useListboxContext_unstable = (selector) => useContextSelector(ListboxContext, (ctx = listboxContextDefaultValue) => selector(ctx));
var ListboxProvider = ListboxContext.Provider;

// node_modules/@fluentui/react-combobox/lib/contexts/useComboboxContextValues.js
var React168 = __toESM(require_react());
function useComboboxContextValues(state) {
  const { appearance, open, getOptionById, getOptionsMatchingValue, registerOption, selectedOptions, selectOption, setOpen, size: size3, activeDescendantController, onOptionClick, onActiveDescendantChange } = state;
  const combobox = {
    activeOption: void 0,
    appearance,
    focusVisible: false,
    open,
    registerOption,
    selectedOptions,
    selectOption,
    setActiveOption: () => null,
    setOpen,
    size: size3
  };
  const listbox = {
    activeOption: void 0,
    focusVisible: false,
    getOptionById,
    getOptionsMatchingValue,
    registerOption,
    selectedOptions,
    selectOption,
    setActiveOption: () => null,
    onOptionClick,
    onActiveDescendantChange
  };
  const activeDescendant = React168.useMemo(() => ({
    controller: activeDescendantController
  }), [
    activeDescendantController
  ]);
  return {
    combobox,
    activeDescendant,
    listbox
  };
}

// node_modules/@fluentui/react-combobox/lib/contexts/useListboxContextValues.js
var React169 = __toESM(require_react());
function useListboxContextValues(state) {
  const hasListboxContext = useHasParentContext(ListboxContext);
  const { getOptionById, getOptionsMatchingValue, multiselect, registerOption, selectedOptions, selectOption, activeDescendantController } = state;
  const parentRegisterOption = useListboxContext_unstable((ctx) => ctx.registerOption);
  const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
  const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
  const registerOptionValue = hasListboxContext ? parentRegisterOption : registerOption;
  const listbox = {
    activeOption: void 0,
    focusVisible: false,
    getOptionById,
    getOptionsMatchingValue,
    multiselect,
    registerOption: registerOptionValue,
    selectedOptions,
    selectOption,
    setActiveOption: () => void 0,
    onOptionClick,
    onActiveDescendantChange
  };
  const activeDescendant = React169.useMemo(() => ({
    controller: activeDescendantController
  }), [
    activeDescendantController
  ]);
  return {
    listbox,
    activeDescendant
  };
}

// node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
var React174 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
var React173 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/dropdownKeyActions.js
var React170 = __toESM(require_react());
function getDropdownActionFromKey(e, options = {}) {
  const { open = true, multiselect = false } = options;
  const code = e.key;
  const { altKey, ctrlKey, key, metaKey } = e;
  if (key.length === 1 && code !== Space && !altKey && !ctrlKey && !metaKey) {
    return "Type";
  }
  if (!open) {
    if (code === ArrowDown || code === ArrowUp || code === Enter || code === Space) {
      return "Open";
    }
    return "None";
  }
  if (code === ArrowUp && altKey || code === Enter || !multiselect && code === Space) {
    return "CloseSelect";
  }
  if (multiselect && code === Space) {
    return "Select";
  }
  if (code === Escape) {
    return "Close";
  }
  if (code === ArrowDown) {
    return "Next";
  }
  if (code === ArrowUp) {
    return "Previous";
  }
  if (code === Home) {
    return "First";
  }
  if (code === End) {
    return "Last";
  }
  if (code === PageUp) {
    return "PageUp";
  }
  if (code === PageDown) {
    return "PageDown";
  }
  if (code === Tab) {
    return "Tab";
  }
  return "None";
}

// node_modules/@fluentui/react-combobox/lib/utils/useOptionCollection.js
var React171 = __toESM(require_react());
var useOptionCollection = () => {
  const optionsById = React171.useRef(/* @__PURE__ */ new Map());
  const collectionAPI = React171.useMemo(() => {
    const getCount = () => optionsById.current.size;
    const getOptionAtIndex = () => void 0;
    const getIndexOfId = () => -1;
    const getOptionById = (id) => {
      return optionsById.current.get(id);
    };
    const getOptionsMatchingText = (matcher) => {
      return Array.from(optionsById.current.values()).filter(({ text }) => matcher(text));
    };
    const getOptionsMatchingValue = (matcher) => {
      const matches = [];
      for (const option of optionsById.current.values()) {
        if (matcher(option.value)) {
          matches.push(option);
        }
      }
      return matches;
    };
    return {
      getCount,
      getOptionAtIndex,
      getIndexOfId,
      getOptionById,
      getOptionsMatchingText,
      getOptionsMatchingValue
    };
  }, []);
  const registerOption = React171.useCallback((option) => {
    optionsById.current.set(option.id, option);
    return () => optionsById.current.delete(option.id);
  }, []);
  return {
    ...collectionAPI,
    options: Array.from(optionsById.current.values()),
    registerOption
  };
};

// node_modules/@fluentui/react-combobox/lib/utils/useSelection.js
var React172 = __toESM(require_react());
var useSelection2 = (props) => {
  const { defaultSelectedOptions, multiselect, onOptionSelect } = props;
  const [selectedOptions, setSelectedOptions] = useControllableState({
    state: props.selectedOptions,
    defaultState: defaultSelectedOptions,
    initialState: []
  });
  const selectOption = React172.useCallback((event, option) => {
    if (option.disabled) {
      return;
    }
    let newSelection = [
      option.value
    ];
    if (multiselect) {
      const selectedIndex = selectedOptions.findIndex((o) => o === option.value);
      if (selectedIndex > -1) {
        newSelection = [
          ...selectedOptions.slice(0, selectedIndex),
          ...selectedOptions.slice(selectedIndex + 1)
        ];
      } else {
        newSelection = [
          ...selectedOptions,
          option.value
        ];
      }
    }
    setSelectedOptions(newSelection);
    onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
      optionValue: option.value,
      optionText: option.text,
      selectedOptions: newSelection
    });
  }, [
    onOptionSelect,
    multiselect,
    selectedOptions,
    setSelectedOptions
  ]);
  const clearSelection = (event) => {
    setSelectedOptions([]);
    onOptionSelect === null || onOptionSelect === void 0 ? void 0 : onOptionSelect(event, {
      optionValue: void 0,
      optionText: void 0,
      selectedOptions: []
    });
  };
  return {
    clearSelection,
    selectOption,
    selectedOptions
  };
};

// node_modules/@fluentui/react-combobox/lib/components/Option/useOptionStyles.styles.js
var optionClassNames = {
  root: "fui-Option",
  checkIcon: "fui-Option__checkIcon"
};
var useStyles12 = __styles2({
  root: {
    Bt984gj: "f122n59",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    sj55zd: "f19n0e5",
    i8kkvl: "f1ufnopg",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f22iagw",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fm5eomj",
    qhf8xq: "f10pi13n",
    Jwef8y: "f1knas48",
    Bi91k9c: "feu1g3u",
    zqbkvg: "fo79ri9",
    h82x05: ["f1osiabc", "f1e8le25"],
    cqj998: "f1yusjty",
    j3hlsh: ["f1e8le25", "f1osiabc"],
    ecr2s2: "fb40n2d",
    lj723h: "f1g4hkjv",
    Btxx2vb: "f1lnr2zp",
    sltcwy: ["f1ogfk9z", "f1g7j8ec"],
    dnwvvm: "fiuf46r",
    Blyvkvs: ["f1g7j8ec", "f1ogfk9z"]
  },
  active: {
    Bowz1zl: "f11vrvdw",
    oxogb1: "f17hxjb7",
    Ix2sn8: "f1dha69c",
    q7v32p: "f1lm7500",
    B7cbj04: 0,
    Bewtojm: 0,
    b50fsz: 0,
    B1wzb3v: 0,
    Bqwk70n: 0,
    B37u8z8: 0,
    avt0cx: 0,
    f0sref: 0,
    B9fkznv: 0,
    Be3o27t: 0,
    Bertapg: 0,
    B53xpsf: 0,
    Bsv72rj: 0,
    B39dzdd: 0,
    Btq9bd3: 0,
    Bqfxd14: 0,
    atup0s: "fo7xqb",
    Fffuxt: 0,
    Bttcd12: 0,
    Beitzug: 0,
    Bqougee: 0,
    B86i8pi: "f1kurthe",
    Bhijsxg: "fwq15dy",
    kktds4: "f1pb3wry",
    Bmau3bo: ["ftjv2f4", "f1flhb1f"],
    npektv: ["f1flhb1f", "ftjv2f4"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Jwef8y: "f9ql6rf",
    Bi91k9c: "fvgxktp",
    zqbkvg: "f185j3qj",
    h82x05: ["f1dligi3", "f1vydzie"],
    cqj998: "fjw1di3",
    j3hlsh: ["f1vydzie", "f1dligi3"],
    ecr2s2: "fgj9um3",
    lj723h: "f19wldhg",
    Btxx2vb: "f1ss0kt2",
    sltcwy: ["f1t6oli3", "fjy9ci8"],
    dnwvvm: "fresaxk",
    Blyvkvs: ["fjy9ci8", "f1t6oli3"],
    B7iucu3: "f1cyfu5x"
  },
  selected: {},
  checkIcon: {
    Bnnss6s: "fi64zpg",
    Be2twd7: "fod5ikn",
    Frg6f3: ["f18b9hdq", "fn6qj8t"],
    t21cq0: ["f1xk557c", "f1h9en5y"],
    Bcdw1i0: "fd7fpy0",
    Bo70h7d: "fvc9v3g"
  },
  selectedCheck: {
    Bcdw1i0: "f1022m68"
  },
  multiselectCheck: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1l3cf7o",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bkfmm31: "f1w9h62z",
    Be2twd7: "f1ugzwwg",
    Bqenvij: "fd461yt",
    a9b677: "fjw5fx7",
    Bcdw1i0: "f1022m68"
  },
  selectedMultiselectCheck: {
    De3pzq: "ftywsgz",
    sj55zd: "fqpbvvt",
    g2u3we: "f3xi7mh",
    h3c5rm: ["ftovhe4", "f1wczvin"],
    B9xav0g: "f68vbr6",
    zhjwy3: ["f1wczvin", "ftovhe4"]
  },
  checkDisabled: {
    sj55zd: "f1s2aq7o",
    B7iucu3: "f1cyfu5x"
  },
  multiselectCheckDisabled: {
    g2u3we: "f1r1t4y1",
    h3c5rm: ["fmj8ijw", "figx54m"],
    B9xav0g: "f360ss8",
    zhjwy3: ["figx54m", "fmj8ijw"]
  }
}, {
  d: [".f122n59{align-items:center;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f1k6fduh{cursor:pointer;}", ".f22iagw{display:flex;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fm5eomj{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f10pi13n{position:relative;}", '.f11vrvdw[data-activedescendant-focusvisible]::after{content:"";}', ".f17hxjb7[data-activedescendant-focusvisible]::after{position:absolute;}", ".f1dha69c[data-activedescendant-focusvisible]::after{pointer-events:none;}", ".f1lm7500[data-activedescendant-focusvisible]::after{z-index:1;}", [".fo7xqb[data-activedescendant-focusvisible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1kurthe[data-activedescendant-focusvisible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fwq15dy[data-activedescendant-focusvisible]::after{top:-2px;}", ".f1pb3wry[data-activedescendant-focusvisible]::after{bottom:-2px;}", ".ftjv2f4[data-activedescendant-focusvisible]::after{left:-2px;}", ".f1flhb1f[data-activedescendant-focusvisible]::after{right:-2px;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fi64zpg{flex-shrink:0;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f18b9hdq{margin-left:calc(var(--spacingHorizontalXXS) * -1);}", ".fn6qj8t{margin-right:calc(var(--spacingHorizontalXXS) * -1);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".fd7fpy0{visibility:hidden;}", ".fvc9v3g svg{display:block;}", ".f1022m68{visibility:visible;}", [".f1l3cf7o{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -2
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f4d9j23{justify-content:center;}", ".f1w9h62z{fill:currentColor;}", ".f1ugzwwg{font-size:12px;}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".f3xi7mh{border-top-color:var(--colorCompoundBrandBackground);}", ".ftovhe4{border-right-color:var(--colorCompoundBrandBackground);}", ".f1wczvin{border-left-color:var(--colorCompoundBrandBackground);}", ".f68vbr6{border-bottom-color:var(--colorCompoundBrandBackground);}", ".f1r1t4y1{border-top-color:var(--colorNeutralForegroundDisabled);}", ".fmj8ijw{border-right-color:var(--colorNeutralForegroundDisabled);}", ".figx54m{border-left-color:var(--colorNeutralForegroundDisabled);}", ".f360ss8{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  h: [".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".fo79ri9:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1osiabc:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1e8le25:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".f1yusjty:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f185j3qj:hover .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1dligi3:hover .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".f1vydzie:hover .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fjw1di3:hover .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1lnr2zp:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForeground1Hover);}", ".f1ogfk9z:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForeground1Hover);}", ".f1g7j8ec:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForeground1Hover);}", ".fiuf46r:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForeground1Hover);}", ".fgj9um3:active{background-color:var(--colorTransparentBackground);}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f1ss0kt2:active .fui-Option__checkIcon{border-top-color:var(--colorNeutralForegroundDisabled);}", ".f1t6oli3:active .fui-Option__checkIcon{border-right-color:var(--colorNeutralForegroundDisabled);}", ".fjy9ci8:active .fui-Option__checkIcon{border-left-color:var(--colorNeutralForegroundDisabled);}", ".fresaxk:active .fui-Option__checkIcon{border-bottom-color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useOptionStyles_unstable = (state) => {
  "use no memo";
  const {
    disabled,
    multiselect,
    selected
  } = state;
  const styles = useStyles12();
  state.root.className = mergeClasses(optionClassNames.root, styles.root, styles.active, disabled && styles.disabled, selected && styles.selected, state.root.className);
  if (state.checkIcon) {
    state.checkIcon.className = mergeClasses(optionClassNames.checkIcon, styles.checkIcon, multiselect && styles.multiselectCheck, selected && styles.selectedCheck, selected && multiselect && styles.selectedMultiselectCheck, disabled && styles.checkDisabled, disabled && multiselect && styles.multiselectCheckDisabled, state.checkIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListbox.js
var UNSAFE_noLongerUsed = {
  activeOption: void 0,
  focusVisible: false,
  setActiveOption: () => null
};
var useListbox_unstable = (props, ref) => {
  "use no memo";
  const { multiselect, disableAutoFocus = false } = props;
  const optionCollection = useOptionCollection();
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const hasListboxContext = useHasParentContext(ListboxContext);
  const onActiveDescendantChange = useListboxContext_unstable((ctx) => ctx.onActiveDescendantChange);
  const contextGetOptionById = useListboxContext_unstable((ctx) => ctx.getOptionById);
  const contextGetOptionsMatchingValue = useListboxContext_unstable((ctx) => ctx.getOptionsMatchingValue);
  const getOptionById = hasListboxContext ? contextGetOptionById : optionCollection.getOptionById;
  const getOptionsMatchingValue = hasListboxContext ? contextGetOptionsMatchingValue : optionCollection.getOptionsMatchingValue;
  const listenerRef = React173.useMemo(() => {
    let element = null;
    const listener = (untypedEvent) => {
      const event = untypedEvent;
      onActiveDescendantChange === null || onActiveDescendantChange === void 0 ? void 0 : onActiveDescendantChange(event);
    };
    return (el) => {
      if (!el) {
        element === null || element === void 0 ? void 0 : element.removeEventListener("activedescendantchange", listener);
        return;
      }
      element = el;
      element.addEventListener("activedescendantchange", listener);
    };
  }, [
    onActiveDescendantChange
  ]);
  const [isNavigatingWithKeyboard, setIsNavigatingWithKeyboard] = React173.useState(false);
  useOnKeyboardNavigationChange(setIsNavigatingWithKeyboard);
  const activeDescendantContext = useActiveDescendantContext();
  const hasParentActiveDescendantContext = useHasParentActiveDescendantContext();
  const activeDescendantController = hasParentActiveDescendantContext ? activeDescendantContext.controller : controller;
  const { clearSelection, selectedOptions, selectOption } = useSelection2(props);
  const onKeyDown = (event) => {
    const action = getDropdownActionFromKey(event, {
      open: true
    });
    const activeOptionId = activeDescendantController.active();
    const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
    switch (action) {
      case "First":
      case "Last":
      case "Next":
      case "Previous":
      case "PageDown":
      case "PageUp":
      case "CloseSelect":
      case "Select":
        event.preventDefault();
        break;
    }
    switch (action) {
      case "Next":
        if (activeOption) {
          activeDescendantController.next();
        } else {
          activeDescendantController.first();
        }
        break;
      case "Previous":
        if (activeOption) {
          activeDescendantController.prev();
        } else {
          activeDescendantController.first();
        }
        break;
      case "PageUp":
      case "First":
        activeDescendantController.first();
        break;
      case "PageDown":
      case "Last":
        activeDescendantController.last();
        break;
      case "Select":
      case "CloseSelect":
        activeOption && selectOption(event, activeOption);
        break;
    }
  };
  const contextSelectedOptions = useListboxContext_unstable((ctx) => ctx.selectedOptions);
  const contextSelectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
  const optionContextValues = hasListboxContext ? {
    selectedOptions: contextSelectedOptions,
    selectOption: contextSelectOption,
    ...UNSAFE_noLongerUsed
  } : {
    selectedOptions,
    selectOption,
    ...UNSAFE_noLongerUsed
  };
  React173.useEffect(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.hideFocusVisibleAttributes();
    if (!disableAutoFocus) {
      if (!multiselect && optionContextValues.selectedOptions.length > 0) {
        const selectedOption = getOptionsMatchingValue((v) => v === optionContextValues.selectedOptions[0]).pop();
        if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
          activeDescendantController.focus(selectedOption.id);
        }
      } else {
        activeDescendantController.first();
      }
    }
    return () => {
      activeDescendantController.blur();
    };
  }, []);
  const onFocus = React173.useCallback(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.showFocusVisibleAttributes();
    if (isNavigatingWithKeyboard) {
      activeDescendantController.scrollActiveIntoView();
    }
  }, [
    activeDescendantController,
    hasParentActiveDescendantContext,
    isNavigatingWithKeyboard
  ]);
  const onBlur = React173.useCallback(() => {
    if (hasParentActiveDescendantContext) {
      return;
    }
    activeDescendantController.hideFocusVisibleAttributes();
  }, [
    activeDescendantController,
    hasParentActiveDescendantContext
  ]);
  const state = {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, activeParentRef, activeDescendantListboxRef, listenerRef),
      role: multiselect ? "menu" : "listbox",
      tabIndex: 0,
      ...props
    }), {
      elementType: "div"
    }),
    standalone: !hasListboxContext,
    multiselect,
    clearSelection,
    activeDescendantController,
    onActiveDescendantChange,
    ...optionCollection,
    ...optionContextValues
  };
  state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, onKeyDown));
  state.root.onFocus = useEventCallback(mergeCallbacks(state.root.onFocus, onFocus));
  state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlur));
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/renderListbox.js
var renderListbox_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ActiveDescendantContextProvider, {
    value: contextValues.activeDescendant,
    children: jsx(ListboxContext.Provider, {
      value: contextValues.listbox,
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/useListboxStyles.styles.js
var listboxClassNames = {
  root: "fui-Listbox"
};
var useStyles13 = __styles2({
  root: {
    De3pzq: "fxugw4r",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Bf4jedk: "f3hsy1e",
    Bmxbyg5: "f5zp4f",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f1iepc6i",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1t35pdg",
    Belr9w4: "fiut8dr"
  }
}, {
  d: [".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f3hsy1e{min-width:160px;}", ".f5zp4f{overflow-y:auto;}", [".f1iepc6i{outline:1px solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1t35pdg{padding:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".fiut8dr{row-gap:var(--spacingHorizontalXXS);}"]
});
var useListboxStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles13();
  state.root.className = mergeClasses(listboxClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Listbox/Listbox.js
var Listbox = React174.forwardRef((props, ref) => {
  const state = useListbox_unstable(props, ref);
  const contextValues = useListboxContextValues(state);
  useListboxStyles_unstable(state);
  useCustomStyleHook("useListboxStyles_unstable")(state);
  return renderListbox_unstable(state, contextValues);
});
Listbox.displayName = "Listbox";

// node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
var React176 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Option/useOption.js
var React175 = __toESM(require_react());
function getTextString(text, children) {
  if (text !== void 0) {
    return text;
  }
  let textString = "";
  let hasNonStringChild = false;
  React175.Children.forEach(children, (child) => {
    if (typeof child === "string") {
      textString += child;
    } else {
      hasNonStringChild = true;
    }
  });
  if (hasNonStringChild) {
    console.warn("Provide a `text` prop to Option components when they contain non-string children.");
  }
  return textString;
}
var useOption_unstable = (props, ref) => {
  const { children, disabled, text, value } = props;
  const optionRef = React175.useRef(null);
  const optionText = getTextString(text, children);
  const optionValue = value !== null && value !== void 0 ? value : optionText;
  const id = useId2("fluent-option", props.id);
  const optionData = React175.useMemo(() => ({
    id,
    disabled,
    text: optionText,
    value: optionValue
  }), [
    id,
    disabled,
    optionText,
    optionValue
  ]);
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const multiselect = useListboxContext_unstable((ctx) => ctx.multiselect);
  const registerOption = useListboxContext_unstable((ctx) => ctx.registerOption);
  const selected = useListboxContext_unstable((ctx) => {
    const selectedOptions = ctx.selectedOptions;
    return optionValue !== void 0 && selectedOptions.find((o) => o === optionValue) !== void 0;
  });
  const selectOption = useListboxContext_unstable((ctx) => ctx.selectOption);
  const onOptionClick = useListboxContext_unstable((ctx) => ctx.onOptionClick);
  let CheckIcon = React175.createElement(CheckmarkFilled, null);
  if (multiselect) {
    CheckIcon = selected ? React175.createElement(Checkmark12Filled, null) : "";
  }
  const onClick = (event) => {
    var _props_onClick;
    if (disabled) {
      event.preventDefault();
      return;
    }
    activeDescendantController.focus(id);
    selectOption(event, optionData);
    onOptionClick(event);
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
  };
  React175.useEffect(() => {
    if (id && optionRef.current) {
      return registerOption(optionData, optionRef.current);
    }
  }, [
    id,
    optionData,
    registerOption
  ]);
  const semanticProps = multiselect ? {
    role: "menuitemcheckbox",
    "aria-checked": selected
  } : {
    role: "option",
    "aria-selected": selected
  };
  return {
    components: {
      root: "div",
      checkIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, optionRef),
      "aria-disabled": disabled ? "true" : void 0,
      id,
      ...semanticProps,
      ...props,
      onClick
    }), {
      elementType: "div"
    }),
    checkIcon: slot_exports.optional(props.checkIcon, {
      renderByDefault: true,
      defaultProps: {
        "aria-hidden": "true",
        children: CheckIcon
      },
      elementType: "span"
    }),
    disabled,
    multiselect,
    selected,
    // no longer used
    focusVisible: false,
    active: false
  };
};

// node_modules/@fluentui/react-combobox/lib/components/Option/renderOption.js
var renderOption_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkIcon && jsx(state.checkIcon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Option/Option.js
var Option = React176.forwardRef((props, ref) => {
  const state = useOption_unstable(props, ref);
  useOptionStyles_unstable(state);
  useCustomStyleHook("useOptionStyles_unstable")(state);
  return renderOption_unstable(state);
});
Option.displayName = "Option";

// node_modules/@fluentui/react-combobox/lib/components/Combobox/Combobox.js
var React183 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useCombobox.js
var React182 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/useComboboxBaseState.js
var React177 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var useComboboxBaseState = (props) => {
  "use no memo";
  const { appearance = "outline", disableAutoFocus, children, clearable = false, editable = false, inlinePopup = false, mountNode = void 0, multiselect, onOpenChange, size: size3 = "medium", activeDescendantController, freeform = false, disabled = false, onActiveOptionChange = null } = props;
  const optionCollection = useOptionCollection();
  const { getOptionsMatchingValue } = optionCollection;
  const { getOptionById } = optionCollection;
  const getActiveOption = React177.useCallback(() => {
    const activeOptionId = activeDescendantController.active();
    return activeOptionId ? getOptionById(activeOptionId) : void 0;
  }, [
    activeDescendantController,
    getOptionById
  ]);
  const UNSAFE_activeOption = getActiveOption();
  const UNSAFE_setActiveOption = React177.useCallback((option) => {
    let nextOption = void 0;
    if (typeof option === "function") {
      const activeOption = getActiveOption();
      nextOption = option(activeOption);
    }
    if (nextOption) {
      activeDescendantController.focus(nextOption.id);
    } else {
      activeDescendantController.blur();
    }
  }, [
    activeDescendantController,
    getActiveOption
  ]);
  const [focusVisible, setFocusVisible] = React177.useState(false);
  const [hasFocus, setHasFocus] = React177.useState(false);
  const ignoreNextBlur = React177.useRef(false);
  const isFirstMount = useFirstMount();
  const [controllableValue, setValue] = useControllableState({
    state: props.value,
    initialState: void 0
  });
  const { selectedOptions, selectOption: baseSelectOption, clearSelection } = useSelection2(props);
  const selectOption = React177.useCallback((ev, option) => {
    ReactDOM2.unstable_batchedUpdates(() => {
      setValue(void 0);
      baseSelectOption(ev, option);
    });
  }, [
    setValue,
    baseSelectOption
  ]);
  const value = React177.useMemo(() => {
    if (controllableValue !== void 0) {
      return controllableValue;
    }
    if (isFirstMount && props.defaultValue !== void 0) {
      return props.defaultValue;
    }
    const selectedOptionsText = getOptionsMatchingValue((optionValue) => {
      return selectedOptions.includes(optionValue);
    }).map((option) => option.text);
    if (multiselect) {
      return editable ? "" : selectedOptionsText.join(", ");
    }
    return selectedOptionsText[0];
  }, [
    controllableValue,
    editable,
    getOptionsMatchingValue,
    multiselect,
    selectedOptions
  ]);
  const [open, setOpenState] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const setOpen = React177.useCallback((event, newState) => {
    if (disabled) {
      return;
    }
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
      open: newState
    });
    ReactDOM2.unstable_batchedUpdates(() => {
      if (!newState && !freeform) {
        setValue(void 0);
      }
      setOpenState(newState);
    });
  }, [
    onOpenChange,
    setOpenState,
    setValue,
    freeform,
    disabled
  ]);
  React177.useEffect(() => {
    if (open) {
      if (!multiselect && selectedOptions.length > 0) {
        const selectedOption = getOptionsMatchingValue((v) => v === selectedOptions[0]).pop();
        if (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.id) {
          activeDescendantController.focus(selectedOption.id);
        }
      }
    } else {
      activeDescendantController.blur();
    }
  }, [
    open,
    activeDescendantController
  ]);
  React177.useEffect(() => {
    if (open && !disableAutoFocus && !activeDescendantController.active()) {
      activeDescendantController.first();
    }
  }, [
    open,
    children,
    disableAutoFocus,
    activeDescendantController,
    getOptionById
  ]);
  const onActiveDescendantChange = useEventCallback((event) => {
    const previousOption = event.detail.previousId ? optionCollection.getOptionById(event.detail.previousId) : null;
    const nextOption = optionCollection.getOptionById(event.detail.id);
    onActiveOptionChange === null || onActiveOptionChange === void 0 ? void 0 : onActiveOptionChange(event, {
      event,
      type: "change",
      previousOption,
      nextOption
    });
  });
  return {
    ...optionCollection,
    freeform,
    disabled,
    selectOption,
    clearSelection,
    selectedOptions,
    activeOption: UNSAFE_activeOption,
    appearance,
    clearable,
    focusVisible,
    ignoreNextBlur,
    inlinePopup,
    mountNode,
    open,
    hasFocus,
    setActiveOption: UNSAFE_setActiveOption,
    setFocusVisible,
    setHasFocus,
    setOpen,
    setValue,
    size: size3,
    value,
    multiselect,
    onOptionClick: useEventCallback((e) => {
      if (!multiselect) {
        setOpen(e, false);
      }
    }),
    onActiveDescendantChange
  };
};

// node_modules/@fluentui/react-combobox/lib/utils/useComboboxPositioning.js
var React178 = __toESM(require_react());
function useComboboxPositioning(props) {
  const { positioning } = props;
  const fallbackPositions2 = [
    "above",
    "after",
    "after-top",
    "before",
    "before-top"
  ];
  const popperOptions = {
    position: "below",
    align: "start",
    offset: {
      crossAxis: 0,
      mainAxis: 2
    },
    fallbackPositions: fallbackPositions2,
    matchTargetSize: "width",
    autoSize: true,
    ...resolvePositioningShorthand(positioning)
  };
  const { targetRef, containerRef } = usePositioning(popperOptions);
  return [
    containerRef,
    targetRef
  ];
}

// node_modules/@fluentui/react-combobox/lib/utils/useListboxSlot.js
var React179 = __toESM(require_react());
function useListboxSlot(listboxSlotFromProp, ref, options) {
  const { state: { multiselect }, triggerRef, defaultProps } = options;
  const listboxId = useId2("fluent-listbox", isResolvedShorthand(listboxSlotFromProp) ? listboxSlotFromProp.id : void 0);
  const listboxSlot = slot_exports.optional(listboxSlotFromProp, {
    renderByDefault: true,
    elementType: Listbox,
    defaultProps: {
      id: listboxId,
      multiselect,
      tabIndex: void 0,
      ...defaultProps
    }
  });
  const fieldControlProps = useFieldControlProps_unstable({
    id: listboxId
  }, {
    supportsLabelFor: true
  });
  if (listboxSlot && !listboxSlot["aria-label"] && !listboxSlot["aria-labelledby"] && fieldControlProps["aria-labelledby"]) {
    listboxSlot["aria-labelledby"] = fieldControlProps["aria-labelledby"];
  }
  const onMouseDown = useEventCallback(mergeCallbacks((event) => {
    event.preventDefault();
  }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onMouseDown));
  const onClick = useEventCallback(mergeCallbacks((event) => {
    var _triggerRef_current;
    event.preventDefault();
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }, listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.onClick));
  const listboxRef = useMergedRefs(listboxSlot === null || listboxSlot === void 0 ? void 0 : listboxSlot.ref, ref);
  if (listboxSlot) {
    listboxSlot.ref = listboxRef;
    listboxSlot.onMouseDown = onMouseDown;
    listboxSlot.onClick = onClick;
  }
  return listboxSlot;
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useInputTriggerSlot.js
var React181 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/utils/useTriggerSlot.js
var React180 = __toESM(require_react());
function useTriggerSlot(triggerSlotFromProp, ref, options) {
  const { state: { open, setOpen, setHasFocus }, defaultProps, elementType, activeDescendantController } = options;
  const trigger = slot_exports.always(triggerSlotFromProp, {
    defaultProps: {
      type: "text",
      "aria-expanded": open,
      role: "combobox",
      ...typeof defaultProps === "object" && defaultProps
    },
    elementType
  });
  const triggerRef = React180.useRef(null);
  trigger.ref = useMergedRefs(triggerRef, trigger.ref, ref);
  trigger.onBlur = mergeCallbacks((event) => {
    setOpen(event, false);
    setHasFocus(false);
  }, trigger.onBlur);
  trigger.onFocus = mergeCallbacks((event) => {
    if (event.target === event.currentTarget) {
      setHasFocus(true);
    }
  }, trigger.onFocus);
  trigger.onClick = mergeCallbacks((event) => {
    setOpen(event, !open);
  }, trigger.onClick);
  trigger.onKeyDown = mergeCallbacks(useTriggerKeydown({
    activeDescendantController,
    ...options.state
  }), trigger.onKeyDown);
  return trigger;
}
function useTriggerKeydown(options) {
  const { activeDescendantController, getOptionById, setOpen, selectOption, multiselect, open } = options;
  const getActiveOption = React180.useCallback(() => {
    const activeOptionId = activeDescendantController.active();
    return activeOptionId ? getOptionById(activeOptionId) : void 0;
  }, [
    activeDescendantController,
    getOptionById
  ]);
  const first = () => {
    activeDescendantController.first();
  };
  const last = () => {
    activeDescendantController.last();
  };
  const next = (activeOption) => {
    if (activeOption) {
      activeDescendantController.next();
    } else {
      activeDescendantController.first();
    }
  };
  const previous = (activeOption) => {
    if (activeOption) {
      activeDescendantController.prev();
    } else {
      activeDescendantController.first();
    }
  };
  const pageUp = () => {
    for (let i = 0; i < 10; i++) {
      activeDescendantController.prev();
    }
  };
  const pageDown = () => {
    for (let i = 0; i < 10; i++) {
      activeDescendantController.next();
    }
  };
  const setKeyboardNavigation = useSetKeyboardNavigation();
  return useEventCallback((e) => {
    const action = getDropdownActionFromKey(e, {
      open,
      multiselect
    });
    const activeOption = getActiveOption();
    switch (action) {
      case "First":
      case "Last":
      case "Next":
      case "Previous":
      case "PageDown":
      case "PageUp":
      case "Open":
      case "Close":
      case "CloseSelect":
      case "Select":
        e.preventDefault();
        break;
    }
    setKeyboardNavigation(true);
    switch (action) {
      case "First":
        first();
        break;
      case "Last":
        last();
        break;
      case "Next":
        next(activeOption);
        break;
      case "Previous":
        previous(activeOption);
        break;
      case "PageDown":
        pageDown();
        break;
      case "PageUp":
        pageUp();
        break;
      case "Open":
        setOpen(e, true);
        break;
      case "Close":
        e.stopPropagation();
        setOpen(e, false);
        break;
      case "CloseSelect":
        !multiselect && !(activeOption === null || activeOption === void 0 ? void 0 : activeOption.disabled) && setOpen(e, false);
      case "Select":
        activeOption && selectOption(e, activeOption);
        break;
      case "Tab":
        !multiselect && activeOption && selectOption(e, activeOption);
        break;
    }
  });
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useInputTriggerSlot.js
function useInputTriggerSlot(triggerFromProps, ref, options) {
  "use no memo";
  const { state: { open, value, selectOption, setValue, multiselect, selectedOptions, clearSelection, getOptionById, setOpen }, freeform, defaultProps, activeDescendantController } = options;
  const onBlur = (event) => {
    if (!open && !freeform) {
      const activeOptionId = activeDescendantController.active();
      const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
      if (value && activeOption && value.trim().toLowerCase() === (activeOption === null || activeOption === void 0 ? void 0 : activeOption.text.toLowerCase())) {
        selectOption(event, activeOption);
      }
      setValue(void 0);
    }
  };
  const getOptionFromInput = (inputValue) => {
    const searchString = inputValue === null || inputValue === void 0 ? void 0 : inputValue.trim().toLowerCase();
    if (!searchString || searchString.length === 0) {
      activeDescendantController.blur();
      return;
    }
    const matcher = (optionText) => optionText.toLowerCase().indexOf(searchString) === 0;
    const match = activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    });
    if (!match) {
      activeDescendantController.blur();
      return void 0;
    }
    return getOptionById(match);
  };
  const onChange = (event) => {
    const inputValue = event.target.value;
    setValue(inputValue);
    const matchingOption = getOptionFromInput(inputValue);
    if (!multiselect && selectedOptions.length === 1 && (inputValue.length < 1 || !matchingOption)) {
      clearSelection(event);
    }
  };
  const trigger = useTriggerSlot(triggerFromProps, ref, {
    state: options.state,
    defaultProps,
    elementType: "input",
    activeDescendantController
  });
  trigger.onChange = mergeCallbacks(trigger.onChange, onChange);
  trigger.onBlur = mergeCallbacks(trigger.onBlur, onBlur);
  const [hideActiveDescendant, setHideActiveDescendant] = React181.useState(false);
  const isTyping = React181.useRef(false);
  const defaultOnKeyDown = trigger.onKeyDown;
  const onKeyDown = useEventCallback((event) => {
    if (!open && getDropdownActionFromKey(event) === "Type") {
      setOpen(event, true);
    }
    if (event.key === ArrowLeft || event.key === ArrowRight) {
      setHideActiveDescendant(true);
    } else {
      setHideActiveDescendant(false);
    }
    const action = getDropdownActionFromKey(event, {
      open,
      multiselect
    });
    if (action === "Type") {
      isTyping.current = true;
    } else if (action === "Open" && event.key !== " " || action === "Next" || action === "Previous" || action === "First" || action === "Last" || action === "PageUp" || action === "PageDown") {
      isTyping.current = false;
    }
    if ((isTyping.current || !open) && event.key === " ") {
      var _triggerFromProps_onKeyDown;
      triggerFromProps === null || triggerFromProps === void 0 ? void 0 : (_triggerFromProps_onKeyDown = triggerFromProps.onKeyDown) === null || _triggerFromProps_onKeyDown === void 0 ? void 0 : _triggerFromProps_onKeyDown.call(triggerFromProps, event);
      return;
    }
    defaultOnKeyDown === null || defaultOnKeyDown === void 0 ? void 0 : defaultOnKeyDown(event);
  });
  trigger.onKeyDown = onKeyDown;
  if (hideActiveDescendant) {
    trigger["aria-activedescendant"] = void 0;
  }
  return trigger;
}

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useCombobox.js
var useCombobox_unstable = (props, ref) => {
  "use no memo";
  var _state_clearIcon, _state_clearIcon1;
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const baseState = useComboboxBaseState({
    ...props,
    editable: true,
    activeDescendantController
  });
  const { clearable, clearSelection, disabled, multiselect, open, selectedOptions, setOpen, value, hasFocus } = baseState;
  const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
  const { disableAutoFocus = false, freeform, inlinePopup } = props;
  const comboId = useId2("combobox-");
  const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "children",
      "size"
    ]
  });
  const triggerRef = React182.useRef(null);
  const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
    state: baseState,
    triggerRef,
    defaultProps: {
      children: props.children,
      disableAutoFocus
    }
  });
  var _props_input;
  const triggerSlot = useInputTriggerSlot((_props_input = props.input) !== null && _props_input !== void 0 ? _props_input : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
    state: baseState,
    freeform,
    defaultProps: {
      type: "text",
      value: value !== null && value !== void 0 ? value : "",
      "aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...triggerNativeProps
    },
    activeDescendantController
  });
  const rootSlot = slot_exports.always(props.root, {
    defaultProps: {
      "aria-owns": !inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...rootNativeProps
    },
    elementType: "div"
  });
  rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
  const showClearIcon = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
  const state = {
    components: {
      root: "div",
      input: "input",
      expandIcon: "span",
      listbox: Listbox,
      clearIcon: "span"
    },
    root: rootSlot,
    input: triggerSlot,
    listbox: open || hasFocus ? listbox : void 0,
    clearIcon: slot_exports.optional(props.clearIcon, {
      defaultProps: {
        "aria-hidden": "true",
        children: React182.createElement(DismissRegular, null)
      },
      elementType: "span",
      renderByDefault: true
    }),
    expandIcon: slot_exports.optional(props.expandIcon, {
      renderByDefault: true,
      defaultProps: {
        "aria-disabled": disabled ? "true" : void 0,
        "aria-expanded": open,
        children: React182.createElement(ChevronDownRegular, null),
        role: "button"
      },
      elementType: "span"
    }),
    showClearIcon,
    activeDescendantController,
    ...baseState
  };
  const { targetDocument } = useFluent();
  useOnClickOutside({
    element: targetDocument,
    callback: (event) => setOpen(event, false),
    refs: [
      triggerRef,
      comboboxPopupRef,
      comboboxTargetRef
    ],
    disabled: !open
  });
  const { onMouseDown: onIconMouseDown } = state.expandIcon || {};
  const onExpandIconMouseDown = useEventCallback(mergeCallbacks(onIconMouseDown, (event) => {
    var _triggerRef_current;
    event.preventDefault();
    state.setOpen(event, !state.open);
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }));
  if (state.expandIcon) {
    state.expandIcon.onMouseDown = onExpandIconMouseDown;
    const hasExpandLabel = state.expandIcon["aria-label"] || state.expandIcon["aria-labelledby"];
    const defaultOpenString = "Open";
    if (!hasExpandLabel) {
      if (props["aria-labelledby"]) {
        var _state_expandIcon_id;
        const chevronId = (_state_expandIcon_id = state.expandIcon.id) !== null && _state_expandIcon_id !== void 0 ? _state_expandIcon_id : `${comboId}-chevron`;
        const chevronLabelledBy = `${chevronId} ${state.input["aria-labelledby"]}`;
        state.expandIcon["aria-label"] = defaultOpenString;
        state.expandIcon.id = chevronId;
        state.expandIcon["aria-labelledby"] = chevronLabelledBy;
      } else if (props["aria-label"]) {
        state.expandIcon["aria-label"] = `${defaultOpenString} ${props["aria-label"]}`;
      } else {
        state.expandIcon["aria-label"] = defaultOpenString;
      }
    }
  }
  const onClearIconMouseDown = useEventCallback(mergeCallbacks((_state_clearIcon = state.clearIcon) === null || _state_clearIcon === void 0 ? void 0 : _state_clearIcon.onMouseDown, (ev) => {
    ev.preventDefault();
  }));
  const onClearIconClick = useEventCallback(mergeCallbacks((_state_clearIcon1 = state.clearIcon) === null || _state_clearIcon1 === void 0 ? void 0 : _state_clearIcon1.onClick, (ev) => {
    clearSelection(ev);
  }));
  if (state.clearIcon) {
    state.clearIcon.onMouseDown = onClearIconMouseDown;
    state.clearIcon.onClick = onClearIconClick;
  }
  if (multiselect) {
    state.clearIcon = void 0;
  }
  if (true) {
    React182.useEffect(() => {
      if (clearable && multiselect) {
        console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
      }
    }, [
      clearable,
      multiselect
    ]);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/renderCombobox.js
var renderCombobox_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(ActiveDescendantContextProvider, {
      value: contextValues.activeDescendant,
      children: jsx(ListboxProvider, {
        value: contextValues.listbox,
        children: jsxs(ComboboxContext.Provider, {
          value: contextValues.combobox,
          children: [
            jsx(state.input, {}),
            state.clearIcon && jsx(state.clearIcon, {}),
            state.expandIcon && jsx(state.expandIcon, {}),
            state.listbox && (state.inlinePopup ? jsx(state.listbox, {}) : jsx(Portal, {
              mountNode: state.mountNode,
              children: jsx(state.listbox, {})
            }))
          ]
        })
      })
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/useComboboxStyles.styles.js
var comboboxClassNames = {
  root: "fui-Combobox",
  input: "fui-Combobox__input",
  expandIcon: "fui-Combobox__expandIcon",
  clearIcon: "fui-Combobox__clearIcon",
  listbox: "fui-Combobox__listbox"
};
var useStyles14 = __styles2({
  root: {
    Bt984gj: "f122n59",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    B7ck84d: "f1ewtqcl",
    i8kkvl: "f14mj54c",
    mc9l5x: "fwk3njj",
    Budl1dq: "fz17x9o",
    Brf1p80: "f1869bpl",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "f145g4dw",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    wi16st: "fsrmcvb",
    ywj3b2: "f1t3k7v9",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    Bnupc0a: "fx04xgm",
    bing71: "f1c7in40",
    Bercvud: "f1ibeo51"
  },
  listbox: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  inlineListbox: {
    Bj3rh1h: "f19g0ac"
  },
  small: {
    Bqenvij: "frvgh55",
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    Bqenvij: "f1d2rq10",
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  large: {
    i8kkvl: "f1rjii52",
    Bqenvij: "fbhnoac",
    z189sj: ["fw5db7e", "f1uw59to"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  }
}, {
  d: [".f122n59{align-items:center;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".fwk3njj{display:inline-grid;}", ".fz17x9o{grid-template-columns:1fr auto;}", ".f1869bpl{justify-content:space-between;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f19g0ac{z-index:1;}", ".frvgh55{height:24px;}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".f1d2rq10{height:32px;}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fbhnoac{height:40px;}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useInputStyles2 = __styles2({
  input: {
    qb2dma: "f1ub7u0d",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    sj55zd: "f19n0e5",
    Bahqtrf: "fk6fouc",
    Brovlpu: "ftqa4ok",
    yvdlaj: "fwyc1cq",
    B3o7kgh: "f13ta7ih"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fxe2rs", "f1gflqzi"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fzy81xo", "f58b53b"]
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1kdav7a", "footqm6"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1ub7u0d{align-self:stretch;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fxe2rs{padding:0 0 0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f1gflqzi{padding:0 calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 0 0;}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fzy81xo{padding:0 0 0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58b53b{padding:0 calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 0 0;}", {
    p: -1
  }], ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1kdav7a{padding:0 0 0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".footqm6{padding:0 calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 0 0;}", {
    p: -1
  }], ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"],
  f: [".ftqa4ok:focus{outline-style:none;}"]
});
var useIconStyles4 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    Bceei9c: "f1k6fduh",
    mc9l5x: "ftgm304",
    Be2twd7: "f1pp30po",
    Bo70h7d: "fvc9v3g"
  },
  hidden: {
    mc9l5x: "fjseox"
  },
  visuallyHidden: {
    Bh84pgu: "f1ekcaio",
    Bqenvij: "f1mpe4l3",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1jlpb2r",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    a9b677: "frkrog8",
    qhf8xq: "f1euv43f"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  large: {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".f1k6fduh{cursor:pointer;}", ".ftgm304{display:block;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fvc9v3g svg{display:block;}", ".fjseox{display:none;}", ".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}", ".f1mpe4l3{height:1px;}", [".f1jlpb2r{margin:-1px;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1euv43f{position:absolute;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}"]
});
var useComboboxStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    open,
    size: size3,
    showClearIcon
  } = state;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const disabled = state.input.disabled;
  const styles = useStyles14();
  const iconStyles = useIconStyles4();
  const inputStyles = useInputStyles2();
  state.root.className = mergeClasses(comboboxClassNames.root, styles.root, styles[appearance], styles[size3], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
  state.input.className = mergeClasses(comboboxClassNames.input, inputStyles.input, inputStyles[size3], disabled && inputStyles.disabled, state.input.className);
  if (state.listbox) {
    state.listbox.className = mergeClasses(comboboxClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(comboboxClassNames.expandIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, showClearIcon && iconStyles.visuallyHidden, state.expandIcon.className);
  }
  if (state.clearIcon) {
    state.clearIcon.className = mergeClasses(comboboxClassNames.clearIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, !showClearIcon && iconStyles.hidden, state.clearIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Combobox/Combobox.js
var Combobox = React183.forwardRef((props, ref) => {
  const state = useCombobox_unstable(props, ref);
  const contextValues = useComboboxContextValues(state);
  useComboboxStyles_unstable(state);
  useCustomStyleHook("useComboboxStyles_unstable")(state);
  return renderCombobox_unstable(state, contextValues);
});
Combobox.displayName = "Combobox";

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
var React186 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
var React185 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useButtonTriggerSlot.js
var React184 = __toESM(require_react());
function useButtonTriggerSlot(triggerFromProps, ref, options) {
  "use no memo";
  const { state: { open, setOpen, getOptionById }, defaultProps, activeDescendantController } = options;
  const searchString = React184.useRef("");
  const [setKeyTimeout, clearKeyTimeout] = useTimeout();
  const moveToNextMatchingOption = (matcher, opt = {
    startFromNext: false
  }) => {
    const { startFromNext } = opt;
    const activeOptionId = activeDescendantController.active();
    const nextInOrder = activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    }, {
      startFrom: startFromNext ? activeDescendantController.next({
        passive: true
      }) : activeOptionId
    });
    if (nextInOrder) {
      return nextInOrder;
    }
    return activeDescendantController.find((id) => {
      const option = getOptionById(id);
      return !!option && matcher(option.text);
    });
  };
  const moveToNextMatchingOptionWithSameCharacterHandling = () => {
    if (moveToNextMatchingOption((optionText) => {
      return optionText.toLocaleLowerCase().indexOf(searchString.current) === 0;
    }, {
      // Slowly pressing the same key will cycle through options
      startFromNext: searchString.current.length === 1
    })) {
      return;
    }
    if (allCharactersSame(searchString.current) && moveToNextMatchingOption((optionText) => {
      return optionText.toLocaleLowerCase().indexOf(searchString.current[0]) === 0;
    }, {
      // if the search is all the same letter, cycle through options starting with that letter
      startFromNext: true
    })) {
      return;
    }
    activeDescendantController.blur();
  };
  const onTriggerKeyDown = (ev) => {
    clearKeyTimeout();
    if (getDropdownActionFromKey(ev) === "Type") {
      searchString.current += ev.key.toLowerCase();
      setKeyTimeout(() => {
        searchString.current = "";
      }, 500);
      if (open) {
        moveToNextMatchingOptionWithSameCharacterHandling();
      }
      !open && setOpen(ev, true);
    }
  };
  const trigger = useTriggerSlot(triggerFromProps, ref, {
    state: options.state,
    defaultProps,
    elementType: "button",
    activeDescendantController
  });
  trigger.onKeyDown = mergeCallbacks(onTriggerKeyDown, trigger.onKeyDown);
  return trigger;
}
function allCharactersSame(str) {
  for (let i = 1; i < str.length; i++) {
    if (str[i] !== str[i - 1]) {
      return false;
    }
  }
  return true;
}

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdown.js
var useDropdown_unstable = (props, ref) => {
  "use no memo";
  var _state_clearButton;
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsSize: true
  });
  const { listboxRef: activeDescendantListboxRef, activeParentRef, controller: activeDescendantController } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const baseState = useComboboxBaseState({
    ...props,
    activeDescendantController,
    freeform: false
  });
  const { clearable, clearSelection, disabled, hasFocus, multiselect, open, selectedOptions, setOpen } = baseState;
  const { primary: triggerNativeProps, root: rootNativeProps } = getPartitionedNativeProps({
    props,
    primarySlotTagName: "button",
    excludedPropNames: [
      "children"
    ]
  });
  const [comboboxPopupRef, comboboxTargetRef] = useComboboxPositioning(props);
  const triggerRef = React185.useRef(null);
  const listbox = useListboxSlot(props.listbox, useMergedRefs(comboboxPopupRef, activeDescendantListboxRef), {
    state: baseState,
    triggerRef,
    defaultProps: {
      children: props.children
    }
  });
  const { targetDocument } = useFluent();
  useOnClickOutside({
    element: targetDocument,
    callback: (event) => setOpen(event, false),
    refs: [
      triggerRef,
      comboboxPopupRef,
      comboboxTargetRef
    ],
    disabled: !open
  });
  var _props_button;
  const trigger = useButtonTriggerSlot((_props_button = props.button) !== null && _props_button !== void 0 ? _props_button : {}, useMergedRefs(triggerRef, activeParentRef, ref), {
    state: baseState,
    defaultProps: {
      type: "button",
      // tabster navigation breaks if the button is disabled and tabIndex is 0
      tabIndex: triggerNativeProps.disabled ? void 0 : 0,
      children: baseState.value || props.placeholder,
      "aria-controls": open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      ...triggerNativeProps
    },
    activeDescendantController
  });
  const rootSlot = slot_exports.always(props.root, {
    defaultProps: {
      "aria-owns": !props.inlinePopup && open ? listbox === null || listbox === void 0 ? void 0 : listbox.id : void 0,
      children: props.children,
      ...rootNativeProps
    },
    elementType: "div"
  });
  rootSlot.ref = useMergedRefs(rootSlot.ref, comboboxTargetRef);
  const showClearButton = selectedOptions.length > 0 && !disabled && clearable && !multiselect;
  const state = {
    components: {
      root: "div",
      button: "button",
      clearButton: "button",
      expandIcon: "span",
      listbox: Listbox
    },
    root: rootSlot,
    button: trigger,
    listbox: open || hasFocus ? listbox : void 0,
    clearButton: slot_exports.optional(props.clearButton, {
      defaultProps: {
        "aria-label": "Clear selection",
        children: React185.createElement(DismissRegular, null),
        // Safari doesn't allow to focus an element with this
        // when the element is not visible (display: none) we need to remove it to avoid tabster issues
        tabIndex: showClearButton ? 0 : void 0,
        type: "button"
      },
      elementType: "button",
      renderByDefault: true
    }),
    expandIcon: slot_exports.optional(props.expandIcon, {
      renderByDefault: true,
      defaultProps: {
        children: React185.createElement(ChevronDownRegular, null)
      },
      elementType: "span"
    }),
    placeholderVisible: !baseState.value && !!props.placeholder,
    showClearButton,
    activeDescendantController,
    ...baseState
  };
  const onClearButtonClick = useEventCallback(mergeCallbacks((_state_clearButton = state.clearButton) === null || _state_clearButton === void 0 ? void 0 : _state_clearButton.onClick, (ev) => {
    var _triggerRef_current;
    clearSelection(ev);
    (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
  }));
  if (state.clearButton) {
    state.clearButton.onClick = onClearButtonClick;
  }
  if (multiselect) {
    state.clearButton = void 0;
  }
  if (true) {
    React185.useEffect(() => {
      if (clearable && multiselect) {
        console.error(`[@fluentui/react-combobox] "clearable" prop is not supported in multiselect mode.`);
      }
    }, [
      clearable,
      multiselect
    ]);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/renderDropdown.js
var renderDropdown_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(ActiveDescendantContextProvider, {
      value: contextValues.activeDescendant,
      children: jsx(ListboxContext.Provider, {
        value: contextValues.listbox,
        children: jsxs(ComboboxContext.Provider, {
          value: contextValues.combobox,
          children: [
            jsxs(state.button, {
              children: [
                state.button.children,
                state.expandIcon && jsx(state.expandIcon, {})
              ]
            }),
            state.clearButton && jsx(state.clearButton, {}),
            state.listbox && (state.inlinePopup ? jsx(state.listbox, {}) : jsx(Portal, {
              mountNode: state.mountNode,
              children: jsx(state.listbox, {})
            }))
          ]
        })
      })
    })
  });
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/useDropdownStyles.styles.js
var dropdownClassNames = {
  root: "fui-Dropdown",
  button: "fui-Dropdown__button",
  clearButton: "fui-Dropdown__clearButton",
  expandIcon: "fui-Dropdown__expandIcon",
  listbox: "fui-Dropdown__listbox"
};
var useStyles15 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "ftuwxu6",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    ha4doy: "fmrv4ls",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "ffyw7fx",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    wi16st: "fsrmcvb",
    ywj3b2: "f1t3k7v9",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    Bnupc0a: "fx04xgm",
    bing71: "f1c7in40",
    Bercvud: "f1ibeo51",
    Br277j9: "f18qfb8s",
    Btis473: "f1m082s7"
  },
  listbox: {
    B7ck84d: "f1ewtqcl",
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  inlineListbox: {
    Bj3rh1h: "f19g0ac"
  },
  button: {
    Bt984gj: "f122n59",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    i8kkvl: "f14mj54c",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f13qh94s",
    Bahqtrf: "fk6fouc",
    Budl1dq: "f12nh0o2",
    Brf1p80: "f1869bpl",
    fsow6f: ["f1o700av", "fes3tcz"],
    a9b677: "fly5x3f",
    Brovlpu: "ftqa4ok"
  },
  placeholder: {
    sj55zd: "fxc4j92"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fye6m5k", "f3cq2dl"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f14ev680", "f58uxzw"]
  },
  large: {
    i8kkvl: "f1rjii52",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f139mn7i", "f1v3q0m"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  },
  disabledText: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  },
  hidden: {
    mc9l5x: "fjseox"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".ftuwxu6{display:inline-flex;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fmrv4ls{vertical-align:middle;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f19g0ac{z-index:1;}", ".f122n59{align-items:center;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1k6fduh{cursor:pointer;}", ".f13qh94s{display:grid;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f12nh0o2{grid-template-columns:[content] 1fr [icon] auto [end];}", ".f1869bpl{justify-content:space-between;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fly5x3f{width:100%;}", ".fxc4j92{color:var(--colorNeutralForeground4);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  t: ["@supports selector(:has(*)){.f18qfb8s:has(.fui-Dropdown__clearButton:focus)::after{border-bottom-color:initial;}}", "@supports selector(:has(*)){.f1m082s7:has(.fui-Dropdown__clearButton:focus)::after{transform:scaleX(0);}}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useIconStyles5 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    mc9l5x: "ftgm304",
    Be2twd7: "f1pp30po",
    Br312pm: "f12w6cgp",
    Bw0ie65: "f8bv1bt",
    Bo70h7d: "fvc9v3g"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"]
  },
  large: {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  disabled: {
    sj55zd: "f1s2aq7o"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".ftgm304{display:block;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f12w6cgp{grid-column-start:icon;}", ".f8bv1bt{grid-column-end:end;}", ".fvc9v3g svg{display:block;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"]
});
var useBaseClearButtonStyle = __resetStyles("rticfuj", "r1vp6jef", {
  r: [".rticfuj{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-right:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".rticfuj:focus{outline-style:none;}", ".rticfuj:focus-visible{outline-style:none;}", ".rticfuj[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rticfuj[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r1vp6jef{align-self:center;background-color:var(--colorTransparentBackground);border:none;cursor:pointer;height:fit-content;margin:0;margin-left:var(--spacingHorizontalMNudge);padding:0;position:relative;}", ".r1vp6jef:focus{outline-style:none;}", ".r1vp6jef:focus-visible{outline-style:none;}", ".r1vp6jef[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r1vp6jef[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.rticfuj[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.r1vp6jef[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDropdownStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    open,
    placeholderVisible,
    showClearButton,
    size: size3
  } = state;
  const invalid = `${state.button["aria-invalid"]}` === "true";
  const disabled = state.button.disabled;
  const styles = useStyles15();
  const iconStyles = useIconStyles5();
  const clearButtonStyle = useBaseClearButtonStyle();
  state.root.className = mergeClasses(dropdownClassNames.root, styles.root, styles[appearance], !disabled && appearance === "outline" && styles.outlineInteractive, invalid && appearance !== "underline" && styles.invalid, invalid && appearance === "underline" && styles.invalidUnderline, disabled && styles.disabled, state.root.className);
  state.button.className = mergeClasses(dropdownClassNames.button, styles.button, styles[size3], placeholderVisible && styles.placeholder, disabled && styles.disabledText, state.button.className);
  if (state.listbox) {
    state.listbox.className = mergeClasses(dropdownClassNames.listbox, styles.listbox, state.inlinePopup && styles.inlineListbox, !open && styles.listboxCollapsed, state.listbox.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(dropdownClassNames.expandIcon, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, showClearButton && styles.hidden, state.expandIcon.className);
  }
  if (state.clearButton) {
    state.clearButton.className = mergeClasses(dropdownClassNames.clearButton, clearButtonStyle, iconStyles.icon, iconStyles[size3], disabled && iconStyles.disabled, !showClearButton && styles.hidden, state.clearButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/Dropdown/Dropdown.js
var Dropdown = React186.forwardRef((props, ref) => {
  const state = useDropdown_unstable(props, ref);
  const contextValues = useComboboxContextValues(state);
  useDropdownStyles_unstable(state);
  useCustomStyleHook("useDropdownStyles_unstable")(state);
  return renderDropdown_unstable(state, contextValues);
});
Dropdown.displayName = "Dropdown";

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/OptionGroup.js
var React188 = __toESM(require_react());

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroup.js
var React187 = __toESM(require_react());
var useOptionGroup_unstable = (props, ref) => {
  const labelId = useId2("group-label");
  const { label } = props;
  return {
    components: {
      root: "div",
      label: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: "group",
      "aria-labelledby": label ? labelId : void 0,
      ...props
    }), {
      elementType: "div"
    }),
    label: slot_exports.optional(label, {
      defaultProps: {
        id: labelId,
        role: "presentation"
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/renderOptionGroup.js
var renderOptionGroup_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.label && jsx(state.label, {
        children: state.label.children
      }),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/useOptionGroupStyles.styles.js
var optionGroupClassNames = {
  root: "fui-OptionGroup",
  label: "fui-OptionGroup__label"
};
var useStyles16 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "fiut8dr",
    B8lkq7l: "f1xxzjds",
    eii1in: 0,
    H93o2g: 0,
    Gwp8xu: 0,
    Bd39igo: "f16cmn8k",
    om0q45: "f5642y",
    Hl9o3s: "ffdf81h",
    sl1c2c: 0,
    z4hxbw: 0,
    B0i58d9: 0,
    Bi9x0x4: 0,
    Bgurq3m: "f1bsn9kn"
  },
  label: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    sj55zd: "f11d4kpn",
    mc9l5x: "ftgm304",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mpq0zz"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".fiut8dr{row-gap:var(--spacingHorizontalXXS);}", '.f1xxzjds:not(:last-child)::after{content:"";}', [".f16cmn8k:not(:last-child)::after{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], ".f5642y:not(:last-child)::after{display:block;}", ".ffdf81h:not(:last-child)::after{padding-bottom:var(--spacingHorizontalXS);}", [".f1bsn9kn:not(:last-child)::after{margin:0 calc(var(--spacingHorizontalXS) * -1) var(--spacingVerticalXS);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".ftgm304{display:block;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".f1mpq0zz{padding:var(--spacingHorizontalS) var(--spacingHorizontalSNudge);}", {
    p: -1
  }]]
});
var useOptionGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles16();
  state.root.className = mergeClasses(optionGroupClassNames.root, styles.root, state.root.className);
  if (state.label) {
    state.label.className = mergeClasses(optionGroupClassNames.label, styles.label, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-combobox/lib/components/OptionGroup/OptionGroup.js
var OptionGroup = React188.forwardRef((props, ref) => {
  const state = useOptionGroup_unstable(props, ref);
  useOptionGroupStyles_unstable(state);
  useCustomStyleHook("useOptionGroupStyles_unstable")(state);
  return renderOptionGroup_unstable(state);
});
OptionGroup.displayName = "OptionGroup";

// node_modules/@fluentui/react-combobox/lib/hooks/useComboboxFilter.js
var React189 = __toESM(require_react());
function defaultFilter(optionText, query) {
  if (query === "") {
    return true;
  }
  return optionText.toLowerCase().includes(query.toLowerCase());
}
function defaultToString(option) {
  return typeof option === "string" ? option : option.value;
}
function useComboboxFilter(query, options, config) {
  const { filter = defaultFilter, noOptionsMessage = "We couldn't find any matches.", optionToReactKey = defaultToString, optionToText = defaultToString, renderOption = (option) => {
    if (typeof option === "string") {
      return React189.createElement(Option, {
        key: option
      }, option);
    }
    return React189.createElement(Option, {
      ...option,
      key: optionToReactKey(option),
      text: optionToText(option),
      value: option.value
    }, option.children);
  } } = config;
  const filteredOptions = React189.useMemo(() => {
    const searchValue = query.trim();
    return options.filter((option) => filter(optionToText(option), searchValue));
  }, [
    options,
    optionToText,
    filter,
    query
  ]);
  if (filteredOptions.length === 0) {
    return [
      React189.createElement(Option, {
        "aria-disabled": "true",
        key: "no-results",
        text: ""
      }, noOptionsMessage)
    ];
  }
  return filteredOptions.map((option) => renderOption(option));
}

// node_modules/@fluentui/react-divider/lib/components/Divider/Divider.js
var React191 = __toESM(require_react());

// node_modules/@fluentui/react-divider/lib/components/Divider/renderDivider.js
var renderDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children !== void 0 && jsx(state.wrapper, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-divider/lib/components/Divider/useDivider.js
var React190 = __toESM(require_react());
var useDivider_unstable = (props, ref) => {
  const { alignContent = "center", appearance = "default", inset = false, ...rest } = props;
  const state = useDividerBase_unstable(rest, ref);
  return {
    alignContent,
    appearance,
    inset,
    ...state
  };
};
var useDividerBase_unstable = (props, ref) => {
  const { vertical = false, wrapper, ...rest } = props;
  const dividerId = useId2("divider-");
  return {
    vertical,
    components: {
      root: "div",
      wrapper: "div"
    },
    root: slot_exports.always({
      role: "separator",
      "aria-orientation": vertical ? "vertical" : "horizontal",
      "aria-labelledby": props.children ? dividerId : void 0,
      ref,
      ...rest
    }, {
      elementType: "div"
    }),
    wrapper: slot_exports.always(wrapper, {
      defaultProps: {
        id: dividerId,
        children: props.children
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-divider/lib/components/Divider/useDividerStyles.styles.js
var dividerClassNames = {
  root: "fui-Divider",
  wrapper: "fui-Divider__wrapper"
};
var useBaseStyles = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bh6795r: "fqerorx",
    qhf8xq: "f10pi13n",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    fsow6f: "f17mccla",
    Bcvre1j: "fyl8oag",
    Br0sdwz: "f16vkdww",
    Bn78ew0: "fhsnbul",
    li1rpt: "f1gw3sf2",
    ap17g6: "f1ly5f7u",
    B771hl4: "f1s3tz6t"
  },
  childless: {
    susq4k: "f1kyqvp9",
    Bicfajf: ["fzynn9s", "f1z0ukd1"],
    jwcpgy: ["fekrn8e", "ftdg338"],
    B4rk6o: "fesgyo"
  },
  start: {
    Bsft5z2: "f13zj6fq"
  },
  center: {
    Ftih45: "f1wl9k8s",
    Bsft5z2: "f13zj6fq"
  },
  end: {
    Ftih45: "f1wl9k8s"
  },
  brand: {
    sj55zd: "f16muhyy",
    Bq4z7u6: "fcbuu2a",
    Bk5zm6e: ["f1wdw2dr", "f1ttio3w"],
    Bqjgrrk: "f1582fpk",
    Bm6vgfq: ["f1ttio3w", "f1wdw2dr"],
    B0n5ga8: "f1ahrvm8",
    s924m2: ["f1cd3wbc", "f17hbk9y"],
    B1q35kw: "fvrapl0",
    Gp14am: ["f17hbk9y", "f1cd3wbc"]
  },
  "default": {
    sj55zd: "fkfq4zb",
    Bq4z7u6: "f1vccso1",
    Bk5zm6e: ["f1geml7w", "fjml6kk"],
    Bqjgrrk: "f1r7kh1m",
    Bm6vgfq: ["fjml6kk", "f1geml7w"],
    B0n5ga8: "f16j7guv",
    s924m2: ["fx01ahm", "fj1a37q"],
    B1q35kw: "fl8d8yv",
    Gp14am: ["fj1a37q", "fx01ahm"]
  },
  subtle: {
    sj55zd: "f11d4kpn",
    Bq4z7u6: "f5g06un",
    Bk5zm6e: ["f13sxdku", "f1n015lb"],
    Bqjgrrk: "f1x6bl8t",
    Bm6vgfq: ["f1n015lb", "f13sxdku"],
    B0n5ga8: "fvod1wy",
    s924m2: ["fwslg65", "flk0e17"],
    B1q35kw: "f103fvts",
    Gp14am: ["flk0e17", "fwslg65"]
  },
  strong: {
    sj55zd: "f19n0e5",
    Bq4z7u6: "f10tv6oz",
    Bk5zm6e: ["f16xp3sf", "f1seuxxq"],
    Bqjgrrk: "fwrmqbx",
    Bm6vgfq: ["f1seuxxq", "f16xp3sf"],
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"]
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fqerorx{flex-grow:1;}", ".f10pi13n{position:relative;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f17mccla{text-align:center;}", ".fyl8oag::before{box-sizing:border-box;}", ".f16vkdww::before{display:flex;}", ".fhsnbul::before{flex-grow:1;}", ".f1gw3sf2::after{box-sizing:border-box;}", ".f1ly5f7u::after{display:flex;}", ".f1s3tz6t::after{flex-grow:1;}", ".f1kyqvp9::before{margin-bottom:0;}", ".fzynn9s::before{margin-right:0;}", ".f1z0ukd1::before{margin-left:0;}", ".fekrn8e::after{margin-left:0;}", ".ftdg338::after{margin-right:0;}", ".fesgyo::after{margin-top:0;}", '.f13zj6fq::after{content:"";}', '.f1wl9k8s::before{content:"";}', ".f16muhyy{color:var(--colorBrandForeground1);}", ".fcbuu2a::before{border-top-color:var(--colorBrandStroke1);}", ".f1wdw2dr::before{border-right-color:var(--colorBrandStroke1);}", ".f1ttio3w::before{border-left-color:var(--colorBrandStroke1);}", ".f1582fpk::before{border-bottom-color:var(--colorBrandStroke1);}", ".f1ahrvm8::after{border-top-color:var(--colorBrandStroke1);}", ".f1cd3wbc::after{border-right-color:var(--colorBrandStroke1);}", ".f17hbk9y::after{border-left-color:var(--colorBrandStroke1);}", ".fvrapl0::after{border-bottom-color:var(--colorBrandStroke1);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1vccso1::before{border-top-color:var(--colorNeutralStroke2);}", ".f1geml7w::before{border-right-color:var(--colorNeutralStroke2);}", ".fjml6kk::before{border-left-color:var(--colorNeutralStroke2);}", ".f1r7kh1m::before{border-bottom-color:var(--colorNeutralStroke2);}", ".f16j7guv::after{border-top-color:var(--colorNeutralStroke2);}", ".fx01ahm::after{border-right-color:var(--colorNeutralStroke2);}", ".fj1a37q::after{border-left-color:var(--colorNeutralStroke2);}", ".fl8d8yv::after{border-bottom-color:var(--colorNeutralStroke2);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f5g06un::before{border-top-color:var(--colorNeutralStroke3);}", ".f13sxdku::before{border-right-color:var(--colorNeutralStroke3);}", ".f1n015lb::before{border-left-color:var(--colorNeutralStroke3);}", ".f1x6bl8t::before{border-bottom-color:var(--colorNeutralStroke3);}", ".fvod1wy::after{border-top-color:var(--colorNeutralStroke3);}", ".fwslg65::after{border-right-color:var(--colorNeutralStroke3);}", ".flk0e17::after{border-left-color:var(--colorNeutralStroke3);}", ".f103fvts::after{border-bottom-color:var(--colorNeutralStroke3);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f10tv6oz::before{border-top-color:var(--colorNeutralStroke1);}", ".f16xp3sf::before{border-right-color:var(--colorNeutralStroke1);}", ".f1seuxxq::before{border-left-color:var(--colorNeutralStroke1);}", ".fwrmqbx::before{border-bottom-color:var(--colorNeutralStroke1);}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}"]
});
var useHorizontalStyles = __styles2({
  base: {
    a9b677: "fly5x3f",
    Bdkvgpv: "f163fonl",
    B0qfbqy: "f51yk4v",
    pbipgd: "f13rof3u",
    Bm2nyyq: "f8rth92",
    xrcqlc: "f6czdpx",
    i5u598: "f1iyka9k"
  },
  inset: {
    uwmqm3: ["fjlbh76", "f11qrl6u"],
    z189sj: ["f11qrl6u", "fjlbh76"]
  },
  start: {
    fsow6f: ["f1o700av", "fes3tcz"],
    Ftih45: "f1wl9k8s",
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    Bxwl2t9: "f1he2m4d",
    jwcpgy: ["f12w1bnb", "f1558wlj"]
  },
  center: {
    fsow6f: "f17mccla",
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    jwcpgy: ["f12w1bnb", "f1558wlj"]
  },
  end: {
    fsow6f: ["fes3tcz", "f1o700av"],
    Bicfajf: ["f1ojjlep", "fk1kexq"],
    Bsft5z2: "f13zj6fq",
    jwcpgy: ["f12w1bnb", "f1558wlj"],
    Iy66sp: "f1ayce8x"
  }
}, {
  d: [".fly5x3f{width:100%;}", ".f163fonl::before{border-top-style:solid;}", ".f51yk4v::before{border-top-width:var(--strokeWidthThin);}", ".f13rof3u::before{min-width:8px;}", ".f8rth92::after{border-top-style:solid;}", ".f6czdpx::after{border-top-width:var(--strokeWidthThin);}", ".f1iyka9k::after{min-width:8px;}", ".fjlbh76{padding-left:12px;}", ".f11qrl6u{padding-right:12px;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", '.f1wl9k8s::before{content:"";}', ".f1ojjlep::before{margin-right:12px;}", ".fk1kexq::before{margin-left:12px;}", ".f1he2m4d::before{max-width:8px;}", ".f12w1bnb::after{margin-left:12px;}", ".f1558wlj::after{margin-right:12px;}", ".f17mccla{text-align:center;}", '.f13zj6fq::after{content:"";}', ".f1ayce8x::after{max-width:8px;}"]
});
var useVerticalStyles = __styles2({
  base: {
    Beiy3e4: "f1vx9l62",
    sshi5w: "f16gbxbe",
    m598lv: ["f1yq6w5o", "f1jpmc5p"],
    B4f6apu: ["f9sc749", "f1x8pvcy"],
    zkzzav: "fhkwbjy",
    Barhvk9: ["flthirb", "ftkbnf5"],
    Ihftqj: ["f13hvwk3", "f1en4csx"],
    Bde111x: "f19onpk6"
  },
  inset: {
    B6of3ja: "f1xdg43u",
    jrapky: "f1jlhsmd"
  },
  withChildren: {
    sshi5w: "f1tjaq3g"
  },
  start: {
    Ftih45: "f1wl9k8s",
    susq4k: "fg2pwug",
    Bbdr6tz: "fkjtzyi",
    B4rk6o: "f8vk40g"
  },
  center: {
    susq4k: "fg2pwug",
    B4rk6o: "f8vk40g"
  },
  end: {
    susq4k: "fg2pwug",
    Bsft5z2: "f13zj6fq",
    B4rk6o: "f8vk40g",
    gn64ia: "fqg5mu5"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f16gbxbe{min-height:20px;}", ".f1yq6w5o::before{border-right-style:solid;}", ".f1jpmc5p::before{border-left-style:solid;}", ".f9sc749::before{border-right-width:var(--strokeWidthThin);}", ".f1x8pvcy::before{border-left-width:var(--strokeWidthThin);}", ".fhkwbjy::before{min-height:8px;}", ".flthirb::after{border-right-style:solid;}", ".ftkbnf5::after{border-left-style:solid;}", ".f13hvwk3::after{border-right-width:var(--strokeWidthThin);}", ".f1en4csx::after{border-left-width:var(--strokeWidthThin);}", ".f19onpk6::after{min-height:8px;}", ".f1xdg43u{margin-top:12px;}", ".f1jlhsmd{margin-bottom:12px;}", ".f1tjaq3g{min-height:84px;}", '.f1wl9k8s::before{content:"";}', ".fg2pwug::before{margin-bottom:12px;}", ".fkjtzyi::before{max-height:8px;}", ".f8vk40g::after{margin-top:12px;}", '.f13zj6fq::after{content:"";}', ".fqg5mu5::after{max-height:8px;}"]
});
var useDividerStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles();
  const horizontalStyles = useHorizontalStyles();
  const verticalStyles = useVerticalStyles();
  const {
    alignContent,
    appearance,
    inset,
    vertical
  } = state;
  state.root.className = mergeClasses(
    dividerClassNames.root,
    // Base styles
    baseStyles3.base,
    baseStyles3[alignContent],
    appearance && baseStyles3[appearance],
    // Horizontal styles
    !vertical && horizontalStyles.base,
    !vertical && inset && horizontalStyles.inset,
    !vertical && horizontalStyles[alignContent],
    // Vertical styles
    vertical && verticalStyles.base,
    vertical && inset && verticalStyles.inset,
    vertical && verticalStyles[alignContent],
    vertical && state.root.children !== void 0 && verticalStyles.withChildren,
    // Childless styles
    state.root.children === void 0 && baseStyles3.childless,
    // User provided class name
    state.root.className
  );
  if (state.wrapper) {
    state.wrapper.className = mergeClasses(dividerClassNames.wrapper, state.wrapper.className);
  }
  return state;
};

// node_modules/@fluentui/react-divider/lib/components/Divider/Divider.js
var Divider = React191.forwardRef((props, ref) => {
  const state = useDivider_unstable(props, ref);
  useDividerStyles_unstable(state);
  useCustomStyleHook("useDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
Divider.displayName = "Divider";

// node_modules/@fluentui/react-input/lib/components/Input/Input.js
var React193 = __toESM(require_react());

// node_modules/@fluentui/react-input/lib/components/Input/useInput.js
var React192 = __toESM(require_react());
var useInput_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
  if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") {
    console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
  }
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: ""
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "size",
      "onChange",
      "value",
      "defaultValue"
    ]
  });
  const state = {
    size: size3,
    appearance,
    components: {
      root: "span",
      input: "input",
      contentBefore: "span",
      contentAfter: "span"
    },
    input: slot_exports.always(props.input, {
      defaultProps: {
        type: "text",
        ref,
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    contentAfter: slot_exports.optional(props.contentAfter, {
      elementType: "span"
    }),
    contentBefore: slot_exports.optional(props.contentBefore, {
      elementType: "span"
    }),
    root: slot_exports.always(props.root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.input.value = value;
  state.input.onChange = useEventCallback((ev) => {
    const newValue = ev.target.value;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      value: newValue
    });
    setValue(newValue);
  });
  return state;
};

// node_modules/@fluentui/react-input/lib/components/Input/renderInput.js
var renderInput_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.contentBefore && jsx(state.contentBefore, {}),
      jsx(state.input, {}),
      state.contentAfter && jsx(state.contentAfter, {})
    ]
  });
};

// node_modules/@fluentui/react-input/lib/components/Input/useInputStyles.styles.js
var inputClassNames = {
  root: "fui-Input",
  input: "fui-Input__input",
  contentBefore: "fui-Input__contentBefore",
  contentAfter: "fui-Input__contentAfter"
};
var horizontalPadding = {
  root: {
    small: tokens.spacingHorizontalSNudge,
    medium: tokens.spacingHorizontalMNudge,
    large: tokens.spacingHorizontalM
  },
  input: {
    small: tokens.spacingHorizontalXXS,
    medium: tokens.spacingHorizontalXXS,
    large: tokens.spacingHorizontalSNudge
  },
  combined: {
    small: tokens.spacingHorizontalS,
    medium: tokens.spacingHorizontalM,
    large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
  }
};
var useRootClassName4 = __resetStyles("r1oeeo9n", "r9sxh5", {
  r: [".r1oeeo9n{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r1oeeo9n::after{box-sizing:border-box;content:"";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1oeeo9n:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1oeeo9n:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1oeeo9n:focus-within{outline:2px solid transparent;}", ".r9sxh5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;vertical-align:middle;min-height:32px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r9sxh5::after{box-sizing:border-box;content:"";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r9sxh5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r9sxh5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r9sxh5:focus-within{outline:2px solid transparent;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1oeeo9n:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r9sxh5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
});
var useRootStyles8 = __styles2({
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {},
  large: {
    sshi5w: "f1w5jphr",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  outline: {},
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    Drbcw7: "f8vnjqi",
    udz0bu: ["fz1etlk", "f1hc16gm"],
    Be8ivqh: "f1klwx88",
    ofdepl: ["f1hc16gm", "fz1etlk"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779",
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    wvpqe5: ["f1deefiw", "f1n71otn"],
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    B1piin3: ["f15yvnhg", "f1n6gb5g"]
  },
  underlineInteractive: {
    oetu4i: "f1l4zc64",
    Be8ivqh: "f1klwx88",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f2ale1x"
  },
  filled: {
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"]
  },
  filledInteractive: {
    q7v0qe: "ftmjh5b",
    kmh5ft: ["f17blpuu", "fsrcdbj"],
    nagaa4: "f1tpwn32",
    B1yhkcb: ["fsrcdbj", "f17blpuu"]
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker-shadow": {
    De3pzq: "f16xq7d1",
    E5pizo: "fyed02w"
  },
  "filled-lighter-shadow": {
    De3pzq: "fxugw4r",
    E5pizo: "fyed02w"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"],
    Bsft5z2: "fhr9occ",
    Bduesf4: "f99w1ws"
  },
  smallWithContentBefore: {
    uwmqm3: ["fk8j09s", "fdw0yi8"]
  },
  smallWithContentAfter: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  mediumWithContentBefore: {
    uwmqm3: ["f1ng84yb", "f11gcy0p"]
  },
  mediumWithContentAfter: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  largeWithContentBefore: {
    uwmqm3: ["f1uw59to", "fw5db7e"]
  },
  largeWithContentAfter: {
    z189sj: ["fw5db7e", "f1uw59to"]
  }
}, {
  d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1w5jphr{min-height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".fokr779{border-radius:0;}", {
    p: -1
  }], ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", [".f2ale1x::after{border-radius:0;}", {
    p: -1
  }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fyed02w{box-shadow:var(--shadow2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhr9occ::after{content:unset;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
  a: [".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  w: [".f99w1ws:focus-within{outline-style:none;}"]
});
var useInputClassName = __resetStyles("r12stul0", null, [".r12stul0{align-self:stretch;box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalM);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}", ".r12stul0::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r12stul0::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
var useInputElementStyles = __styles2({
  small: {
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  medium: {},
  large: {
    uwmqm3: ["fnphzt9", "flt1dlf"],
    z189sj: ["flt1dlf", "fnphzt9"]
  },
  smallWithContentBefore: {
    uwmqm3: ["fgiv446", "ffczdla"]
  },
  smallWithContentAfter: {
    z189sj: ["ffczdla", "fgiv446"]
  },
  mediumWithContentBefore: {
    uwmqm3: ["fgiv446", "ffczdla"]
  },
  mediumWithContentAfter: {
    z189sj: ["ffczdla", "fgiv446"]
  },
  largeWithContentBefore: {
    uwmqm3: ["fk8j09s", "fdw0yi8"]
  },
  largeWithContentAfter: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useContentClassName = __resetStyles("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
var useContentStyles2 = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o"
  },
  small: {
    Duoase: "f3qv9w"
  },
  medium: {},
  large: {
    Duoase: "f16u2scb"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
});
var useInputStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance
  } = state;
  const disabled = state.input.disabled;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles8();
  const inputStyles = useInputElementStyles();
  const contentStyles = useContentStyles2();
  state.root.className = mergeClasses(inputClassNames.root, useRootClassName4(), rootStyles[size3], state.contentBefore && rootStyles[`${size3}WithContentBefore`], state.contentAfter && rootStyles[`${size3}WithContentAfter`], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
  state.input.className = mergeClasses(inputClassNames.input, useInputClassName(), inputStyles[size3], state.contentBefore && inputStyles[`${size3}WithContentBefore`], state.contentAfter && inputStyles[`${size3}WithContentAfter`], disabled && inputStyles.disabled, state.input.className);
  const contentClasses = [useContentClassName(), disabled && contentStyles.disabled, contentStyles[size3]];
  if (state.contentBefore) {
    state.contentBefore.className = mergeClasses(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
  }
  if (state.contentAfter) {
    state.contentAfter.className = mergeClasses(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
  }
  return state;
};

// node_modules/@fluentui/react-input/lib/components/Input/Input.js
var Input = React193.forwardRef((props, ref) => {
  const state = useInput_unstable(props, ref);
  useInputStyles_unstable(state);
  useCustomStyleHook("useInputStyles_unstable")(state);
  return renderInput_unstable(state);
});
Input.displayName = "Input";

// node_modules/@fluentui/react-image/lib/components/Image/Image.js
var React195 = __toESM(require_react());

// node_modules/@fluentui/react-image/lib/components/Image/renderImage.js
var renderImage_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-image/lib/components/Image/useImage.js
var React194 = __toESM(require_react());
var useImage_unstable = (props, ref) => {
  const { bordered = false, fit = "default", block = false, shape = "square", shadow = false } = props;
  const state = {
    bordered,
    fit,
    block,
    shape,
    shadow,
    components: {
      root: "img"
    },
    root: slot_exports.always(getIntrinsicElementProps("img", {
      ref,
      ...props
    }), {
      elementType: "img"
    })
  };
  return state;
};

// node_modules/@fluentui/react-image/lib/components/Image/useImageStyles.styles.js
var imageClassNames = {
  root: "fui-Image"
};
var useStyles17 = __styles2({
  base: {
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f14t3ns0"
  },
  bordered: {
    icvyot: "fzkkow9",
    vrafjx: ["fcdblym", "fjik90z"],
    oivjwe: "fg706s2",
    wvpqe5: ["fjik90z", "fcdblym"],
    B4j52fo: "f192inf7",
    Bekrc4i: ["f5tn483", "f1ojsxk5"],
    Bn0qgzm: "f1vxd6vx",
    ibv6hh: ["f1ojsxk5", "f5tn483"]
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {},
  shadow: {
    E5pizo: "f1whvlc6"
  },
  center: {
    st4lth: "f1plgu50",
    Ermj5k: "f14xojzb"
  },
  contain: {
    st4lth: "f1kle4es",
    Ermj5k: "f14xojzb"
  },
  "default": {},
  cover: {
    st4lth: "f1ps3kmd",
    Ermj5k: "f14xojzb"
  },
  none: {
    st4lth: "f1plgu50",
    Ermj5k: ["f13uwng7", "fjmyj0p"]
  },
  fitFill: {
    Bqenvij: "f1l02sjl",
    a9b677: "fly5x3f"
  },
  block: {
    a9b677: "fly5x3f"
  }
}, {
  d: [".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f14t3ns0{display:inline-block;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".f1plgu50{object-fit:none;}", ".f14xojzb{object-position:center;}", ".f1kle4es{object-fit:contain;}", ".f1ps3kmd{object-fit:cover;}", ".f13uwng7{object-position:left top;}", ".fjmyj0p{object-position:right top;}", ".f1l02sjl{height:100%;}", ".fly5x3f{width:100%;}"]
});
var useImageStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles17();
  const {
    height,
    width
  } = state.root;
  const hasExplicitSize = height != null || width != null;
  const shouldApplyFitFill = state.fit !== "default" && !hasExplicitSize;
  state.root.className = mergeClasses(imageClassNames.root, styles.base, state.block && styles.block, state.bordered && styles.bordered, state.shadow && styles.shadow, styles[state.fit], shouldApplyFitFill && styles.fitFill, styles[state.shape], state.root.className);
  return state;
};

// node_modules/@fluentui/react-image/lib/components/Image/Image.js
var Image = React195.forwardRef((props, ref) => {
  const state = useImage_unstable(props, ref);
  useImageStyles_unstable(state);
  useCustomStyleHook("useImageStyles_unstable")(state);
  return renderImage_unstable(state);
});
Image.displayName = "Image";

// node_modules/@fluentui/react-link/lib/components/Link/Link.js
var React199 = __toESM(require_react());

// node_modules/@fluentui/react-link/lib/components/Link/useLink.js
var React198 = __toESM(require_react());

// node_modules/@fluentui/react-link/lib/components/Link/useLinkState.js
var React196 = __toESM(require_react());
var useLinkState_unstable = (state) => {
  const { disabled, disabledFocusable } = state;
  const { onClick, onKeyDown, role, tabIndex } = state.root;
  if (state.root.as === "a") {
    state.root.href = disabled ? void 0 : state.root.href;
    if (disabled || disabledFocusable) {
      state.root.role = role || "link";
    }
  }
  if (state.root.as === "a" || state.root.as === "span") {
    state.root.tabIndex = tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled && !disabledFocusable ? void 0 : 0;
  }
  state.root.onClick = (ev) => {
    if (disabled || disabledFocusable) {
      ev.preventDefault();
    } else {
      onClick === null || onClick === void 0 ? void 0 : onClick(ev);
    }
  };
  state.root.onKeyDown = (ev) => {
    const keyPressed = ev.key === Enter || ev.key === Space;
    if ((disabled || disabledFocusable) && keyPressed) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
      if (state.root.as === "span" && !!state.root.onClick && !onKeyDown && keyPressed) {
        ev.preventDefault();
        ev.currentTarget.click();
      }
    }
  };
  state.disabled = disabled || disabledFocusable;
  state.root["aria-disabled"] = disabled || disabledFocusable || void 0;
  if (state.root.as === "button") {
    state.root.disabled = disabled && !disabledFocusable;
  }
  return state;
};

// node_modules/@fluentui/react-link/lib/contexts/linkContext.js
var React197 = __toESM(require_react());
var LinkContext = React197.createContext(void 0);
var linkContextDefaultValue = {
  inline: false
};
var LinkContextProvider = LinkContext.Provider;
var useLinkContext = () => {
  var _React_useContext;
  return (_React_useContext = React197.useContext(LinkContext)) !== null && _React_useContext !== void 0 ? _React_useContext : linkContextDefaultValue;
};

// node_modules/@fluentui/react-link/lib/components/Link/useLink.js
var useLink_unstable = (props, ref) => {
  const backgroundAppearance = useBackgroundAppearance();
  const { inline: inlineContext } = useLinkContext();
  const { appearance = "default", disabled = false, disabledFocusable = false, inline: inline2 = false } = props;
  const elementType = props.as || (props.href ? "a" : "button");
  const propsWithAssignedAs = {
    role: elementType === "span" ? "button" : void 0,
    type: elementType === "button" ? "button" : void 0,
    ...props,
    as: elementType
  };
  const state = {
    // Props passed at the top-level
    appearance,
    disabled,
    disabledFocusable,
    inline: inline2 !== null && inline2 !== void 0 ? inline2 : !!inlineContext,
    // Slots definition
    components: {
      root: elementType
    },
    root: slot_exports.always(getIntrinsicElementProps(elementType, {
      ref,
      ...propsWithAssignedAs
    }), {
      elementType
    }),
    backgroundAppearance
  };
  useLinkState_unstable(state);
  return state;
};

// node_modules/@fluentui/react-link/lib/components/Link/useLinkStyles.styles.js
var linkClassNames = {
  root: "fui-Link"
};
var useStyles18 = __styles2({
  focusIndicator: {
    Bttzg6e: "fhgqx19",
    B3uz8dt: "f1olyrje",
    B6ihwck: "f1p93eir",
    g9k6zt: "f1nev41a"
  },
  root: {
    B486eqv: "f2hkw1w",
    De3pzq: "f3rmtva",
    B7ck84d: "f1ewtqcl",
    sj55zd: "fyind8e",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f1w7gpdv",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "fnbmjn9",
    fsow6f: ["f1o700av", "fes3tcz"],
    w71qe1: "f1iuv45f",
    Bkioxbp: "f1cmlufx",
    ygn44y: "f9n3di6",
    famaaq: "f1ids18y",
    Bde5pd6: "f1tx3yz7",
    Bi91k9c: "f1deo86v",
    i089h6: "f1eh06m1",
    lj723h: "f1iescvh"
  },
  button: {
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"]
  },
  href: {
    Be2twd7: "fjoy568"
  },
  subtle: {
    sj55zd: "f2yjg6r",
    Bde5pd6: "f1tx3yz7",
    Bi91k9c: "fj1cjhr",
    i089h6: "f1eh06m1",
    lj723h: "fhucn0c"
  },
  inline: {
    w71qe1: "f13mvf36"
  },
  disabled: {
    w71qe1: "f1iuv45f",
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bde5pd6: "fbnuktb",
    Bi91k9c: "fvgxktp",
    i089h6: "fljg2da",
    lj723h: "f19wldhg"
  },
  inverted: {
    sj55zd: "f1qz2gb0",
    Bi91k9c: "f1ujg2k6",
    lj723h: "f1ebemlp"
  },
  brand: {
    sj55zd: "f179xftw",
    Bi91k9c: "f1sk1dtk",
    lj723h: "f182g21t"
  }
}, {
  d: [".fhgqx19[data-fui-focus-visible]{text-decoration-color:var(--colorStrokeFocus2);}", ".f1olyrje[data-fui-focus-visible]{text-decoration-line:underline;}", ".f1p93eir[data-fui-focus-visible]{text-decoration-style:double;}", ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".fyind8e{color:var(--colorBrandForegroundLink);}", ".f1k6fduh{cursor:pointer;}", ".f1w7gpdv{display:inline;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".fnbmjn9{overflow:inherit;}", {
    p: -1
  }], ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".f1iuv45f{text-decoration-line:none;}", ".f1cmlufx{text-decoration-thickness:var(--strokeWidthThin);}", ".f9n3di6{text-overflow:inherit;}", ".f1ids18y{-webkit-user-select:text;-moz-user-select:text;user-select:text;}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", ".fjoy568{font-size:inherit;}", ".f2yjg6r{color:var(--colorNeutralForeground2Link);}", ".f13mvf36{text-decoration-line:underline;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f1qz2gb0{color:var(--colorBrandForegroundInverted);}", ".f179xftw{color:var(--colorNeutralForegroundInvertedLink);}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  h: [".f1tx3yz7:hover{text-decoration-line:underline;}", ".f1deo86v:hover{color:var(--colorBrandForegroundLinkHover);}", ".fj1cjhr:hover{color:var(--colorNeutralForeground2LinkHover);}", ".fbnuktb:hover{text-decoration-line:none;}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1ujg2k6:hover{color:var(--colorBrandForegroundInverted);}", ".f1sk1dtk:hover{color:var(--colorNeutralForegroundInvertedLinkHover);}"],
  a: [".f1eh06m1:active{text-decoration-line:underline;}", ".f1iescvh:active{color:var(--colorBrandForegroundLinkPressed);}", ".fhucn0c:active{color:var(--colorNeutralForeground2LinkPressed);}", ".fljg2da:active{text-decoration-line:none;}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f1ebemlp:active{color:var(--colorBrandForegroundInverted);}", ".f182g21t:active{color:var(--colorNeutralForegroundInvertedLinkPressed);}"]
});
var useLinkStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles18();
  const {
    appearance,
    disabled,
    inline: inline2,
    root,
    backgroundAppearance
  } = state;
  state.root.className = mergeClasses(linkClassNames.root, styles.root, styles.focusIndicator, root.as === "a" && root.href && styles.href, root.as === "button" && styles.button, appearance === "subtle" && styles.subtle, backgroundAppearance === "inverted" && styles.inverted, backgroundAppearance === "brand" && styles.brand, inline2 && styles.inline, disabled && styles.disabled, state.root.className);
  return state;
};

// node_modules/@fluentui/react-link/lib/components/Link/renderLink.js
var renderLink_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-link/lib/components/Link/Link.js
var Link2 = React199.forwardRef((props, ref) => {
  const state = useLink_unstable(props, ref);
  useLinkStyles_unstable(state);
  useCustomStyleHook("useLinkStyles_unstable")(state);
  return renderLink_unstable(state);
});
Link2.displayName = "Link";

// node_modules/@fluentui/react-menu/lib/contexts/menuContext.js
var React200 = __toESM(require_react());
var MenuContext = createContext13(void 0);
var menuContextDefaultValue = {
  open: false,
  setOpen: () => false,
  checkedValues: {},
  onCheckedValueChange: () => null,
  isSubmenu: false,
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  triggerRef: {
    current: null
  },
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  menuPopoverRef: {
    current: null
  },
  mountNode: null,
  triggerId: "",
  openOnContext: false,
  openOnHover: false,
  hasIcons: false,
  hasCheckmarks: false,
  inline: false,
  persistOnItemClick: false
};
var MenuProvider = MenuContext.Provider;
var useMenuContext_unstable = (selector) => useContextSelector(MenuContext, (ctx = menuContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-menu/lib/contexts/menuTriggerContext.js
var React201 = __toESM(require_react());
var MenuTriggerContext = React201.createContext(void 0);
var menuTriggerContextDefaultValue = false;
var MenuTriggerContextProvider = MenuTriggerContext.Provider;
var useMenuTriggerContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React201.useContext(MenuTriggerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuTriggerContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuGroupContext.js
var React202 = __toESM(require_react());
var MenuGroupContext = React202.createContext(void 0);
var menuGroupContextDefaultValue = {
  headerId: ""
};
var MenuGroupContextProvider = MenuGroupContext.Provider;
var useMenuGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React202.useContext(MenuGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuGroupContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuListContext.js
var React203 = __toESM(require_react());
var MenuListContext = createContext13(void 0);
var menuListContextDefaultValue = {
  checkedValues: {},
  setFocusByFirstCharacter: () => null,
  toggleCheckbox: () => null,
  selectRadio: () => null,
  hasIcons: false,
  hasCheckmarks: false
};
var MenuListProvider = MenuListContext.Provider;
var useMenuListContext_unstable = (selector) => useContextSelector(MenuListContext, (ctx = menuListContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-menu/lib/components/Menu/Menu.js
var React209 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenu.js
var React207 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/utils/useOnMenuEnter.js
var React204 = __toESM(require_react());
var MENU_ENTER_EVENT = "fuimenuenter";
var useOnMenuMouseEnter = (options) => {
  const { refs, callback, element, disabled } = options;
  const listener = useEventCallback((ev) => {
    const popoverRef = refs[0];
    const someMenuPopover = ev.target;
    var _popoverRef_current;
    const isOutsidePopover = !elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover);
    if (isOutsidePopover && !disabled) {
      callback(ev);
    }
  });
  React204.useEffect(() => {
    if (element == null) {
      return;
    }
    if (!disabled) {
      element.addEventListener(MENU_ENTER_EVENT, listener);
    }
    return () => {
      element.removeEventListener(MENU_ENTER_EVENT, listener);
    };
  }, [
    listener,
    element,
    disabled
  ]);
};
var dispatchMenuEnterEvent = (el, nativeEvent) => {
  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {
    bubbles: true,
    detail: {
      nativeEvent
    }
  }));
};

// node_modules/@fluentui/react-menu/lib/utils/useIsSubmenu.js
function useIsSubmenu() {
  const menuContextValue = useMenuContext_unstable((context) => context.isSubmenu);
  const hasMenuListContext = useHasParentContext(MenuListContext);
  return menuContextValue || hasMenuListContext;
}

// node_modules/@fluentui/react-menu/lib/utils/useValidateNesting.js
var React205 = __toESM(require_react());
var useValidateNesting = (componentName) => {
  "use no memo";
  const { targetDocument } = useFluent();
  const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
  const inline2 = useMenuContext_unstable((context) => context.inline);
  const ref = React205.useRef(null);
  if (true) {
    React205.useEffect(() => {
      let ancestor = ref.current;
      let ancestorComponentName = "";
      do {
        var _ancestor_parentElement;
        ancestor = (_ancestor_parentElement = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parentElement) !== null && _ancestor_parentElement !== void 0 ? _ancestor_parentElement : null;
        if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuList")) {
          break;
        } else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGrid")) {
          ancestorComponentName = "MenuGrid";
        } else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridItem")) {
          ancestorComponentName = "MenuGridItem";
        } else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridRow")) {
          ancestorComponentName = "MenuGridRow";
        } else if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridCell")) {
          ancestorComponentName = "MenuGridCell";
        }
        if ([
          "MenuItem",
          "MenuItemCheckbox",
          "MenuItemRadio"
        ].includes(componentName)) {
          if ([
            "MenuGrid",
            "MenuGridItem",
            "MenuGridRow",
            "MenuGridCell"
          ].includes(ancestorComponentName)) {
            throw new Error(`${componentName} is incorrectly nested within ${ancestorComponentName}. You probably want to wrap it in a MenuList instead.`);
          }
        } else if (componentName === "MenuList") {
          if (ancestorComponentName === "MenuGridCell") {
            if (inline2 && getCellOfTrigger(triggerRef.current, targetDocument) === ancestor) {
              break;
            }
            throw new Error(`MenuList is incorrectly nested within MenuGridCell.`);
          } else if ([
            "MenuGrid",
            "MenuGridItem",
            "MenuGridRow"
          ].includes(ancestorComponentName)) {
            throw new Error(`MenuList is incorrectly nested within ${ancestorComponentName}.`);
          }
        }
      } while (ancestor && ancestor !== (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body));
    }, [
      componentName,
      ref,
      triggerRef,
      inline2,
      targetDocument
    ]);
  }
  return ref;
};
var getCellOfTrigger = (trigger, targetDocument) => {
  let ancestor = trigger === null || trigger === void 0 ? void 0 : trigger.parentElement;
  while (ancestor && ancestor !== (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body)) {
    if (ancestor === null || ancestor === void 0 ? void 0 : ancestor.classList.contains("fui-MenuGridCell")) {
      return ancestor;
    }
    var _ancestor_parentElement;
    ancestor = (_ancestor_parentElement = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parentElement) !== null && _ancestor_parentElement !== void 0 ? _ancestor_parentElement : null;
  }
  return null;
};

// node_modules/@fluentui/react-menu/lib/utils/useOnMenuSafeZoneTimeout.js
var React206 = __toESM(require_react());
var MENU_SAFEZONE_TIMEOUT_EVENT = "fuimenusafezonetimeout";
var useOnMenuSafeZoneTimeout = (listener) => {
  const elementRef = React206.useRef(null);
  return React206.useCallback((element) => {
    var _elementRef_current;
    (_elementRef_current = elementRef.current) === null || _elementRef_current === void 0 ? void 0 : _elementRef_current.removeEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
    element === null || element === void 0 ? void 0 : element.addEventListener(MENU_SAFEZONE_TIMEOUT_EVENT, listener);
    elementRef.current = element;
  }, [
    listener
  ]);
};

// node_modules/@fluentui/react-menu/lib/selectable/useCheckmarkStyles.styles.js
var useStyles19 = __styles2({
  root: {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt",
    Bcdw1i0: "fd7fpy0",
    Bnnss6s: "fi64zpg"
  },
  rootChecked: {
    Bcdw1i0: "f1022m68",
    Bnnss6s: "fi64zpg"
  }
}, {
  d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".fd7fpy0{visibility:hidden;}", ".fi64zpg{flex-shrink:0;}", ".f1022m68{visibility:visible;}"]
});
var useCheckmarkStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles19();
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(styles.root, state.checked && styles.rootChecked, state.checkmark.className);
  }
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItemStyles.styles.js
var menuItemClassNames = {
  root: "fui-MenuItem",
  icon: "fui-MenuItem__icon",
  checkmark: "fui-MenuItem__checkmark",
  submenuIndicator: "fui-MenuItem__submenuIndicator",
  content: "fui-MenuItem__content",
  secondaryContent: "fui-MenuItem__secondaryContent",
  subText: "fui-MenuItem__subText"
};
var useRootBaseStyles = __resetStyles("rfoezjv", "r8lt3v0", {
  r: [".rfoezjv{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-right:var(--spacingVerticalSNudge);padding-left:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".rfoezjv:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".rfoezjv:hover .fui-Icon-filled{display:inline;}", ".rfoezjv:hover .fui-Icon-regular{display:none;}", ".rfoezjv:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".rfoezjv:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}", ".rfoezjv:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".rfoezjv:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}", ".rfoezjv:focus{outline-style:none;}", ".rfoezjv:focus-visible{outline-style:none;}", ".rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rfoezjv[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r8lt3v0{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-left:var(--spacingVerticalSNudge);padding-right:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);padding-bottom:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".r8lt3v0:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".r8lt3v0:hover .fui-Icon-filled{display:inline;}", ".r8lt3v0:hover .fui-Icon-regular{display:none;}", ".r8lt3v0:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".r8lt3v0:hover .fui-MenuItem__subText{color:var(--colorNeutralForeground3Hover);}", ".r8lt3v0:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".r8lt3v0:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForeground3Pressed);}", ".r8lt3v0:focus{outline-style:none;}", ".r8lt3v0:focus-visible{outline-style:none;}", ".r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r8lt3v0[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ['@media (forced-colors: active){.rfoezjv:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.rfoezjv:focus{outline-style:none;}.rfoezjv:focus-visible{outline-style:none;}.rfoezjv[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}.rfoezjv[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}}', "@media (forced-colors: active){.rfoezjv[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", '@media (forced-colors: active){.r8lt3v0:hover{background-color:Canvas;border-color:Highlight;color:Highlight;}.r8lt3v0:focus{outline-style:none;}.r8lt3v0:focus-visible{outline-style:none;}.r8lt3v0[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}.r8lt3v0[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid Highlight;border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}}', "@media (forced-colors: active){.r8lt3v0[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useContentBaseStyles = __resetStyles("r1ls86vo", "rpbc5dr", [".r1ls86vo{padding-left:2px;padding-right:2px;background-color:transparent;flex-grow:1;}", ".rpbc5dr{padding-right:2px;padding-left:2px;background-color:transparent;flex-grow:1;}"]);
var useSecondaryContentBaseStyles = __resetStyles("r12mwwux", "r1ewgu5j", [".r12mwwux{padding-left:2px;padding-right:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}", ".r12mwwux:hover{color:var(--colorNeutralForeground3Hover);}", ".r12mwwux:focus{color:var(--colorNeutralForeground3Hover);}", ".r1ewgu5j{padding-right:2px;padding-left:2px;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);color:var(--colorNeutralForeground3);}", ".r1ewgu5j:hover{color:var(--colorNeutralForeground3Hover);}", ".r1ewgu5j:focus{color:var(--colorNeutralForeground3Hover);}"]);
var useIconBaseStyles = __resetStyles("ro9koqv", null, [".ro9koqv{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;flex-shrink:0;}"]);
var useSubmenuIndicatorBaseStyles = __resetStyles("r9c34qo", null, [".r9c34qo{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;}"]);
var useSubtextBaseStyles = __resetStyles("rk2ppru", null, [".rk2ppru{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);color:var(--colorNeutralForeground3);}"]);
var useStyles20 = __styles2({
  checkmark: {
    B6of3ja: "fmnzpld"
  },
  splitItemMain: {
    Bh6795r: "fqerorx"
  },
  splitItemTrigger: {
    Btl43ni: ["f1ozlkrg", "f10ostut"],
    Beyfa6y: ["f1deotkl", "f1krrbdw"],
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    Ftih45: "f1wl9k8s",
    Ccq8qp: "f1yn80uh",
    Baz25je: "f68mna0",
    cmx5o7: "f1p5zmk"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bi91k9c: "fvgxktp",
    Jwef8y: "f1ijtazh",
    eoavqd: "fphbwmw",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    Bg7n49j: "f1q1x1ba",
    c7f7en: "ff3wrqt",
    B2d53fq: "fcvwxyo",
    iro3zm: "f1to34ca",
    Bumww26: "fszh5vc",
    t0hwav: "ft33916",
    B7iucu3: "f1cyfu5x",
    Bahaeuw: "fa9u7a5",
    Bbkh6qg: "f1wzezsb",
    B3ejlan: "f1egomlm",
    B41git9: "f1wf2001",
    Boq1n10: "fied5gk",
    Dcq74g: "f1efp33f",
    rxnm8d: "f1m2zpi7",
    wxluhh: "fei14nx",
    idgcvv: "f12hmwa5",
    j9xr24: "f1hzwxd0"
  }
}, {
  d: [".fmnzpld{margin-top:2px;}", ".fqerorx{flex-grow:1;}", ".f1ozlkrg{border-top-left-radius:0;}", ".f10ostut{border-top-right-radius:0;}", ".f1deotkl{border-bottom-left-radius:0;}", ".f1krrbdw{border-bottom-right-radius:0;}", ".f1cnd47f{padding-left:0;}", ".fhxju0i{padding-right:0;}", '.f1wl9k8s::before{content:"";}', ".f1yn80uh::before{width:var(--strokeWidthThin);}", ".f68mna0::before{height:24px;}", ".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  h: [".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1ijtazh:hover{background-color:var(--colorNeutralBackground1);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1q1x1ba:hover .fui-MenuItem__icon{color:var(--colorNeutralForegroundDisabled);}", ".ff3wrqt:hover .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f1to34ca:hover:active{background-color:var(--colorNeutralBackground1);}", ".fszh5vc:hover:active .fui-MenuItem__subText{color:var(--colorNeutralForegroundDisabled);}"],
  f: [".ft33916:focus{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fa9u7a5:hover{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wzezsb:hover{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1egomlm:hover .fui-MenuItem__icon{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wf2001:hover .fui-MenuItem__icon{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fied5gk:hover .fui-MenuItem__subText{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1efp33f:hover:active{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1m2zpi7:hover:active{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fei14nx:hover:active .fui-MenuItem__subText{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f12hmwa5:focus{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1hzwxd0:focus{background-color:Canvas;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSubTextStyles = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o",
    B7iucu3: "f1cyfu5x"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useMultilineStyles = __styles2({
  content: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  },
  secondaryContent: {
    qb2dma: "f7nlbp4"
  },
  submenuIndicator: {
    qb2dma: "f7nlbp4"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f7nlbp4{align-self:center;}"]
});
var useMenuItemStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles20();
  const rootBaseStyles = useRootBaseStyles();
  const contentBaseStyles = useContentBaseStyles();
  const secondaryContentBaseStyles = useSecondaryContentBaseStyles();
  const iconBaseStyles = useIconBaseStyles();
  const submenuIndicatorBaseStyles = useSubmenuIndicatorBaseStyles();
  const multilineStyles = useMultilineStyles();
  const subtextBaseStyles = useSubtextBaseStyles();
  const subTextStyles = useSubTextStyles();
  const multiline = !!state.subText;
  state.root.className = mergeClasses(menuItemClassNames.root, rootBaseStyles, state.disabled && styles.disabled, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemClassNames.content, contentBaseStyles, state.content.className, multiline && multilineStyles.content);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemClassNames.checkmark, styles.checkmark, state.checkmark.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemClassNames.secondaryContent, secondaryContentBaseStyles, state.disabled && styles.disabled, state.secondaryContent.className, multiline && multilineStyles.secondaryContent);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemClassNames.icon, iconBaseStyles, state.icon.className);
  }
  if (state.submenuIndicator) {
    state.submenuIndicator.className = mergeClasses(menuItemClassNames.submenuIndicator, submenuIndicatorBaseStyles, state.submenuIndicator.className, multiline && multilineStyles.submenuIndicator);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemClassNames.subText, state.disabled && subTextStyles.disabled, state.subText.className, subtextBaseStyles);
  }
  useCheckmarkStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenu.js
var submenuFallbackPositions = [
  "after",
  "after-bottom",
  "before-top",
  "before",
  "before-bottom",
  "above"
];
var useMenu_unstable = (props) => {
  const isSubmenu = useIsSubmenu();
  const { hoverDelay = 500, inline: inline2 = false, hasCheckmarks = false, hasIcons = false, closeOnScroll = false, openOnContext = false, persistOnItemClick = false, openOnHover = isSubmenu, defaultCheckedValues, mountNode = null, safeZone } = props;
  const { targetDocument } = useFluent();
  const triggerId = useId2("menu");
  const [contextTarget, setContextTarget] = usePositioningMouseTarget();
  const positioningOptions = {
    position: isSubmenu ? "after" : "below",
    align: isSubmenu ? "top" : "start",
    target: props.openOnContext ? contextTarget : void 0,
    fallbackPositions: isSubmenu ? submenuFallbackPositions : void 0,
    ...resolvePositioningShorthand(props.positioning)
  };
  const children = React207.Children.toArray(props.children);
  if (true) {
    if (children.length === 0) {
      console.warn("Menu must contain at least one child");
    }
    if (children.length > 2) {
      console.warn("Menu must contain at most two children");
    }
  }
  let menuTrigger = void 0;
  let menuPopover = void 0;
  if (children.length === 2) {
    menuTrigger = children[0];
    menuPopover = children[1];
  } else if (children.length === 1) {
    menuPopover = children[0];
  }
  const { targetRef, containerRef } = usePositioning(positioningOptions);
  const enableSafeZone = safeZone && openOnHover;
  const safeZoneDescriptorRef = React207.useRef({
    isInside: false,
    mouseCoordinates: {
      x: 0,
      y: 0
    }
  });
  const safeZoneHandle = useSafeZoneArea({
    disabled: !enableSafeZone,
    timeout: typeof safeZone === "object" ? safeZone.timeout : 300,
    onSafeZoneEnter: (e) => {
      setOpen(e, {
        open: true,
        keyboard: false,
        type: "menuSafeZoneMouseEnter",
        event: e
      });
      safeZoneDescriptorRef.current.isInside = true;
    },
    onSafeZoneLeave: () => {
      safeZoneDescriptorRef.current.isInside = false;
    },
    onSafeZoneMove: (e) => {
      safeZoneDescriptorRef.current.mouseCoordinates = {
        x: e.clientX,
        y: e.clientY
      };
    },
    onSafeZoneTimeout: () => {
      const event = new CustomEvent(MENU_SAFEZONE_TIMEOUT_EVENT);
      setOpen(event, {
        open: false,
        keyboard: false,
        type: "menuSafeZoneTimeout",
        event
      });
      if (safeZoneDescriptorRef.current.isInside && targetDocument) {
        const elementsInPoint = targetDocument.elementsFromPoint(safeZoneDescriptorRef.current.mouseCoordinates.x, safeZoneDescriptorRef.current.mouseCoordinates.y);
        const menuItemEl = elementsInPoint.find((el) => {
          return el.classList.contains(menuItemClassNames.root);
        });
        menuItemEl === null || menuItemEl === void 0 ? void 0 : menuItemEl.dispatchEvent(event);
      }
    }
  });
  const triggerRef = useMergedRefs(targetRef, safeZoneHandle.targetRef);
  const menuPopoverRef = useMergedRefs(containerRef, safeZoneHandle.containerRef);
  const [open, setOpen] = useMenuOpenState({
    hoverDelay,
    isSubmenu,
    setContextTarget,
    closeOnScroll,
    menuPopoverRef,
    triggerRef,
    open: props.open,
    defaultOpen: props.defaultOpen,
    onOpenChange: props.onOpenChange,
    openOnContext
  });
  const [checkedValues, onCheckedValueChange] = useMenuSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  return {
    inline: inline2,
    hoverDelay,
    triggerId,
    isSubmenu,
    openOnHover,
    contextTarget,
    setContextTarget,
    hasCheckmarks,
    hasIcons,
    closeOnScroll,
    menuTrigger,
    menuPopover,
    mountNode,
    triggerRef,
    menuPopoverRef,
    components: {},
    openOnContext,
    open,
    setOpen,
    checkedValues,
    onCheckedValueChange,
    persistOnItemClick,
    safeZone: safeZoneHandle.elementToRender
  };
};
var useMenuSelectableState = (props) => {
  const [checkedValues, setCheckedValues] = useControllableState({
    state: props.checkedValues,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  const onCheckedValueChange = useEventCallback((e, { name, checkedItems }) => {
    var _props_onCheckedValueChange;
    (_props_onCheckedValueChange = props.onCheckedValueChange) === null || _props_onCheckedValueChange === void 0 ? void 0 : _props_onCheckedValueChange.call(props, e, {
      name,
      checkedItems
    });
    setCheckedValues((currentValue) => ({
      ...currentValue,
      [name]: checkedItems
    }));
  });
  return [
    checkedValues,
    onCheckedValueChange
  ];
};
var useMenuOpenState = (state) => {
  "use no memo";
  const { targetDocument } = useFluent();
  const parentSetOpen = useMenuContext_unstable((context) => context.setOpen);
  const onOpenChange = useEventCallback((e, data) => {
    var _state_onOpenChange;
    return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e, data);
  });
  const enteringTriggerRef = React207.useRef(false);
  const [open, setOpenState] = useControllableState({
    state: state.open,
    defaultState: state.defaultOpen,
    initialState: false
  });
  const trySetOpen = useEventCallback((e, data) => {
    const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
      ...data
    });
    if (data.open && e.type === "contextmenu") {
      state.setContextTarget(e);
    }
    if (!data.open) {
      state.setContextTarget(void 0);
    }
    if (data.bubble) {
      parentSetOpen(e, {
        ...data
      });
    }
    setOpenState(data.open);
  });
  const [setOpenTimeout, clearOpenTimeout] = useTimeout();
  const setOpen = useEventCallback((e, data) => {
    clearOpenTimeout();
    if (!(e instanceof Event) && e.persist) {
      e.persist();
    }
    const shouldUseDelay = !data.ignoreHoverDelay && (e.type === "mouseleave" || e.type === "mouseover" || e.type === "mousemove" || e.type === MENU_ENTER_EVENT);
    if (shouldUseDelay) {
      var _state_triggerRef_current;
      if ((_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.contains(e.target)) {
        enteringTriggerRef.current = e.type === "mouseover" || e.type === "mousemove";
      }
      setOpenTimeout(() => trySetOpen(e, data), state.hoverDelay);
    } else {
      trySetOpen(e, data);
    }
  });
  useOnClickOutside({
    contains: elementContains,
    disabled: !open,
    element: targetDocument,
    refs: [
      state.menuPopoverRef,
      !state.openOnContext && state.triggerRef
    ].filter(Boolean),
    callback: (event) => setOpen(event, {
      open: false,
      type: "clickOutside",
      event
    })
  });
  const closeOnScroll = state.openOnContext || state.closeOnScroll;
  useOnScrollOutside({
    contains: elementContains,
    element: targetDocument,
    callback: (event) => setOpen(event, {
      open: false,
      type: "scrollOutside",
      event
    }),
    refs: [
      state.menuPopoverRef,
      !state.openOnContext && state.triggerRef
    ].filter(Boolean),
    disabled: !open || !closeOnScroll
  });
  useOnMenuMouseEnter({
    element: targetDocument,
    callback: (event) => {
      if (!enteringTriggerRef.current) {
        setOpen(event, {
          open: false,
          type: "menuMouseEnter",
          event
        });
      }
    },
    disabled: !open,
    refs: [
      state.menuPopoverRef
    ]
  });
  const { findFirstFocusable } = useFocusFinders();
  const focusFirst = React207.useCallback(() => {
    const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [
    findFirstFocusable,
    state.menuPopoverRef
  ]);
  const firstMount = useFirstMount();
  React207.useEffect(() => {
    if (open) {
      focusFirst();
    } else {
      if (!firstMount) {
        if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body)) {
          var _state_triggerRef_current;
          (_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.focus();
        }
      }
    }
  }, [
    state.triggerRef,
    state.isSubmenu,
    open,
    focusFirst,
    targetDocument,
    state.menuPopoverRef
  ]);
  return [
    open,
    setOpen
  ];
};

// node_modules/@fluentui/react-menu/lib/components/Menu/useMenuContextValues.js
function useMenuContextValues_unstable(state) {
  const { checkedValues, hasCheckmarks, hasIcons, inline: inline2, isSubmenu, menuPopoverRef, mountNode, onCheckedValueChange, open, openOnContext, openOnHover, persistOnItemClick, safeZone, setOpen, triggerId, triggerRef } = state;
  const menu = {
    checkedValues,
    hasCheckmarks,
    hasIcons,
    inline: inline2,
    isSubmenu,
    menuPopoverRef,
    mountNode,
    onCheckedValueChange,
    open,
    openOnContext,
    openOnHover,
    persistOnItemClick,
    safeZone,
    setOpen,
    triggerId,
    triggerRef
  };
  return {
    menu
  };
}

// node_modules/@fluentui/react-menu/lib/components/Menu/renderMenu.js
var React208 = __toESM(require_react());
var renderMenu_unstable = (state, contextValues) => {
  return React208.createElement(MenuProvider, {
    value: contextValues.menu
  }, state.menuTrigger, state.open && state.menuPopover);
};

// node_modules/@fluentui/react-menu/lib/components/Menu/Menu.js
var Menu = (props) => {
  const state = useMenu_unstable(props);
  const contextValues = useMenuContextValues_unstable(state);
  return renderMenu_unstable(state, contextValues);
};
Menu.displayName = "Menu";

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/MenuDivider.js
var React211 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDivider.js
var React210 = __toESM(require_react());
var useMenuDivider_unstable = (props, ref) => {
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "presentation",
      "aria-hidden": true,
      ...props,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/useMenuDividerStyles.styles.js
var menuDividerClassNames = {
  root: "fui-MenuDivider"
};
var useStyles21 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f8dz51a",
    a9b677: "f14z66ap",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  }
}, {
  d: [[".f8dz51a{margin:4px -5px 4px -5px;}", {
    p: -1
  }], ".f14z66ap{width:auto;}", [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }]]
});
var useMenuDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles21();
  state.root.className = mergeClasses(menuDividerClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/renderMenuDivider.js
var renderMenuDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-menu/lib/components/MenuDivider/MenuDivider.js
var MenuDivider = React211.forwardRef((props, ref) => {
  const state = useMenuDivider_unstable(props, ref);
  useMenuDividerStyles_unstable(state);
  useCustomStyleHook("useMenuDividerStyles_unstable")(state);
  return renderMenuDivider_unstable(state);
});
MenuDivider.displayName = "MenuDivider";

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/MenuGroup.js
var React214 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroup.js
var React212 = __toESM(require_react());
function useMenuGroup_unstable(props, ref) {
  const headerId = useId2("menu-group");
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      "aria-labelledby": headerId,
      role: "group",
      ...props
    }), {
      elementType: "div"
    }),
    headerId
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/renderMenuGroup.js
var renderMenuGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(MenuGroupContextProvider, {
    value: contextValues.menuGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupContextValues.js
var React213 = __toESM(require_react());
function useMenuGroupContextValues_unstable(state) {
  const { headerId } = state;
  const menuGroup = React213.useMemo(() => ({
    headerId
  }), [
    headerId
  ]);
  return {
    menuGroup
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/useMenuGroupStyles.styles.js
var menuGroupClassNames = {
  root: "fui-MenuGroup"
};
var useMenuGroupStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuGroupClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroup/MenuGroup.js
var MenuGroup = React214.forwardRef((props, ref) => {
  const state = useMenuGroup_unstable(props, ref);
  const contextValues = useMenuGroupContextValues_unstable(state);
  useMenuGroupStyles_unstable(state);
  useCustomStyleHook("useMenuGroupStyles_unstable")(state);
  return renderMenuGroup_unstable(state, contextValues);
});
MenuGroup.displayName = "MenuGroup";

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/MenuGroupHeader.js
var React216 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeader.js
var React215 = __toESM(require_react());
function useMenuGroupHeader_unstable(props, ref) {
  const { headerId: id } = useMenuGroupContext_unstable();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      id,
      ...props
    }), {
      elementType: "div"
    })
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/useMenuGroupHeaderStyles.styles.js
var menuGroupHeaderClassNames = {
  root: "fui-MenuGroupHeader"
};
var useStyles22 = __styles2({
  root: {
    Be2twd7: "fy9rknc",
    sj55zd: "f11d4kpn",
    uwmqm3: ["f177v4lu", "f19lj068"],
    z189sj: ["f19lj068", "f177v4lu"],
    Bhrd7zp: "fl43uef",
    Bqenvij: "f1d2rq10",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  }
}, {
  d: [".fy9rknc{font-size:var(--fontSizeBase200);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f177v4lu{padding-left:8px;}", ".f19lj068{padding-right:8px;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1d2rq10{height:32px;}", ".f22iagw{display:flex;}", ".f122n59{align-items:center;}"]
});
var useMenuGroupHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles22();
  state.root.className = mergeClasses(menuGroupHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/renderMenuGroupHeader.js
var renderMenuGroupHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-menu/lib/components/MenuGroupHeader/MenuGroupHeader.js
var MenuGroupHeader = React216.forwardRef((props, ref) => {
  const state = useMenuGroupHeader_unstable(props, ref);
  useMenuGroupHeaderStyles_unstable(state);
  useCustomStyleHook("useMenuGroupHeaderStyles_unstable")(state);
  return renderMenuGroupHeader_unstable(state);
});
MenuGroupHeader.displayName = "MenuGroupHeader";

// node_modules/@fluentui/react-menu/lib/components/MenuItem/MenuItem.js
var React220 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItem.js
var React219 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useCharacterSearch.js
var React217 = __toESM(require_react());
var useCharacterSearch = (state, ref) => {
  "use no memo";
  const setFocusByFirstCharacter = useMenuListContext_unstable((context) => context.setFocusByFirstCharacter);
  const { onKeyDown: originalOnKeyDown } = state.root;
  state.root.onKeyDown = (e) => {
    var _e_key;
    originalOnKeyDown === null || originalOnKeyDown === void 0 ? void 0 : originalOnKeyDown(e);
    if (((_e_key = e.key) === null || _e_key === void 0 ? void 0 : _e_key.length) > 1) {
      return;
    }
    if (ref.current) {
      setFocusByFirstCharacter === null || setFocusByFirstCharacter === void 0 ? void 0 : setFocusByFirstCharacter(e, ref.current);
    }
  };
  return state;
};

// node_modules/@fluentui/react-menu/lib/contexts/menuSplitGroupContext.js
var React218 = __toESM(require_react());
var MenuSplitGroupContext = React218.createContext(void 0);
var menuSplitGroupContextDefaultValue = {
  setMultiline: () => null
};
var MenuSplitGroupContextProvider = MenuSplitGroupContext.Provider;
var useMenuSplitGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React218.useContext(MenuSplitGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuSplitGroupContextDefaultValue;
};
var useIsInMenuSplitGroup = () => {
  const context = useMenuSplitGroupContext_unstable();
  return context !== menuSplitGroupContextDefaultValue;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/useMenuItem.js
var ChevronRightIcon = bundleIcon(ChevronRightFilled, ChevronRightRegular);
var ChevronLeftIcon = bundleIcon(ChevronLeftFilled, ChevronLeftRegular);
var useMenuItem_unstable = (props, ref) => {
  const { dir } = useFluent();
  const state = useMenuItemBase_unstable(props, ref);
  if (state.submenuIndicator) {
    var _state_submenuIndicator;
    var _children;
    (_children = (_state_submenuIndicator = state.submenuIndicator).children) !== null && _children !== void 0 ? _children : _state_submenuIndicator.children = dir === "rtl" ? React219.createElement(ChevronLeftIcon, null) : React219.createElement(ChevronRightIcon, null);
  }
  return state;
};
var useMenuItemBase_unstable = (props, ref) => {
  const isSubmenuTrigger = useMenuTriggerContext_unstable();
  const persistOnClickContext = useMenuContext_unstable((context) => context.persistOnItemClick);
  const { as = "div", disabled = false, hasSubmenu = isSubmenuTrigger, persistOnClick = persistOnClickContext, content: _content, ...rest } = props;
  const { hasIcons, hasCheckmarks } = useIconAndCheckmarkAlignment({
    hasSubmenu
  });
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  useNotifySplitItemMultiline({
    multiline: !!props.subText,
    hasSubmenu
  });
  const innerRef = React219.useRef(null);
  const dismissedWithKeyboardRef = React219.useRef(false);
  const validateNestingRef = useValidateNesting(getValidateNestingComponentName(props.role));
  const state = {
    hasSubmenu,
    disabled,
    persistOnClick,
    components: {
      root: "div",
      icon: "span",
      checkmark: "span",
      submenuIndicator: "span",
      content: "span",
      secondaryContent: "span",
      subText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(as, {
      role: "menuitem",
      ...rest,
      disabled: false,
      disabledFocusable: disabled,
      ref: useMergedRefs(ref, innerRef, validateNestingRef),
      onKeyDown: useEventCallback((event) => {
        var _props_onKeyDown;
        (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
        if (!event.isDefaultPrevented() && (event.key === Space || event.key === Enter)) {
          dismissedWithKeyboardRef.current = true;
        }
      }),
      onMouseMove: useEventCallback((event) => {
        var _props_onMouseMove;
        if (event.currentTarget.ownerDocument.activeElement !== event.currentTarget) {
          var _innerRef_current;
          (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.focus();
        }
        (_props_onMouseMove = props.onMouseMove) === null || _props_onMouseMove === void 0 ? void 0 : _props_onMouseMove.call(props, event);
      }),
      onClick: useEventCallback((event) => {
        var _props_onClick;
        if (!hasSubmenu && !persistOnClick) {
          setOpen(event, {
            open: false,
            keyboard: dismissedWithKeyboardRef.current,
            bubble: true,
            type: "menuItemClick",
            event
          });
          dismissedWithKeyboardRef.current = false;
        }
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
      })
    })), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      renderByDefault: hasIcons,
      elementType: "span"
    }),
    checkmark: slot_exports.optional(props.checkmark, {
      renderByDefault: hasCheckmarks,
      elementType: "span"
    }),
    submenuIndicator: slot_exports.optional(props.submenuIndicator, {
      renderByDefault: hasSubmenu,
      elementType: "span"
    }),
    content: slot_exports.optional(props.content, {
      renderByDefault: !!props.children,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryContent: slot_exports.optional(props.secondaryContent, {
      elementType: "span"
    }),
    subText: slot_exports.optional(props.subText, {
      elementType: "span"
    })
  };
  useCharacterSearch(state, innerRef);
  return state;
};
var useNotifySplitItemMultiline = (options) => {
  const { hasSubmenu, multiline } = options;
  const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
  const { setMultiline } = useMenuSplitGroupContext_unstable();
  useIsomorphicLayoutEffect(() => {
    if (!isSplitItemTrigger) {
      setMultiline(multiline);
    }
  }, [
    setMultiline,
    multiline,
    isSplitItemTrigger
  ]);
};
var useIconAndCheckmarkAlignment = (options) => {
  const { hasSubmenu } = options;
  const hasIcons = useMenuListContext_unstable((context) => context.hasIcons);
  const hasCheckmarks = useMenuListContext_unstable((context) => context.hasCheckmarks);
  const isSplitItemTrigger = useIsInMenuSplitGroup() && hasSubmenu;
  return {
    hasIcons: hasIcons && !isSplitItemTrigger,
    hasCheckmarks: hasCheckmarks && !isSplitItemTrigger
  };
};
var getValidateNestingComponentName = (role) => {
  switch (role) {
    case "menuitemcheckbox":
      return "MenuItemCheckbox";
    case "menuitemradio":
      return "MenuItemRadio";
  }
  return "MenuItem";
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/renderMenuItem.js
var renderMenuItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {}),
      state.submenuIndicator && jsx(state.submenuIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItem/MenuItem.js
var MenuItem = React220.forwardRef((props, ref) => {
  const state = useMenuItem_unstable(props, ref);
  useMenuItemStyles_unstable(state);
  useCustomStyleHook("useMenuItemStyles_unstable")(state);
  return renderMenuItem_unstable(state);
});
MenuItem.displayName = "MenuItem";

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/MenuItemCheckbox.js
var React222 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckbox.js
var React221 = __toESM(require_react());
var useMenuItemCheckbox_unstable = (props, ref) => {
  const state = useMenuItemCheckboxBase_unstable(props, ref);
  if (state.checkmark) {
    var _state_checkmark;
    var _children;
    (_children = (_state_checkmark = state.checkmark).children) !== null && _children !== void 0 ? _children : _state_checkmark.children = React221.createElement(Checkmark16Filled, null);
  }
  return state;
};
var useMenuItemCheckboxBase_unstable = (props, ref) => {
  const toggleCheckbox = useMenuListContext_unstable((context) => context.toggleCheckbox);
  const { name, value } = props;
  const checked = useMenuListContext_unstable((context) => {
    var _context_checkedValues;
    const checkedItems = ((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || [];
    return checkedItems.indexOf(value) !== -1;
  });
  const state = {
    ...useMenuItemBase_unstable({
      role: "menuitemcheckbox",
      persistOnClick: true,
      ...props,
      "aria-checked": checked,
      checkmark: slot_exports.optional(props.checkmark, {
        renderByDefault: true,
        elementType: "span"
      }),
      onClick: (e) => {
        var _props_onClick;
        toggleCheckbox === null || toggleCheckbox === void 0 ? void 0 : toggleCheckbox(e, name, value, checked);
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
      }
    }, ref),
    name,
    value,
    checked
  };
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/renderMenuItemCheckbox.js
var renderMenuItemCheckbox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/useMenuItemCheckboxStyles.styles.js
var menuItemCheckboxClassNames = {
  root: "fui-MenuItemCheckbox",
  icon: "fui-MenuItemCheckbox__icon",
  checkmark: "fui-MenuItemCheckbox__checkmark",
  content: "fui-MenuItemCheckbox__content",
  secondaryContent: "fui-MenuItemCheckbox__secondaryContent",
  subText: "fui-MenuItemCheckbox__subText"
};
var useMenuItemCheckboxStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuItemCheckboxClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemCheckboxClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemCheckboxClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemCheckboxClassNames.icon, state.icon.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemCheckboxClassNames.checkmark, state.checkmark.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemCheckboxClassNames.subText, state.subText.className);
  }
  useMenuItemStyles_unstable(state);
  useCheckmarkStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemCheckbox/MenuItemCheckbox.js
var MenuItemCheckbox = React222.forwardRef((props, ref) => {
  const state = useMenuItemCheckbox_unstable(props, ref);
  useMenuItemCheckboxStyles_unstable(state);
  useCustomStyleHook("useMenuItemCheckboxStyles_unstable")(state);
  return renderMenuItemCheckbox_unstable(state);
});
MenuItemCheckbox.displayName = "MenuItemCheckbox";

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/MenuItemRadio.js
var React224 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadio.js
var React223 = __toESM(require_react());
var useMenuItemRadio_unstable = (props, ref) => {
  const state = useMenuItemRadioBase_unstable(props, ref);
  if (state.checkmark) {
    var _state_checkmark;
    var _children;
    (_children = (_state_checkmark = state.checkmark).children) !== null && _children !== void 0 ? _children : _state_checkmark.children = React223.createElement(Checkmark16Filled, null);
  }
  return state;
};
var useMenuItemRadioBase_unstable = (props, ref) => {
  const { name, value } = props;
  const checked = useMenuListContext_unstable((context) => {
    var _context_checkedValues;
    const checkedItems = ((_context_checkedValues = context.checkedValues) === null || _context_checkedValues === void 0 ? void 0 : _context_checkedValues[name]) || [];
    return checkedItems.indexOf(value) !== -1;
  });
  const selectRadio = useMenuListContext_unstable((context) => context.selectRadio);
  return {
    ...useMenuItemBase_unstable({
      ...props,
      role: "menuitemradio",
      "aria-checked": checked,
      checkmark: slot_exports.optional(props.checkmark, {
        renderByDefault: true,
        elementType: "span"
      }),
      onClick: (e) => {
        var _props_onClick;
        selectRadio === null || selectRadio === void 0 ? void 0 : selectRadio(e, name, value, checked);
        (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
      }
    }, ref),
    checked,
    name,
    value
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/renderMenuItemRadio.js
var renderMenuItemRadio_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/useMenuItemRadioStyles.styles.js
var menuItemRadioClassNames = {
  root: "fui-MenuItemRadio",
  icon: "fui-MenuItemRadio__icon",
  checkmark: "fui-MenuItemRadio__checkmark",
  content: "fui-MenuItemRadio__content",
  secondaryContent: "fui-MenuItemRadio__secondaryContent",
  subText: "fui-MenuItemRadio__subText"
};
var useMenuItemRadioStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(menuItemRadioClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemRadioClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemRadioClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemRadioClassNames.icon, state.icon.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemRadioClassNames.checkmark, state.checkmark.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemRadioClassNames.subText, state.subText.className);
  }
  useMenuItemStyles_unstable(state);
  useCheckmarkStyles_unstable(state);
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemRadio/MenuItemRadio.js
var MenuItemRadio = React224.forwardRef((props, ref) => {
  const state = useMenuItemRadio_unstable(props, ref);
  useMenuItemRadioStyles_unstable(state);
  useCustomStyleHook("useMenuItemRadioStyles_unstable")(state);
  return renderMenuItemRadio_unstable(state);
});
MenuItemRadio.displayName = "MenuItemRadio";

// node_modules/@fluentui/react-menu/lib/components/MenuList/MenuList.js
var React226 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuList.js
var React225 = __toESM(require_react());
var useMenuList_unstable = (props, ref) => {
  const { findAllFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const menuContext = useMenuContextSelectors();
  const hasMenuContext = useHasParentContext(MenuContext);
  const focusAttributes = useArrowNavigationGroup({
    circular: true
  });
  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {
    console.warn("You are using both MenuList and Menu props, we recommend you to use Menu props when available");
  }
  const innerRef = React225.useRef(null);
  const validateNestingRef = useValidateNesting("MenuList");
  React225.useEffect(() => {
    const element = innerRef.current;
    if (hasMenuContext && targetDocument && element) {
      const onTabsterMoveFocus = (e) => {
        const nextElement = e.detail.next;
        if (nextElement && element.contains(targetDocument.activeElement) && !element.contains(nextElement)) {
          e.preventDefault();
        }
      };
      targetDocument.addEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
      return () => {
        targetDocument.removeEventListener(TabsterMoveFocusEventName, onTabsterMoveFocus);
      };
    }
  }, [
    innerRef,
    targetDocument,
    hasMenuContext
  ]);
  const setFocusByFirstCharacter = React225.useCallback((e, itemEl) => {
    const acceptedRoles = [
      "menuitem",
      "menuitemcheckbox",
      "menuitemradio"
    ];
    if (!innerRef.current) {
      return;
    }
    const menuItems = findAllFocusable(innerRef.current, (el) => el.hasAttribute("role") && acceptedRoles.indexOf(el.getAttribute("role")) !== -1);
    let startIndex = menuItems.indexOf(itemEl) + 1;
    if (startIndex === menuItems.length) {
      startIndex = 0;
    }
    const firstChars = menuItems.map((menuItem) => {
      var _menuItem_textContent;
      return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();
    });
    const char = e.key.toLowerCase();
    const getIndexFirstChars = (start, firstChar) => {
      for (let i = start; i < firstChars.length; i++) {
        if (char === firstChars[i]) {
          return i;
        }
      }
      return -1;
    };
    let index = getIndexFirstChars(startIndex, char);
    if (index === -1) {
      index = getIndexFirstChars(0, char);
    }
    if (index > -1) {
      menuItems[index].focus();
    }
  }, [
    findAllFocusable
  ]);
  var _props_checkedValues;
  const [checkedValues, setCheckedValues] = useControllableState({
    state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : void 0,
    defaultState: props.defaultCheckedValues,
    initialState: {}
  });
  var _props_onCheckedValueChange;
  const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : void 0;
  const toggleCheckbox = useEventCallback((e, name, value, checked) => {
    const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
    const newCheckedItems = [
      ...checkedItems
    ];
    if (checked) {
      newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
    } else {
      newCheckedItems.push(value);
    }
    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
    setCheckedValues((s) => ({
      ...s,
      [name]: newCheckedItems
    }));
  });
  const selectRadio = useEventCallback((e, name, value) => {
    const newCheckedItems = [
      value
    ];
    setCheckedValues((s) => ({
      ...s,
      [name]: newCheckedItems
    }));
    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {
      name,
      checkedItems: newCheckedItems
    });
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef, validateNestingRef),
      role: "menu",
      "aria-labelledby": menuContext.triggerId,
      ...focusAttributes,
      ...props
    }), {
      elementType: "div"
    }),
    hasIcons: menuContext.hasIcons || false,
    hasCheckmarks: menuContext.hasCheckmarks || false,
    checkedValues,
    hasMenuContext,
    setFocusByFirstCharacter,
    selectRadio,
    toggleCheckbox
  };
};
var useMenuContextSelectors = () => {
  const checkedValues = useMenuContext_unstable((context) => context.checkedValues);
  const onCheckedValueChange = useMenuContext_unstable((context) => context.onCheckedValueChange);
  const triggerId = useMenuContext_unstable((context) => context.triggerId);
  const hasIcons = useMenuContext_unstable((context) => context.hasIcons);
  const hasCheckmarks = useMenuContext_unstable((context) => context.hasCheckmarks);
  return {
    checkedValues,
    onCheckedValueChange,
    triggerId,
    hasIcons,
    hasCheckmarks
  };
};
var usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {
  let isUsingPropsAndContext = false;
  for (const val in contextValue) {
    if (props[val]) {
      isUsingPropsAndContext = true;
    }
  }
  return hasMenuContext && isUsingPropsAndContext;
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/renderMenuList.js
var renderMenuList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(MenuListProvider, {
    value: contextValues.menuList,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListContextValues.js
function useMenuListContextValues_unstable(state) {
  const { checkedValues, hasCheckmarks, hasIcons, selectRadio, setFocusByFirstCharacter, toggleCheckbox } = state;
  const menuList = {
    checkedValues,
    hasCheckmarks,
    hasIcons,
    selectRadio,
    setFocusByFirstCharacter,
    toggleCheckbox
  };
  return {
    menuList
  };
}

// node_modules/@fluentui/react-menu/lib/components/MenuList/useMenuListStyles.styles.js
var menuListClassNames = {
  root: "fui-MenuList"
};
var useStyles23 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1t6b6ee"
  },
  hasMenuContext: {
    Bqenvij: "f1l02sjl"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", [".f1t6b6ee{gap:2px;}", {
    p: -1
  }], ".f1l02sjl{height:100%;}"]
});
var useMenuListStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles23();
  state.root.className = mergeClasses(menuListClassNames.root, styles.root, state.hasMenuContext && styles.hasMenuContext, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuList/MenuList.js
var MenuList = React226.forwardRef((props, ref) => {
  const state = useMenuList_unstable(props, ref);
  const contextValues = useMenuListContextValues_unstable(state);
  useMenuListStyles_unstable(state);
  useCustomStyleHook("useMenuListStyles_unstable")(state);
  return renderMenuList_unstable(state, contextValues);
});
MenuList.displayName = "MenuList";

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/MenuPopover.js
var React228 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopover.js
var React227 = __toESM(require_react());
var useMenuPopover_unstable = (props, ref) => {
  "use no memo";
  const safeZone = useMenuContext_unstable((context) => context.safeZone);
  const popoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  const open = useMenuContext_unstable((context) => context.open);
  const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
  const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
  const isSubmenu = useIsSubmenu();
  const canDispatchCustomEventRef = React227.useRef(true);
  const restoreFocusSourceAttributes = useRestoreFocusSource();
  const [setThrottleTimeout, clearThrottleTimeout] = useTimeout();
  const { dir } = useFluent();
  const CloseArrowKey = dir === "ltr" ? ArrowLeft : ArrowRight;
  const mouseOverListenerCallbackRef = React227.useCallback((node) => {
    if (node) {
      node.addEventListener("mouseover", (e) => {
        if (canDispatchCustomEventRef.current) {
          canDispatchCustomEventRef.current = false;
          dispatchMenuEnterEvent(popoverRef.current, e);
          setThrottleTimeout(() => {
            canDispatchCustomEventRef.current = true;
          }, 250);
        }
      });
    }
  }, [
    popoverRef,
    setThrottleTimeout
  ]);
  React227.useEffect(() => {
    return () => clearThrottleTimeout();
  }, [
    clearThrottleTimeout
  ]);
  var _useMenuContext_unstable;
  const inline2 = (_useMenuContext_unstable = useMenuContext_unstable((context) => context.inline)) !== null && _useMenuContext_unstable !== void 0 ? _useMenuContext_unstable : false;
  const mountNode = useMenuContext_unstable((context) => context.mountNode);
  const rootProps = slot_exports.always(getIntrinsicElementProps("div", {
    role: "presentation",
    ...restoreFocusSourceAttributes,
    ...props,
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref: useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef)
  }), {
    elementType: "div"
  });
  const { onMouseEnter: onMouseEnterOriginal, onKeyDown: onKeyDownOriginal } = rootProps;
  rootProps.onMouseEnter = useEventCallback((event) => {
    if (openOnHover || isSubmenu) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuPopoverMouseEnter",
        event
      });
    }
    onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
  });
  rootProps.onKeyDown = useEventCallback((event) => {
    const key = event.key;
    if (key === Escape || isSubmenu && key === CloseArrowKey) {
      var _popoverRef_current;
      if (open && ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(event.target)) && !event.isDefaultPrevented()) {
        setOpen(event, {
          open: false,
          keyboard: true,
          type: "menuPopoverKeyDown",
          event
        });
        event.preventDefault();
      }
    }
    if (key === Tab) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: "menuPopoverKeyDown",
        event
      });
      if (!isSubmenu) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    }
    onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
  });
  return {
    inline: inline2,
    mountNode,
    safeZone,
    components: {
      root: "div"
    },
    root: rootProps
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/useMenuPopoverStyles.styles.js
var menuPopoverClassNames = {
  root: "fui-MenuPopover"
};
var useStyles24 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    De3pzq: "fxugw4r",
    sj55zd: "f19n0e5",
    B7ck84d: "f1ewtqcl",
    Bf4jedk: "fl8fusi",
    B2u0y6b: "f1kaai3v",
    B68tc82: "f1p9o1ba",
    a9b677: "f1ahpp82",
    E5pizo: "f1hg901r",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fd3pd8h",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f9ggezi",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B93otf3: "f18k4bn6",
    vin17d: "fo1kyvf",
    Ezkn3b: "fetxo7e",
    nyiy2g: "f8x1vz1",
    swvrvq: "f8g0anz",
    Bkovbt3: "fezwn9i",
    hgjdhn: "fz5efge",
    fsy9dk: "f1ydixl4",
    B3ogreh: "f8dgqj5",
    jv49x5: "fnyfnr8",
    Bk7o48c: "fgw77r4",
    Bv12yb3: "f1noc5he",
    i09l9u: "f1k46bua",
    Bcrj8ia: "f1lhuzxm",
    Bmmhre5: "f1f9qikc"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".fl8fusi{min-width:138px;}", ".f1kaai3v{max-width:300px;}", ".f1p9o1ba{overflow-x:hidden;}", ".f1ahpp82{width:max-content;}", ".f1hg901r{box-shadow:var(--shadow16);}", [".fd3pd8h{padding:4px;}", {
    p: -1
  }], [".f9ggezi{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".f8x1vz1{--fui-positioning-slide-distance-x:0px;}", ".f8g0anz{--fui-positioning-slide-distance-y:10px;}", ".fezwn9i[data-popper-placement^=right]{--fui-positioning-slide-distance-x:-10px;}", ".fz5efge[data-popper-placement^=right]{--fui-positioning-slide-distance-y:0px;}", ".f1ydixl4[data-popper-placement^=bottom]{--fui-positioning-slide-distance-x:0px;}", ".f8dgqj5[data-popper-placement^=bottom]{--fui-positioning-slide-distance-y:-10px;}", ".fnyfnr8[data-popper-placement^=left]{--fui-positioning-slide-distance-x:10px;}", ".fgw77r4[data-popper-placement^=left]{--fui-positioning-slide-distance-y:0px;}", ".f1noc5he{animation-name:f1m0q9mo,f79suad;}"],
  k: ["@keyframes f1m0q9mo{from{opacity:-1;}to{opacity:0;}}", "@keyframes f79suad{from{transform:translate(var(--fui-positioning-slide-distance-x), var(--fui-positioning-slide-distance-y));}}"],
  m: [["@media (prefers-reduced-motion){.f1k46bua[data-popper-placement]{animation-duration:1ms;}}", {
    m: "(prefers-reduced-motion)"
  }], ["@media (prefers-reduced-motion){.f1lhuzxm[data-popper-placement]{animation-name:f1m0q9mo;}}", {
    m: "(prefers-reduced-motion)"
  }]],
  t: ["@supports not (animation-composition: accumulate){.f1f9qikc[data-popper-placement]{animation-name:f1m0q9mo;}}"]
});
var useMenuPopoverStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles24();
  state.root.className = mergeClasses(menuPopoverClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/renderMenuPopover.js
var renderMenuPopover_unstable = (state) => {
  assertSlots(state);
  if (state.inline) {
    return jsxs(import_react.Fragment, {
      children: [
        jsx(state.root, {}),
        state.safeZone
      ]
    });
  }
  return jsxs(Portal, {
    mountNode: state.mountNode,
    children: [
      jsx(state.root, {}),
      state.safeZone
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuPopover/MenuPopover.js
var MenuPopover = React228.forwardRef((props, ref) => {
  const state = useMenuPopover_unstable(props, ref);
  useMenuPopoverStyles_unstable(state);
  useCustomStyleHook("useMenuPopoverStyles_unstable")(state);
  return renderMenuPopover_unstable(state);
});
MenuPopover.displayName = "MenuPopover";

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/MenuSplitGroup.js
var React231 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroup.js
var React229 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupStyles.styles.js
var menuSplitGroupMultilineAttr = "data-multiline";
var menuSplitGroupClassNames = {
  root: "fui-MenuSplitGroup"
};
var useStyles25 = __styles2({
  root: {
    Bhlrgs3: "f1v24km9",
    mc9l5x: "f22iagw",
    rue6gn: 0,
    oe75ve: 0,
    Bbblmiw: 0,
    Bn2ps6a: "fa49so4",
    Bu15iap: ["fsdyxoe", "fuk6rhi"],
    B71tm0z: ["fn8z6db", "f1be8c1t"],
    Gjs4sj: ["f1vtn0lh", "f8hq2kl"],
    foni4y: "f7j48hl",
    Ie9k5m: "f13du8c1",
    f30fub: "fe64lw1",
    Jberyy: "f92oj5h"
  }
}, {
  d: [".f1v24km9[data-multiline]>.fui-MenuItem:nth-of-type(2){align-self:center;}", ".f22iagw{display:flex;}", [".fa49so4>.fui-MenuItem:nth-of-type(1){flex:1;}", {
    p: -1
  }], ".fsdyxoe>.fui-MenuItem:nth-of-type(2){border-top-left-radius:0;}", ".fuk6rhi>.fui-MenuItem:nth-of-type(2){border-top-right-radius:0;}", ".fn8z6db>.fui-MenuItem:nth-of-type(2){border-bottom-left-radius:0;}", ".f1be8c1t>.fui-MenuItem:nth-of-type(2){border-bottom-right-radius:0;}", ".f1vtn0lh>.fui-MenuItem:nth-of-type(2){padding-left:0;}", ".f8hq2kl>.fui-MenuItem:nth-of-type(2){padding-right:0;}", '.f7j48hl>.fui-MenuItem:nth-of-type(2)::before{content:"";}', ".f13du8c1>.fui-MenuItem:nth-of-type(2)::before{width:var(--strokeWidthThin);}", ".fe64lw1>.fui-MenuItem:nth-of-type(2)::before{height:20px;}", ".f92oj5h>.fui-MenuItem:nth-of-type(2)::before{background-color:var(--colorNeutralStroke1);}"]
});
var useMenuSplitGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles25();
  state.root.className = mergeClasses(menuSplitGroupClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroup.js
var useMenuSplitGroup_unstable = (props, ref) => {
  const innerRef = React229.useRef(void 0);
  const { dir, targetDocument } = useFluent();
  const nextArrowKey = getRTLSafeKey(ArrowRight, dir);
  const prevArrowKey = getRTLSafeKey(ArrowLeft, dir);
  const { findNextFocusable, findPrevFocusable } = useFocusFinders();
  const { multilineRef, setMultiline } = useHandleMultilineMenuItem();
  const onKeyDown = React229.useCallback((e) => {
    var _innerRef_current;
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if (!activeElement) {
      return;
    }
    if (!((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement))) {
      return;
    }
    if (e.key === nextArrowKey) {
      const next = findNextFocusable(activeElement, {
        container: innerRef.current
      });
      next === null || next === void 0 ? void 0 : next.focus();
    }
    if (e.key === prevArrowKey) {
      const prev = findPrevFocusable(activeElement, {
        container: innerRef.current
      });
      prev === null || prev === void 0 ? void 0 : prev.focus();
    }
  }, [
    findNextFocusable,
    findPrevFocusable,
    targetDocument,
    nextArrowKey,
    prevArrowKey
  ]);
  return {
    components: {
      root: "div"
    },
    setMultiline,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "group",
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef, multilineRef),
      onKeyDown,
      ...props
    }), {
      elementType: "div"
    })
  };
};
var useHandleMultilineMenuItem = () => {
  const [handle] = React229.useState(() => {
    let isMultiline = false;
    let multilineNode = null;
    function applyAttr() {
      multilineNode === null || multilineNode === void 0 ? void 0 : multilineNode.toggleAttribute(menuSplitGroupMultilineAttr, isMultiline);
    }
    return {
      multilineRef: (node) => {
        if (node) {
          multilineNode = node;
          applyAttr();
        } else {
          multilineNode = null;
        }
      },
      setMultiline: (value) => {
        isMultiline = value;
        applyAttr();
      }
    };
  });
  return handle;
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/renderMenuSplitGroup.js
var renderMenuSplitGroup_unstable = (state, contexts) => {
  assertSlots(state);
  var _contexts_menuSplitGroup;
  return jsx(MenuSplitGroupContextProvider, {
    value: (_contexts_menuSplitGroup = contexts === null || contexts === void 0 ? void 0 : contexts.menuSplitGroup) !== null && _contexts_menuSplitGroup !== void 0 ? _contexts_menuSplitGroup : menuSplitGroupContextDefaultValue,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/useMenuSplitGroupContextValues.js
var React230 = __toESM(require_react());
var useMenuSplitGroupContextValues = (state) => {
  "use no memo";
  return React230.useMemo(() => {
    return {
      menuSplitGroup: {
        setMultiline: state.setMultiline
      }
    };
  }, [
    state.setMultiline
  ]);
};

// node_modules/@fluentui/react-menu/lib/components/MenuSplitGroup/MenuSplitGroup.js
var MenuSplitGroup = React231.forwardRef((props, ref) => {
  const state = useMenuSplitGroup_unstable(props, ref);
  useMenuSplitGroupStyles_unstable(state);
  useCustomStyleHook("useMenuSplitGroupStyles_unstable")(state);
  return renderMenuSplitGroup_unstable(state, useMenuSplitGroupContextValues(state));
});
MenuSplitGroup.displayName = "MenuSplitGroup";

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/MenuTrigger.js
var React234 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/useMenuTrigger.js
var React232 = __toESM(require_react());
function noop3() {
}
var useMenuTrigger_unstable = (props) => {
  const { children, disableButtonEnhancement = false } = props;
  const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
  const menuPopoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
  const setOpen = useMenuContext_unstable((context) => context.setOpen);
  const open = useMenuContext_unstable((context) => context.open);
  const triggerId = useMenuContext_unstable((context) => context.triggerId);
  const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
  const openOnContext = useMenuContext_unstable((context) => context.openOnContext);
  const isSubmenu = useIsSubmenu();
  const { findFirstFocusable } = useFocusFinders();
  const focusFirst = React232.useCallback(() => {
    const firstFocusable = findFirstFocusable(menuPopoverRef.current);
    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
  }, [
    findFirstFocusable,
    menuPopoverRef
  ]);
  const openedWithKeyboardRef = React232.useRef(false);
  const openedViaSafeZoneRef = React232.useRef(false);
  const hasMouseMovedRef = React232.useRef(false);
  const { dir } = useFluent();
  const OpenArrowKey = dir === "ltr" ? ArrowRight : ArrowLeft;
  const child = getTriggerChild(children);
  const safeZoneHandlerRef = useOnMenuSafeZoneTimeout(useEventCallback(() => {
    if (isSubmenu) {
      openedViaSafeZoneRef.current = true;
    }
  }));
  const onContextMenu = (event) => {
    if (isTargetDisabled(event) || event.isDefaultPrevented()) {
      return;
    }
    if (openOnContext) {
      event.preventDefault();
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuTriggerContextMenu",
        event
      });
    }
  };
  const onClick = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (!openOnContext) {
      setOpen(event, {
        open: !open,
        keyboard: openedWithKeyboardRef.current,
        type: "menuTriggerClick",
        event
      });
      openedWithKeyboardRef.current = false;
    }
  };
  const onKeyDown = (event) => {
    if (isTargetDisabled(event) || event.isDefaultPrevented()) {
      return;
    }
    const key = event.key;
    if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === ArrowDown)) {
      setOpen(event, {
        open: true,
        keyboard: true,
        type: "menuTriggerKeyDown",
        event
      });
    }
    if (key === Escape && !isSubmenu) {
      setOpen(event, {
        open: false,
        keyboard: true,
        type: "menuTriggerKeyDown",
        event
      });
    }
    if (open && key === OpenArrowKey && isSubmenu) {
      focusFirst();
    }
  };
  const onMouseOver = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover) {
      if (hasMouseMovedRef.current) {
        setOpen(event, {
          open: true,
          keyboard: false,
          type: "menuTriggerMouseEnter",
          event
        });
      } else if (openedViaSafeZoneRef.current) {
        setOpen(event, {
          open: true,
          keyboard: false,
          ignoreHoverDelay: true,
          type: "menuTriggerMouseEnter",
          event
        });
        openedViaSafeZoneRef.current = false;
      }
    }
  };
  const onMouseMove = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover && !hasMouseMovedRef.current) {
      setOpen(event, {
        open: true,
        keyboard: false,
        type: "menuTriggerMouseMove",
        event
      });
      hasMouseMovedRef.current = true;
    }
  };
  const onMouseLeave = (event) => {
    if (isTargetDisabled(event)) {
      return;
    }
    if (openOnHover) {
      setOpen(event, {
        open: false,
        keyboard: false,
        type: "menuTriggerMouseLeave",
        event
      });
    }
  };
  var _child_props_onMouseEnter;
  const contextMenuProps = {
    id: triggerId,
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: useMergedRefs(triggerRef, getReactElementRef(child), safeZoneHandlerRef),
    onMouseEnter: useEventCallback((_child_props_onMouseEnter = child === null || child === void 0 ? void 0 : child.props.onMouseEnter) !== null && _child_props_onMouseEnter !== void 0 ? _child_props_onMouseEnter : noop3),
    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
    onMouseMove: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove)),
    onMouseOver: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseOver, onMouseOver))
  };
  const triggerChildProps = {
    "aria-haspopup": "menu",
    "aria-expanded": !open && !isSubmenu ? void 0 : open,
    ...contextMenuProps,
    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
  return {
    isSubmenu,
    children: applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};
var isTargetDisabled = (event) => {
  const isDisabled = (el) => el.hasAttribute("disabled") || el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") === "true";
  if (isHTMLElement(event.target) && isDisabled(event.target)) {
    return true;
  }
  return isHTMLElement(event.currentTarget) && isDisabled(event.currentTarget);
};

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/renderMenuTrigger.js
var React233 = __toESM(require_react());
var renderMenuTrigger_unstable = (state) => {
  return React233.createElement(MenuTriggerContextProvider, {
    value: state.isSubmenu
  }, state.children);
};

// node_modules/@fluentui/react-menu/lib/components/MenuTrigger/MenuTrigger.js
var MenuTrigger = (props) => {
  const state = useMenuTrigger_unstable(props);
  return renderMenuTrigger_unstable(state);
};
MenuTrigger.displayName = "MenuTrigger";
MenuTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/MenuItemLink.js
var React236 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLink.js
var React235 = __toESM(require_react());
var useMenuItemLink_unstable = (props, ref) => {
  const baseState = useMenuItem_unstable(props, null);
  const _props = {
    ...props,
    ...baseState.root,
    ref,
    tabIndex: props.tabIndex
  };
  return {
    ...baseState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      root: "a"
    },
    root: slot_exports.always(getIntrinsicElementProps("a", {
      role: "menuitem",
      ..._props
    }), {
      elementType: "a"
    })
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/renderMenuItemLink.js
var renderMenuItemLink_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.icon && jsx(state.icon, {}),
      state.content && jsx(state.content, {}),
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/useMenuItemLinkStyles.styles.js
var menuItemLinkClassNames = {
  root: "fui-MenuItemLink",
  icon: "fui-MenuItemLink__icon",
  checkmark: "fui-MenuItemLink__checkmark",
  content: "fui-MenuItemLink__content",
  secondaryContent: "fui-MenuItemLink__secondaryContent"
};
var useStyles26 = __styles2({
  resetLink: {
    w71qe1: "f1iuv45f",
    Bkioxbp: "f9pkogg",
    I8pafv: "foe20s3",
    dvvfom: "f1kn6jj"
  }
}, {
  d: [".f1iuv45f{text-decoration-line:none;}", ".f9pkogg{text-decoration-thickness:initial;}", ".foe20s3{text-decoration-style:initial;}", ".f1kn6jj{text-decoration-color:initial;}"]
});
var useMenuItemLinkStyles_unstable = (state) => {
  "use no memo";
  useMenuItemStyles_unstable(state);
  const styles = useStyles26();
  state.root.className = mergeClasses(menuItemLinkClassNames.root, styles.resetLink, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemLinkClassNames.icon, state.icon.className);
  }
  if (state.content) {
    state.content.className = mergeClasses(menuItemLinkClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemLinkClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(menuItemLinkClassNames.checkmark, state.checkmark.className);
  }
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemLink/MenuItemLink.js
var MenuItemLink = React236.forwardRef((props, ref) => {
  const state = useMenuItemLink_unstable(props, ref);
  useMenuItemLinkStyles_unstable(state);
  useCustomStyleHook("useMenuItemLinkStyles_unstable")(state);
  return renderMenuItemLink_unstable(state);
});
MenuItemLink.displayName = "MenuItemLink";

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/MenuItemSwitch.js
var React238 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitch.js
var React237 = __toESM(require_react());

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitchStyles.styles.js
var menuItemSwitchClassNames = {
  root: "fui-MenuItemSwitch",
  icon: "fui-MenuItemSwitch__icon",
  content: "fui-MenuItemSwitch__content",
  secondaryContent: "fui-MenuItemSwitch__secondaryContent",
  switchIndicator: "fui-MenuItemSwitch__switchIndicator",
  subText: "fui-MenuItemSwitch__subText"
};
var circleFilledClassName = "fui-MenuItemSwitch__switchIndicator__circleFilled";
var spaceBetweenThumbAndTrack = 2;
var trackHeight = 20;
var thumbSize = trackHeight - spaceBetweenThumbAndTrack;
var useSwitchIndicatorBaseClassName = __resetStyles("r1x31n8g", "rsmcm5v", {
  r: [".r1x31n8g{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-right:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}", ".r1x31n8g:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r1x31n8g:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}", ".rsmcm5v{border-radius:var(--borderRadiusCircular);border:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;margin-left:var(--spacingHorizontalXS);color:var(--colorNeutralStrokeAccessible);}", ".rsmcm5v:hover{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsmcm5v:hover:active{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1x31n8g{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1x31n8g .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rsmcm5v{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rsmcm5v .fui-MenuItemSwitch__switchIndicator__circleFilled{transition-duration:0.01ms;}}"]
});
var useSwitchIndicatorStyles = __styles2({
  checked: {
    G4r02d: ["fdca5i2", "fk0rr1z"],
    De3pzq: "ftywsgz",
    sj55zd: "fqpbvvt",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    Bi91k9c: "fz46y8r",
    Jwef8y: "f1kjrvvj",
    Bgoe8wy: "fpa59ij",
    Bwzppfd: ["f1rhln42", "f1l1ogpg"],
    oetu4i: "fz67qlh",
    gg5e9n: ["f1l1ogpg", "f1rhln42"],
    B2d53fq: "frlnr8d",
    iro3zm: "fle2s0s",
    b661bw: "f1j8ziw4",
    Bk6r4ia: ["f1xzu9i0", "f1jlpvxk"],
    B9zn80p: "f1i1ccxp",
    Bpld233: ["f1jlpvxk", "f1xzu9i0"]
  }
}, {
  d: [".fdca5i2 .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(20px);}", ".fk0rr1z .fui-MenuItemSwitch__switchIndicator__circleFilled{transform:translateX(-20px);}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}"],
  h: [".fz46y8r:hover{color:var(--colorNeutralForegroundInverted);}", ".f1kjrvvj:hover{background-color:var(--colorCompoundBrandBackgroundHover);}", ".fpa59ij:hover{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f1rhln42:hover{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f1l1ogpg:hover{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fz67qlh:hover{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".frlnr8d:hover:active{color:var(--colorNeutralForegroundInverted);}", ".fle2s0s:hover:active{background-color:var(--colorCompoundBrandBackgroundPressed);}", ".f1j8ziw4:hover:active{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f1xzu9i0:hover:active{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f1jlpvxk:hover:active{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1i1ccxp:hover:active{border-bottom-color:var(--colorTransparentStrokeInteractive);}"]
});
var useMultilineStyles2 = __styles2({
  "switch": {
    qb2dma: "f7nlbp4"
  }
}, {
  d: [".f7nlbp4{align-self:center;}"]
});
var useMenuItemSwitchStyles_unstable = (state) => {
  "use no memo";
  const {
    checked,
    subText
  } = state;
  const multiline = !!subText;
  const switchIndicatorStyles = useSwitchIndicatorStyles();
  const switchIndicatorBaseStyles = useSwitchIndicatorBaseClassName();
  const multilineStyles = useMultilineStyles2();
  state.root.className = mergeClasses(menuItemSwitchClassNames.root, state.root.className);
  if (state.content) {
    state.content.className = mergeClasses(menuItemSwitchClassNames.content, state.content.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(menuItemSwitchClassNames.secondaryContent, state.secondaryContent.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(menuItemSwitchClassNames.icon, state.icon.className);
  }
  if (state.subText) {
    state.subText.className = mergeClasses(menuItemSwitchClassNames.subText, state.subText.className);
  }
  if (state.switchIndicator) {
    state.switchIndicator.className = mergeClasses(menuItemSwitchClassNames.switchIndicator, switchIndicatorBaseStyles, checked && switchIndicatorStyles.checked, state.switchIndicator.className, multiline && multilineStyles.switch);
  }
  useMenuItemStyles_unstable({
    ...state,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...state.components,
      checkmark: "span",
      submenuIndicator: "span"
    },
    checkmark: void 0,
    submenuIndicator: void 0,
    hasSubmenu: false,
    persistOnClick: true
  });
  return state;
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/useMenuItemSwitch.js
var useMenuItemSwitch_unstable = (props, ref) => {
  const state = useMenuItemSwitchBase_unstable(props, ref);
  if (state.switchIndicator) {
    var _state_switchIndicator;
    var _children;
    (_children = (_state_switchIndicator = state.switchIndicator).children) !== null && _children !== void 0 ? _children : _state_switchIndicator.children = React237.createElement(CircleFilled, {
      className: circleFilledClassName
    });
  }
  return state;
};
var useMenuItemSwitchBase_unstable = (props, ref) => {
  const baseState = useMenuItemCheckboxBase_unstable(props, ref);
  return {
    ...baseState,
    switchIndicator: slot_exports.optional(props.switchIndicator, {
      renderByDefault: true,
      elementType: "span"
    }),
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      switchIndicator: "span"
    }
  };
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/renderMenuItemSwitch.js
var renderMenuItemSwitch_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.content && jsxs(state.content, {
        children: [
          state.content.children,
          state.subText && jsx(state.subText, {})
        ]
      }),
      state.secondaryContent && jsx(state.secondaryContent, {}),
      state.switchIndicator && jsx(state.switchIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-menu/lib/components/MenuItemSwitch/MenuItemSwitch.js
var MenuItemSwitch = React238.forwardRef((props, ref) => {
  const state = useMenuItemSwitch_unstable(props, ref);
  useMenuItemSwitchStyles_unstable(state);
  useCustomStyleHook("useMenuItemSwitchStyles_unstable")(state);
  return renderMenuItemSwitch_unstable(state);
});
MenuItemSwitch.displayName = "MenuItemSwitch";

// node_modules/@fluentui/react-persona/lib/components/Persona/Persona.js
var React240 = __toESM(require_react());

// node_modules/@fluentui/react-persona/lib/components/Persona/renderPersona.js
var renderPersona_unstable = (state) => {
  const { presenceOnly, textPosition } = state;
  assertSlots(state);
  const coin = presenceOnly ? state.presence && jsx(state.presence, {}) : state.avatar && jsx(state.avatar, {});
  return jsxs(state.root, {
    children: [
      (textPosition === "after" || textPosition === "below") && coin,
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {}),
      state.tertiaryText && jsx(state.tertiaryText, {}),
      state.quaternaryText && jsx(state.quaternaryText, {}),
      textPosition === "before" && coin
    ]
  });
};

// node_modules/@fluentui/react-persona/lib/components/Persona/usePersona.js
var React239 = __toESM(require_react());
var usePersona_unstable = (props, ref) => {
  const { name, presenceOnly = false, size: size3 = "medium", textAlignment = "start", textPosition = "after" } = props;
  const primaryText = slot_exports.optional(props.primaryText, {
    renderByDefault: true,
    defaultProps: {
      children: name
    },
    elementType: "span"
  });
  const secondaryText = slot_exports.optional(props.secondaryText, {
    elementType: "span"
  });
  const tertiaryText = slot_exports.optional(props.tertiaryText, {
    elementType: "span"
  });
  const quaternaryText = slot_exports.optional(props.quaternaryText, {
    elementType: "span"
  });
  const numTextLines = [
    primaryText,
    secondaryText,
    tertiaryText,
    quaternaryText
  ].filter(Boolean).length;
  return {
    numTextLines,
    presenceOnly,
    size: size3,
    textAlignment,
    textPosition,
    components: {
      root: "div",
      avatar: Avatar,
      presence: PresenceBadge,
      primaryText: "span",
      secondaryText: "span",
      tertiaryText: "span",
      quaternaryText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(
      "div",
      {
        ...props,
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref
      },
      /* excludedPropNames */
      [
        "name"
      ]
    ), {
      elementType: "div"
    }),
    avatar: !presenceOnly ? slot_exports.optional(props.avatar, {
      renderByDefault: true,
      defaultProps: {
        name,
        badge: props.presence,
        size: avatarSizes[size3]
      },
      elementType: Avatar
    }) : void 0,
    presence: presenceOnly ? slot_exports.optional(props.presence, {
      defaultProps: {
        size: presenceSizes[size3]
      },
      elementType: PresenceBadge
    }) : void 0,
    primaryText,
    secondaryText,
    tertiaryText,
    quaternaryText
  };
};
var presenceSizes = {
  "extra-small": "tiny",
  small: "extra-small",
  medium: "small",
  large: "medium",
  "extra-large": "large",
  huge: "large"
};
var avatarSizes = {
  "extra-small": 20,
  small: 28,
  medium: 32,
  large: 36,
  "extra-large": 40,
  huge: 56
};

// node_modules/@fluentui/react-persona/lib/components/Persona/usePersonaStyles.styles.js
var personaClassNames = {
  root: "fui-Persona",
  avatar: "fui-Persona__avatar",
  presence: "fui-Persona__presence",
  primaryText: "fui-Persona__primaryText",
  secondaryText: "fui-Persona__secondaryText",
  tertiaryText: "fui-Persona__tertiaryText",
  quaternaryText: "fui-Persona__quaternaryText"
};
var useRootClassName5 = __resetStyles("rlroi9i", null, [".rlroi9i{display:inline-grid;grid-auto-rows:max-content;grid-auto-flow:column;justify-items:start;grid-template-columns:max-content [middle] auto;}"]);
var useStyles27 = __styles2({
  beforeAfterCenter: {
    wkccdc: "f1iantul"
  },
  after: {},
  before: {
    B7hvi0a: "f1tll2w5",
    Budl1dq: "ffvkwdr"
  },
  below: {
    Bxotwcr: "f1nkeedh",
    B7hvi0a: "f1oiokrs",
    Budl1dq: "f1emgwh2"
  },
  media: {
    Ijaq50: "f1hek2iy"
  },
  mediaBeforeAfterCenter: {
    Ijaq50: "fa4dipu"
  },
  start: {
    qb2dma: "f9h729m"
  },
  center: {
    qb2dma: "f7nlbp4"
  },
  afterAlignToPrimary: {
    qb2dma: "f7nlbp4",
    Ijaq50: "f1rnkkuc",
    Bw0ie65: "f1warjpf"
  },
  beforeAlignToPrimary: {
    qb2dma: "f7nlbp4",
    Ijaq50: "f1rnkkuc",
    Br312pm: "fwu52yu"
  },
  secondLineSpacing: {
    B6of3ja: "f1ryq6si"
  },
  primary: {
    Ijaq50: "f1q3ipgb"
  },
  secondary: {
    Ijaq50: "f3drtdk"
  },
  tertiary: {
    Ijaq50: "fa1o6s1"
  },
  quaternary: {
    Ijaq50: "f1tuwaia"
  }
}, {
  d: [".f1iantul{grid-template-rows:1fr [primary] max-content [secondary] max-content [tertiary] max-content [quaternary] max-content 1fr;}", ".f1tll2w5{justify-items:end;}", ".ffvkwdr{grid-template-columns:auto [middle] max-content;}", ".f1nkeedh{grid-auto-flow:unset;}", ".f1oiokrs{justify-items:center;}", ".f1emgwh2{grid-template-columns:unset;}", ".f1hek2iy{grid-row-start:span 5;}", ".fa4dipu{grid-row-start:span 6;}", ".f9h729m{align-self:start;}", ".f7nlbp4{align-self:center;}", ".f1rnkkuc{grid-row-start:unset;}", ".f1warjpf{grid-column-end:middle;}", ".fwu52yu{grid-column-start:middle;}", ".f1ryq6si{margin-top:-2px;}", ".f1q3ipgb{grid-row-start:primary;}", ".f3drtdk{grid-row-start:secondary;}", ".fa1o6s1{grid-row-start:tertiary;}", ".f1tuwaia{grid-row-start:quaternary;}"]
});
var useAvatarSpacingStyles = __styles2({
  "extra-small": {
    Bs1gm4r: "f1e48tse"
  },
  small: {
    Bs1gm4r: "f18q9vkd"
  },
  medium: {
    Bs1gm4r: "f18q9vkd"
  },
  large: {
    Bs1gm4r: "fx34bi6"
  },
  "extra-large": {
    Bs1gm4r: "fx34bi6"
  },
  huge: {
    Bs1gm4r: "f1o96qtm"
  },
  after: {
    t21cq0: ["f103ycu4", "f1tao51"]
  },
  below: {
    jrapky: "fbo7acy"
  },
  before: {
    Frg6f3: ["f1tao51", "f103ycu4"]
  }
}, {
  d: [".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}", ".f18q9vkd{--fui-Persona__avatar--spacing:var(--spacingHorizontalS);}", ".fx34bi6{--fui-Persona__avatar--spacing:var(--spacingHorizontalMNudge);}", ".f1o96qtm{--fui-Persona__avatar--spacing:var(--spacingHorizontalM);}", ".f103ycu4{margin-right:var(--fui-Persona__avatar--spacing);}", ".f1tao51{margin-left:var(--fui-Persona__avatar--spacing);}", ".fbo7acy{margin-bottom:var(--fui-Persona__avatar--spacing);}"]
});
var usePresenceSpacingStyles = __styles2({
  small: {
    Bs1gm4r: "f1e48tse"
  }
}, {
  d: [".f1e48tse{--fui-Persona__avatar--spacing:var(--spacingHorizontalSNudge);}"]
});
var usePersonaStyles_unstable = (state) => {
  "use no memo";
  const {
    presenceOnly,
    size: size3,
    textAlignment,
    textPosition
  } = state;
  const alignToPrimary = presenceOnly && textAlignment === "start" && size3 !== "extra-large" && size3 !== "huge";
  const alignBeforeAfterCenter = textPosition !== "below" && textAlignment === "center";
  const {
    primaryTextClassName,
    optionalTextClassName
  } = useTextClassNames(state, alignToPrimary);
  const rootClassName = useRootClassName5();
  const styles = useStyles27();
  const avatarSpacingStyles = useAvatarSpacingStyles();
  const presenceSpacingStyles = {
    ...avatarSpacingStyles,
    ...usePresenceSpacingStyles()
  };
  state.root.className = mergeClasses(personaClassNames.root, rootClassName, alignBeforeAfterCenter && styles.beforeAfterCenter, styles[textPosition], state.root.className);
  if (state.avatar) {
    state.avatar.className = mergeClasses(personaClassNames.avatar, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], avatarSpacingStyles[size3], avatarSpacingStyles[textPosition], state.avatar.className);
  }
  if (state.presence) {
    state.presence.className = mergeClasses(personaClassNames.presence, textPosition !== "below" && styles.media, alignBeforeAfterCenter && styles.mediaBeforeAfterCenter, styles[textAlignment], presenceSpacingStyles[size3], presenceSpacingStyles[textPosition], textPosition === "after" && alignToPrimary && styles.afterAlignToPrimary, textPosition === "before" && alignToPrimary && styles.beforeAlignToPrimary, state.presence.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(personaClassNames.primaryText, alignBeforeAfterCenter && styles.primary, primaryTextClassName, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(personaClassNames.secondaryText, alignBeforeAfterCenter && styles.secondary, optionalTextClassName, styles.secondLineSpacing, state.secondaryText.className);
  }
  if (state.tertiaryText) {
    state.tertiaryText.className = mergeClasses(personaClassNames.tertiaryText, alignBeforeAfterCenter && styles.tertiary, optionalTextClassName, state.tertiaryText.className);
  }
  if (state.quaternaryText) {
    state.quaternaryText.className = mergeClasses(personaClassNames.quaternaryText, alignBeforeAfterCenter && styles.quaternary, optionalTextClassName, state.quaternaryText.className);
  }
  return state;
};
var usePrimaryTextBaseClassName = __resetStyles("rvj41k9", null, [".rvj41k9{display:block;color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}"]);
var useOptionalTextBaseClassName = __resetStyles("rp1pf9e", null, [".rp1pf9e{display:block;color:var(--colorNeutralForeground2);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useTextStyles = __styles2({
  beforeAlignToPrimary: {
    Bw0ie65: "f1warjpf"
  },
  afterAlignToPrimary: {
    Br312pm: "fwu52yu"
  },
  body1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  caption1: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  subtitle2: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f1warjpf{grid-column-end:middle;}", ".fwu52yu{grid-column-start:middle;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});
var useTextClassNames = (state, alignToPrimary) => {
  const {
    presenceOnly,
    size: size3,
    textPosition
  } = state;
  const primaryTextBaseClassName = usePrimaryTextBaseClassName();
  const optionalTextBaseClassName = useOptionalTextBaseClassName();
  const textStyles = useTextStyles();
  let primaryTextSize;
  let alignToPrimaryClassName;
  if (presenceOnly) {
    if (size3 === "extra-small") {
      primaryTextSize = state.numTextLines <= 1 && textStyles.caption1;
    } else if (size3 === "extra-large" || size3 === "huge") {
      primaryTextSize = textStyles.subtitle2;
    }
    if (alignToPrimary) {
      if (textPosition === "before") {
        alignToPrimaryClassName = textStyles.beforeAlignToPrimary;
      } else if (textPosition === "after") {
        alignToPrimaryClassName = textStyles.afterAlignToPrimary;
      }
    }
  } else {
    if (size3 === "huge") {
      primaryTextSize = textStyles.subtitle2;
    } else if (size3 === "extra-large") {
      primaryTextSize = textStyles.subtitle2;
    }
  }
  return {
    primaryTextClassName: mergeClasses(primaryTextBaseClassName, primaryTextSize, alignToPrimaryClassName),
    optionalTextClassName: mergeClasses(optionalTextBaseClassName, !presenceOnly && size3 === "huge" && textStyles.body1, alignToPrimaryClassName)
  };
};

// node_modules/@fluentui/react-persona/lib/components/Persona/Persona.js
var Persona = React240.forwardRef((props, ref) => {
  const state = usePersona_unstable(props, ref);
  usePersonaStyles_unstable(state);
  useCustomStyleHook("usePersonaStyles_unstable")(state);
  return renderPersona_unstable(state);
});
Persona.displayName = "Persona";

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var React244 = __toESM(require_react());

// node_modules/@fluentui/react-radio/lib/contexts/RadioGroupContext.js
var React241 = __toESM(require_react());
var RadioGroupContext = React241.createContext(void 0);
var radioGroupContextDefaultValue = {};
var RadioGroupProvider = RadioGroupContext.Provider;
var useRadioGroupContextValue_unstable = () => React241.useContext(RadioGroupContext) || radioGroupContextDefaultValue;
var useRadioGroupContext_unstable = (selector) => selector(useRadioGroupContextValue_unstable());

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/renderRadioGroup.js
var renderRadioGroup_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RadioGroupContext.Provider, {
    value: contextValues.radioGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroup.js
var React242 = __toESM(require_react());
var useRadioGroup_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props);
  const generatedName = useId2("radiogroup-");
  const { name = generatedName, value, defaultValue, disabled, layout = "vertical", onChange, required } = props;
  return {
    layout,
    name,
    value,
    defaultValue,
    disabled,
    required,
    components: {
      root: "div"
    },
    root: {
      ref,
      role: "radiogroup",
      ...slot_exports.always(getIntrinsicElementProps(
        "div",
        props,
        /*excludedPropNames:*/
        [
          "onChange",
          "name"
        ]
      ), {
        elementType: "div"
      }),
      onChange: useEventCallback((ev) => {
        if (onChange && isHTMLElement(ev.target, {
          constructorName: "HTMLInputElement"
        }) && ev.target.type === "radio") {
          onChange(ev, {
            value: ev.target.value
          });
        }
      })
    }
  };
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/useRadioGroupStyles.styles.js
var radioGroupClassNames = {
  root: "fui-RadioGroup"
};
var useStyles28 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f6jr5hl"
  },
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f6jr5hl{align-items:flex-start;}", ".f1vx9l62{flex-direction:column;}"]
});
var useRadioGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles28();
  state.root.className = mergeClasses(radioGroupClassNames.root, styles.root, state.layout === "vertical" && styles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-radio/lib/contexts/useRadioGroupContextValues.js
var React243 = __toESM(require_react());
var useRadioGroupContextValues = (state) => {
  const { name, value, defaultValue, disabled, layout, required } = state;
  const ariaDescribedBy = state.root["aria-describedby"];
  const radioGroup = React243.useMemo(() => ({
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    "aria-describedby": ariaDescribedBy
  }), [
    name,
    value,
    defaultValue,
    disabled,
    layout,
    required,
    ariaDescribedBy
  ]);
  return {
    radioGroup
  };
};

// node_modules/@fluentui/react-radio/lib/components/RadioGroup/RadioGroup.js
var RadioGroup = React244.forwardRef((props, ref) => {
  const state = useRadioGroup_unstable(props, ref);
  const contextValues = useRadioGroupContextValues(state);
  useRadioGroupStyles_unstable(state);
  useCustomStyleHook("useRadioGroupStyles_unstable")(state);
  return renderRadioGroup_unstable(state, contextValues);
});
RadioGroup.displayName = "RadioGroup";

// node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var React246 = __toESM(require_react());

// node_modules/@fluentui/react-radio/lib/components/Radio/renderRadio.js
var renderRadio_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.indicator, {}),
      state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-radio/lib/components/Radio/useRadio.js
var React245 = __toESM(require_react());
var useRadio_unstable = (props, ref) => {
  const group = useRadioGroupContextValue_unstable();
  const { name = group.name, checked = group.value !== void 0 ? group.value === props.value : void 0, defaultChecked = group.defaultValue !== void 0 ? group.defaultValue === props.value : void 0, labelPosition = group.layout === "horizontal-stacked" ? "below" : "after", disabled = group.disabled, required = group.required, "aria-describedby": ariaDescribedBy = group["aria-describedby"], onChange } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "onChange"
    ]
  });
  const root = slot_exports.always(props.root, {
    defaultProps: {
      ref: useFocusWithin(),
      ...nativeProps.root
    },
    elementType: "span"
  });
  const input = slot_exports.always(props.input, {
    defaultProps: {
      ref,
      type: "radio",
      id: useId2("radio-", nativeProps.primary.id),
      name,
      checked,
      defaultChecked,
      disabled,
      required,
      "aria-describedby": ariaDescribedBy,
      ...nativeProps.primary
    },
    elementType: "input"
  });
  input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
    value: ev.currentTarget.value
  }));
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      htmlFor: input.id,
      disabled: input.disabled
    },
    elementType: Label
  });
  const indicator = slot_exports.always(props.indicator, {
    defaultProps: {
      "aria-hidden": true
    },
    elementType: "div"
  });
  return {
    labelPosition,
    components: {
      root: "span",
      input: "input",
      label: Label,
      indicator: "div"
    },
    root,
    input,
    label,
    indicator
  };
};

// node_modules/@fluentui/react-radio/lib/components/Radio/useRadioStyles.styles.js
var radioClassNames = {
  root: "fui-Radio",
  indicator: "fui-Radio__indicator",
  input: "fui-Radio__input",
  label: "fui-Radio__label"
};
var useRootBaseClassName3 = __resetStyles("r1siqwd8", "rmnplyc", {
  r: [".r1siqwd8{display:inline-flex;position:relative;}", ".r1siqwd8:focus{outline-style:none;}", ".r1siqwd8:focus-visible{outline-style:none;}", ".r1siqwd8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1siqwd8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rmnplyc{display:inline-flex;position:relative;}", ".rmnplyc:focus{outline-style:none;}", ".rmnplyc:focus-visible{outline-style:none;}", ".rmnplyc[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rmnplyc[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1siqwd8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmnplyc[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles9 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f122n59{align-items:center;}"]
});
var useInputBaseClassName2 = __resetStyles("rg1upok", "rzwdzb4", {
  r: [".rg1upok{position:absolute;left:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".rg1upok:enabled{cursor:pointer;}", ".rg1upok:enabled~.fui-Radio__label{cursor:pointer;}", ".rg1upok:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".rg1upok:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".rg1upok:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rg1upok:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rg1upok:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rg1upok:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".rg1upok:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".rg1upok:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".rg1upok:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".rg1upok:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}", ".rzwdzb4{position:absolute;right:0;top:0;width:calc(16px + 2 * var(--spacingHorizontalS));height:100%;box-sizing:border-box;margin:0;opacity:0;}", ".rzwdzb4:enabled{cursor:pointer;}", ".rzwdzb4:enabled~.fui-Radio__label{cursor:pointer;}", ".rzwdzb4:enabled:not(:checked)~.fui-Radio__label{color:var(--colorNeutralForeground3);}", ".rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessible);}", ".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__label{color:var(--colorNeutralForeground2);}", ".rzwdzb4:enabled:not(:checked):hover~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rzwdzb4:enabled:not(:checked):hover:active~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rzwdzb4:enabled:checked~.fui-Radio__label{color:var(--colorNeutralForeground1);}", ".rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStroke);color:var(--colorCompoundBrandForeground1);}", ".rzwdzb4:enabled:checked:hover~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokeHover);color:var(--colorCompoundBrandForeground1Hover);}", ".rzwdzb4:enabled:checked:hover:active~.fui-Radio__indicator{border-color:var(--colorCompoundBrandStrokePressed);color:var(--colorCompoundBrandForeground1Pressed);}", ".rzwdzb4:disabled~.fui-Radio__label{color:var(--colorNeutralForegroundDisabled);cursor:default;}", ".rzwdzb4:disabled~.fui-Radio__indicator{border-color:var(--colorNeutralStrokeDisabled);color:var(--colorNeutralForegroundDisabled);}"],
  s: ["@media (forced-colors: active){.rg1upok:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}", "@media (forced-colors: active){.rg1upok:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rg1upok:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}", "@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__label{color:GrayText;}}", "@media (forced-colors: active){.rg1upok:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rg1upok:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}", "@media (forced-colors: active){.rzwdzb4:enabled:not(:checked)~.fui-Radio__indicator{border-color:ButtonBorder;}}", "@media (forced-colors: active){.rzwdzb4:enabled:checked~.fui-Radio__indicator{border-color:Highlight;color:Highlight;}.rzwdzb4:enabled:checked~.fui-Radio__indicator::after{background-color:Highlight;}}", "@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__label{color:GrayText;}}", "@media (forced-colors: active){.rzwdzb4:disabled~.fui-Radio__indicator{border-color:GrayText;color:GrayText;}.rzwdzb4:disabled~.fui-Radio__indicator::after{background-color:GrayText;}}"]
});
var useInputStyles3 = __styles2({
  below: {
    a9b677: "fly5x3f",
    Bqenvij: "f1je6zif"
  },
  defaultIndicator: {
    Blbys7f: "f9ma1gx"
  },
  customIndicator: {
    Bj53wkj: "f12zxao0"
  }
}, {
  d: [".fly5x3f{width:100%;}", ".f1je6zif{height:calc(16px + 2 * var(--spacingVerticalS));}", '.f9ma1gx:checked~.fui-Radio__indicator::after{content:"";}', ".f12zxao0:not(:checked)~.fui-Radio__indicator>*{opacity:0;}"]
});
var useIndicatorBaseClassName2 = __resetStyles("rwtekvw", null, [".rwtekvw{position:relative;width:16px;height:16px;font-size:12px;box-sizing:border-box;flex-shrink:0;display:flex;align-items:center;justify-content:center;overflow:hidden;border:var(--strokeWidthThin) solid;border-radius:var(--borderRadiusCircular);margin:var(--spacingVerticalS) var(--spacingHorizontalS);fill:currentColor;pointer-events:none;}", ".rwtekvw::after{position:absolute;width:16px;height:16px;border-radius:var(--borderRadiusCircular);transform:scale(0.625);background-color:currentColor;}"]);
var useLabelStyles3 = __styles2({
  base: {
    qb2dma: "f7nlbp4",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"],
    B6of3ja: "fjzwpt6",
    jrapky: "fh6j2fo"
  },
  below: {
    z8tnut: "f1ywm7hm",
    fsow6f: "f17mccla"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fjzwpt6{margin-top:calc((16px - var(--lineHeightBase300)) / 2);}", ".fh6j2fo{margin-bottom:calc((16px - var(--lineHeightBase300)) / 2);}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f17mccla{text-align:center;}"]
});
var useRadioStyles_unstable = (state) => {
  "use no memo";
  const {
    labelPosition
  } = state;
  const rootBaseClassName = useRootBaseClassName3();
  const rootStyles = useRootStyles9();
  state.root.className = mergeClasses(radioClassNames.root, rootBaseClassName, labelPosition === "below" && rootStyles.vertical, state.root.className);
  const inputBaseClassName = useInputBaseClassName2();
  const inputStyles = useInputStyles3();
  state.input.className = mergeClasses(radioClassNames.input, inputBaseClassName, labelPosition === "below" && inputStyles.below, state.indicator.children ? inputStyles.customIndicator : inputStyles.defaultIndicator, state.input.className);
  const indicatorBaseClassName = useIndicatorBaseClassName2();
  state.indicator.className = mergeClasses(radioClassNames.indicator, indicatorBaseClassName, state.indicator.className);
  const labelStyles = useLabelStyles3();
  if (state.label) {
    state.label.className = mergeClasses(radioClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-radio/lib/components/Radio/Radio.js
var Radio = React246.forwardRef((props, ref) => {
  const state = useRadio_unstable(props, ref);
  useRadioStyles_unstable(state);
  useCustomStyleHook("useRadioStyles_unstable")(state);
  return renderRadio_unstable(state);
});
Radio.displayName = "Radio";

// node_modules/@fluentui/react-select/lib/components/Select/Select.js
var React248 = __toESM(require_react());

// node_modules/@fluentui/react-select/lib/components/Select/useSelect.js
var React247 = __toESM(require_react());
var useSelect_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { defaultValue, value, select, icon, root, appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange, size: size3 = "medium" } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "select",
    excludedPropNames: [
      "appearance",
      "defaultValue",
      "onChange",
      "size",
      "value"
    ]
  });
  const state = {
    size: size3,
    appearance,
    components: {
      root: "span",
      select: "select",
      icon: "span"
    },
    select: slot_exports.always(select, {
      defaultProps: {
        defaultValue,
        value,
        ref,
        ...nativeProps.primary
      },
      elementType: "select"
    }),
    icon: slot_exports.optional(icon, {
      renderByDefault: true,
      defaultProps: {
        children: React247.createElement(ChevronDownRegular, null)
      },
      elementType: "span"
    }),
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.select.onChange = useEventCallback((event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      value: event.target.value
    });
  });
  return state;
};

// node_modules/@fluentui/react-select/lib/components/Select/renderSelect.js
var renderSelect_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.select, {
        children: state.select.children
      }),
      state.icon && jsx(state.icon, {})
    ]
  });
};

// node_modules/@fluentui/react-select/lib/components/Select/useSelectStyles.styles.js
var selectClassNames = {
  root: "fui-Select",
  select: "fui-Select__select",
  icon: "fui-Select__icon"
};
var iconSizes2 = {
  small: "16px",
  medium: "20px",
  large: "24px"
};
var paddingRight = {
  small: `calc(${tokens.spacingHorizontalSNudge}
    + ${iconSizes2.small}
    + ${tokens.spacingHorizontalXXS}
    + ${tokens.spacingHorizontalXXS})`,
  medium: `calc(${tokens.spacingHorizontalMNudge}
    + ${iconSizes2.medium}
    + ${tokens.spacingHorizontalXXS}
    + ${tokens.spacingHorizontalXXS})`,
  large: `calc(${tokens.spacingHorizontalM}
    + ${iconSizes2.large}
    + ${tokens.spacingHorizontalSNudge}
    + ${tokens.spacingHorizontalSNudge})`
};
var paddingLeft = {
  small: `calc(${tokens.spacingHorizontalSNudge} + ${tokens.spacingHorizontalXXS})`,
  medium: `calc(${tokens.spacingHorizontalMNudge} + ${tokens.spacingHorizontalXXS})`,
  large: `calc(${tokens.spacingHorizontalM} + ${tokens.spacingHorizontalSNudge})`
};
var useRootStyles10 = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Eh141a: "flvyvdh",
    Bahqtrf: "fk6fouc",
    qhf8xq: "f10pi13n",
    h62rwi: "f7ll8cq",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fe5s0lv",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    Dlnsje: "fhwjr99",
    E3zdtr: "f1mdlcz9",
    By385i5: "fo72kxq",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    B1piin3: ["f15yvnhg", "f1n6gb5g"],
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    wi16st: "fsrmcvb",
    ywj3b2: "f1t3k7v9",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    Bnupc0a: "fx04xgm",
    bing71: "f1c7in40"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".flvyvdh{flex-wrap:nowrap;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f10pi13n{position:relative;}", ".f7ll8cq::after{background-image:linear-gradient(\n        0deg,\n        var(--colorCompoundBrandStroke) 0%,\n        var(--colorCompoundBrandStroke) 50%,\n        transparent 50%,\n        transparent 100%\n      );}", [".fe5s0lv::after{border-radius:0 0 var(--borderRadiusMedium) var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".fhwjr99::after{height:var(--borderRadiusMedium);}", ".f1mdlcz9::after{position:absolute;}", ".fo72kxq::after{bottom:0;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}"]
});
var useSelectStyles = __styles2({
  base: {
    Bowrso0: "fqrijq1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "faev5xe",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    E5pizo: "f1couhl3",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    Bceei9c: "f1k6fduh",
    Bh6795r: "fqerorx",
    B2u0y6b: "f6dzj5z",
    Byoj8tv: "f1qch9an",
    z8tnut: "f1g0x7ka",
    B3aqqti: "fatbyko",
    Brovlpu: "f1grzc83",
    Bxa1mx5: "f19shzzi"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  },
  disabledUnderline: {
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  small: {
    Bqenvij: "frvgh55",
    uwmqm3: ["f1xile11", "fqznh8f"],
    z189sj: ["fiqd4sw", "f11fkzut"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    uwmqm3: ["f1e60jzv", "f135dnwl"],
    z189sj: ["f154vowv", "flqamny"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Bqenvij: "fbhnoac",
    uwmqm3: ["fnphzt9", "flt1dlf"],
    z189sj: ["f1xi5ia2", "f1xi1l47"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fm9niy"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "flmw63s",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fqhmt4z",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "fd91s9p",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779",
    C8i20h: "fb77jct"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  }
}, {
  d: [".fqrijq1{-webkit-appearance:none;-moz-appearance:none;appearance:none;}", [".faev5xe{border:1px solid transparent;}", {
    p: -2
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1couhl3{box-shadow:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1k6fduh{cursor:pointer;}", ".fqerorx{flex-grow:1;}", ".f6dzj5z{max-width:100%;}", ".f1qch9an{padding-bottom:0;}", ".f1g0x7ka{padding-top:0;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".frvgh55{height:24px;}", ".f1xile11{padding-left:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".fqznh8f{padding-right:calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", ".fiqd4sw{padding-right:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".f11fkzut{padding-left:calc(var(--spacingHorizontalSNudge)\n    + 16px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1d2rq10{height:32px;}", ".f1e60jzv{padding-left:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", ".f135dnwl{padding-right:calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", ".f154vowv{padding-right:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".flqamny{padding-left:calc(var(--spacingHorizontalMNudge)\n    + 20px\n    + var(--spacingHorizontalXXS)\n    + var(--spacingHorizontalXXS));}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fbhnoac{height:40px;}", ".fnphzt9{padding-left:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".flt1dlf{padding-right:calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", ".f1xi5ia2{padding-right:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}", ".f1xi1l47{padding-left:calc(var(--spacingHorizontalM)\n    + 24px\n    + var(--spacingHorizontalSNudge)\n    + var(--spacingHorizontalSNudge));}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fm9niy{border:1px solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".fd91s9p{border-bottom:1px solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], ".fb77jct option{background-color:var(--colorNeutralBackground1);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
  f: [".fatbyko:focus{outline-width:2px;}", ".f1grzc83:focus{outline-style:solid;}", ".f19shzzi:focus{outline-color:transparent;}"],
  m: [["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"]
});
var useIconStyles6 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    mc9l5x: "ftgm304",
    qhf8xq: "f1euv43f",
    Bkecrkj: "f1aehjj5",
    Bo70h7d: "fvc9v3g"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    B7iucu3: "f1cyfu5x"
  },
  small: {
    Be2twd7: "f4ybsrx",
    Bqenvij: "fd461yt",
    j35jbq: ["f13lnp83", "f1i5nn0v"],
    a9b677: "fjw5fx7"
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    j35jbq: ["fnyteob", "f1enpzzf"],
    a9b677: "f64fuq3"
  },
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    j35jbq: ["f8b87gs", "fedtrts"],
    a9b677: "fq4mcun"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".ftgm304{display:block;}", ".f1euv43f{position:absolute;}", ".f1aehjj5{pointer-events:none;}", ".fvc9v3g svg{display:block;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f4ybsrx{font-size:16px;}", ".fd461yt{height:16px;}", ".f13lnp83{right:var(--spacingHorizontalSNudge);}", ".f1i5nn0v{left:var(--spacingHorizontalSNudge);}", ".fjw5fx7{width:16px;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".fnyteob{right:var(--spacingHorizontalMNudge);}", ".f1enpzzf{left:var(--spacingHorizontalMNudge);}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".fq4mcun{width:24px;}"],
  m: [["@media (forced-colors: active){.f1cyfu5x{color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSelectStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance
  } = state;
  const disabled = state.select.disabled;
  const invalid = `${state.select["aria-invalid"]}` === "true";
  const iconStyles = useIconStyles6();
  const rootStyles = useRootStyles10();
  const selectStyles = useSelectStyles();
  state.root.className = mergeClasses(selectClassNames.root, rootStyles.base, state.root.className);
  state.select.className = mergeClasses(selectClassNames.select, selectStyles.base, selectStyles[size3], selectStyles[appearance], !disabled && appearance === "outline" && selectStyles.outlineInteractive, !disabled && invalid && appearance !== "underline" && selectStyles.invalid, !disabled && invalid && appearance === "underline" && selectStyles.invalidUnderline, disabled && selectStyles.disabled, disabled && appearance === "underline" && selectStyles.disabledUnderline, state.select.className);
  if (state.icon) {
    state.icon.className = mergeClasses(selectClassNames.icon, iconStyles.icon, disabled && iconStyles.disabled, iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-select/lib/components/Select/Select.js
var Select2 = React248.forwardRef((props, ref) => {
  const state = useSelect_unstable(props, ref);
  useSelectStyles_unstable(state);
  useCustomStyleHook("useSelectStyles_unstable")(state);
  return renderSelect_unstable(state);
});
Select2.displayName = "Select";

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/Skeleton.js
var React252 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeleton.js
var React250 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/contexts/SkeletonContext.js
var React249 = __toESM(require_react());
var SkeletonContext = React249.createContext(void 0);
var skeletonContextDefaultValue = {};
var SkeletonContextProvider = SkeletonContext.Provider;
var useSkeletonContext = () => {
  var _React_useContext;
  return (_React_useContext = React249.useContext(SkeletonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : skeletonContextDefaultValue;
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeleton.js
var useSkeleton_unstable = (props, ref) => {
  const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
  const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque" } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role: "progressbar",
    "aria-busy": true,
    ...props
  }), {
    elementType: "div"
  });
  return {
    animation,
    appearance,
    components: {
      root: "div"
    },
    root
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/renderSkeleton.js
var renderSkeleton_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(SkeletonContextProvider, {
    value: contextValues.skeletonGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonStyles.styles.js
var skeletonClassNames = {
  root: "fui-Skeleton"
};
var useStyles29 = __styles2({
  blockStyling: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useSkeletonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles29();
  state.root.className = mergeClasses(skeletonClassNames.root, state.root.as === "span" && styles.blockStyling, state.root.className);
  return state;
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/useSkeletonContextValues.js
var React251 = __toESM(require_react());
var useSkeletonContextValues = (state) => {
  const { animation, appearance } = state;
  const skeletonGroup = React251.useMemo(() => ({
    animation,
    appearance
  }), [
    animation,
    appearance
  ]);
  return {
    skeletonGroup
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/Skeleton/Skeleton.js
var Skeleton = React252.forwardRef((props, ref) => {
  const state = useSkeleton_unstable(props, ref);
  const contextValues = useSkeletonContextValues(state);
  useSkeletonStyles_unstable(state);
  useCustomStyleHook("useSkeletonStyles_unstable")(state);
  return renderSkeleton_unstable(state, contextValues);
});
Skeleton.displayName = "Skeleton";

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/SkeletonItem.js
var React254 = __toESM(require_react());

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItem.js
var React253 = __toESM(require_react());
var useSkeletonItem_unstable = (props, ref) => {
  const { animation: contextAnimation, appearance: contextAppearance } = useSkeletonContext();
  const { animation = contextAnimation !== null && contextAnimation !== void 0 ? contextAnimation : "wave", appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "opaque", size: size3 = 16, shape = "rectangle" } = props;
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    ...props
  }), {
    elementType: "div"
  });
  return {
    appearance,
    animation,
    size: size3,
    shape,
    components: {
      root: "div"
    },
    root
  };
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/renderSkeletonItem.js
var renderSkeletonItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/useSkeletonItemStyles.styles.js
var skeletonItemClassNames = {
  root: "fui-SkeletonItem"
};
var useStyles30 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Bsft5z2: "f13zj6fq",
    ap17g6: "f2gz7yw",
    E3zdtr: "f1mdlcz9",
    By385i5: 0,
    Eqx8gd: 0,
    B1piin3: 0,
    bn5sak: 0,
    B58onuk: "f1nt53hs",
    s9ouvv: "f18xs7ez",
    xr36ep: "ffm3629",
    Bitv4sc: "f1f9zsvm",
    Gt9ir8: "f1evo4vk",
    Crt7la: "f18va1k3"
  },
  wave: {
    De3pzq: "f1gjxg63",
    Br128sd: ["f3fo419", "f6m9r4"],
    h62rwi: ["ftnv2js", "f12jzhyt"],
    b1kco5: ["fig1c6l", "f1rv5y9h"],
    Iqrfzq: "f1xjc3a9"
  },
  pulse: {
    Br128sd: "f171zwvm",
    xr36ep: "fs3pcyf",
    Bjyk6c5: "f1yu5riq"
  },
  translucent: {
    De3pzq: "f162mh4z",
    h62rwi: ["flvf4r0", "f1uek97b"]
  },
  translucentPulse: {
    De3pzq: "flu3bqm",
    Bjyk6c5: "fxucc0w"
  },
  blockStyling: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".f10pi13n{position:relative;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}', ".f2gz7yw::after{display:block;}", ".f1mdlcz9::after{position:absolute;}", [".f1nt53hs::after{inset:0;}", {
    p: -1
  }], ".f18xs7ez::after{animation-iteration-count:infinite;}", ".ffm3629::after{animation-duration:3s;}", ".f1f9zsvm::after{animation-timing-function:ease-in-out;}", ".f1gjxg63{background-color:var(--colorNeutralStencil1);}", ".f3fo419::after{animation-name:f1efwx7q;}", ".f6m9r4::after{animation-name:f1kkgpz1;}", ".ftnv2js::after{background-image:linear-gradient(\n        to right,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}", ".f12jzhyt::after{background-image:linear-gradient(\n        to left,\n        var(--colorNeutralStencil1) 0%,\n        var(--colorNeutralStencil2) 50%,\n        var(--colorNeutralStencil1) 100%);}", ".fig1c6l::after{transform:translate(-100%);}", ".f1rv5y9h::after{transform:translate(100%);}", ".f171zwvm::after{animation-name:f12o7gg6;}", ".fs3pcyf::after{animation-duration:1s;}", ".f1yu5riq::after{background-color:var(--colorNeutralStencil1);}", ".f162mh4z{background-color:var(--colorNeutralStencil1Alpha);}", ".flvf4r0::after{background-image:linear-gradient(\n      to right,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}", ".f1uek97b::after{background-image:linear-gradient(\n      to left,\n      transparent 0%,\n      var(--colorNeutralStencil1Alpha) 50%,\n      transparent 100%);}", ".flu3bqm{background-color:none;}", ".fxucc0w::after{background-color:var(--colorNeutralStencil1Alpha);}", ".ftgm304{display:block;}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1evo4vk::after{animation-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f18va1k3::after{animation-iteration-count:1;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (forced-colors: active){.f1xjc3a9::after{background-color:WindowText;}}", {
    m: "screen and (forced-colors: active)"
  }]],
  k: ["@keyframes f1efwx7q{to{transform:translate(100%);}}", "@keyframes f1kkgpz1{to{transform:translate(-100%);}}", "@keyframes f12o7gg6{0%{opacity:1;}50%{opacity:0.4;}100%{opacity:1;}}"]
});
var useRectangleStyles = __styles2({
  "8": {
    Bqenvij: "f1x82gua"
  },
  "12": {
    Bqenvij: "fvblgha"
  },
  "16": {
    Bqenvij: "fd461yt"
  },
  "20": {
    Bqenvij: "fjamq6b"
  },
  "24": {
    Bqenvij: "frvgh55"
  },
  "28": {
    Bqenvij: "fxldao9"
  },
  "32": {
    Bqenvij: "f1d2rq10"
  },
  "36": {
    Bqenvij: "f8ljn23"
  },
  "40": {
    Bqenvij: "fbhnoac"
  },
  "48": {
    Bqenvij: "ff2sm71"
  },
  "56": {
    Bqenvij: "fzki0ko"
  },
  "64": {
    Bqenvij: "f16k9i2m"
  },
  "72": {
    Bqenvij: "f1shusfg"
  },
  "96": {
    Bqenvij: "fypu0ge"
  },
  "120": {
    Bqenvij: "fjr5b71"
  },
  "128": {
    Bqenvij: "fele2au"
  },
  root: {
    a9b677: "fly5x3f",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  }
}, {
  d: [".f1x82gua{height:8px;}", ".fvblgha{height:12px;}", ".fd461yt{height:16px;}", ".fjamq6b{height:20px;}", ".frvgh55{height:24px;}", ".fxldao9{height:28px;}", ".f1d2rq10{height:32px;}", ".f8ljn23{height:36px;}", ".fbhnoac{height:40px;}", ".ff2sm71{height:48px;}", ".fzki0ko{height:56px;}", ".f16k9i2m{height:64px;}", ".f1shusfg{height:72px;}", ".fypu0ge{height:96px;}", ".fjr5b71{height:120px;}", ".fele2au{height:128px;}", ".fly5x3f{width:100%;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }]]
});
var useSizeStyles2 = __styles2({
  "8": {
    a9b677: "f1o3cbw4",
    Bqenvij: "f1x82gua"
  },
  "12": {
    a9b677: "frx94fk",
    Bqenvij: "fvblgha"
  },
  "16": {
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  "20": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "24": {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  "28": {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  "32": {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  },
  "36": {
    a9b677: "fpdz1er",
    Bqenvij: "f8ljn23"
  },
  "40": {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac"
  },
  "48": {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  },
  "56": {
    a9b677: "f1u66zr1",
    Bqenvij: "fzki0ko"
  },
  "64": {
    a9b677: "fa9ln6p",
    Bqenvij: "f16k9i2m"
  },
  "72": {
    a9b677: "fhcae8x",
    Bqenvij: "f1shusfg"
  },
  "96": {
    a9b677: "f1kyr2gn",
    Bqenvij: "fypu0ge"
  },
  "120": {
    a9b677: "fwfqyga",
    Bqenvij: "fjr5b71"
  },
  "128": {
    a9b677: "f1iksgmy",
    Bqenvij: "fele2au"
  }
}, {
  d: [".f1o3cbw4{width:8px;}", ".f1x82gua{height:8px;}", ".frx94fk{width:12px;}", ".fvblgha{height:12px;}", ".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
});
var useCircleSizeStyles = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f5q2cvs"
  }
}, {
  d: [[".f5q2cvs{border-radius:50%;}", {
    p: -1
  }]]
});
var useSkeletonItemStyles_unstable = (state) => {
  "use no memo";
  const {
    animation,
    appearance,
    size: size3,
    shape
  } = state;
  const rootStyles = useStyles30();
  const rectStyles = useRectangleStyles();
  const sizeStyles = useSizeStyles2();
  const circleStyles = useCircleSizeStyles();
  state.root.className = mergeClasses(skeletonItemClassNames.root, rootStyles.root, state.root.as === "span" && rootStyles.blockStyling, animation === "wave" && rootStyles.wave, animation === "pulse" && rootStyles.pulse, appearance === "translucent" && rootStyles.translucent, animation === "pulse" && appearance === "translucent" && rootStyles.translucentPulse, shape === "rectangle" && rectStyles.root, shape === "rectangle" && rectStyles[size3], shape === "square" && sizeStyles[size3], shape === "circle" && circleStyles.root, shape === "circle" && sizeStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-skeleton/lib/components/SkeletonItem/SkeletonItem.js
var SkeletonItem = React254.forwardRef((props, ref) => {
  const state = useSkeletonItem_unstable(props, ref);
  useSkeletonItemStyles_unstable(state);
  useCustomStyleHook("useSkeletonItemStyles_unstable")(state);
  return renderSkeletonItem_unstable(state);
});
SkeletonItem.displayName = "SkeletonItem";

// node_modules/@fluentui/react-slider/lib/components/Slider/Slider.js
var React257 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSlider.js
var React256 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderState.js
var React255 = __toESM(require_react());

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderStyles.styles.js
var sliderClassNames = {
  root: "fui-Slider",
  rail: "fui-Slider__rail",
  thumb: "fui-Slider__thumb",
  input: "fui-Slider__input"
};
var sliderCSSVars = {
  sliderDirectionVar: `--fui-Slider--direction`,
  sliderInnerThumbRadiusVar: `--fui-Slider__inner-thumb--radius`,
  sliderProgressVar: `--fui-Slider--progress`,
  sliderProgressColorVar: `--fui-Slider__progress--color`,
  sliderRailSizeVar: `--fui-Slider__rail--size`,
  sliderRailColorVar: `--fui-Slider__rail--color`,
  sliderStepsPercentVar: `--fui-Slider--steps-percent`,
  sliderThumbColorVar: `--fui-Slider__thumb--color`,
  sliderThumbSizeVar: `--fui-Slider__thumb--size`
};
var {
  sliderDirectionVar,
  sliderInnerThumbRadiusVar,
  sliderProgressVar,
  sliderProgressColorVar,
  sliderRailSizeVar,
  sliderRailColorVar,
  sliderStepsPercentVar,
  sliderThumbColorVar,
  sliderThumbSizeVar
} = sliderCSSVars;
var useRootStyles11 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    mc9l5x: "fwk3njj",
    lpbzjs: "f1sdsnyy",
    Bt984gj: "f122n59",
    B7hvi0a: "f1oiokrs"
  },
  small: {
    Bi64ftq: "f1agqo6f",
    Bslxy2k: "f1mmvox9",
    Ba19x4e: "f1i7ztpd",
    sshi5w: "f1pha7fy"
  },
  medium: {
    Bi64ftq: "f1a78h9h",
    Bslxy2k: "fh1udnr",
    Ba19x4e: "fuok0yf",
    sshi5w: "f1nxs5xn"
  },
  horizontal: {
    Bf4jedk: "fyvtabn",
    wkccdc: "fgfd48t",
    Budl1dq: "f4t5rw1"
  },
  vertical: {
    sshi5w: "f1pzv1zu",
    wkccdc: "fktlcaf",
    Budl1dq: "fiadc6h"
  },
  enabled: {
    B7wi8oa: "f4l8x3l",
    B250r6j: "f671q34",
    Bpmy4es: "fvfzmw5",
    Buw9y6v: "faw1t00",
    Bq939m0: "fxdgx5",
    gjzr1t: "fii04fa",
    tg7hqu: "f36hzz8",
    qhf704: "fdjsfay",
    Blfvze: "f1fen33d",
    genz7u: "f1c6b0w1",
    Brgvh4e: "f1rq9b4z",
    Bsjyjqp: "f4xxiul"
  },
  disabled: {
    Bpmy4es: "foojseg",
    B7wi8oa: "f1lgdqhv",
    B250r6j: "f1veetlj",
    qhf704: "fn4acdm",
    Blfvze: "f4s8dx0",
    genz7u: "f1wil5xy"
  },
  focusIndicatorHorizontal: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    h6p2u: "f1ufm4qn",
    I6qiy5: ["f1qnwcb4", "fgrk5zm"],
    yzno9d: "fi52z01",
    By0wis0: ["fgrk5zm", "f1qnwcb4"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1pffoy2",
    B29w5g4: ["f1dfga45", "f63jj3o"],
    Bhhzhcn: "fs6b7xr",
    Bec0n69: ["f63jj3o", "f1dfga45"]
  },
  focusIndicatorVertical: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    h6p2u: "f1ufm4qn",
    I6qiy5: ["f1qnwcb4", "fgrk5zm"],
    yzno9d: "fi52z01",
    By0wis0: ["fgrk5zm", "f1qnwcb4"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1pffoy2",
    B29w5g4: ["fm5xmfm", "femsgmt"],
    Bhhzhcn: "fs6b7xr",
    Bec0n69: ["femsgmt", "fm5xmfm"]
  }
}, {
  d: [".f10pi13n{position:relative;}", ".fwk3njj{display:inline-grid;}", ".f1sdsnyy{touch-action:none;}", ".f122n59{align-items:center;}", ".f1oiokrs{justify-items:center;}", ".f1agqo6f{--fui-Slider__thumb--size:16px;}", ".f1mmvox9{--fui-Slider__inner-thumb--radius:5px;}", ".f1i7ztpd{--fui-Slider__rail--size:2px;}", ".f1pha7fy{min-height:24px;}", ".f1a78h9h{--fui-Slider__thumb--size:20px;}", ".fh1udnr{--fui-Slider__inner-thumb--radius:6px;}", ".fuok0yf{--fui-Slider__rail--size:4px;}", ".f1nxs5xn{min-height:32px;}", ".fyvtabn{min-width:120px;}", ".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f4t5rw1{grid-template-columns:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}", ".f1pzv1zu{min-height:120px;}", ".fktlcaf{grid-template-rows:1fr calc(100% - var(--fui-Slider__thumb--size)) 1fr;}", ".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f4l8x3l{--fui-Slider__rail--color:var(--colorNeutralStrokeAccessible);}", ".f671q34{--fui-Slider__progress--color:var(--colorCompoundBrandBackground);}", ".fvfzmw5{--fui-Slider__thumb--color:var(--colorCompoundBrandBackground);}", ".foojseg{--fui-Slider__thumb--color:var(--colorNeutralForegroundDisabled);}", ".f1lgdqhv{--fui-Slider__rail--color:var(--colorNeutralBackgroundDisabled);}", ".f1veetlj{--fui-Slider__progress--color:var(--colorNeutralForegroundDisabled);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1pffoy2[data-fui-focus-within]:focus-within::after{top:calc(0px - 2px - -2px);}", ".f1dfga45[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - -4px);}", ".f63jj3o[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - -4px);}", ".fs6b7xr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - 2px - -2px);}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fm5xmfm[data-fui-focus-within]:focus-within::after{right:calc(0px - 2px - 4px);}", ".femsgmt[data-fui-focus-within]:focus-within::after{left:calc(0px - 2px - 4px);}"],
  h: [".faw1t00:hover{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundHover);}", ".fxdgx5:hover{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundHover);}"],
  a: [".fii04fa:active{--fui-Slider__thumb--color:var(--colorCompoundBrandBackgroundPressed);}", ".f36hzz8:active{--fui-Slider__progress--color:var(--colorCompoundBrandBackgroundPressed);}"],
  m: [["@media (forced-colors: active){.fdjsfay{--fui-Slider__rail--color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1fen33d{--fui-Slider__thumb--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1c6b0w1{--fui-Slider__progress--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rq9b4z:hover{--fui-Slider__thumb--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4xxiul:hover{--fui-Slider__progress--color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fn4acdm{--fui-Slider__rail--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f4s8dx0{--fui-Slider__thumb--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wil5xy{--fui-Slider__progress--color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"]
});
var useRailStyles = __styles2({
  rail: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    Bkecrkj: "f1aehjj5",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f10pi13n",
    Bvjb7m6: "fdgv6k0",
    Bcmaq0h: "fizngqt",
    Bpd4iqm: "fpvhumw",
    oeaueh: "f1yog68k",
    Bw0xxkn: "f13sgyd8",
    Ftih45: "fzhtfnv",
    Brfgrao: "f1j7ml58",
    Bbn5juq: "fx36ao7",
    Bses4cn: "fddlh2i"
  },
  horizontal: {
    a9b677: "fly5x3f",
    Bqenvij: "f1cy86ho",
    Fbdkly: ["f1heqfse", "fkh49vu"],
    mdwyqc: ["fkh49vu", "f1heqfse"],
    Baz25je: "f16tdq4e"
  },
  vertical: {
    a9b677: "fqxfnkd",
    Bqenvij: "f1l02sjl",
    Ccq8qp: "f1rik0od",
    Bciustq: "f14xwovp",
    lawp4y: "fdehrcx"
  }
}, {
  d: [[".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".f1aehjj5{pointer-events:none;}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f10pi13n{position:relative;}", ".fdgv6k0{forced-color-adjust:none;}", ".fizngqt{background-image:linear-gradient(\n      var(--fui-Slider--direction),\n      var(--fui-Slider__progress--color) 0%,\n      var(--fui-Slider__progress--color) var(--fui-Slider--progress),\n      var(--fui-Slider__rail--color) var(--fui-Slider--progress)\n    );}", ".fpvhumw{outline-width:1px;}", ".f1yog68k{outline-style:solid;}", ".f13sgyd8{outline-color:var(--colorTransparentStroke);}", ".fzhtfnv::before{content:'';}", ".f1j7ml58::before{position:absolute;}", ".fx36ao7::before{background-image:repeating-linear-gradient(\n        var(--fui-Slider--direction),\n        #0000 0%,\n        #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) calc(var(--fui-Slider--steps-percent) - 1px),\n        var(--colorNeutralBackground1) var(--fui-Slider--steps-percent)\n      );}", ".fly5x3f{width:100%;}", ".f1cy86ho{height:var(--fui-Slider__rail--size);}", ".f1heqfse::before{left:-1px;}", ".fkh49vu::before{right:-1px;}", ".f16tdq4e::before{height:var(--fui-Slider__rail--size);}", ".fqxfnkd{width:var(--fui-Slider__rail--size);}", ".f1l02sjl{height:100%;}", ".f1rik0od::before{width:var(--fui-Slider__rail--size);}", ".f14xwovp::before{top:-1px;}", ".fdehrcx::before{bottom:-1px;}"],
  m: [["@media (forced-colors: active){.fddlh2i::before{background-image:repeating-linear-gradient(\n          var(--fui-Slider--direction),\n          #0000 0%,\n          #0000 calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText calc(var(--fui-Slider--steps-percent) - 1px),\n          HighlightText var(--fui-Slider--steps-percent)\n        );}}", {
    m: "(forced-colors: active)"
  }]]
});
var useThumbStyles = __styles2({
  thumb: {
    B2lzsem: "ftx3jue",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    E5pizo: "fof7hq0",
    De3pzq: "foksa45",
    Brfgrao: "f1j7ml58",
    Bciustq: "f14u7mkt",
    Fbdkly: ["f5zrw40", "f1ks5ppg"],
    lawp4y: "fto0uou",
    mdwyqc: ["f1ks5ppg", "f5zrw40"],
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1fsco4d"
  },
  disabled: {
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1pv9hn4"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["foa2ioz", "fjmilum"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "f1k2fpdo"
  }
}, {
  d: [".ftx3jue{--fui-Slider__thumb--position:clamp(var(--fui-Slider__inner-thumb--radius), var(--fui-Slider--progress), calc(100% - var(--fui-Slider__inner-thumb--radius)));}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fof7hq0{box-shadow:0 0 0 calc(var(--fui-Slider__thumb--size) * .2) var(--colorNeutralBackground1) inset;}", ".foksa45{background-color:var(--fui-Slider__thumb--color);}", ".f1j7ml58::before{position:absolute;}", ".f14u7mkt::before{top:0px;}", ".f5zrw40::before{left:0px;}", ".f1ks5ppg::before{right:0px;}", ".fto0uou::before{bottom:0px;}", [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f1fsco4d::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], [".f1pv9hn4::before{border:calc(var(--fui-Slider__thumb--size) * .05) solid var(--colorNeutralForegroundDisabled);}", {
    p: -2
  }], ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".foa2ioz{left:var(--fui-Slider__thumb--position);}", ".fjmilum{right:var(--fui-Slider__thumb--position);}", ".f5cv5a3{transform:translateY(50%);}", ".f1k2fpdo{bottom:var(--fui-Slider__thumb--position);}"]
});
var useInputStyles4 = __styles2({
  input: {
    Bceei9c: "f1k6fduh",
    abs64n: "fk73vx1",
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z",
    Br312pm: "fwpfdsa",
    Bw0ie65: "fuur7zz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao"
  },
  disabled: {
    Bceei9c: "f158kwzp"
  },
  horizontal: {
    Bqenvij: "f1yfdkfd",
    a9b677: "fly5x3f"
  },
  vertical: {
    Bqenvij: "f1l02sjl",
    a9b677: "f174ca62",
    wtfg9d: "f135tqni",
    By3ymbm: ["f114o3fk", "f1o9w1zd"],
    B1e78rk: "f1jr0wcp"
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fk73vx1{opacity:0;}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".fwpfdsa{grid-column-start:1;}", ".fuur7zz{grid-column-end:-1;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f158kwzp{cursor:default;}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}"],
  t: ["@supports (writing-mode: sideways-lr){.f135tqni{writing-mode:vertical-lr;}}", "@supports (writing-mode: sideways-lr){.f114o3fk{direction:rtl;}.f1o9w1zd{direction:ltr;}}", "@supports not (writing-mode: sideways-lr){.f1jr0wcp{-webkit-appearance:slider-vertical;}}"]
});
var useSliderStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles11();
  const railStyles = useRailStyles();
  const thumbStyles = useThumbStyles();
  const inputStyles = useInputStyles4();
  const isVertical = state.vertical;
  state.root.className = mergeClasses(sliderClassNames.root, rootStyles.root, isVertical ? rootStyles.focusIndicatorVertical : rootStyles.focusIndicatorHorizontal, rootStyles[state.size], isVertical ? rootStyles.vertical : rootStyles.horizontal, state.disabled ? rootStyles.disabled : rootStyles.enabled, state.root.className);
  state.rail.className = mergeClasses(sliderClassNames.rail, railStyles.rail, isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
  state.thumb.className = mergeClasses(sliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.disabled && thumbStyles.disabled, state.thumb.className);
  state.input.className = mergeClasses(sliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.disabled && inputStyles.disabled, state.input.className);
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/useSliderState.js
var { sliderStepsPercentVar: sliderStepsPercentVar2, sliderProgressVar: sliderProgressVar2, sliderDirectionVar: sliderDirectionVar2 } = sliderCSSVars;
var getPercent = (value, min2, max2) => {
  return max2 === min2 ? 0 : (value - min2) / (max2 - min2) * 100;
};
var useSliderState_unstable = (state, props) => {
  "use no memo";
  const { min: min2 = 0, max: max2 = 100, step } = props;
  const { dir } = useFluent();
  const [currentValue, setCurrentValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: 0
  });
  const clampedValue = clamp(currentValue, min2, max2);
  const valuePercent = getPercent(clampedValue, min2, max2);
  const inputOnChange = state.input.onChange;
  const propsOnChange = props.onChange;
  const onChange = useEventCallback((ev) => {
    const newValue = Number(ev.target.value);
    setCurrentValue(clamp(newValue, min2, max2));
    if (inputOnChange && inputOnChange !== propsOnChange) {
      inputOnChange(ev);
    } else if (propsOnChange) {
      propsOnChange(ev, {
        value: newValue
      });
    }
  });
  const stepPercent = step && step > 0 ? `${step * 100 / (max2 - min2)}%` : void 0;
  const rootVariables = {
    [sliderDirectionVar2]: state.vertical ? "0deg" : dir === "ltr" ? "90deg" : "270deg",
    [sliderProgressVar2]: `${valuePercent}%`,
    // Set the sliderStepsPercentVar only if defined - fixes SSR errors in React 18
    ...stepPercent !== void 0 && {
      [sliderStepsPercentVar2]: stepPercent
    }
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = onChange;
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/useSlider.js
var useSlider_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "size"
    ]
  });
  const {
    disabled,
    vertical,
    size: size3 = "medium",
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const state = {
    disabled,
    size: size3,
    vertical,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        ...nativeProps.primary,
        type: "range",
        orient: vertical ? "vertical" : void 0
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.ref = useMergedRefs(state.root.ref, useFocusWithin());
  useSliderState_unstable(state, props);
  return state;
};

// node_modules/@fluentui/react-slider/lib/components/Slider/renderSlider.js
var renderSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-slider/lib/components/Slider/Slider.js
var Slider = React257.forwardRef((props, ref) => {
  const state = useSlider_unstable(props, ref);
  useSliderStyles_unstable(state);
  useCustomStyleHook("useSliderStyles_unstable")(state);
  return renderSlider_unstable(state);
});
Slider.displayName = "Slider";

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/SpinButton.js
var React259 = __toESM(require_react());

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButton.js
var React258 = __toESM(require_react());

// node_modules/@fluentui/react-spinbutton/lib/utils/clamp.js
var clamp3 = (value, min2, max2) => {
  let nextValue = value;
  if (min2 !== void 0) {
    if (max2 !== void 0 && min2 > max2) {
      const error = new Error();
      if (true) {
        console.error([
          `"min" value "${min2}" is greater than "max" value "${max2}".`,
          '"min" must be less than or equal to "max".',
          `Returning value "${value}".`,
          error.stack
        ].join());
      }
      return value;
    }
    nextValue = Math.max(min2, nextValue);
  }
  if (max2 !== void 0) {
    nextValue = Math.min(max2, nextValue);
  }
  return nextValue;
};

// node_modules/@fluentui/react-spinbutton/lib/utils/getBound.js
var getBound = (value, min2, max2) => {
  if (min2 !== void 0 && value === min2) {
    if (max2 === min2) {
      return "both";
    }
    return "min";
  } else if (max2 !== void 0 && value === max2) {
    return "max";
  }
  return "none";
};

// node_modules/@fluentui/react-spinbutton/lib/utils/precision.js
function calculatePrecision(value) {
  const groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
  if (!groups) {
    return 0;
  }
  if (groups[1]) {
    return -groups[1].length;
  }
  if (groups[2]) {
    return groups[2].length;
  }
  return 0;
}
function precisionRound(value, precision, base = 10) {
  const exp = base ** precision;
  return Math.round(value * exp) / exp;
}

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButton.js
var DEFAULT_SPIN_DELAY_MS = 150;
var MIN_SPIN_DELAY_MS = 80;
var MAX_SPIN_TIME_MS = 1e3;
var lerp = (start, end, percent) => start + (end - start) * percent;
var useSpinButton_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "defaultValue",
      "max",
      "min",
      "onChange",
      "size",
      "value"
    ]
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { value, displayValue, defaultValue, min: min2, max: max2, step = 1, stepPage = 1, precision: precisionFromProps, onChange, size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", root, input, incrementButton, decrementButton } = props;
  const precision = React258.useMemo(() => {
    return precisionFromProps !== null && precisionFromProps !== void 0 ? precisionFromProps : Math.max(calculatePrecision(step), 0);
  }, [
    precisionFromProps,
    step
  ]);
  const [currentValue, setCurrentValue] = useControllableState({
    state: value,
    defaultState: defaultValue,
    initialState: 0
  });
  const inputRef = React258.useRef(null);
  const isControlled = value !== void 0;
  const [textValue, setTextValue] = React258.useState(void 0);
  const [keyboardSpinState, setKeyboardSpinState] = React258.useState("rest");
  const internalState = React258.useRef({
    value: currentValue,
    spinState: "rest",
    spinTime: 0,
    spinDelay: DEFAULT_SPIN_DELAY_MS,
    atBound: currentValue !== null ? getBound(precisionRound(currentValue, precision), min2, max2) : "none"
  });
  const [setStepTimeout, clearStepTimeout] = useTimeout();
  const stepValue = (e, direction, startFrom) => {
    let startValue = internalState.current.value;
    if (startFrom) {
      const num = parseFloat(startFrom);
      if (!isNaN(num)) {
        startValue = num;
      }
    }
    const val = startValue;
    const dir = direction === "up" || direction === "upPage" ? 1 : -1;
    const stepSize = direction === "upPage" || direction === "downPage" ? stepPage : step;
    if (val === null) {
      const stepStart = min2 === void 0 ? 0 : min2;
      const nullStep = clamp3(stepStart + stepSize * dir, min2, max2);
      commit(e, nullStep);
      return;
    }
    let newValue = val + stepSize * dir;
    if (!Number.isNaN(newValue)) {
      newValue = clamp3(newValue, min2, max2);
    }
    commit(e, newValue);
    if (internalState.current.spinState !== "rest") {
      setStepTimeout(() => {
        internalState.current.spinTime += internalState.current.spinDelay;
        internalState.current.spinDelay = lerp(DEFAULT_SPIN_DELAY_MS, MIN_SPIN_DELAY_MS, internalState.current.spinTime / MAX_SPIN_TIME_MS);
        stepValue(e, direction);
      }, internalState.current.spinDelay);
    }
  };
  const handleInputChange = (e) => {
    if (!internalState.current.previousTextValue) {
      internalState.current.previousTextValue = textValue !== null && textValue !== void 0 ? textValue : String(currentValue);
    }
    const newValue = e.target.value;
    setTextValue(newValue);
    if (inputRef.current) {
      inputRef.current.ariaValueNow = newValue;
    }
  };
  const handleIncrementMouseDown = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.spinState = "up";
    stepValue(e, "up");
  };
  const handleDecrementMouseDown = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.spinState = "down";
    stepValue(e, "down");
  };
  const handleStepMouseUpOrLeave = (e) => {
    clearStepTimeout();
    internalState.current.spinState = "rest";
    internalState.current.spinDelay = DEFAULT_SPIN_DELAY_MS;
    internalState.current.spinTime = 0;
  };
  const handleBlur = (e) => {
    commit(e, currentValue, textValue);
    internalState.current.previousTextValue = void 0;
  };
  const handleKeyDown = (e) => {
    let nextKeyboardSpinState = "rest";
    if (e.key === ArrowUp) {
      stepValue(e, "up", textValue);
      nextKeyboardSpinState = "up";
    } else if (e.key === ArrowDown) {
      stepValue(e, "down", textValue);
      nextKeyboardSpinState = "down";
    } else if (e.key === PageUp) {
      e.preventDefault();
      stepValue(e, "upPage", textValue);
      nextKeyboardSpinState = "up";
    } else if (e.key === PageDown) {
      e.preventDefault();
      stepValue(e, "downPage", textValue);
      nextKeyboardSpinState = "down";
    } else if (!e.shiftKey && e.key === Home && min2 !== void 0) {
      commit(e, min2);
      nextKeyboardSpinState = "down";
    } else if (!e.shiftKey && e.key === End && max2 !== void 0) {
      commit(e, max2);
      nextKeyboardSpinState = "up";
    } else if (e.key === Enter) {
      commit(e, currentValue, textValue);
      internalState.current.previousTextValue = void 0;
    } else if (e.key === Escape) {
      if (internalState.current.previousTextValue) {
        setTextValue(void 0);
        internalState.current.previousTextValue = void 0;
      }
    }
    if (keyboardSpinState !== nextKeyboardSpinState) {
      setKeyboardSpinState(nextKeyboardSpinState);
    }
  };
  const handleKeyUp = (e) => {
    if (keyboardSpinState !== "rest") {
      setKeyboardSpinState("rest");
      internalState.current.spinState = "rest";
    }
  };
  const commit = (e, newValue, newDisplayValue) => {
    const valueChanged = newValue !== void 0 && currentValue !== newValue;
    const displayValueChanged = newDisplayValue !== void 0 && internalState.current.previousTextValue !== void 0 && internalState.current.previousTextValue !== newDisplayValue;
    let roundedValue;
    if (valueChanged) {
      roundedValue = precisionRound(newValue, precision);
      setCurrentValue(roundedValue);
      internalState.current.value = roundedValue;
    } else if (displayValueChanged && !isControlled) {
      const nextValue = parseFloat(newDisplayValue);
      if (!isNaN(nextValue)) {
        setCurrentValue(precisionRound(nextValue, precision));
        internalState.current.value = precisionRound(nextValue, precision);
      }
    }
    if (valueChanged || displayValueChanged) {
      onChange === null || onChange === void 0 ? void 0 : onChange(e, {
        value: roundedValue,
        displayValue: newDisplayValue
      });
    }
    setTextValue(void 0);
  };
  let valueToDisplay;
  if (textValue !== void 0) {
    valueToDisplay = textValue;
  } else if (value === null || currentValue === null) {
    valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : "";
    internalState.current.value = null;
    internalState.current.atBound = "none";
  } else {
    const roundedValue = precisionRound(currentValue, precision);
    internalState.current.value = roundedValue;
    internalState.current.atBound = getBound(roundedValue, min2, max2);
    if (isControlled) {
      valueToDisplay = displayValue !== null && displayValue !== void 0 ? displayValue : String(roundedValue);
    } else {
      valueToDisplay = String(roundedValue);
    }
  }
  const state = {
    size: size3,
    appearance,
    spinState: keyboardSpinState,
    atBound: internalState.current.atBound,
    components: {
      root: "span",
      input: "input",
      incrementButton: "button",
      decrementButton: "button"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        autoComplete: "off",
        role: "spinbutton",
        appearance,
        type: "text",
        ...nativeProps.primary
      },
      elementType: "input"
    }),
    incrementButton: slot_exports.always(incrementButton, {
      defaultProps: {
        tabIndex: -1,
        children: React258.createElement(ChevronUp16Regular, null),
        disabled: nativeProps.primary.disabled || internalState.current.atBound === "max" || internalState.current.atBound === "both",
        "aria-label": "Increment value",
        type: "button"
      },
      elementType: "button"
    }),
    decrementButton: slot_exports.always(decrementButton, {
      defaultProps: {
        tabIndex: -1,
        children: React258.createElement(ChevronDown16Regular, null),
        disabled: nativeProps.primary.disabled || internalState.current.atBound === "min" || internalState.current.atBound === "both",
        "aria-label": "Decrement value",
        type: "button"
      },
      elementType: "button"
    })
  };
  state.input.value = valueToDisplay;
  state.input.ref = useMergedRefs(inputRef, ref);
  state.input["aria-valuemin"] = min2;
  state.input["aria-valuemax"] = max2;
  var _internalState_current_value;
  state.input["aria-valuenow"] = (_internalState_current_value = internalState.current.value) !== null && _internalState_current_value !== void 0 ? _internalState_current_value : void 0;
  var _state_input_ariavaluetext;
  state.input["aria-valuetext"] = (_state_input_ariavaluetext = state.input["aria-valuetext"]) !== null && _state_input_ariavaluetext !== void 0 ? _state_input_ariavaluetext : value !== void 0 && displayValue || void 0;
  state.input.onChange = mergeCallbacks(state.input.onChange, handleInputChange);
  state.input.onInput = mergeCallbacks(state.input.onInput, handleInputChange);
  state.input.onBlur = mergeCallbacks(state.input.onBlur, handleBlur);
  state.input.onKeyDown = mergeCallbacks(state.input.onKeyDown, handleKeyDown);
  state.input.onKeyUp = mergeCallbacks(state.input.onKeyUp, handleKeyUp);
  state.incrementButton.onMouseDown = mergeCallbacks(handleIncrementMouseDown, state.incrementButton.onMouseDown);
  state.incrementButton.onMouseUp = mergeCallbacks(state.incrementButton.onMouseUp, handleStepMouseUpOrLeave);
  state.incrementButton.onMouseLeave = mergeCallbacks(state.incrementButton.onMouseLeave, handleStepMouseUpOrLeave);
  state.decrementButton.onMouseDown = mergeCallbacks(handleDecrementMouseDown, state.decrementButton.onMouseDown);
  state.decrementButton.onMouseUp = mergeCallbacks(state.decrementButton.onMouseUp, handleStepMouseUpOrLeave);
  state.decrementButton.onMouseLeave = mergeCallbacks(state.decrementButton.onMouseLeave, handleStepMouseUpOrLeave);
  return state;
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/renderSpinButton.js
var renderSpinButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.incrementButton, {}),
      jsx(state.decrementButton, {})
    ]
  });
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/useSpinButtonStyles.styles.js
var spinButtonClassNames = {
  root: "fui-SpinButton",
  input: "fui-SpinButton__input",
  incrementButton: "fui-SpinButton__incrementButton",
  decrementButton: "fui-SpinButton__decrementButton"
};
var spinButtonExtraClassNames = {
  buttonActive: "fui-SpinButton__button_active"
};
var useRootClassName6 = __resetStyles("r109xulx", "r1h2jnch", {
  r: [".r109xulx{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 0 0 var(--spacingHorizontalMNudge);border-radius:var(--borderRadiusMedium);}", '.r109xulx::before{content:"";box-sizing:border-box;position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}', '.r109xulx::after{box-sizing:border-box;content:"";position:absolute;right:0;bottom:0;left:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r109xulx:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r109xulx:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r109xulx:focus-within{outline:2px solid transparent;}", ".r1h2jnch{display:inline-grid;grid-template-columns:1fr 24px;grid-template-rows:1fr 1fr;column-gap:var(--spacingHorizontalXS);row-gap:0;position:relative;isolation:isolate;vertical-align:middle;background-color:var(--colorNeutralBackground1);min-height:32px;padding:0 var(--spacingHorizontalMNudge) 0 0;border-radius:var(--borderRadiusMedium);}", '.r1h2jnch::before{content:"";box-sizing:border-box;position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none;z-index:10;border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);border-radius:var(--borderRadiusMedium);}', '.r1h2jnch::after{box-sizing:border-box;content:"";position:absolute;left:0;bottom:0;right:0;z-index:20;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1h2jnch:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1h2jnch:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1h2jnch:focus-within{outline:2px solid transparent;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r109xulx::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r109xulx:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1h2jnch::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1h2jnch:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
});
var useRootStyles12 = __styles2({
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
  },
  medium: {},
  outline: {},
  outlineInteractive: {
    Bo3r8zu: "f1w2y1rc",
    Hpvxnh: ["f1gofhvl", "f18htlvq"],
    Bx11ytk: "ffcnd28",
    B1rg0w0: ["f18htlvq", "f1gofhvl"],
    Bsg1tlv: "f6lmxco",
    Brjw370: ["fcoc0mf", "f15r4wkl"],
    xcfy85: "f1ipdth8",
    Bcc6kan: ["f15r4wkl", "fcoc0mf"]
  },
  underline: {
    B0qfbqy: "f1o236ok",
    B4f6apu: ["faeg28l", "f64aojp"],
    y0oebl: "fdw6hkg",
    uvfttm: ["f64aojp", "faeg28l"],
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "f1xyh2jw"
  },
  underlineInteractive: {
    Bx11ytk: "ffcnd28",
    xcfy85: "f1ipdth8",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fkp7w9h"
  },
  filled: {
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f1kc0wz4"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  filledInteractive: {
    B05mzqr: "f1xqt08",
    tb9y6h: ["fzt5lgo", "f8tv3r9"],
    jcehpj: "fyhrops",
    B23o0hn: ["f8tv3r9", "fzt5lgo"]
  },
  invalid: {
    emecyz: "fl48pg9",
    lz0pba: ["f1a168p3", "f1pvdymy"],
    Bo1k74p: "f11knvgl",
    Ba322q7: ["f1pvdymy", "f1a168p3"]
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    Bq4z7u6: "f1a0lfh7",
    Bk5zm6e: ["f1p2ejm6", "fmzytvz"],
    Bqjgrrk: "fas2e61",
    Bm6vgfq: ["fmzytvz", "f1p2ejm6"],
    Bvljrlq: "f1p5b8em",
    Cqojjj: ["fs6f9xf", "f11b7h5x"],
    G3zxag: "f1vrn6tw",
    H8270r: ["f11b7h5x", "fs6f9xf"]
  }
}, {
  d: [".f1pha7fy{min-height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1o236ok::before{border-top-width:0;}", ".faeg28l::before{border-right-width:0;}", ".f64aojp::before{border-left-width:0;}", ".fdw6hkg::before{border-bottom-width:1px;}", [".f1xyh2jw::before{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fkp7w9h::after{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".f1kc0wz4::before{border:1px solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fl48pg9:not(:focus-within)::before,.fl48pg9:hover:not(:focus-within)::before{border-top-color:var(--colorPaletteRedBorder2);}", ".f1a168p3:not(:focus-within)::before,.f1a168p3:hover:not(:focus-within)::before{border-right-color:var(--colorPaletteRedBorder2);}", ".f1pvdymy:not(:focus-within)::before,.f1pvdymy:hover:not(:focus-within)::before{border-left-color:var(--colorPaletteRedBorder2);}", ".f11knvgl:not(:focus-within)::before,.f11knvgl:hover:not(:focus-within)::before{border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1a0lfh7::before{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1p2ejm6::before{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fmzytvz::before{border-left-color:var(--colorNeutralStrokeDisabled);}", ".fas2e61::before{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  h: [".f1w2y1rc:hover::before{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1gofhvl:hover::before{border-right-color:var(--colorNeutralStroke1Hover);}", ".f18htlvq:hover::before{border-left-color:var(--colorNeutralStroke1Hover);}", ".ffcnd28:hover::before{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".f1xqt08:hover::before,.f1xqt08:focus-within::before{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fzt5lgo:hover::before,.fzt5lgo:focus-within::before{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f8tv3r9:hover::before,.f8tv3r9:focus-within::before{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fyhrops:hover::before,.fyhrops:focus-within::before{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
  a: [".f6lmxco:active::before,.f6lmxco:focus-within::before{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fcoc0mf:active::before,.fcoc0mf:focus-within::before{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f15r4wkl:active::before,.f15r4wkl:focus-within::before{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1ipdth8:active::before,.f1ipdth8:focus-within::before{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media (forced-colors: active){.f1p5b8em::before{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f11b7h5x::before{border-left-color:GrayText;}.fs6f9xf::before{border-right-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1vrn6tw::before{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputClassName2 = __resetStyles("r1ljrqje", null, [".r1ljrqje{grid-column-start:1;grid-column-end:2;grid-row-start:1;grid-row-end:3;outline-style:none;border:0;padding:0;color:var(--colorNeutralForeground1);background-color:transparent;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;width:100%;}", ".r1ljrqje::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1ljrqje::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1ljrqje::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
var useInputStyles5 = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useBaseButtonClassName = __resetStyles("r1g4chgs", null, [".r1g4chgs{display:inline-flex;width:24px;align-items:center;justify-content:center;border:0;position:absolute;outline-style:none;height:16px;background-color:transparent;color:var(--colorNeutralForeground3);grid-column-start:2;border-radius:0;padding:0 5px 0 5px;}", ".r1g4chgs:active{outline-style:none;}", ".r1g4chgs:enabled:hover{cursor:pointer;color:var(--colorNeutralForeground3Hover);background-color:var(--colorSubtleBackgroundHover);}", ".r1g4chgs:enabled:active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1g4chgs:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1g4chgs:disabled{cursor:not-allowed;color:var(--colorNeutralForegroundDisabled);}"]);
var useButtonStyles = __styles2({
  increment: {
    Ijaq50: "f16hsg94",
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    z8tnut: "f10ra9hq",
    Byoj8tv: "f1brlhvm"
  },
  decrement: {
    Ijaq50: "faunodf",
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
    z8tnut: "f1sl3k7w",
    Byoj8tv: "f1y2xyjm"
  },
  incrementButtonSmall: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f4lv8q1", "fm3uwd2"],
    Bqenvij: "fvblgha"
  },
  decrementButtonSmall: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1q86st8", "frkrfqj"],
    Bqenvij: "fvblgha"
  },
  outline: {},
  underline: {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "f1bifk9c",
    p743kt: "fp1zg4s",
    B7xitij: "fo6hitd",
    B6siaa6: "f1wiab75",
    Ba9qmo4: "fj9zm5z",
    Dyrjrp: "f1cqwcg4"
  },
  "filled-darker": {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "fwwxidx",
    p743kt: "fp1zg4s",
    B7xitij: "f14i52sd",
    B6siaa6: "f1wiab75",
    Ba9qmo4: "fwry2ka",
    Dyrjrp: "f1cqwcg4"
  },
  "filled-lighter": {
    De3pzq: "f3rmtva",
    sj55zd: "f11d4kpn",
    r4wkhp: "f1no7wuu",
    B95qlz1: "f1yywxnv",
    drw0cw: "fzaa11h",
    idzz8t: "f4fpmm9",
    Dyrjrp: "f1cqwcg4"
  }
}, {
  d: [".f16hsg94{grid-row-start:1;}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f10ra9hq{padding-top:4px;}", ".f1brlhvm{padding-bottom:1px;}", ".faunodf{grid-row-start:2;}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1sl3k7w{padding-top:1px;}", ".f1y2xyjm{padding-bottom:4px;}", [".f4lv8q1{padding:3px 6px 0px 4px;}", {
    p: -1
  }], [".fm3uwd2{padding:3px 4px 0px 6px;}", {
    p: -1
  }], ".fvblgha{height:12px;}", [".f1q86st8{padding:0px 6px 3px 4px;}", {
    p: -1
  }], [".frkrfqj{padding:0px 4px 3px 6px;}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f1no7wuu:enabled:hover{color:var(--colorNeutralForeground3Hover);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fp1zg4s:enabled:active{color:var(--colorNeutralForeground3Pressed);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1wiab75:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}", ".fj9zm5z:enabled.fui-SpinButton__button_active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1cqwcg4:disabled{color:var(--colorNeutralForegroundDisabled);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".fwry2ka:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground3Pressed);}", ".f1yywxnv:enabled:hover{background-color:var(--colorNeutralBackground1Hover);}", ".fzaa11h:enabled:active,.fzaa11h:enabled.fui-SpinButton__button_active{color:var(--colorNeutralForeground3Pressed);}", ".f4fpmm9:enabled:active,.f4fpmm9:enabled.fui-SpinButton__button_active{background-color:var(--colorNeutralBackground1Pressed);}"]
});
var useSpinButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    spinState,
    size: size3
  } = state;
  const disabled = state.input.disabled;
  const invalid = `${state.input["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles12();
  const buttonStyles = useButtonStyles();
  const inputStyles = useInputStyles5();
  state.root.className = mergeClasses(spinButtonClassNames.root, useRootClassName6(), rootStyles[size3], rootStyles[appearance], filled && rootStyles.filled, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
  state.incrementButton.className = mergeClasses(spinButtonClassNames.incrementButton, spinState === "up" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.increment, buttonStyles[appearance], size3 === "small" && buttonStyles.incrementButtonSmall, state.incrementButton.className);
  state.decrementButton.className = mergeClasses(spinButtonClassNames.decrementButton, spinState === "down" && `${spinButtonExtraClassNames.buttonActive}`, useBaseButtonClassName(), buttonStyles.decrement, buttonStyles[appearance], size3 === "small" && buttonStyles.decrementButtonSmall, state.decrementButton.className);
  state.input.className = mergeClasses(spinButtonClassNames.input, useInputClassName2(), disabled && inputStyles.disabled, state.input.className);
  return state;
};

// node_modules/@fluentui/react-spinbutton/lib/components/SpinButton/SpinButton.js
var SpinButton = React259.forwardRef((props, ref) => {
  const state = useSpinButton_unstable(props, ref);
  useSpinButtonStyles_unstable(state);
  useCustomStyleHook("useSpinButtonStyles_unstable")(state);
  return renderSpinButton_unstable(state);
});
SpinButton.displayName = "SpinButton";

// node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
var React262 = __toESM(require_react());

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
var React261 = __toESM(require_react());

// node_modules/@fluentui/react-spinner/lib/contexts/SpinnerContext.js
var React260 = __toESM(require_react());
var SpinnerContext = React260.createContext(void 0);
var SpinnerContextDefaultValue = {};
var SpinnerContextProvider = SpinnerContext.Provider;
var useSpinnerContext = () => {
  var _React_useContext;
  return (_React_useContext = React260.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinner.js
var useSpinner_unstable = (props, ref) => {
  const { size: contextSize } = useSpinnerContext();
  const { appearance = "primary", labelPosition = "after", size: size3 = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay = 0 } = props;
  const baseId = useId2("spinner");
  const { role = "progressbar", ...rest } = props;
  const nativeRoot = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role,
    ...rest
  }, [
    "size"
  ]), {
    elementType: "div"
  });
  const [isShownAfterDelay, setIsShownAfterDelay] = React261.useState(false);
  const [setDelayTimeout, clearDelayTimeout] = useTimeout();
  React261.useEffect(() => {
    if (delay <= 0) {
      return;
    }
    setDelayTimeout(() => {
      setIsShownAfterDelay(true);
    }, delay);
    return () => {
      clearDelayTimeout();
    };
  }, [
    setDelayTimeout,
    clearDelayTimeout,
    delay
  ]);
  const labelShorthand = slot_exports.optional(props.label, {
    defaultProps: {
      id: baseId
    },
    renderByDefault: false,
    elementType: Label
  });
  const spinnerShortHand = slot_exports.optional(props.spinner, {
    renderByDefault: true,
    elementType: "span"
  });
  if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) {
    nativeRoot["aria-labelledby"] = labelShorthand.id;
  }
  const state = {
    appearance,
    delay,
    labelPosition,
    size: size3,
    shouldRenderSpinner: !delay || isShownAfterDelay,
    components: {
      root: "div",
      spinner: "span",
      spinnerTail: "span",
      label: Label
    },
    root: nativeRoot,
    spinner: spinnerShortHand,
    spinnerTail: slot_exports.always(props.spinnerTail, {
      elementType: "span"
    }),
    label: labelShorthand
  };
  return state;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/renderSpinner.js
var renderSpinner_unstable = (state) => {
  assertSlots(state);
  const { labelPosition, shouldRenderSpinner } = state;
  return jsxs(state.root, {
    children: [
      state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && jsx(state.label, {}),
      state.spinner && shouldRenderSpinner && jsx(state.spinner, {
        children: state.spinnerTail && jsx(state.spinnerTail, {})
      }),
      state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/useSpinnerStyles.styles.js
var spinnerClassNames = {
  root: "fui-Spinner",
  spinner: "fui-Spinner__spinner",
  spinnerTail: "fui-Spinner__spinnerTail",
  label: "fui-Spinner__label"
};
var useRootBaseClassName4 = __resetStyles("rpp59a7", null, [".rpp59a7{display:flex;align-items:center;justify-content:center;line-height:0;gap:8px;overflow:hidden;min-width:min-content;}"]);
var useRootStyles13 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}"]
});
var useSpinnerBaseClassName = __resetStyles("rvgcg50", "r15nd2jo", {
  r: [".rvgcg50{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:rb7n1on;}", "@keyframes rb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}", ".r15nd2jo{position:relative;flex-shrink:0;-webkit-mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);mask-image:radial-gradient(closest-side, transparent calc(100% - var(--fui-Spinner--strokeWidth) - 1px), white calc(100% - var(--fui-Spinner--strokeWidth)) calc(100% - 1px), transparent 100%);background-color:var(--colorBrandStroke2Contrast);color:var(--colorBrandStroke1);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear;animation-name:r1gx3jof;}", "@keyframes r1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"],
  s: ["@media screen and (forced-colors: active){.rvgcg50{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.rvgcg50{animation-duration:1.8s;}}", "@media screen and (forced-colors: active){.r15nd2jo{background-color:HighlightText;color:Highlight;forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r15nd2jo{animation-duration:1.8s;}}"]
});
var useSpinnerTailBaseClassName = __resetStyles("rxov3xa", "r1o544mv", {
  r: [".rxov3xa{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r15mim6k;}", '.rxov3xa::before,.rxov3xa::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r15mim6k{0%{transform:rotate(-135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(225deg);}}", ".rxov3xa::before{animation-name:r18vhmn8;}", "@keyframes r18vhmn8{0%{transform:rotate(0deg);}50%{transform:rotate(105deg);}100%{transform:rotate(0deg);}}", ".rxov3xa::after{animation-name:rkgrvoi;}", "@keyframes rkgrvoi{0%{transform:rotate(0deg);}50%{transform:rotate(225deg);}100%{transform:rotate(0deg);}}", ".r1o544mv{position:absolute;display:block;width:100%;height:100%;-webkit-mask-image:conic-gradient(transparent 105deg, white 105deg);mask-image:conic-gradient(transparent 105deg, white 105deg);animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:var(--curveEasyEase);animation-name:r109gmi5;}", '.r1o544mv::before,.r1o544mv::after{content:"";position:absolute;display:block;width:100%;height:100%;animation:inherit;background-image:conic-gradient(currentcolor 135deg, transparent 135deg);}', "@keyframes r109gmi5{0%{transform:rotate(135deg);}50%{transform:rotate(0deg);}100%{transform:rotate(-225deg);}}", ".r1o544mv::before{animation-name:r17whflh;}", "@keyframes r17whflh{0%{transform:rotate(0deg);}50%{transform:rotate(-105deg);}100%{transform:rotate(0deg);}}", ".r1o544mv::after{animation-name:re4odhl;}", "@keyframes re4odhl{0%{transform:rotate(0deg);}50%{transform:rotate(-225deg);}100%{transform:rotate(0deg);}}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.rxov3xa{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.rxov3xa::before,.rxov3xa::after{content:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1o544mv{animation-iteration-count:0;background-image:conic-gradient(transparent 120deg, currentcolor 360deg);}.r1o544mv::before,.r1o544mv::after{content:none;}}"]
});
var useSpinnerStyles = __styles2({
  inverted: {
    De3pzq: "fr407j0",
    sj55zd: "f1f7voed"
  },
  rtlTail: {
    btxmck: "f179dep3",
    gb5jj2: "fbz9ihp",
    Bdya8wy: "f1pme1qz"
  },
  "extra-tiny": {
    Bqenvij: "fd461yt",
    a9b677: "fjw5fx7",
    qmp6fs: "f1v3ph3m"
  },
  tiny: {
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3",
    qmp6fs: "f1v3ph3m"
  },
  "extra-small": {
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun",
    qmp6fs: "f1v3ph3m"
  },
  small: {
    Bqenvij: "fxldao9",
    a9b677: "f1w9dchk",
    qmp6fs: "f1v3ph3m"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    a9b677: "f1szoe96",
    qmp6fs: "fb52u90"
  },
  large: {
    Bqenvij: "f8ljn23",
    a9b677: "fpdz1er",
    qmp6fs: "fb52u90"
  },
  "extra-large": {
    Bqenvij: "fbhnoac",
    a9b677: "feqmc2u",
    qmp6fs: "fb52u90"
  },
  huge: {
    Bqenvij: "f1ft4266",
    a9b677: "fksc0bp",
    qmp6fs: "fa3u9ii"
  }
}, {
  d: [".fr407j0{background-color:var(--colorNeutralStrokeAlpha2);}", ".f1f7voed{color:var(--colorNeutralStrokeOnBrand2);}", ".f179dep3{-webkit-mask-image:conic-gradient(white 255deg, transparent 255deg);mask-image:conic-gradient(white 255deg, transparent 255deg);}", ".fbz9ihp::before,.fbz9ihp::after{background-image:conic-gradient(transparent 225deg, currentcolor 225deg);}", ".fd461yt{height:16px;}", ".fjw5fx7{width:16px;}", ".f1v3ph3m{--fui-Spinner--strokeWidth:var(--strokeWidthThick);}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxldao9{height:28px;}", ".f1w9dchk{width:28px;}", ".f1d2rq10{height:32px;}", ".f1szoe96{width:32px;}", ".fb52u90{--fui-Spinner--strokeWidth:var(--strokeWidthThicker);}", ".f8ljn23{height:36px;}", ".fpdz1er{width:36px;}", ".fbhnoac{height:40px;}", ".feqmc2u{width:40px;}", ".f1ft4266{height:44px;}", ".fksc0bp{width:44px;}", ".fa3u9ii{--fui-Spinner--strokeWidth:var(--strokeWidthThickest);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.f1pme1qz{background-image:conic-gradient(currentcolor 0deg, transparent 240deg);}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]]
});
var useLabelStyles4 = __styles2({
  inverted: {
    sj55zd: "fonrgv7"
  },
  "extra-tiny": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  tiny: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  "extra-small": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  "extra-large": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  huge: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  }
}, {
  d: [".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
});
var useSpinnerStyles_unstable = (state) => {
  "use no memo";
  const {
    labelPosition,
    size: size3,
    appearance
  } = state;
  const {
    dir
  } = useFluent();
  const rootBaseClassName = useRootBaseClassName4();
  const rootStyles = useRootStyles13();
  const spinnerBaseClassName = useSpinnerBaseClassName();
  const spinnerStyles = useSpinnerStyles();
  const spinnerTailBaseClassName = useSpinnerTailBaseClassName();
  const labelStyles = useLabelStyles4();
  state.root.className = mergeClasses(spinnerClassNames.root, rootBaseClassName, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, state.root.className);
  if (state.spinner) {
    state.spinner.className = mergeClasses(spinnerClassNames.spinner, spinnerBaseClassName, spinnerStyles[size3], appearance === "inverted" && spinnerStyles.inverted, state.spinner.className);
  }
  if (state.spinnerTail) {
    state.spinnerTail.className = mergeClasses(spinnerClassNames.spinnerTail, spinnerTailBaseClassName, dir === "rtl" && spinnerStyles.rtlTail, state.spinnerTail.className);
  }
  if (state.label) {
    state.label.className = mergeClasses(spinnerClassNames.label, labelStyles[size3], appearance === "inverted" && labelStyles.inverted, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-spinner/lib/components/Spinner/Spinner.js
var Spinner = React262.forwardRef((props, ref) => {
  const state = useSpinner_unstable(props, ref);
  useSpinnerStyles_unstable(state);
  useCustomStyleHook("useSpinnerStyles_unstable")(state);
  return renderSpinner_unstable(state);
});
Spinner.displayName = "Spinner";

// node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
var React264 = __toESM(require_react());

// node_modules/@fluentui/react-switch/lib/components/Switch/useSwitch.js
var React263 = __toESM(require_react());
var useSwitch_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true
  });
  const { checked, defaultChecked, disabled, labelPosition = "after", size: size3 = "medium", onChange, required } = props;
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "checked",
      "defaultChecked",
      "onChange",
      "size"
    ]
  });
  const id = useId2("switch-", nativeProps.primary.id);
  const root = slot_exports.always(props.root, {
    defaultProps: {
      ref: useFocusWithin(),
      ...nativeProps.root
    },
    elementType: "div"
  });
  const indicator = slot_exports.always(props.indicator, {
    defaultProps: {
      "aria-hidden": true,
      children: React263.createElement(CircleFilled, null)
    },
    elementType: "div"
  });
  const input = slot_exports.always(props.input, {
    defaultProps: {
      checked,
      defaultChecked,
      id,
      ref,
      role: "switch",
      type: "checkbox",
      ...nativeProps.primary
    },
    elementType: "input"
  });
  input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
    checked: ev.currentTarget.checked
  }));
  const label = slot_exports.optional(props.label, {
    defaultProps: {
      disabled,
      htmlFor: id,
      required,
      size: "medium"
    },
    elementType: Label
  });
  return {
    labelPosition,
    components: {
      root: "div",
      indicator: "div",
      input: "input",
      label: Label
    },
    root,
    indicator,
    input,
    label,
    size: size3
  };
};

// node_modules/@fluentui/react-switch/lib/components/Switch/renderSwitch.js
var renderSwitch_unstable = (state) => {
  assertSlots(state);
  const { labelPosition } = state;
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      labelPosition !== "after" && state.label && jsx(state.label, {}),
      jsx(state.indicator, {}),
      labelPosition === "after" && state.label && jsx(state.label, {})
    ]
  });
};

// node_modules/@fluentui/react-switch/lib/components/Switch/useSwitchStyles.styles.js
var switchClassNames = {
  root: "fui-Switch",
  indicator: "fui-Switch__indicator",
  input: "fui-Switch__input",
  label: "fui-Switch__label"
};
var switchClassName = switchClassNames.root;
var spaceBetweenThumbAndTrack2 = 2;
var trackHeightMedium = 20;
var thumbSizeMedium = trackHeightMedium - spaceBetweenThumbAndTrack2;
var trackHeightSmall = 16;
var thumbSizeSmall = trackHeightSmall - spaceBetweenThumbAndTrack2;
var useRootBaseClassName5 = __resetStyles("r2i81i2", "rofhmb8", {
  r: [".r2i81i2{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".r2i81i2:focus{outline-style:none;}", ".r2i81i2:focus-visible{outline-style:none;}", ".r2i81i2[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2i81i2[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rofhmb8{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rofhmb8:focus{outline-style:none;}", ".rofhmb8:focus-visible{outline-style:none;}", ".rofhmb8[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rofhmb8[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r2i81i2[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rofhmb8[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useRootStyles14 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}"]
});
var useIndicatorBaseClassName3 = __resetStyles("r1c3hft5", null, {
  r: [".r1c3hft5{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r1c3hft5>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
  s: ["@media screen and (prefers-reduced-motion: reduce){.r1c3hft5{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1c3hft5{color:CanvasText;}.r1c3hft5>i{forced-color-adjust:none;}}", "@media screen and (prefers-reduced-motion: reduce){.r1c3hft5>*{transition-duration:0.01ms;}}"]
});
var useIndicatorStyles2 = __styles2({
  labelAbove: {
    B6of3ja: "f1hu3pq6"
  },
  sizeSmall: {
    Be2twd7: "fses1vf",
    Bqenvij: "fd461yt",
    a9b677: "f1szoe96"
  }
}, {
  d: [".f1hu3pq6{margin-top:0;}", ".fses1vf{font-size:14px;}", ".fd461yt{height:16px;}", ".f1szoe96{width:32px;}"]
});
var useInputBaseClassName3 = __resetStyles("rsji9ng", "r15xih98", {
  r: [".rsji9ng{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".rsji9ng:checked~.fui-Switch__indicator>*{transform:translateX(20px);}", ".rsji9ng:disabled{cursor:default;}", ".rsji9ng:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".rsji9ng:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".rsji9ng:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rsji9ng:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".rsji9ng:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".rsji9ng:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}", ".r15xih98{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".r15xih98:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}", ".r15xih98:disabled{cursor:default;}", ".r15xih98:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".r15xih98:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".r15xih98:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r15xih98:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r15xih98:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".r15xih98:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".r15xih98:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"],
  s: ["@media (forced-colors: active){.rsji9ng:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rsji9ng:disabled~.fui-Switch__label{color:GrayText;}.rsji9ng:hover{color:CanvasText;}.rsji9ng:hover:active{color:CanvasText;}.rsji9ng:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rsji9ng:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r15xih98:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r15xih98:disabled~.fui-Switch__label{color:GrayText;}.r15xih98:hover{color:CanvasText;}.r15xih98:hover:active{color:CanvasText;}.r15xih98:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked:hover:active~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r15xih98:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
});
var useInputStyles6 = __styles2({
  before: {
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bhzewxz: "f15twtuk"
  },
  after: {
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    Bhzewxz: "f15twtuk"
  },
  above: {
    B5kzvoi: "f1yab3r1",
    Bqenvij: "f1aar7gd",
    a9b677: "fly5x3f"
  },
  sizeSmall: {
    a9b677: "f83td6f",
    oedwrj: ["f1t5zc5r", "fmy58zi"]
  }
}, {
  d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}", ".fly5x3f{width:100%;}", ".f83td6f{width:calc(32px + 2 * var(--spacingHorizontalS));}", ".f1t5zc5r:checked~.fui-Switch__indicator>*{transform:translateX(16px);}", ".fmy58zi:checked~.fui-Switch__indicator>*{transform:translateX(-16px);}"]
});
var useLabelStyles5 = __styles2({
  base: {
    Bceei9c: "f1k6fduh",
    jrapky: "f49ad5g",
    B6of3ja: "f1xlvstr",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8"
  },
  sizeSmall: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    jrapky: "f1suqah5",
    B6of3ja: "f26bnac"
  },
  above: {
    z8tnut: "f1ywm7hm",
    Byoj8tv: "f14wxoun",
    a9b677: "fly5x3f"
  },
  after: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  before: {
    z189sj: ["f7x41pl", "fruq291"]
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1suqah5{margin-bottom:calc((16px - var(--lineHeightBase200)) / 2);}", ".f26bnac{margin-top:calc((16px - var(--lineHeightBase200)) / 2);}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".fly5x3f{width:100%;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}"]
});
var useSwitchStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName5();
  const rootStyles = useRootStyles14();
  const indicatorBaseClassName = useIndicatorBaseClassName3();
  const indicatorStyles = useIndicatorStyles2();
  const inputBaseClassName = useInputBaseClassName3();
  const inputStyles = useInputStyles6();
  const labelStyles = useLabelStyles5();
  const {
    label,
    labelPosition,
    size: size3
  } = state;
  state.root.className = mergeClasses(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
  state.indicator.className = mergeClasses(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, size3 === "small" && indicatorStyles.sizeSmall, state.indicator.className);
  state.input.className = mergeClasses(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], size3 === "small" && inputStyles.sizeSmall, state.input.className);
  if (state.label) {
    state.label.className = mergeClasses(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], size3 === "small" && labelStyles.sizeSmall, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-switch/lib/components/Switch/Switch.js
var Switch = React264.forwardRef((props, ref) => {
  const state = useSwitch_unstable(props, ref);
  useSwitchStyles_unstable(state);
  useCustomStyleHook("useSwitchStyles_unstable")(state);
  return renderSwitch_unstable(state);
});
Switch.displayName = "Switch";

// node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
var React269 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
var React267 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
var React266 = __toESM(require_react());

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabList.js
var React265 = __toESM(require_react());
var useTabList_unstable = (props, ref) => {
  const { appearance = "transparent", reserveSelectedTabSpace = true, size: size3 = "medium" } = props;
  const state = useTabListBase_unstable(props, ref);
  const focusAttributes = useTabListA11yBehavior_unstable({
    vertical: state.vertical
  });
  return {
    ...state,
    root: {
      ...state.root,
      ...focusAttributes
    },
    appearance,
    reserveSelectedTabSpace,
    size: size3
  };
};
var useTabListBase_unstable = (props, ref) => {
  const { disabled = false, onTabSelect, selectTabOnFocus = false, vertical = false, selectedValue: controlledSelectedValue, defaultSelectedValue, ...rest } = props;
  const innerRef = React265.useRef(null);
  const [selectedValue, setSelectedValue] = useControllableState({
    state: controlledSelectedValue,
    defaultState: defaultSelectedValue,
    initialState: void 0
  });
  const currentSelectedValue = React265.useRef(void 0);
  const previousSelectedValue = React265.useRef(void 0);
  React265.useEffect(() => {
    previousSelectedValue.current = currentSelectedValue.current;
    currentSelectedValue.current = selectedValue;
  }, [
    selectedValue
  ]);
  const onSelect = useEventCallback((event, data) => {
    setSelectedValue(data.value);
    onTabSelect === null || onTabSelect === void 0 ? void 0 : onTabSelect(event, data);
  });
  const registeredTabs = React265.useRef({});
  const onRegister = useEventCallback((data) => {
    const key = JSON.stringify(data.value);
    if (!key && true) {
      console.error([
        `[@fluentui/react-tabs] The value "${data.value}" cannot be serialized to JSON string.`,
        "Tab component requires serializable values.",
        "Please provide a primitive value (string, number, boolean),",
        `or a plain object/array that doesn't contain functions, symbols, or circular references.`
      ].join(" "));
    }
    registeredTabs.current[key] = data;
  });
  const onUnregister = useEventCallback((data) => {
    delete registeredTabs.current[JSON.stringify(data.value)];
  });
  const getRegisteredTabs = React265.useCallback(() => {
    return {
      selectedValue: currentSelectedValue.current,
      previousSelectedValue: previousSelectedValue.current,
      registeredTabs: registeredTabs.current
    };
  }, []);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always({
      ref: useMergedRefs(ref, innerRef),
      role: "tablist",
      "aria-orientation": vertical ? "vertical" : "horizontal",
      ...rest
    }, {
      elementType: "div"
    }),
    disabled,
    selectTabOnFocus,
    selectedValue,
    onRegister,
    onUnregister,
    onSelect,
    getRegisteredTabs,
    vertical
  };
};
var useTabListA11yBehavior_unstable = ({ vertical }) => {
  return useArrowNavigationGroup({
    circular: true,
    axis: vertical ? "vertical" : "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabListContext.js
var tabListContextDefaultValue = {
  appearance: "transparent",
  reserveSelectedTabSpace: true,
  selectTabOnFocus: false,
  disabled: false,
  selectedValue: void 0,
  onRegister: () => {
  },
  onUnregister: () => {
  },
  onSelect: () => {
  },
  getRegisteredTabs: () => {
    return {
      registeredTabs: {}
    };
  },
  size: "medium",
  vertical: false
};
var TabListContext = createContext13(void 0);
var TabListProvider = TabListContext.Provider;
var useTabListContext_unstable = (selector) => useContextSelector(TabListContext, (ctx = tabListContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-tabs/lib/components/TabList/renderTabList.js
var renderTabList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(TabListProvider, {
      value: contextValues.tabList,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListStyles.styles.js
var tabListClassNames = {
  root: "fui-TabList"
};
var useStyles31 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bnnss6s: "fi64zpg",
    Eh141a: "flvyvdh",
    qhf8xq: "f10pi13n"
  },
  horizontal: {
    Bt984gj: "f1q9h2pe",
    Beiy3e4: "f1063pyq"
  },
  vertical: {
    Bt984gj: "f1q9h2pe",
    Beiy3e4: "f1vx9l62"
  },
  roundedSmall: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  rounded: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "faqewft"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fi64zpg{flex-shrink:0;}", ".flvyvdh{flex-wrap:nowrap;}", ".f10pi13n{position:relative;}", ".f1q9h2pe{align-items:stretch;}", ".f1vx9l62{flex-direction:column;}", [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".faqewft{gap:var(--spacingHorizontalS);}", {
    p: -1
  }]]
});
var useTabListStyles_unstable = (state) => {
  "use no memo";
  const {
    appearance,
    vertical,
    size: size3
  } = state;
  const styles = useStyles31();
  const isRounded = appearance === "subtle-circular" || appearance === "filled-circular";
  state.root.className = mergeClasses(tabListClassNames.root, styles.root, vertical ? styles.vertical : styles.horizontal, isRounded && (size3 === "small" ? styles.roundedSmall : styles.rounded), state.root.className);
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/TabList/useTabListContextValues.js
function useTabListContextValues_unstable(state) {
  const { appearance, reserveSelectedTabSpace, disabled, selectTabOnFocus, selectedValue: selectedKey, onRegister, onUnregister, onSelect, getRegisteredTabs, size: size3, vertical } = state;
  const tabList = {
    appearance,
    reserveSelectedTabSpace,
    disabled,
    selectTabOnFocus,
    selectedValue: selectedKey,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredTabs,
    size: size3,
    vertical
  };
  return {
    tabList
  };
}

// node_modules/@fluentui/react-tabs/lib/components/TabList/TabList.js
var TabList = React266.forwardRef((props, ref) => {
  const state = useTabList_unstable(props, ref);
  const contextValues = useTabListContextValues_unstable(state);
  useTabListStyles_unstable(state);
  useCustomStyleHook("useTabListStyles_unstable")(state);
  return renderTabList_unstable(state, contextValues);
});
TabList.displayName = "TabList";

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTab.js
var useTab_unstable = (props, ref) => {
  const { content } = props;
  const state = useTabBase_unstable(props, ref);
  const focusAttributes = useTabA11yBehavior_unstable(state);
  const appearance = useTabListContext_unstable((ctx) => ctx.appearance);
  const reserveSelectedTabSpace = useTabListContext_unstable((ctx) => ctx.reserveSelectedTabSpace);
  const size3 = useTabListContext_unstable((ctx) => {
    var _ctx_size;
    return (_ctx_size = ctx.size) !== null && _ctx_size !== void 0 ? _ctx_size : "medium";
  });
  const contentReservedSpace = content && typeof content === "object" ? omit(content, [
    "ref"
  ]) : content;
  return {
    ...state,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    components: {
      ...state.components,
      contentReservedSpace: "span"
    },
    root: {
      ...state.root,
      ...focusAttributes
    },
    contentReservedSpace: slot_exports.optional(contentReservedSpace, {
      renderByDefault: !state.selected && !state.iconOnly && reserveSelectedTabSpace,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    appearance,
    size: size3
  };
};
var useTabBase_unstable = (props, ref) => {
  const { content, disabled: tabDisabled = false, icon, onClick, onFocus, value, ...rest } = props;
  const selectTabOnFocus = useTabListContext_unstable((ctx) => ctx.selectTabOnFocus);
  const listDisabled = useTabListContext_unstable((ctx) => ctx.disabled);
  const selected = useTabListContext_unstable((ctx) => ctx.selectedValue === value);
  const onRegister = useTabListContext_unstable((ctx) => ctx.onRegister);
  const onUnregister = useTabListContext_unstable((ctx) => ctx.onUnregister);
  const onSelect = useTabListContext_unstable((ctx) => ctx.onSelect);
  const vertical = useTabListContext_unstable((ctx) => !!ctx.vertical);
  const disabled = listDisabled || tabDisabled;
  const innerRef = React267.useRef(null);
  const onSelectCallback = (event) => onSelect(event, {
    value
  });
  const onTabClick = useEventCallback(mergeCallbacks(onClick, onSelectCallback));
  const onTabFocus = useEventCallback(mergeCallbacks(onFocus, onSelectCallback));
  React267.useEffect(() => {
    onRegister({
      value,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    value
  ]);
  const iconSlot = slot_exports.optional(icon, {
    elementType: "span"
  });
  const contentSlot = slot_exports.always(content, {
    defaultProps: {
      children: props.children
    },
    elementType: "span"
  });
  const iconOnly = Boolean((iconSlot === null || iconSlot === void 0 ? void 0 : iconSlot.children) && !contentSlot.children);
  return {
    components: {
      root: "button",
      icon: "span",
      content: "span",
      contentReservedSpace: "span"
    },
    root: slot_exports.always({
      ref: useMergedRefs(ref, innerRef),
      role: "tab",
      type: "button",
      // aria-selected undefined indicates it is not selectable
      // according to https://www.w3.org/TR/wai-aria-1.1/#aria-selected
      "aria-selected": disabled ? void 0 : `${selected}`,
      value,
      ...rest,
      disabled,
      onClick: onTabClick,
      onFocus: selectTabOnFocus ? onTabFocus : onFocus
    }, {
      elementType: "button"
    }),
    icon: iconSlot,
    iconOnly,
    content: contentSlot,
    disabled,
    selected,
    value,
    vertical
  };
};
var useTabA11yBehavior_unstable = ({ selected }) => {
  return useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/renderTab.js
var renderTab_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      !state.iconOnly && jsx(state.content, {}),
      state.contentReservedSpace && jsx(state.contentReservedSpace, {})
    ]
  });
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTabAnimatedIndicator.styles.js
var React268 = __toESM(require_react());
var tabIndicatorCssVars_unstable = {
  offsetVar: "--fui-Tab__indicator--offset",
  scaleVar: "--fui-Tab__indicator--scale"
};
var useActiveIndicatorStyles = __styles2({
  base: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg"
  },
  animated: {
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f6zz20j",
    B1dyfl9: "f1ai4sc1",
    Bu93a1u: "f1rnm8gg",
    Bdasjez: "f1x3cmqg"
  },
  horizontal: {
    sjv3b2: ["fug4aj8", "f1i5xzg7"],
    b1kco5: "f1q7ujh"
  },
  vertical: {
    sjv3b2: "f1hqboyk",
    b1kco5: "f1dxupa6"
  }
}, {
  d: [[".f1gl81tg{overflow:visible;}", {
    p: -1
  }], ".fhwpy7i::after{transition-property:transform;}", ".f6zz20j::after{transition-duration:var(--durationSlow);}", ".f1ai4sc1::after{transition-timing-function:var(--curveDecelerateMax);}", ".fug4aj8::after{transform-origin:left;}", ".f1i5xzg7::after{transform-origin:right;}", ".f1q7ujh::after{transform:translateX(var(--fui-Tab__indicator--offset)) scaleX(var(--fui-Tab__indicator--scale));}", ".f1hqboyk::after{transform-origin:top;}", ".f1dxupa6::after{transform:translateY(var(--fui-Tab__indicator--offset)) scaleY(var(--fui-Tab__indicator--scale));}"],
  m: [["@media (prefers-reduced-motion: reduce){.f1rnm8gg::after{transition-property:none;}}", {
    m: "(prefers-reduced-motion: reduce)"
  }], ["@media (prefers-reduced-motion: reduce){.f1x3cmqg::after{transition-duration:0.01ms;}}", {
    m: "(prefers-reduced-motion: reduce)"
  }]]
});
var calculateTabRect = (element) => {
  if (element) {
    var _element_parentElement;
    const parentRect = ((_element_parentElement = element.parentElement) === null || _element_parentElement === void 0 ? void 0 : _element_parentElement.getBoundingClientRect()) || {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    const tabRect = element.getBoundingClientRect();
    return {
      x: tabRect.x - parentRect.x,
      y: tabRect.y - parentRect.y,
      width: tabRect.width,
      height: tabRect.height
    };
  }
  return void 0;
};
var getRegisteredTabRect = (registeredTabs, value) => {
  var _registeredTabs_JSON_stringify;
  const element = isValueDefined(value) ? (_registeredTabs_JSON_stringify = registeredTabs[JSON.stringify(value)]) === null || _registeredTabs_JSON_stringify === void 0 ? void 0 : _registeredTabs_JSON_stringify.ref.current : void 0;
  return element ? calculateTabRect(element) : void 0;
};
var isValueDefined = (value) => value != null;
var useTabAnimatedIndicatorStyles_unstable = (state) => {
  const {
    disabled,
    selected,
    vertical
  } = state;
  const activeIndicatorStyles = useActiveIndicatorStyles();
  const [lastAnimatedFrom, setLastAnimatedFrom] = React268.useState();
  const [animationValues, setAnimationValues] = React268.useState({
    offset: 0,
    scale: 1
  });
  const getRegisteredTabs = useTabListContext_unstable((ctx) => ctx.getRegisteredTabs);
  const [requestAnimationFrame2] = useAnimationFrame();
  if (selected) {
    const {
      previousSelectedValue,
      selectedValue,
      registeredTabs
    } = getRegisteredTabs();
    if (isValueDefined(previousSelectedValue) && lastAnimatedFrom !== previousSelectedValue) {
      const previousSelectedTabRect = getRegisteredTabRect(registeredTabs, previousSelectedValue);
      const selectedTabRect = getRegisteredTabRect(registeredTabs, selectedValue);
      if (selectedTabRect && previousSelectedTabRect) {
        const offset4 = vertical ? previousSelectedTabRect.y - selectedTabRect.y : previousSelectedTabRect.x - selectedTabRect.x;
        const scale = vertical ? previousSelectedTabRect.height / selectedTabRect.height : previousSelectedTabRect.width / selectedTabRect.width;
        setAnimationValues({
          offset: offset4,
          scale
        });
        setLastAnimatedFrom(previousSelectedValue);
        requestAnimationFrame2(() => setAnimationValues({
          offset: 0,
          scale: 1
        }));
      }
    }
  } else if (isValueDefined(lastAnimatedFrom)) {
    setLastAnimatedFrom(void 0);
  }
  if (disabled) {
    return state;
  }
  const animating = animationValues.offset === 0 && animationValues.scale === 1;
  state.root.className = mergeClasses(state.root.className, selected && activeIndicatorStyles.base, selected && animating && activeIndicatorStyles.animated, selected && (vertical ? activeIndicatorStyles.vertical : activeIndicatorStyles.horizontal));
  const rootCssVars = {
    [tabIndicatorCssVars_unstable.offsetVar]: `${animationValues.offset}px`,
    [tabIndicatorCssVars_unstable.scaleVar]: `${animationValues.scale}`
  };
  state.root.style = {
    ...rootCssVars,
    ...state.root.style
  };
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/useTabStyles.styles.js
var tabClassNames = {
  root: "fui-Tab",
  icon: "fui-Tab__icon",
  content: "fui-Tab__content"
};
var tabReservedSpaceClassNames = {
  content: "fui-Tab__content--reserved-space"
};
var useRootStyles15 = __styles2({
  root: {
    Bt984gj: "f122n59",
    mc9l5x: "f13qh94s",
    Bnnss6s: "fi64zpg",
    Bxotwcr: "f1u07yai",
    Budl1dq: "frn2hmy",
    wkccdc: "f1olsevy",
    oeaueh: "f1s6fcnf",
    qhf8xq: "f10pi13n"
  },
  button: {
    Bt984gj: "f122n59",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f13qh94s",
    Bnnss6s: "fi64zpg",
    Bxotwcr: "f1u07yai",
    Budl1dq: "frn2hmy",
    wkccdc: "f1olsevy",
    Bahqtrf: "fk6fouc",
    Bg96gwp: "f1i3iumi",
    oeaueh: "f1s6fcnf",
    qhf8xq: "f10pi13n",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    B9bfxx9: "f1cxpek8"
  },
  horizontal: {
    Brf1p80: "f4d9j23"
  },
  vertical: {
    Brf1p80: "f1s9ku6b"
  },
  smallHorizontal: {
    i8kkvl: "f14mj54c",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1wmopi4"
  },
  smallVertical: {
    i8kkvl: "f14mj54c",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f12or63q"
  },
  mediumHorizontal: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1w08f2p"
  },
  mediumVertical: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fymxs25"
  },
  largeHorizontal: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ssfvub"
  },
  largeVertical: {
    i8kkvl: "f1rjii52",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fwkd1rq"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    B95qlz1: "f9rvdkv",
    B7xitij: "f1051ucx",
    Bptxc3x: "fmmjozx",
    Bwqhzpy: "fqhzt5g",
    iyk698: "f7l5cgy",
    cl4aha: "fpkze5g",
    B0q3jbp: "f1iywnoi",
    Be9ayug: "f9n45c4"
  },
  subtle: {
    De3pzq: "fhovq9v",
    B95qlz1: "f1bifk9c",
    B7xitij: "fo6hitd",
    Bptxc3x: "fmmjozx",
    Bwqhzpy: "fqhzt5g",
    iyk698: "f7l5cgy",
    cl4aha: "fpkze5g",
    B0q3jbp: "f1iywnoi",
    Be9ayug: "f9n45c4"
  },
  disabledCursor: {
    Bceei9c: "fdrzuqr"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    Bptxc3x: "fato7r6",
    cl4aha: "fao1bnu"
  },
  selected: {
    Bptxc3x: "f1cadz5z",
    Bwqhzpy: "fwhdxxj",
    iyk698: "fintccb",
    cl4aha: "ffplhdr",
    B0q3jbp: "fjo17wb",
    Be9ayug: "f148789c"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f13qh94s{display:grid;}", ".fi64zpg{flex-shrink:0;}", ".f1u07yai{grid-auto-flow:column;}", ".frn2hmy{grid-template-columns:auto;}", ".f1olsevy{grid-template-rows:auto;}", ".f1s6fcnf{outline-style:none;}", ".f10pi13n{position:relative;}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1cxpek8{text-transform:none;}", ".f4d9j23{justify-content:center;}", ".f1s9ku6b{justify-content:start;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", [".f1wmopi4{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".f12or63q{padding:var(--spacingVerticalXXS) var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", [".f1w08f2p{padding:var(--spacingVerticalM) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fymxs25{padding:var(--spacingVerticalSNudge) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1ssfvub{padding:var(--spacingVerticalL) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fwkd1rq{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f9rvdkv:enabled:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1051ucx:enabled:active{background-color:var(--colorTransparentBackgroundPressed);}", ".fmmjozx .fui-Tab__icon{color:var(--colorNeutralForeground2);}", ".fqhzt5g:enabled:hover .fui-Tab__icon{color:var(--colorNeutralForeground2Hover);}", ".f7l5cgy:enabled:active .fui-Tab__icon{color:var(--colorNeutralForeground2Pressed);}", ".fpkze5g .fui-Tab__content{color:var(--colorNeutralForeground2);}", ".f1iywnoi:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground2Hover);}", ".f9n45c4:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground2Pressed);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fdrzuqr{cursor:not-allowed;}", ".fato7r6 .fui-Tab__icon{color:var(--colorNeutralForegroundDisabled);}", ".fao1bnu .fui-Tab__content{color:var(--colorNeutralForegroundDisabled);}", ".f1cadz5z .fui-Tab__icon{color:var(--colorCompoundBrandForeground1);}", ".fwhdxxj:enabled:hover .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Hover);}", ".fintccb:enabled:active .fui-Tab__icon{color:var(--colorCompoundBrandForeground1Pressed);}", ".ffplhdr .fui-Tab__content{color:var(--colorNeutralForeground1);}", ".fjo17wb:enabled:hover .fui-Tab__content{color:var(--colorNeutralForeground1Hover);}", ".f148789c:enabled:active .fui-Tab__content{color:var(--colorNeutralForeground1Pressed);}"]
});
var useCircularAppearanceStyles = __styles2({
  base: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fp7rvkm",
    Bptxc3x: "ftorr8m",
    cl4aha: "f16lqpmv"
  },
  small: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "fzklhed"
  },
  medium: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "f1j721cc"
  },
  large: {
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "frx9knr"
  },
  subtle: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    B95qlz1: "f1bifk9c",
    Eo63ln: 0,
    r9osk6: 0,
    Itrz8y: 0,
    zeg6vx: 0,
    l65xgk: 0,
    Bw4olcx: 0,
    Folb0i: 0,
    I2h8y4: 0,
    Bgxgoyi: 0,
    Bvlkotb: 0,
    Fwyncl: 0,
    Byh5edv: 0,
    Becqvjq: 0,
    uumbiq: 0,
    B73q3dg: 0,
    Bblwbaf: 0,
    B0ezav: "ft57sj0",
    r4wkhp: "f1fcoy83",
    B7xitij: "fo6hitd",
    d3wsvi: 0,
    Hdqn7s: 0,
    zu5y1p: 0,
    owqphb: 0,
    g9c53k: 0,
    Btmu08z: 0,
    Bthxvy6: 0,
    gluvuq: 0,
    tb88gp: 0,
    wns6jk: 0,
    kdfdk4: 0,
    Bbw008l: 0,
    Bayi1ib: 0,
    B1kkfu3: 0,
    J1oqyp: 0,
    kem6az: 0,
    goa3yj: "fhn220o",
    p743kt: "f15qf7sh",
    wmvzou: 0,
    sc4o1m: 0,
    wymq9i: 0,
    u9orzk: 0,
    puiv5t: 0,
    Bosien3: 0,
    b2z72d: 0,
    Beulxaw: 0,
    B57pkaw: 0,
    Jcjdmf: 0,
    B8qgbzl: 0,
    Bbmb0sr: 0,
    B14q8qp: 0,
    Bcq6wej: 0,
    Byz1pjr: 0,
    kr9cjb: 0,
    Ff9ifp: "f1mljprk"
  },
  subtleSelected: {
    De3pzq: "f16xkysk",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1c2pc3t",
    sj55zd: "faj9fo0",
    B95qlz1: "fsm7zmf",
    Eo63ln: 0,
    r9osk6: 0,
    Itrz8y: 0,
    zeg6vx: 0,
    l65xgk: 0,
    Bw4olcx: 0,
    Folb0i: 0,
    I2h8y4: 0,
    Bgxgoyi: 0,
    Bvlkotb: 0,
    Fwyncl: 0,
    Byh5edv: 0,
    Becqvjq: 0,
    uumbiq: 0,
    B73q3dg: 0,
    Bblwbaf: 0,
    B0ezav: "f1wo0sfq",
    r4wkhp: "f1afuynh",
    B7xitij: "f94ddyl",
    d3wsvi: 0,
    Hdqn7s: 0,
    zu5y1p: 0,
    owqphb: 0,
    g9c53k: 0,
    Btmu08z: 0,
    Bthxvy6: 0,
    gluvuq: 0,
    tb88gp: 0,
    wns6jk: 0,
    kdfdk4: 0,
    Bbw008l: 0,
    Bayi1ib: 0,
    B1kkfu3: 0,
    J1oqyp: 0,
    kem6az: 0,
    goa3yj: "fmle6oo",
    p743kt: "f1d3itm4",
    wmvzou: 0,
    sc4o1m: 0,
    wymq9i: 0,
    u9orzk: 0,
    puiv5t: 0,
    Bosien3: 0,
    b2z72d: 0,
    Beulxaw: 0,
    B57pkaw: 0,
    Jcjdmf: 0,
    B8qgbzl: 0,
    Bbmb0sr: 0,
    B14q8qp: 0,
    Bcq6wej: 0,
    Byz1pjr: 0,
    kr9cjb: 0,
    Ff9ifp: "f1e9l2u"
  },
  subtleDisabled: {
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o"
  },
  subtleDisabledSelected: {
    De3pzq: "f1bg9a2p",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fegtqic",
    sj55zd: "f1s2aq7o"
  },
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    B95qlz1: "fwwxidx",
    r4wkhp: "f1fcoy83",
    B7xitij: "f14i52sd",
    p743kt: "f15qf7sh",
    Hhssn: "f1cpi5f4",
    uaurb9: "f6pj1s0",
    B401qx7: "f12sz5kj",
    Buyp1jb: "f17588c3",
    gsp74p: "fnthgdt"
  },
  filledSelected: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk",
    B95qlz1: "f1lm9dni",
    r4wkhp: "f1mn5ei1",
    B7xitij: "f1g6ncd0",
    p743kt: "fl71aob",
    Gedr8k: "f14zl92z",
    Bm69vlq: "f16zy3eu",
    Bodipah: "f1gdgb7p",
    B5kpen0: "f1tua9ng"
  },
  filledDisabled: {
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o"
  },
  filledDisabledSelected: {
    De3pzq: "f1bg9a2p",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fegtqic",
    sj55zd: "f1s2aq7o"
  }
}, {
  d: [[".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".fp7rvkm{border:solid var(--strokeWidthThin) var(--colorTransparentStroke);}", {
    p: -2
  }], ".ftorr8m .fui-Tab__icon{color:inherit;}", ".f16lqpmv .fui-Tab__content{color:inherit;}", [".fzklhed{padding-block:calc(var(--spacingVerticalXXS) - var(--strokeWidthThin));}", {
    p: -1
  }], [".f1j721cc{padding-block:calc(var(--spacingVerticalSNudge) - var(--strokeWidthThin));}", {
    p: -1
  }], [".frx9knr{padding-block:calc(var(--spacingVerticalS) - var(--strokeWidthThin));}", {
    p: -1
  }], ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1bifk9c:enabled:hover{background-color:var(--colorSubtleBackgroundHover);}", [".ft57sj0:enabled:hover{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Hover);}", {
    p: -2
  }], ".f1fcoy83:enabled:hover{color:var(--colorNeutralForeground2Hover);}", ".fo6hitd:enabled:active{background-color:var(--colorSubtleBackgroundPressed);}", [".fhn220o:enabled:active{border:solid var(--strokeWidthThin) var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f15qf7sh:enabled:active{color:var(--colorNeutralForeground2Pressed);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", [".f1c2pc3t{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStroke);}", {
    p: -2
  }], ".faj9fo0{color:var(--colorBrandForeground2);}", ".fsm7zmf:enabled:hover{background-color:var(--colorBrandBackground2Hover);}", [".f1wo0sfq:enabled:hover{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokeHover);}", {
    p: -2
  }], ".f1afuynh:enabled:hover{color:var(--colorBrandForeground2Hover);}", ".f94ddyl:enabled:active{background-color:var(--colorBrandBackground2Pressed);}", [".fmle6oo:enabled:active{border:solid var(--strokeWidthThin) var(--colorCompoundBrandStrokePressed);}", {
    p: -2
  }], ".f1d3itm4:enabled:active{color:var(--colorBrandForeground2Pressed);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fwwxidx:enabled:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f14i52sd:enabled:active{background-color:var(--colorNeutralBackground3Pressed);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1lm9dni:enabled:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1mn5ei1:enabled:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1g6ncd0:enabled:active{background-color:var(--colorBrandBackgroundPressed);}", ".fl71aob:enabled:active{color:var(--colorNeutralForegroundOnBrand);}", [".fegtqic{border:solid var(--strokeWidthThin) var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }]],
  m: [["@media (forced-colors: active){.f1mljprk{border:solid var(--strokeWidthThin) Canvas;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1e9l2u{border:solid var(--strokeWidthThin) Highlight;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1cpi5f4:enabled:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f6pj1s0:enabled:hover{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f12sz5kj:enabled:hover .fui-Tab__content{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f17588c3:enabled:hover .fui-Icon-filled{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fnthgdt:enabled:hover .fui-Icon-regular{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14zl92z:enabled{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16zy3eu:enabled .fui-Tab__content{color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1gdgb7p:enabled .fui-Tab__content{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1tua9ng:enabled .fui-Tab__icon{color:ButtonFace;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useFocusStyles2 = __styles2({
  base: {
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bn4voq9: "f1p7hgxw",
    Bfpq7zp: "f1way5bb",
    g9k6zt: "f9znhxp",
    j6ew2k: ["fqa318h", "fqa318h"],
    Bhxq17a: "f1vjpng2"
  },
  circular: {
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bn4voq9: "f1p7hgxw",
    Bfpq7zp: "f1way5bb",
    g9k6zt: "f9znhxp",
    j6ew2k: ["fzgyhws", "fqxug60"],
    Bhxq17a: "f1vjpng2"
  }
}, {
  d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1p7hgxw[data-fui-focus-visible]{outline-width:var(--strokeWidthThick);}", ".f1way5bb[data-fui-focus-visible]{outline-color:transparent;}", ".f9znhxp[data-fui-focus-visible]{outline-style:solid;}", ".fqa318h[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2);}", ".f1vjpng2[data-fui-focus-visible]{z-index:1;}", ".fzgyhws[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}", ".fqxug60[data-fui-focus-visible]{box-shadow:var(--shadow4),0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),0 0 0 var(--strokeWidthThin) var(--colorNeutralStrokeOnBrand) inset;}"]
});
var usePendingIndicatorStyles = __styles2({
  base: {
    az7l2e: "fhw179n",
    vqofr: 0,
    Bv4n3vi: 0,
    Bgqb9hq: 0,
    B0uxbk8: 0,
    Bf3jju6: "fg9j5n4",
    amg5m6: "f1kmhr4c",
    zkfqfm: "fl1ydde",
    Bkydozb: "f1y7maxz",
    Bka2azo: 0,
    vzq8l0: 0,
    csmgbd: 0,
    Br4ovkg: 0,
    aelrif: "fceyvr4",
    y36c18: "f16cxu0",
    B1ctymy: "f1nwgacf",
    xzc5d: "fm6alxz",
    h5yqg8: "fhx32z1"
  },
  disabled: {
    az7l2e: "f1ut20fw",
    Bkydozb: "fhrzcfn",
    xzc5d: "fw15awd",
    h5yqg8: "faqmq51"
  },
  smallHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1r53b5e",
    Fbdkly: ["f1s6rxz5", "fo35v8s"],
    mdwyqc: ["fo35v8s", "f1s6rxz5"]
  },
  smallVertical: {
    lawp4y: "fze4zud",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "fdp32p8",
    Ccq8qp: "f1aij3q"
  },
  mediumHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1s2r9ax",
    Fbdkly: ["f1o0nnkk", "fxb7rol"],
    mdwyqc: ["fxb7rol", "f1o0nnkk"]
  },
  mediumVertical: {
    lawp4y: "f17jracn",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "f117lcb2",
    Ccq8qp: "f1aij3q"
  },
  largeHorizontal: {
    lawp4y: "fchca7p",
    Baz25je: "f1s2r9ax",
    Fbdkly: ["f1o0nnkk", "fxb7rol"],
    mdwyqc: ["fxb7rol", "f1o0nnkk"]
  },
  largeVertical: {
    lawp4y: "fel9d3z",
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    Bciustq: "f6vqlre",
    Ccq8qp: "f1aij3q"
  }
}, {
  h: [".fhw179n:hover::before{background-color:var(--colorNeutralStroke1Hover);}", [".fg9j5n4:hover::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f1kmhr4c:hover::before{content:"";}', ".fl1ydde:hover::before{position:absolute;}", ".f1ut20fw:hover::before{background-color:var(--colorTransparentStroke);}"],
  a: [".f1y7maxz:active::before{background-color:var(--colorNeutralStroke1Pressed);}", [".fceyvr4:active::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f16cxu0:active::before{content:"";}', ".f1nwgacf:active::before{position:absolute;}", ".fhrzcfn:active::before{background-color:var(--colorTransparentStroke);}"],
  m: [["@media (forced-colors: active){.fm6alxz:hover::before{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fhx32z1:active::before{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fw15awd:hover::before{background-color:transparent;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.faqmq51:active::before{background-color:transparent;}}", {
    m: "(forced-colors: active)"
  }]],
  d: [".fchca7p::before{bottom:0;}", ".f1r53b5e::before{height:var(--strokeWidthThick);}", ".f1s6rxz5::before{left:var(--spacingHorizontalSNudge);}", ".fo35v8s::before{right:var(--spacingHorizontalSNudge);}", ".fze4zud::before{bottom:var(--spacingVerticalXS);}", ".f1fzr1x6::before{left:0;}", ".f1f351id::before{right:0;}", ".fdp32p8::before{top:var(--spacingVerticalXS);}", ".f1aij3q::before{width:var(--strokeWidthThicker);}", ".f1s2r9ax::before{height:var(--strokeWidthThicker);}", ".f1o0nnkk::before{left:var(--spacingHorizontalM);}", ".fxb7rol::before{right:var(--spacingHorizontalM);}", ".f17jracn::before{bottom:var(--spacingVerticalS);}", ".f117lcb2::before{top:var(--spacingVerticalS);}", ".fel9d3z::before{bottom:var(--spacingVerticalMNudge);}", ".f6vqlre::before{top:var(--spacingVerticalMNudge);}"]
});
var useActiveIndicatorStyles2 = __styles2({
  base: {
    Bjyk6c5: "f1rp0jgh",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f3b9emi",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9"
  },
  selected: {
    Bjyk6c5: "f1ksivud",
    Bej4dhw: "f1476jrx",
    B7wqxwa: "f18q216b",
    Hwb57: "f1wf6u82",
    Beg08s0: "f1xwit7m",
    Bo27r1v: "f1ksfgwi"
  },
  disabled: {
    Bjyk6c5: "f13lkzet"
  },
  smallHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f9bb2ob",
    Eqx8gd: ["f1q70ajw", "f18rbzdx"],
    B1piin3: ["f18rbzdx", "f1q70ajw"]
  },
  smallVertical: {
    By385i5: "fqbue9b",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "fk1klkt",
    a2br6o: "f1o25lip"
  },
  mediumHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f1vx7lu8",
    Eqx8gd: ["fna7m5n", "f1oxpfwv"],
    B1piin3: ["f1oxpfwv", "fna7m5n"]
  },
  mediumVertical: {
    By385i5: "fipylg0",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "fqchiol",
    a2br6o: "f1o25lip"
  },
  largeHorizontal: {
    By385i5: "fo72kxq",
    Dlnsje: "f1vx7lu8",
    Eqx8gd: ["fna7m5n", "f1oxpfwv"],
    B1piin3: ["f1oxpfwv", "fna7m5n"]
  },
  largeVertical: {
    By385i5: "f1w7dm5g",
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    bn5sak: "f1p6em4m",
    a2br6o: "f1o25lip"
  }
}, {
  d: [".f1rp0jgh::after{background-color:var(--colorTransparentStroke);}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1ksivud::after{background-color:var(--colorCompoundBrandStroke);}", ".f1476jrx:enabled:hover::after{background-color:var(--colorCompoundBrandStrokeHover);}", ".f18q216b:enabled:active::after{background-color:var(--colorCompoundBrandStrokePressed);}", ".f13lkzet::after{background-color:var(--colorNeutralForegroundDisabled);}", ".fo72kxq::after{bottom:0;}", ".f9bb2ob::after{height:var(--strokeWidthThick);}", ".f1q70ajw::after{left:var(--spacingHorizontalSNudge);}", ".f18rbzdx::after{right:var(--spacingHorizontalSNudge);}", ".fqbue9b::after{bottom:var(--spacingVerticalXS);}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".fk1klkt::after{top:var(--spacingVerticalXS);}", ".f1o25lip::after{width:var(--strokeWidthThicker);}", ".f1vx7lu8::after{height:var(--strokeWidthThicker);}", ".fna7m5n::after{left:var(--spacingHorizontalM);}", ".f1oxpfwv::after{right:var(--spacingHorizontalM);}", ".fipylg0::after{bottom:var(--spacingVerticalS);}", ".fqchiol::after{top:var(--spacingVerticalS);}", ".f1w7dm5g::after{bottom:var(--spacingVerticalMNudge);}", ".f1p6em4m::after{top:var(--spacingVerticalMNudge);}"],
  m: [["@media (forced-colors: active){.f1wf6u82::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1xwit7m:enabled:hover::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ksfgwi:enabled:active::after{background-color:ButtonText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useIconStyles7 = __styles2({
  base: {
    Br312pm: "fwpfdsa",
    Ijaq50: "f16hsg94",
    Bt984gj: "f122n59",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    D0sxk3: "f16u1re",
    t6yez3: "f8bsbmo"
  },
  small: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  medium: {
    Be2twd7: "fe5j1ua",
    Bqenvij: "fjamq6b",
    a9b677: "f64fuq3"
  },
  large: {
    Be2twd7: "f1rt2boy",
    Bqenvij: "frvgh55",
    a9b677: "fq4mcun"
  },
  selected: {
    D0sxk3: "fxoiby5",
    t6yez3: "f15q0o9g"
  }
}, {
  d: [".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f16u1re .fui-Icon-filled{display:none;}", ".f8bsbmo .fui-Icon-regular{display:inline;}", ".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".f15q0o9g .fui-Icon-regular{display:none;}"]
});
var useContentStyles3 = __styles2({
  base: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bwptpd"
  },
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  },
  largeSelected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  noIconBefore: {
    Br312pm: "fwpfdsa",
    Ijaq50: "f16hsg94"
  },
  iconBefore: {
    Br312pm: "fd46tj4",
    Ijaq50: "f16hsg94"
  },
  placeholder: {
    Bcdw1i0: "fd7fpy0"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1bwptpd{padding:var(--spacingVerticalNone) var(--spacingHorizontalXXS);}", {
    p: -1
  }], ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fwpfdsa{grid-column-start:1;}", ".f16hsg94{grid-row-start:1;}", ".fd46tj4{grid-column-start:2;}", ".fd7fpy0{visibility:hidden;}"]
});
var useTabStyles_unstable = (state) => {
  "use no memo";
  useTabIndicatorStyles_unstable(state);
  useTabButtonStyles_unstable(state, state.root);
  useTabContentStyles_unstable(state);
  return state;
};
var useTabIndicatorStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles15();
  const pendingIndicatorStyles = usePendingIndicatorStyles();
  const activeIndicatorStyles = useActiveIndicatorStyles2();
  const {
    appearance,
    disabled,
    selected,
    size: size3,
    vertical
  } = state;
  const classes = [tabClassNames.root, rootStyles.root];
  if (appearance !== "subtle-circular" && appearance !== "filled-circular") {
    classes.push(
      // pending indicator (before pseudo element)
      pendingIndicatorStyles.base,
      size3 === "small" && (vertical ? pendingIndicatorStyles.smallVertical : pendingIndicatorStyles.smallHorizontal),
      size3 === "medium" && (vertical ? pendingIndicatorStyles.mediumVertical : pendingIndicatorStyles.mediumHorizontal),
      size3 === "large" && (vertical ? pendingIndicatorStyles.largeVertical : pendingIndicatorStyles.largeHorizontal),
      disabled && pendingIndicatorStyles.disabled,
      // active indicator (after pseudo element)
      selected && activeIndicatorStyles.base,
      selected && !disabled && activeIndicatorStyles.selected,
      selected && size3 === "small" && (vertical ? activeIndicatorStyles.smallVertical : activeIndicatorStyles.smallHorizontal),
      selected && size3 === "medium" && (vertical ? activeIndicatorStyles.mediumVertical : activeIndicatorStyles.mediumHorizontal),
      selected && size3 === "large" && (vertical ? activeIndicatorStyles.largeVertical : activeIndicatorStyles.largeHorizontal),
      selected && disabled && activeIndicatorStyles.disabled
    );
  }
  state.root.className = mergeClasses(...classes, state.root.className);
  useTabAnimatedIndicatorStyles_unstable(state);
  return state;
};
var useTabButtonStyles_unstable = (state, slot) => {
  "use no memo";
  const rootStyles = useRootStyles15();
  const focusStyles = useFocusStyles2();
  const circularStyles = useCircularAppearanceStyles();
  const {
    appearance,
    disabled,
    selected,
    size: size3,
    vertical
  } = state;
  const isSubtleCircular = appearance === "subtle-circular";
  const isFilledCircular = appearance === "filled-circular";
  const isCircular = isSubtleCircular || isFilledCircular;
  const circularAppearance = [
    circularStyles.base,
    focusStyles.circular,
    // sizes
    size3 === "small" && circularStyles.small,
    size3 === "medium" && circularStyles.medium,
    size3 === "large" && circularStyles.large,
    // subtle-circular appearance
    isSubtleCircular && circularStyles.subtle,
    selected && isSubtleCircular && circularStyles.subtleSelected,
    disabled && isSubtleCircular && circularStyles.subtleDisabled,
    selected && disabled && isSubtleCircular && circularStyles.subtleDisabledSelected,
    // filled-circular appearance
    isFilledCircular && circularStyles.filled,
    selected && isFilledCircular && circularStyles.filledSelected,
    disabled && isFilledCircular && circularStyles.filledDisabled,
    selected && disabled && isFilledCircular && circularStyles.filledDisabledSelected
  ];
  const regularAppearance = [focusStyles.base, !disabled && appearance === "subtle" && rootStyles.subtle, !disabled && appearance === "transparent" && rootStyles.transparent, !disabled && selected && rootStyles.selected, disabled && rootStyles.disabled];
  slot.className = mergeClasses(
    rootStyles.button,
    // orientation
    vertical ? rootStyles.vertical : rootStyles.horizontal,
    // size
    size3 === "small" && (vertical ? rootStyles.smallVertical : rootStyles.smallHorizontal),
    size3 === "medium" && (vertical ? rootStyles.mediumVertical : rootStyles.mediumHorizontal),
    size3 === "large" && (vertical ? rootStyles.largeVertical : rootStyles.largeHorizontal),
    ...isCircular ? circularAppearance : regularAppearance,
    disabled && rootStyles.disabledCursor,
    slot.className
  );
  return state;
};
var useTabContentStyles_unstable = (state) => {
  "use no memo";
  const iconStyles = useIconStyles7();
  const contentStyles = useContentStyles3();
  const {
    selected,
    size: size3
  } = state;
  if (state.icon) {
    state.icon.className = mergeClasses(tabClassNames.icon, iconStyles.base, iconStyles[size3], selected && iconStyles.selected, state.icon.className);
  }
  if (state.contentReservedSpace) {
    state.contentReservedSpace.className = mergeClasses(tabReservedSpaceClassNames.content, contentStyles.base, size3 === "large" ? contentStyles.largeSelected : contentStyles.selected, state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, contentStyles.placeholder, state.content.className);
    state.contentReservedSpaceClassName = state.contentReservedSpace.className;
  }
  state.content.className = mergeClasses(tabClassNames.content, contentStyles.base, size3 === "large" && contentStyles.large, selected && (size3 === "large" ? contentStyles.largeSelected : contentStyles.selected), state.icon ? contentStyles.iconBefore : contentStyles.noIconBefore, state.content.className);
  return state;
};

// node_modules/@fluentui/react-tabs/lib/components/Tab/Tab.js
var Tab2 = React269.forwardRef((props, ref) => {
  const state = useTab_unstable(props, ref);
  useTabStyles_unstable(state);
  useCustomStyleHook("useTabStyles_unstable")(state);
  return renderTab_unstable(state);
});
Tab2.displayName = "Tab";

// node_modules/@fluentui/react-text/lib/components/Text/Text.js
var React271 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/Text/useText.js
var React270 = __toESM(require_react());
var useText_unstable = (props, ref) => {
  const { wrap, truncate, block, italic, underline, strikethrough, size: size3, font, weight, align } = props;
  const state = {
    align: align !== null && align !== void 0 ? align : "start",
    block: block !== null && block !== void 0 ? block : false,
    font: font !== null && font !== void 0 ? font : "base",
    italic: italic !== null && italic !== void 0 ? italic : false,
    size: size3 !== null && size3 !== void 0 ? size3 : 300,
    strikethrough: strikethrough !== null && strikethrough !== void 0 ? strikethrough : false,
    truncate: truncate !== null && truncate !== void 0 ? truncate : false,
    underline: underline !== null && underline !== void 0 ? underline : false,
    weight: weight !== null && weight !== void 0 ? weight : "regular",
    wrap: wrap !== null && wrap !== void 0 ? wrap : true,
    components: {
      root: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("span", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLHeadingElement & HTMLPreElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "span"
    })
  };
  return state;
};

// node_modules/@fluentui/react-text/lib/components/Text/renderText.js
var renderText_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-text/lib/components/Text/useTextStyles.styles.js
var textClassNames = {
  root: "fui-Text"
};
var useStyles32 = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Bhrd7zp: "figsok6",
    fsow6f: "fpgzoln",
    mc9l5x: "f1w7gpdv",
    Huce71: "f6juhto",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    ygn44y: "f2jf649"
  },
  nowrap: {
    Huce71: "fz5stix",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  },
  truncate: {
    ygn44y: "f1cmbuwj"
  },
  block: {
    mc9l5x: "ftgm304"
  },
  italic: {
    B80ckks: "f1j4dglz"
  },
  underline: {
    w71qe1: "f13mvf36"
  },
  strikethrough: {
    w71qe1: "fv5q2k7"
  },
  strikethroughUnderline: {
    w71qe1: "f1drk4o6"
  },
  base100: {
    Be2twd7: "f13mqy1h",
    Bg96gwp: "fcpl73t"
  },
  base200: {
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm"
  },
  base400: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k"
  },
  base500: {
    Be2twd7: "f1pp30po",
    Bg96gwp: "f106mvju"
  },
  base600: {
    Be2twd7: "f1x0m3f5",
    Bg96gwp: "fb86gi6"
  },
  hero700: {
    Be2twd7: "fojgt09",
    Bg96gwp: "fcen8rp"
  },
  hero800: {
    Be2twd7: "fccw675",
    Bg96gwp: "f1ebx5kk"
  },
  hero900: {
    Be2twd7: "f15afnhw",
    Bg96gwp: "fr3w3wp"
  },
  hero1000: {
    Be2twd7: "fpyltcb",
    Bg96gwp: "f1ivgwrt"
  },
  monospace: {
    Bahqtrf: "f1fedwem"
  },
  numeric: {
    Bahqtrf: "f1uq0ln5"
  },
  weightMedium: {
    Bhrd7zp: "fdj6btp"
  },
  weightSemibold: {
    Bhrd7zp: "fl43uef"
  },
  weightBold: {
    Bhrd7zp: "flh3ekv"
  },
  alignCenter: {
    fsow6f: "f17mccla"
  },
  alignEnd: {
    fsow6f: "f12ymhq5"
  },
  alignJustify: {
    fsow6f: "f1j59e10"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fpgzoln{text-align:start;}", ".f1w7gpdv{display:inline;}", ".f6juhto{white-space:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], ".f2jf649{text-overflow:clip;}", ".fz5stix{white-space:nowrap;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1cmbuwj{text-overflow:ellipsis;}", ".ftgm304{display:block;}", ".f1j4dglz{font-style:italic;}", ".f13mvf36{text-decoration-line:underline;}", ".fv5q2k7{text-decoration-line:line-through;}", ".f1drk4o6{text-decoration-line:line-through underline;}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fcpl73t{line-height:var(--lineHeightBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fb86gi6{line-height:var(--lineHeightBase600);}", ".fojgt09{font-size:var(--fontSizeHero700);}", ".fcen8rp{line-height:var(--lineHeightHero700);}", ".fccw675{font-size:var(--fontSizeHero800);}", ".f1ebx5kk{line-height:var(--lineHeightHero800);}", ".f15afnhw{font-size:var(--fontSizeHero900);}", ".fr3w3wp{line-height:var(--lineHeightHero900);}", ".fpyltcb{font-size:var(--fontSizeHero1000);}", ".f1ivgwrt{line-height:var(--lineHeightHero1000);}", ".f1fedwem{font-family:var(--fontFamilyMonospace);}", ".f1uq0ln5{font-family:var(--fontFamilyNumeric);}", ".fdj6btp{font-weight:var(--fontWeightMedium);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".f17mccla{text-align:center;}", ".f12ymhq5{text-align:end;}", ".f1j59e10{text-align:justify;}"]
});
var useTextStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles32();
  state.root.className = mergeClasses(textClassNames.root, styles.root, state.wrap === false && styles.nowrap, state.truncate && styles.truncate, state.block && styles.block, state.italic && styles.italic, state.underline && styles.underline, state.strikethrough && styles.strikethrough, state.underline && state.strikethrough && styles.strikethroughUnderline, state.size === 100 && styles.base100, state.size === 200 && styles.base200, state.size === 400 && styles.base400, state.size === 500 && styles.base500, state.size === 600 && styles.base600, state.size === 700 && styles.hero700, state.size === 800 && styles.hero800, state.size === 900 && styles.hero900, state.size === 1e3 && styles.hero1000, state.font === "monospace" && styles.monospace, state.font === "numeric" && styles.numeric, state.weight === "medium" && styles.weightMedium, state.weight === "semibold" && styles.weightSemibold, state.weight === "bold" && styles.weightBold, state.align === "center" && styles.alignCenter, state.align === "end" && styles.alignEnd, state.align === "justify" && styles.alignJustify, state.root.className);
  return state;
};

// node_modules/@fluentui/react-text/lib/components/Text/Text.js
var Text = React271.forwardRef((props, ref) => {
  const state = useText_unstable(props, ref);
  useTextStyles_unstable(state);
  useCustomStyleHook("useTextStyles_unstable")(state);
  return renderText_unstable(state);
});
Text.displayName = "Text";

// node_modules/@fluentui/react-text/lib/components/presets/Body1/Body1.js
var React273 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/createPreset.js
var React272 = __toESM(require_react());
function createPreset(options) {
  const { useStyles: useStyles108, className, displayName } = options;
  const Wrapper = React272.forwardRef((props, ref) => {
    "use no memo";
    const styles = useStyles108();
    const state = useText_unstable(props, ref);
    useTextStyles_unstable(state);
    state.root.className = mergeClasses(className, state.root.className, styles.root, props.className);
    return renderText_unstable(state);
  });
  Wrapper.displayName = displayName;
  return Wrapper;
}

// node_modules/@fluentui/react-text/lib/components/presets/Body1/useBody1Styles.styles.js
var body1ClassNames = {
  root: "fui-Body1"
};
var useBody1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1/Body1.js
var Body1 = createPreset({
  useStyles: useBody1Styles,
  className: body1ClassNames.root,
  displayName: "Body1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/Body1Strong.js
var React274 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/useBody1StrongStyles.styles.js
var body1StrongClassNames = {
  root: "fui-Body1Strong"
};
var useBody1StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Strong/Body1Strong.js
var Body1Strong = createPreset({
  useStyles: useBody1StrongStyles,
  className: body1StrongClassNames.root,
  displayName: "Body1Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/Body1Stronger.js
var React275 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/useBody1StrongerStyles.styles.js
var body1StrongerClassNames = {
  root: "fui-Body1Stronger"
};
var useBody1StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body1Stronger/Body1Stronger.js
var Body1Stronger = createPreset({
  useStyles: useBody1StrongerStyles,
  className: body1StrongerClassNames.root,
  displayName: "Body1Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Body2/Body2.js
var React276 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Body2/useBody2Styles.styles.js
var body2ClassNames = {
  root: "fui-Body2"
};
var useBody2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Body2/Body2.js
var Body2 = createPreset({
  useStyles: useBody2Styles,
  className: body2ClassNames.root,
  displayName: "Body2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/Caption1.js
var React277 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/useCaption1Styles.styles.js
var caption1ClassNames = {
  root: "fui-Caption1"
};
var useCaption1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1/Caption1.js
var Caption1 = createPreset({
  useStyles: useCaption1Styles,
  className: caption1ClassNames.root,
  displayName: "Caption1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/Caption1Strong.js
var React278 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/useCaption1StrongStyles.styles.js
var caption1StrongClassNames = {
  root: "fui-Caption1Strong"
};
var useCaption1StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Strong/Caption1Strong.js
var Caption1Strong = createPreset({
  useStyles: useCaption1StrongStyles,
  className: caption1StrongClassNames.root,
  displayName: "Caption1Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/Caption1Stronger.js
var React279 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/useCaption1Stronger.styles.js
var caption1StrongerClassNames = {
  root: "fui-Caption1Stronger"
};
var useCaption1StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption1Stronger/Caption1Stronger.js
var Caption1Stronger = createPreset({
  useStyles: useCaption1StrongerStyles,
  className: caption1StrongerClassNames.root,
  displayName: "Caption1Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/Caption2.js
var React280 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/useCaption2Styles.styles.js
var caption2ClassNames = {
  root: "fui-Caption2"
};
var useCaption2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fcpl73t"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fcpl73t{line-height:var(--lineHeightBase100);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2/Caption2.js
var Caption2 = createPreset({
  useStyles: useCaption2Styles,
  className: caption2ClassNames.root,
  displayName: "Caption2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/Caption2Strong.js
var React281 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/useCaption2StrongStyles.styles.js
var caption2StrongClassNames = {
  root: "fui-Caption2Strong"
};
var useCaption2StrongStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f13mqy1h",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcpl73t"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcpl73t{line-height:var(--lineHeightBase100);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Caption2Strong/Caption2Strong.js
var Caption2Strong = createPreset({
  useStyles: useCaption2StrongStyles,
  className: caption2StrongClassNames.root,
  displayName: "Caption2Strong"
});

// node_modules/@fluentui/react-text/lib/components/presets/Display/Display.js
var React282 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Display/useDisplayStyles.styles.js
var displayClassNames = {
  root: "fui-Display"
};
var useDisplayStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fpyltcb",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1ivgwrt"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fpyltcb{font-size:var(--fontSizeHero1000);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1ivgwrt{line-height:var(--lineHeightHero1000);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Display/Display.js
var Display = createPreset({
  useStyles: useDisplayStyles,
  className: displayClassNames.root,
  displayName: "Display"
});

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/LargeTitle.js
var React283 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/useLargeTitleStyles.styles.js
var largeTitleClassNames = {
  root: "fui-LargeTitle"
};
var useLargeTitleStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f15afnhw",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fr3w3wp"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f15afnhw{font-size:var(--fontSizeHero900);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fr3w3wp{line-height:var(--lineHeightHero900);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/LargeTitle/LargeTitle.js
var LargeTitle = createPreset({
  useStyles: useLargeTitleStyles,
  className: largeTitleClassNames.root,
  displayName: "LargeTitle"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/Subtitle1.js
var React284 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/useSubtitle1Styles.styles.js
var subtitle1ClassNames = {
  root: "fui-Subtitle1"
};
var useSubtitle1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1pp30po",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f106mvju"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle1/Subtitle1.js
var Subtitle1 = createPreset({
  useStyles: useSubtitle1Styles,
  className: subtitle1ClassNames.root,
  displayName: "Subtitle1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/Subtitle2.js
var React285 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/useSubtitle2Styles.styles.js
var subtitle2ClassNames = {
  root: "fui-Subtitle2"
};
var useSubtitle2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2/Subtitle2.js
var Subtitle2 = createPreset({
  useStyles: useSubtitle2Styles,
  className: subtitle2ClassNames.root,
  displayName: "Subtitle2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/Subtitle2Stronger.js
var React286 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/useSubtitle2Stronger.styles.js
var subtitle2StrongerClassNames = {
  root: "fui-Subtitle2Stronger"
};
var useSubtitle2StrongerStyles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "flh3ekv",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".flh3ekv{font-weight:var(--fontWeightBold);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Subtitle2Stronger/Subtitle2Stronger.js
var Subtitle2Stronger = createPreset({
  useStyles: useSubtitle2StrongerStyles,
  className: subtitle2StrongerClassNames.root,
  displayName: "Subtitle2Stronger"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title1/Title1.js
var React287 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title1/useTitle1Styles.styles.js
var title1ClassNames = {
  root: "fui-Title1"
};
var useTitle1Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fccw675",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1ebx5kk"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fccw675{font-size:var(--fontSizeHero800);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1ebx5kk{line-height:var(--lineHeightHero800);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title1/Title1.js
var Title1 = createPreset({
  useStyles: useTitle1Styles,
  className: title1ClassNames.root,
  displayName: "Title1"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title2/Title2.js
var React288 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title2/useTitle2Styles.styles.js
var title2ClassNames = {
  root: "fui-Title2"
};
var useTitle2Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fojgt09",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fcen8rp"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fojgt09{font-size:var(--fontSizeHero700);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fcen8rp{line-height:var(--lineHeightHero700);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title2/Title2.js
var Title2 = createPreset({
  useStyles: useTitle2Styles,
  className: title2ClassNames.root,
  displayName: "Title2"
});

// node_modules/@fluentui/react-text/lib/components/presets/Title3/Title3.js
var React289 = __toESM(require_react());

// node_modules/@fluentui/react-text/lib/components/presets/Title3/useTitle3Styles.styles.js
var title3ClassNames = {
  root: "fui-Title3"
};
var useTitle3Styles = __styles2({
  root: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "f1x0m3f5",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fb86gi6"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fb86gi6{line-height:var(--lineHeightBase600);}"]
});

// node_modules/@fluentui/react-text/lib/components/presets/Title3/Title3.js
var Title3 = createPreset({
  useStyles: useTitle3Styles,
  className: title3ClassNames.root,
  displayName: "Title3"
});

// node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
var React291 = __toESM(require_react());

// node_modules/@fluentui/react-textarea/lib/components/Textarea/renderTextarea.js
var renderTextarea_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(state.textarea, {})
  });
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextarea.js
var React290 = __toESM(require_react());
var useTextarea_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const overrides = useOverrides();
  var _overrides_inputDefaultAppearance;
  const { size: size3 = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", resize = "none", onChange } = props;
  if (appearance === "filled-darker-shadow" || appearance === "filled-lighter-shadow") {
    console.error("The 'filled-darker-shadow' and 'filled-lighter-shadow' appearances are deprecated and will be removed in the future.");
  }
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: void 0
  });
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "textarea",
    excludedPropNames: [
      "onChange",
      "value",
      "defaultValue"
    ]
  });
  const state = {
    size: size3,
    appearance,
    resize,
    components: {
      root: "span",
      textarea: "textarea"
    },
    textarea: slot_exports.always(props.textarea, {
      defaultProps: {
        ref,
        ...nativeProps.primary
      },
      elementType: "textarea"
    }),
    root: slot_exports.always(props.root, {
      defaultProps: nativeProps.root,
      elementType: "span"
    })
  };
  state.textarea.value = value;
  state.textarea.onChange = useEventCallback((ev) => {
    const newValue = ev.target.value;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      value: newValue
    });
    setValue(newValue);
  });
  return state;
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/useTextareaStyles.styles.js
var textareaClassNames = {
  root: "fui-Textarea",
  textarea: "fui-Textarea__textarea"
};
var useRootStyles16 = __styles2({
  base: {
    mc9l5x: "ftuwxu6",
    B7ck84d: "f1ewtqcl",
    qhf8xq: "f10pi13n",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yiegib",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    ha4doy: "f12kltsn"
  },
  disabled: {
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "ff3nzm7",
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  },
  interactive: {
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "ffyw7fx",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "fj2g8qd",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    wi16st: "fsrmcvb",
    ywj3b2: "f1t3k7v9",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    Bnupc0a: "fx04xgm",
    bing71: "f1c7in40",
    Bercvud: "f1ibeo51",
    Bbr2w1p: "f1vnc8sk",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7"
  },
  filled: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    q7v0qe: "ftmjh5b",
    kmh5ft: ["f17blpuu", "fsrcdbj"],
    nagaa4: "f1tpwn32",
    B1yhkcb: ["fsrcdbj", "f17blpuu"]
  },
  "filled-darker": {
    De3pzq: "f16xq7d1"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r"
  },
  "filled-darker-shadow": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1gmd7mu",
    E5pizo: "fyed02w"
  },
  "filled-lighter-shadow": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1gmd7mu",
    E5pizo: "fyed02w"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    kzujx5: 0,
    oetu4i: "f1l4zc64",
    gvrnp0: 0,
    xv9156: 0,
    jek2p4: 0,
    gg5e9n: 0,
    Beu9t3s: 0,
    dt87k2: 0,
    Bt1vbvt: 0,
    Bwzppfd: 0,
    Bop6t4b: 0,
    B2zwrfe: 0,
    Bwp2tzp: 0,
    Bgoe8wy: 0,
    Bf40cpq: 0,
    ckks6v: 0,
    Baalond: "f9mts5e",
    v2iqwr: 0,
    wmxk5l: "f1z0osm6",
    Bj33j0h: 0,
    Bs0cc2w: 0,
    qwjtx1: 0,
    B50zh58: 0,
    f7epvg: 0,
    e1hlit: 0,
    B7mkhst: 0,
    ak43y8: 0,
    Bbcopvn: 0,
    Bvecx4l: 0,
    lwioe0: 0,
    B6oc9vd: 0,
    e2sjt0: 0,
    uqwnxt: 0,
    asj8p9: "f1acnei2",
    Br8fjdy: 0,
    zoxjo1: "f1so894s",
    Bt3ojkv: 0,
    B7pmvfx: 0,
    Bfht2n1: 0,
    an54nd: 0,
    t1ykpo: 0,
    Belqbek: 0,
    bbt1vd: 0,
    Brahy3i: 0,
    r7b1zc: 0,
    rexu52: 0,
    ovtnii: 0,
    Bvq3b66: 0,
    Bawrxx6: 0,
    Bbs6y8j: 0,
    B2qpgjt: "f19ezbcq"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f1ewtqcl{box-sizing:border-box;}", ".f10pi13n{position:relative;}", [".f1yiegib{padding:0 0 var(--strokeWidthThick) 0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f12kltsn{vertical-align:top;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".ff3nzm7{border:var(--strokeWidthThin) solid var(--colorNeutralStrokeDisabled);}", {
    p: -2
  }], ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".ffyw7fx::after{height:max(var(--strokeWidthThick), var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".fj2g8qd::after{clip-path:inset(calc(100% - var(--strokeWidthThick)) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
    p: -2
  }], ".fyed02w{box-shadow:var(--shadow2);}", [".f1gmd7mu{border:var(--strokeWidthThin) solid var(--colorTransparentStrokeInteractive);}", {
    p: -2
  }], [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}"],
  m: [["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  w: [".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1vnc8sk:focus-within{outline-width:var(--strokeWidthThick);}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", [".f19ezbcq:focus-within{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f1so894s:focus-within{border-bottom-color:var(--colorCompoundBrandStroke);}"],
  h: [".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}", [".f9mts5e:hover{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Hover);}", {
    p: -2
  }], ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [[".f1acnei2:active{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1Pressed);}", {
    p: -2
  }], ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useTextareaStyles = __styles2({
  base: {
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    De3pzq: "f3rmtva",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    Bh6795r: "fqerorx",
    Bahqtrf: "fk6fouc",
    Bqenvij: "f1l02sjl",
    yvdlaj: "fwyc1cq",
    B3o7kgh: "f13ta7ih",
    oeaueh: "f1s6fcnf"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  },
  small: {
    sshi5w: "f1w5jphr",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1pnffij",
    Bxyxcbc: "f192z54u",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  medium: {
    sshi5w: "fvmd9f",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ww82xo",
    Bxyxcbc: "f1if7ixc",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  large: {
    sshi5w: "f1kfson",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f15hvtkj",
    Bxyxcbc: "f3kip1f",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fqerorx{flex-grow:1;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1l02sjl{height:100%;}", ".fwyc1cq::-webkit-input-placeholder{color:var(--colorNeutralForeground4);}", ".fwyc1cq::-moz-placeholder{color:var(--colorNeutralForeground4);}", ".f13ta7ih::-webkit-input-placeholder{opacity:1;}", ".f13ta7ih::-moz-placeholder{opacity:1;}", ".f1s6fcnf{outline-style:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".f1w5jphr{min-height:40px;}", [".f1pnffij{padding:var(--spacingVerticalXS) calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f192z54u{max-height:200px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fvmd9f{min-height:52px;}", [".f1ww82xo{padding:var(--spacingVerticalSNudge) calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f1if7ixc{max-height:260px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1kfson{min-height:64px;}", [".f15hvtkj{padding:var(--spacingVerticalS) calc(var(--spacingHorizontalM) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], ".f3kip1f{max-height:320px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}"]
});
var useTextareaResizeStyles = __styles2({
  none: {
    B3rzk8w: "f1o1s39h"
  },
  both: {
    B3rzk8w: "f1pxm0xe"
  },
  horizontal: {
    B3rzk8w: "fq6nmtn"
  },
  vertical: {
    B3rzk8w: "f1f5ktr4"
  }
}, {
  d: [".f1o1s39h{resize:none;}", ".f1pxm0xe{resize:both;}", ".fq6nmtn{resize:horizontal;}", ".f1f5ktr4{resize:vertical;}"]
});
var useTextareaStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3,
    appearance,
    resize
  } = state;
  const disabled = state.textarea.disabled;
  const invalid = `${state.textarea["aria-invalid"]}` === "true";
  const filled = appearance.startsWith("filled");
  const rootStyles = useRootStyles16();
  state.root.className = mergeClasses(textareaClassNames.root, rootStyles.base, disabled && rootStyles.disabled, !disabled && filled && rootStyles.filled, !disabled && rootStyles[appearance], !disabled && rootStyles.interactive, !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && invalid && rootStyles.invalid, state.root.className);
  const textareaStyles = useTextareaStyles();
  const textareaResizeStyles = useTextareaResizeStyles();
  state.textarea.className = mergeClasses(textareaClassNames.textarea, textareaStyles.base, textareaStyles[size3], textareaResizeStyles[resize], disabled && textareaStyles.disabled, state.textarea.className);
  return state;
};

// node_modules/@fluentui/react-textarea/lib/components/Textarea/Textarea.js
var Textarea = React291.forwardRef((props, ref) => {
  const state = useTextarea_unstable(props, ref);
  useTextareaStyles_unstable(state);
  useCustomStyleHook("useTextareaStyles_unstable")(state);
  return renderTextarea_unstable(state);
});
Textarea.displayName = "Textarea";

// node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
var React299 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
var React296 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
var React292 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.styles.js
var useHTMLNoScrollStyles = __resetStyles("r6pzz3z", null, [".r6pzz3z{overflow-y:hidden;overflow-y:clip;scrollbar-gutter:stable;}"]);
var useBodyNoScrollStyles = __resetStyles("r144vlu9", null, [".r144vlu9{overflow-y:hidden;}"]);

// node_modules/@fluentui/react-dialog/lib/utils/useDisableBodyScroll.js
function useDisableBodyScroll() {
  const htmlNoScrollStyles = useHTMLNoScrollStyles();
  const bodyNoScrollStyles = useBodyNoScrollStyles();
  const { targetDocument } = useFluent();
  const disableBodyScroll = React292.useCallback(() => {
    var _targetDocument_defaultView;
    if (!targetDocument) {
      return;
    }
    var _targetDocument_defaultView_innerHeight;
    const isHorizontalScrollbarVisible = (
      // When the window is a fractional height, `innerHeight` always rounds down but `clientHeight` rounds either up or down depending on the value.
      // To properly compare the body clientHeight to the window innerHeight, manually round down the fractional value to match innerHeight's calculation.
      Math.floor(targetDocument.body.getBoundingClientRect().height) > ((_targetDocument_defaultView_innerHeight = (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.innerHeight) !== null && _targetDocument_defaultView_innerHeight !== void 0 ? _targetDocument_defaultView_innerHeight : 0)
    );
    if (!isHorizontalScrollbarVisible) {
      return;
    }
    targetDocument.documentElement.classList.add(htmlNoScrollStyles);
    targetDocument.body.classList.add(bodyNoScrollStyles);
    return;
  }, [
    targetDocument,
    htmlNoScrollStyles,
    bodyNoScrollStyles
  ]);
  const enableBodyScroll = React292.useCallback(() => {
    if (!targetDocument) {
      return;
    }
    targetDocument.documentElement.classList.remove(htmlNoScrollStyles);
    targetDocument.body.classList.remove(bodyNoScrollStyles);
  }, [
    targetDocument,
    htmlNoScrollStyles,
    bodyNoScrollStyles
  ]);
  return {
    disableBodyScroll,
    enableBodyScroll
  };
}

// node_modules/@fluentui/react-dialog/lib/utils/useFocusFirstElement.js
var React293 = __toESM(require_react());
function useFocusFirstElement(open, modalType) {
  const { findFirstFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const dialogRef = React293.useRef(null);
  React293.useEffect(() => {
    if (!open) {
      return;
    }
    const element = dialogRef.current && findFirstFocusable(dialogRef.current);
    if (element) {
      element.focus();
    } else {
      var _dialogRef_current;
      (_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 ? void 0 : _dialogRef_current.focus();
      if (true) {
        console.warn(`@fluentui/react-dialog [useFocusFirstElement]:
A Dialog should have at least one focusable element inside DialogSurface.
Please add at least a close button either on \`DialogTitle\` action slot or inside \`DialogActions\``);
      }
    }
  }, [
    findFirstFocusable,
    open,
    modalType,
    targetDocument
  ]);
  return dialogRef;
}

// node_modules/@fluentui/react-dialog/lib/contexts/dialogContext.js
var React294 = __toESM(require_react());
var defaultContextValue = {
  open: false,
  inertTrapFocus: false,
  modalType: "modal",
  isNestedDialog: false,
  unmountOnClose: true,
  dialogRef: {
    current: null
  },
  requestOpenChange() {
  }
};
var DialogContext = createContext13(void 0);
var DialogProvider = DialogContext.Provider;
var useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue) => selector(ctx));

// node_modules/@fluentui/react-dialog/lib/contexts/dialogSurfaceContext.js
var React295 = __toESM(require_react());
var defaultContextValue2 = false;
var DialogSurfaceContext = React295.createContext(void 0);
var DialogSurfaceProvider = DialogSurfaceContext.Provider;
var useDialogSurfaceContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React295.useContext(DialogSurfaceContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue2;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurfaceMotion.js
var DialogSurfaceMotion = createPresenceComponentVariant(Scale, {
  outScale: 0.85,
  easing: motionTokens.curveDecelerateMid,
  duration: motionTokens.durationGentle,
  exitEasing: motionTokens.curveAccelerateMin,
  exitDuration: motionTokens.durationGentle
});

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialog.js
var useDialog_unstable = (props) => {
  const { children, modalType = "modal", onOpenChange, inertTrapFocus = false, unmountOnClose = true } = props;
  const dialogTitleId = useId2("dialog-title-");
  const [trigger, content] = childrenToTriggerAndContent(children);
  const [open, setOpen] = useControllableState({
    state: props.open,
    defaultState: props.defaultOpen,
    initialState: false
  });
  const requestOpenChange = useEventCallback((data) => {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data.event, data);
    if (!data.event.isDefaultPrevented()) {
      setOpen(data.open);
    }
  });
  const dialogRef = useFocusFirstElement(open, modalType);
  const { modalAttributes, triggerAttributes } = useModalAttributes({
    trapFocus: modalType !== "non-modal",
    legacyTrapFocus: !inertTrapFocus
  });
  const isNestedDialog = useHasParentContext(DialogContext);
  return {
    components: {
      surfaceMotion: DialogSurfaceMotion
    },
    inertTrapFocus,
    open,
    modalType,
    content,
    trigger,
    requestOpenChange,
    dialogTitleId,
    isNestedDialog,
    unmountOnClose,
    dialogRef,
    modalAttributes,
    triggerAttributes,
    surfaceMotion: presenceMotionSlot(props.surfaceMotion, {
      elementType: DialogSurfaceMotion,
      defaultProps: {
        visible: open,
        appear: unmountOnClose,
        unmountOnExit: unmountOnClose
      }
    })
  };
};
function childrenToTriggerAndContent(children) {
  const childrenArray = React296.Children.toArray(children);
  if (true) {
    if (childrenArray.length !== 1 && childrenArray.length !== 2) {
      console.warn(`@fluentui/react-dialog [useDialog]:
Dialog must contain at least one child <DialogSurface/>,
and at most two children <DialogTrigger/> <DialogSurface/> (in this order).`);
    }
  }
  switch (childrenArray.length) {
    case 2:
      return childrenArray;
    case 1:
      return [
        void 0,
        childrenArray[0]
      ];
    default:
      return [
        void 0,
        void 0
      ];
  }
}

// node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
var React298 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/MotionRefForwarder.js
var React297 = __toESM(require_react());
var MotionRefForwarderContext = React297.createContext(void 0);
function useMotionForwardedRef() {
  return React297.useContext(MotionRefForwarderContext);
}
var MotionRefForwarder = React297.forwardRef((props, ref) => {
  return React297.createElement(MotionRefForwarderContext.Provider, {
    value: ref
  }, props.children);
});

// node_modules/@fluentui/react-dialog/lib/components/Dialog/renderDialog.js
var renderDialog_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(DialogProvider, {
    value: contextValues.dialog,
    children: jsxs(DialogSurfaceProvider, {
      value: contextValues.dialogSurface,
      children: [
        state.trigger,
        state.content && jsx(state.surfaceMotion, {
          children: jsx(MotionRefForwarder, {
            children: state.content
          })
        })
      ]
    })
  });
};

// node_modules/@fluentui/react-dialog/lib/components/Dialog/useDialogContextValues.js
function useDialogContextValues_unstable(state) {
  const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes, unmountOnClose } = state;
  const dialog = {
    open,
    modalType,
    dialogRef,
    dialogTitleId,
    isNestedDialog,
    inertTrapFocus,
    modalAttributes,
    triggerAttributes,
    unmountOnClose,
    requestOpenChange
  };
  const dialogSurface = false;
  return {
    dialog,
    dialogSurface
  };
}

// node_modules/@fluentui/react-dialog/lib/components/Dialog/Dialog.js
var Dialog = React299.memo((props) => {
  const state = useDialog_unstable(props);
  const contextValues = useDialogContextValues_unstable(state);
  return renderDialog_unstable(state, contextValues);
});
Dialog.displayName = "Dialog";

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
var React301 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/useDialogTrigger.js
var React300 = __toESM(require_react());
var useDialogTrigger_unstable = (props) => {
  const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
  const { children, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
  const child = getTriggerChild(children);
  const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
  const { triggerAttributes } = useModalAttributes();
  const handleClick = useEventCallback((event) => {
    var _child_props_onClick, _child_props;
    child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, event);
    if (!event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        type: "triggerClick",
        open: action === "open"
      });
    }
  });
  const triggerChildProps = {
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: getReactElementRef(child),
    onClick: handleClick,
    ...triggerAttributes
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
    ...triggerChildProps,
    type: "button"
  });
  return {
    children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/renderDialogTrigger.js
var renderDialogTrigger_unstable = (state) => state.children;

// node_modules/@fluentui/react-dialog/lib/components/DialogTrigger/DialogTrigger.js
var DialogTrigger = (props) => {
  const state = useDialogTrigger_unstable(props);
  return renderDialogTrigger_unstable(state);
};
DialogTrigger.displayName = "DialogTrigger";
DialogTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/DialogActions.js
var React303 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActions.js
var React302 = __toESM(require_react());
var useDialogActions_unstable = (props, ref) => {
  const { position = "end", fluid = false } = props;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    position,
    fluid
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/renderDialogActions.js
var renderDialogActions_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/useDialogActionsStyles.styles.js
var dialogActionsClassNames = {
  root: "fui-DialogActions"
};
var useResetStyles = __resetStyles("rhfpeu0", null, {
  r: [".rhfpeu0{gap:8px;height:fit-content;box-sizing:border-box;display:flex;grid-row-start:3;grid-row-end:3;}"],
  s: ["@media screen and (max-width: 480px){.rhfpeu0{flex-direction:column;justify-self:stretch;}}"]
});
var useStyles33 = __styles2({
  gridPositionEnd: {
    Bdqf98w: "f1a7i8kp",
    Br312pm: "fd46tj4",
    Bw0ie65: "fsyjsko",
    Btsd7tp: "f1n00o3b",
    ufxxby: "f1mvsp37",
    Bq5p579: "flbz1vp"
  },
  gridPositionStart: {
    Bdqf98w: "fsxvdwy",
    Br312pm: "fwpfdsa",
    Bw0ie65: "f1e2fz10",
    Ew0qkd: "f119phc2",
    ufxxby: "f1j719yo",
    Bq5p579: "flbz1vp"
  },
  fluidStart: {
    Bw0ie65: "fsyjsko"
  },
  fluidEnd: {
    Br312pm: "fwpfdsa"
  }
}, {
  d: [".f1a7i8kp{justify-self:end;}", ".fd46tj4{grid-column-start:2;}", ".fsyjsko{grid-column-end:4;}", ".fsxvdwy{justify-self:start;}", ".fwpfdsa{grid-column-start:1;}", ".f1e2fz10{grid-column-end:2;}"],
  m: [["@media screen and (max-width: 480px){.f1n00o3b{grid-column-start:1;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f1mvsp37{grid-row-start:4;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.flbz1vp{grid-row-end:auto;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f119phc2{grid-column-end:4;}}", {
    m: "screen and (max-width: 480px)"
  }], ["@media screen and (max-width: 480px){.f1j719yo{grid-row-start:3;}}", {
    m: "screen and (max-width: 480px)"
  }]]
});
var useDialogActionsStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles();
  const styles = useStyles33();
  state.root.className = mergeClasses(dialogActionsClassNames.root, resetStyles, state.position === "start" && styles.gridPositionStart, state.position === "end" && styles.gridPositionEnd, state.fluid && state.position === "start" && styles.fluidStart, state.fluid && state.position === "end" && styles.fluidEnd, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogActions/DialogActions.js
var DialogActions = React303.forwardRef((props, ref) => {
  const state = useDialogActions_unstable(props, ref);
  useDialogActionsStyles_unstable(state);
  useCustomStyleHook("useDialogActionsStyles_unstable")(state);
  return renderDialogActions_unstable(state);
});
DialogActions.displayName = "DialogActions";

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
var React305 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBody.js
var React304 = __toESM(require_react());
var useDialogBody_unstable = (props, ref) => {
  var _props_as;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/renderDialogBody.js
var renderDialogBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/useDialogBodyStyles.styles.js
var dialogBodyClassNames = {
  root: "fui-DialogBody"
};
var useResetStyles2 = __resetStyles("rhwx3p8", null, {
  r: [".rhwx3p8{overflow:unset;gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);max-height:calc(100dvh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
  s: ["@media screen and (max-width: 480px){.rhwx3p8{max-width:100vw;grid-template-rows:auto 1fr auto;}}", "@media screen and (max-height: 359px){.rhwx3p8{max-height:unset;}}"]
});
var useDialogBodyStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles2();
  state.root.className = mergeClasses(dialogBodyClassNames.root, resetStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogBody/DialogBody.js
var DialogBody = React305.forwardRef((props, ref) => {
  const state = useDialogBody_unstable(props, ref);
  useDialogBodyStyles_unstable(state);
  useCustomStyleHook("useDialogBodyStyles_unstable")(state);
  return renderDialogBody_unstable(state);
});
DialogBody.displayName = "DialogBody";

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
var React307 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
var React306 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitleStyles.styles.js
var dialogTitleClassNames = {
  root: "fui-DialogTitle",
  action: "fui-DialogTitle__action"
};
var useRootResetStyles = __resetStyles("rxjm636", null, [".rxjm636{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
var useStyles34 = __styles2({
  rootWithoutAction: {
    Bw0ie65: "fsyjsko"
  }
}, {
  d: [".fsyjsko{grid-column-end:4;}"]
});
var useActionResetStyles = __resetStyles("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
var useDialogTitleInternalStyles = __resetStyles("r2avt6e", "roj2bbc", {
  r: [".r2avt6e{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".r2avt6e:focus{outline-style:none;}", ".r2avt6e:focus-visible{outline-style:none;}", ".r2avt6e[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r2avt6e[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".roj2bbc{overflow:visible;padding:0;border-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".roj2bbc:focus{outline-style:none;}", ".roj2bbc:focus-visible{outline-style:none;}", ".roj2bbc[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.roj2bbc[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r2avt6e[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.roj2bbc[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDialogTitleStyles_unstable = (state) => {
  "use no memo";
  const rootResetStyles = useRootResetStyles();
  const actionResetStyles = useActionResetStyles();
  const styles = useStyles34();
  state.root.className = mergeClasses(dialogTitleClassNames.root, rootResetStyles, !state.action && styles.rootWithoutAction, state.root.className);
  if (state.action) {
    state.action.className = mergeClasses(dialogTitleClassNames.action, actionResetStyles, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/useDialogTitle.js
var useDialogTitle_unstable = (props, ref) => {
  const { action } = props;
  const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
  const internalStyles = useDialogTitleInternalStyles();
  return {
    components: {
      root: "h2",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("h2", {
      ref,
      id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
      ...props
    }), {
      elementType: "h2"
    }),
    action: slot_exports.optional(action, {
      renderByDefault: modalType === "non-modal",
      defaultProps: {
        children: React306.createElement(DialogTrigger, {
          disableButtonEnhancement: true,
          action: "close"
        }, React306.createElement("button", {
          type: "button",
          className: internalStyles,
          // TODO: find a better way to add internal labels
          "aria-label": "close"
        }, React306.createElement(Dismiss20Regular, null)))
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/renderDialogTitle.js
var renderDialogTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.root, {
        children: state.root.children
      }),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-dialog/lib/components/DialogTitle/DialogTitle.js
var DialogTitle = React307.forwardRef((props, ref) => {
  const state = useDialogTitle_unstable(props, ref);
  useDialogTitleStyles_unstable(state);
  useCustomStyleHook("useDialogTitleStyles_unstable")(state);
  return renderDialogTitle_unstable(state);
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
var React309 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
var React308 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogBackdropMotion.js
var DialogBackdropMotion = FadeRelaxed;

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurface.js
var useDialogSurface_unstable = (props, ref) => {
  const contextRef = useMotionForwardedRef();
  const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
  const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
  const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
  const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
  const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
  const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
  const open = useDialogContext_unstable((ctx) => ctx.open);
  const unmountOnClose = useDialogContext_unstable((ctx) => ctx.unmountOnClose);
  const handledBackdropClick = useEventCallback((event) => {
    if (isResolvedShorthand(props.backdrop)) {
      var _props_backdrop_onClick, _props_backdrop;
      (_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 ? void 0 : _props_backdrop_onClick.call(_props_backdrop, event);
    }
    if (modalType === "modal" && !event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        open: false,
        type: "backdropClick"
      });
    }
  });
  const handleKeyDown = useEventCallback((event) => {
    var _props_onKeyDown;
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
    if (event.key === Escape && !event.isDefaultPrevented()) {
      requestOpenChange({
        event,
        open: false,
        type: "escapeKeyDown"
      });
      event.preventDefault();
    }
  });
  const backdrop = slot_exports.optional(props.backdrop, {
    renderByDefault: modalType !== "non-modal",
    defaultProps: {
      "aria-hidden": "true"
    },
    elementType: "div"
  });
  if (backdrop) {
    backdrop.onClick = handledBackdropClick;
  }
  const { disableBodyScroll, enableBodyScroll } = useDisableBodyScroll();
  useIsomorphicLayoutEffect(() => {
    if (!open) {
      enableBodyScroll();
      return;
    }
    if (isNestedDialog || modalType === "non-modal") {
      return;
    }
    disableBodyScroll();
    return () => enableBodyScroll();
  }, [
    open,
    modalType,
    isNestedDialog,
    disableBodyScroll,
    enableBodyScroll
  ]);
  return {
    components: {
      backdrop: "div",
      root: "div",
      backdropMotion: DialogBackdropMotion
    },
    open,
    backdrop,
    isNestedDialog,
    unmountOnClose,
    mountNode: props.mountNode,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      tabIndex: -1,
      role: modalType === "alert" ? "alertdialog" : "dialog",
      "aria-modal": modalType !== "non-modal",
      "aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
      "aria-hidden": !unmountOnClose && !open ? true : void 0,
      ...props,
      ...modalAttributes,
      onKeyDown: handleKeyDown,
      // FIXME:
      // `DialogSurfaceElement` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, contextRef, dialogRef)
    }), {
      elementType: "div"
    }),
    backdropMotion: presenceMotionSlot(props.backdropMotion, {
      elementType: DialogBackdropMotion,
      defaultProps: {
        appear: unmountOnClose,
        visible: open
      }
    }),
    // Deprecated properties
    transitionStatus: void 0
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/renderDialogSurface.js
var renderDialogSurface_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(Portal, {
    mountNode: state.mountNode,
    children: [
      state.backdrop && // TODO: state.backdropMotion is non nullable, but assertSlots asserts it as nullable
      // FIXME: this should be resolved by properly splitting props and state slots declaration
      state.backdropMotion && jsx(state.backdropMotion, {
        children: jsx(state.backdrop, {})
      }),
      jsx(DialogSurfaceProvider, {
        value: contextValues.dialogSurface,
        children: jsx(state.root, {})
      })
    ]
  });
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceStyles.styles.js
var dialogSurfaceClassNames = {
  root: "fui-DialogSurface",
  backdrop: "fui-DialogSurface__backdrop"
};
var useRootBaseStyle = __resetStyles("r1u3t6p6", "r5coedp", {
  r: [".r1u3t6p6{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".r1u3t6p6:focus{outline-style:none;}", ".r1u3t6p6:focus-visible{outline-style:none;}", ".r1u3t6p6[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1u3t6p6[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r5coedp{inset:0;padding:24px;margin:auto;border-style:none;overflow:unset;border:1px solid var(--colorTransparentStroke);border-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;max-height:100dvh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);box-shadow:var(--shadow64);}", ".r5coedp:focus{outline-style:none;}", ".r5coedp:focus-visible{outline-style:none;}", ".r5coedp[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r5coedp[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r1u3t6p6[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media screen and (max-width: 480px){.r1u3t6p6{max-width:100vw;}}", "@media screen and (max-height: 359px){.r1u3t6p6{overflow-y:auto;padding-right:calc(24px - 4px);border-right-width:4px;border-top-width:4px;border-bottom-width:4px;}}", "@media (forced-colors: active){.r5coedp[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}", "@media screen and (max-width: 480px){.r5coedp{max-width:100vw;}}", "@media screen and (max-height: 359px){.r5coedp{overflow-y:auto;padding-left:calc(24px - 4px);border-left-width:4px;border-top-width:4px;border-bottom-width:4px;}}"]
});
var useBackdropBaseStyle = __resetStyles("r1e18s3l", null, [".r1e18s3l{inset:0px;background-color:var(--colorBackgroundOverlay);position:fixed;}"]);
var useStyles35 = __styles2({
  nestedDialogBackdrop: {
    De3pzq: "f1c21dwh"
  },
  dialogHidden: {
    Bkecrkj: "f1aehjj5"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1aehjj5{pointer-events:none;}"]
});
var useDialogSurfaceStyles_unstable = (state) => {
  "use no memo";
  const {
    isNestedDialog,
    root,
    backdrop,
    open,
    unmountOnClose
  } = state;
  const rootBaseStyle = useRootBaseStyle();
  const backdropBaseStyle = useBackdropBaseStyle();
  const styles = useStyles35();
  const mountedAndClosed = !unmountOnClose && !open;
  root.className = mergeClasses(dialogSurfaceClassNames.root, rootBaseStyle, mountedAndClosed && styles.dialogHidden, root.className);
  if (backdrop) {
    backdrop.className = mergeClasses(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && styles.nestedDialogBackdrop, mountedAndClosed && styles.dialogHidden, backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/useDialogSurfaceContextValues.js
function useDialogSurfaceContextValues_unstable(state) {
  const dialogSurface = true;
  return {
    dialogSurface
  };
}

// node_modules/@fluentui/react-dialog/lib/components/DialogSurface/DialogSurface.js
var DialogSurface = React309.forwardRef((props, ref) => {
  const state = useDialogSurface_unstable(props, ref);
  const contextValues = useDialogSurfaceContextValues_unstable(state);
  useDialogSurfaceStyles_unstable(state);
  useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
  return renderDialogSurface_unstable(state, contextValues);
});
DialogSurface.displayName = "DialogSurface";

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
var React311 = __toESM(require_react());

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContent.js
var React310 = __toESM(require_react());
var useDialogContent_unstable = (props, ref) => {
  var _props_as;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/renderDialogContent.js
var renderDialogContent_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/useDialogContentStyles.styles.js
var dialogContentClassNames = {
  root: "fui-DialogContent"
};
var useStyles36 = __resetStyles("r1v5zwsm", null, {
  r: [".r1v5zwsm{padding:var(--strokeWidthThick);margin:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"],
  s: ["@media screen and (max-height: 359px){.r1v5zwsm{overflow-y:unset;}}"]
});
var useDialogContentStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles36();
  state.root.className = mergeClasses(dialogContentClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-dialog/lib/components/DialogContent/DialogContent.js
var DialogContent = React311.forwardRef((props, ref) => {
  const state = useDialogContent_unstable(props, ref);
  useDialogContentStyles_unstable(state);
  useCustomStyleHook("useDialogContentStyles_unstable")(state);
  return renderDialogContent_unstable(state);
});
DialogContent.displayName = "DialogContent";

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/ProgressBar.js
var React313 = __toESM(require_react());

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBar.js
var React312 = __toESM(require_react());

// node_modules/@fluentui/react-progress/lib/utils/clampMax.js
var clampMax = (max2) => {
  const internalMax = max2 <= 0 ? 1 : max2;
  if (true) {
    if (max2 <= 0) {
      console.error(`The prop 'max' must be greater than 0. Received max: ${max2}`);
    }
  }
  return internalMax;
};

// node_modules/@fluentui/react-progress/lib/utils/clampValue.js
var clampValue = (value, max2) => {
  if (value === void 0) {
    return value;
  }
  const internalValue = value < 0 ? 0 : value > max2 ? max2 : value;
  if (true) {
    if (value < 0) {
      console.error(`The prop 'value' must be greater than or equal to zero. Received value: ${value}`);
    }
    if (value > max2) {
      console.error(`The prop 'value' must be less than or equal to 'max'. Received value: ${value}, max: ${max2}`);
    }
  }
  return internalValue;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBar.js
var useProgressBar_unstable = (props, ref) => {
  const field = useFieldContext_unstable();
  const fieldState = field === null || field === void 0 ? void 0 : field.validationState;
  const { color: color2 = fieldState === "error" || fieldState === "warning" || fieldState === "success" ? fieldState : "brand", shape = "rounded", thickness = "medium" } = props;
  var _props_max;
  const max2 = clampMax((_props_max = props.max) !== null && _props_max !== void 0 ? _props_max : 1);
  const value = clampValue(props.value, max2);
  const root = slot_exports.always(getIntrinsicElementProps("div", {
    // FIXME:
    // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
    // but since it would be a breaking change to fix it, we are casting ref to it's proper type
    ref,
    role: "progressbar",
    "aria-valuemin": value !== void 0 ? 0 : void 0,
    "aria-valuemax": value !== void 0 ? max2 : void 0,
    "aria-valuenow": value,
    "aria-labelledby": field === null || field === void 0 ? void 0 : field.labelId,
    ...props
  }), {
    elementType: "div"
  });
  if (field && (field.validationMessageId || field.hintId)) {
    root["aria-describedby"] = [
      field === null || field === void 0 ? void 0 : field.validationMessageId,
      field === null || field === void 0 ? void 0 : field.hintId,
      root["aria-describedby"]
    ].filter(Boolean).join(" ");
  }
  const bar = slot_exports.always(props.bar, {
    elementType: "div"
  });
  const state = {
    color: color2,
    max: max2,
    shape,
    thickness,
    value,
    components: {
      root: "div",
      bar: "div"
    },
    root,
    bar
  };
  return state;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/renderProgressBar.js
var renderProgressBar_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.bar && jsx(state.bar, {})
  });
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/useProgressBarStyles.styles.js
var progressBarClassNames = {
  root: "fui-ProgressBar",
  bar: "fui-ProgressBar__bar"
};
var ZERO_THRESHOLD = 0.01;
var useRootStyles17 = __styles2({
  root: {
    mc9l5x: "ftgm304",
    De3pzq: "f18f03hv",
    a9b677: "fly5x3f",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Bomf52o: "f1skxd4g"
  },
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  },
  medium: {
    Bqenvij: "f4t8t6x"
  },
  large: {
    Bqenvij: "f6ywr7j"
  }
}, {
  d: [".ftgm304{display:block;}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fly5x3f{width:100%;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], ".f4t8t6x{height:2px;}", ".f6ywr7j{height:4px;}"],
  m: [["@media screen and (forced-colors: active){.f1skxd4g{background-color:CanvasText;}}", {
    m: "screen and (forced-colors: active)"
  }]]
});
var useBarStyles = __styles2({
  base: {
    Bomf52o: "f1tnpuu0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f12b9xdw",
    Bqenvij: "f1l02sjl"
  },
  nonZeroDeterminate: {
    Bmy1vo4: "fjt6zfz",
    B3o57yi: "f1wofebd",
    Bkqvd7p: "fv71qf3"
  },
  indeterminate: {
    B2u0y6b: "fa0wk36",
    qhf8xq: "f10pi13n",
    Bcmaq0h: ["fpo0yib", "f1u5hf6c"],
    Bv12yb3: ["fwd2bol", "f14gig94"],
    vin17d: "f1a27w2r",
    Ezkn3b: "f452v7t",
    w3vfg9: "f1cpbl36",
    jpy9cc: "f3z2g5w",
    Bqo2lbl: "fz5izi4",
    B6plc1d: "fv40pdu",
    I82g5a: "f1uj6jbf"
  },
  brand: {
    De3pzq: "ftywsgz"
  },
  error: {
    De3pzq: "fdl5y0r"
  },
  warning: {
    De3pzq: "f1s438gw"
  },
  success: {
    De3pzq: "flxk52p"
  }
}, {
  m: [["@media screen and (forced-colors: active){.f1tnpuu0{background-color:Highlight;}}", {
    m: "screen and (forced-colors: active)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f3z2g5w{max-width:100%;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fz5izi4{animation-iteration-count:infinite;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fv40pdu{animation-duration:3s;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1uj6jbf{animation-name:ftc26vs;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }]],
  d: [[".f12b9xdw{border-radius:inherit;}", {
    p: -1
  }], ".f1l02sjl{height:100%;}", ".fjt6zfz{transition-property:width;}", ".f1wofebd{transition-duration:0.3s;}", ".fv71qf3{transition-timing-function:ease;}", ".fa0wk36{max-width:33%;}", ".f10pi13n{position:relative;}", ".fpo0yib{background-image:linear-gradient(\n      to right,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}", ".f1u5hf6c{background-image:linear-gradient(\n      to left,\n      var(--colorNeutralBackground6) 0%,\n      var(--colorTransparentBackground) 50%,\n      var(--colorNeutralBackground6) 100%\n    );}", ".fwd2bol{animation-name:f1keuaan;}", ".f14gig94{animation-name:f10x8f8u;}", ".f1a27w2r{animation-duration:3s;}", ".f452v7t{animation-timing-function:linear;}", ".f1cpbl36{animation-iteration-count:infinite;}", ".ftywsgz{background-color:var(--colorCompoundBrandBackground);}", ".fdl5y0r{background-color:var(--colorPaletteRedBackground3);}", ".f1s438gw{background-color:var(--colorPaletteDarkOrangeBackground3);}", ".flxk52p{background-color:var(--colorPaletteGreenBackground3);}"],
  k: ["@keyframes f1keuaan{0%{left:-33%;}100%{left:100%;}}", "@keyframes f10x8f8u{0%{right:-33%;}100%{right:100%;}}", "@keyframes ftc26vs{0%{opacity:.2;}50%{opacity:1;}100%{opacity:.2;}}"]
});
var useProgressBarStyles_unstable = (state) => {
  "use no memo";
  const {
    color: color2,
    max: max2,
    shape,
    thickness,
    value
  } = state;
  const rootStyles = useRootStyles17();
  const barStyles = useBarStyles();
  state.root.className = mergeClasses(progressBarClassNames.root, rootStyles.root, rootStyles[shape], rootStyles[thickness], state.root.className);
  if (state.bar) {
    state.bar.className = mergeClasses(progressBarClassNames.bar, barStyles.base, barStyles.brand, value === void 0 && barStyles.indeterminate, value !== void 0 && value > ZERO_THRESHOLD && barStyles.nonZeroDeterminate, color2 && value !== void 0 && barStyles[color2], state.bar.className);
  }
  if (state.bar && value !== void 0) {
    state.bar.style = {
      width: Math.min(100, Math.max(0, value / max2 * 100)) + "%",
      ...state.bar.style
    };
  }
  return state;
};

// node_modules/@fluentui/react-progress/lib/components/ProgressBar/ProgressBar.js
var ProgressBar = React313.forwardRef((props, ref) => {
  const state = useProgressBar_unstable(props, ref);
  useProgressBarStyles_unstable(state);
  useCustomStyleHook("useProgressBarStyles_unstable")(state);
  return renderProgressBar_unstable(state);
});
ProgressBar.displayName = "ProgressBar";

// node_modules/@fluentui/react-overflow/lib/components/Overflow.js
var React315 = __toESM(require_react());

// node_modules/@fluentui/react-overflow/lib/overflowContext.js
var OverflowContext = createContext13(void 0);
var overflowContextDefaultValue = {
  itemVisibility: {},
  groupVisibility: {},
  hasOverflow: false,
  registerItem: () => () => null,
  updateOverflow: () => null,
  registerOverflowMenu: () => () => null,
  registerDivider: () => () => null
};
var useOverflowContext = (selector) => useContextSelector(OverflowContext, (ctx = overflowContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-overflow/lib/useOverflowContainer.js
var React314 = __toESM(require_react());

// node_modules/@fluentui/priority-overflow/lib/consts.js
var DATA_OVERFLOWING = "data-overflowing";
var DATA_OVERFLOW_GROUP = "data-overflow-group";

// node_modules/@fluentui/priority-overflow/lib/createResizeObserver.js
function observeResize(elementToObserve, callback) {
  var _elementToObserve_ownerDocument_defaultView;
  const GlobalResizeObserver = (_elementToObserve_ownerDocument_defaultView = elementToObserve.ownerDocument.defaultView) === null || _elementToObserve_ownerDocument_defaultView === void 0 ? void 0 : _elementToObserve_ownerDocument_defaultView.ResizeObserver;
  if (!GlobalResizeObserver) {
    if (true) {
      console.error("@fluentui/priority-overflow", "ResizeObserver does not exist on container window");
    }
    return () => null;
  }
  let resizeObserver = new GlobalResizeObserver(callback);
  resizeObserver.observe(elementToObserve);
  return () => {
    resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
    resizeObserver = void 0;
  };
}

// node_modules/@fluentui/priority-overflow/lib/debounce.js
function debounce2(fn) {
  let pending;
  if (false) {
    return fn;
  }
  return () => {
    if (!pending) {
      pending = true;
      queueMicrotask(() => {
        pending = false;
        fn();
      });
    }
  };
}

// node_modules/@fluentui/priority-overflow/lib/priorityQueue.js
function createPriorityQueue2(compare) {
  const arr = [];
  let size3 = 0;
  const left2 = (i) => {
    return 2 * i + 1;
  };
  const right2 = (i) => {
    return 2 * i + 2;
  };
  const parent2 = (i) => {
    return Math.floor((i - 1) / 2);
  };
  const swap = (a, b) => {
    const tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
  };
  const heapify = (i) => {
    let smallest = i;
    const l = left2(i);
    const r = right2(i);
    if (l < size3 && compare(arr[l], arr[smallest]) < 0) {
      smallest = l;
    }
    if (r < size3 && compare(arr[r], arr[smallest]) < 0) {
      smallest = r;
    }
    if (smallest !== i) {
      swap(smallest, i);
      heapify(smallest);
    }
  };
  const dequeue = () => {
    if (size3 === 0) {
      throw new Error("Priority queue empty");
    }
    const res = arr[0];
    arr[0] = arr[--size3];
    heapify(0);
    return res;
  };
  const peek = () => {
    if (size3 === 0) {
      return null;
    }
    return arr[0];
  };
  const enqueue = (item) => {
    arr[size3++] = item;
    let i = size3 - 1;
    let p = parent2(i);
    while (i > 0 && compare(arr[p], arr[i]) > 0) {
      swap(p, i);
      i = p;
      p = parent2(i);
    }
  };
  const contains = (item) => {
    const index = arr.indexOf(item);
    return index >= 0 && index < size3;
  };
  const remove = (item) => {
    const i = arr.indexOf(item);
    if (i === -1 || i >= size3) {
      return;
    }
    arr[i] = arr[--size3];
    heapify(i);
  };
  const clear = () => {
    size3 = 0;
  };
  const all = () => {
    return arr.slice(0, size3);
  };
  return {
    all,
    clear,
    contains,
    dequeue,
    enqueue,
    peek,
    remove,
    size: () => size3
  };
}

// node_modules/@fluentui/priority-overflow/lib/overflowManager.js
function createOverflowManager() {
  const sizeCache = /* @__PURE__ */ new Map();
  let container;
  let overflowMenu;
  let observing = false;
  let forceDispatch = true;
  const options = {
    padding: 10,
    overflowAxis: "horizontal",
    overflowDirection: "end",
    minimumVisible: 0,
    onUpdateItemVisibility: () => void 0,
    onUpdateOverflow: () => void 0,
    hasHiddenItems: false
  };
  const overflowItems = {};
  const overflowDividers = {};
  let disposeResizeObserver = () => null;
  const getNextItem = (queueToDequeue, queueToEnqueue) => {
    const nextItem = queueToDequeue.dequeue();
    queueToEnqueue.enqueue(nextItem);
    return overflowItems[nextItem];
  };
  const groupManager = createGroupManager();
  function compareItems(lt, rt) {
    if (!lt || !rt) {
      return 0;
    }
    const lte = overflowItems[lt];
    const rte = overflowItems[rt];
    if (!lte || !rte) {
      return lte ? 1 : -1;
    }
    if (lte.priority !== rte.priority) {
      return lte.priority > rte.priority ? 1 : -1;
    }
    const positionStatusBit = options.overflowDirection === "end" ? 4 : 2;
    return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;
  }
  function getElementAxisSize(horizontal, vertical, el) {
    if (!sizeCache.has(el)) {
      sizeCache.set(el, options.overflowAxis === "horizontal" ? el[horizontal] : el[vertical]);
    }
    return sizeCache.get(el);
  }
  const getOffsetSize = getElementAxisSize.bind(null, "offsetWidth", "offsetHeight");
  const getClientSize = getElementAxisSize.bind(null, "clientWidth", "clientHeight");
  const invisibleItemQueue = createPriorityQueue2((a, b) => -1 * compareItems(a, b));
  const visibleItemQueue = createPriorityQueue2(compareItems);
  function occupiedSize() {
    const totalItemSize = visibleItemQueue.all().map((id) => overflowItems[id].element).map(getOffsetSize).reduce((prev, current) => prev + current, 0);
    const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state]) => acc + (state !== "hidden" && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);
    const overflowMenuSize = (invisibleItemQueue.size() > 0 || options.hasHiddenItems) && overflowMenu ? getOffsetSize(overflowMenu) : 0;
    return totalItemSize + totalDividerSize + overflowMenuSize;
  }
  const showItem = () => {
    const item = getNextItem(invisibleItemQueue, visibleItemQueue);
    options.onUpdateItemVisibility({
      item,
      visible: true
    });
    if (item.groupId) {
      groupManager.showItem(item.id, item.groupId);
      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
        var _overflowDividers_item_groupId;
        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);
      }
    }
  };
  const hideItem = () => {
    const item = getNextItem(visibleItemQueue, invisibleItemQueue);
    options.onUpdateItemVisibility({
      item,
      visible: false
    });
    if (item.groupId) {
      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {
        var _overflowDividers_item_groupId;
        (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, "");
      }
      groupManager.hideItem(item.id, item.groupId);
    }
  };
  const dispatchOverflowUpdate = () => {
    const visibleItemIds = visibleItemQueue.all();
    const invisibleItemIds = invisibleItemQueue.all();
    const visibleItems = visibleItemIds.map((itemId) => overflowItems[itemId]);
    const invisibleItems = invisibleItemIds.map((itemId) => overflowItems[itemId]);
    options.onUpdateOverflow({
      visibleItems,
      invisibleItems,
      groupVisibility: groupManager.groupVisibility()
    });
  };
  const processOverflowItems = () => {
    if (!container) {
      return false;
    }
    sizeCache.clear();
    const availableSize = getClientSize(container) - options.padding;
    const visibleTop = visibleItemQueue.peek();
    const invisibleTop = invisibleItemQueue.peek();
    while (compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0) {
      hideItem();
    }
    for (let i = 0; i < 2; i++) {
      while (occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1) {
        showItem();
      }
      while (occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {
        hideItem();
      }
    }
    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;
  };
  const forceUpdate = () => {
    if (processOverflowItems() || forceDispatch) {
      forceDispatch = false;
      dispatchOverflowUpdate();
    }
  };
  const update = debounce2(forceUpdate);
  const observe = (observedContainer, userOptions) => {
    Object.assign(options, userOptions);
    observing = true;
    Object.values(overflowItems).forEach((item) => visibleItemQueue.enqueue(item.id));
    container = observedContainer;
    disposeResizeObserver = observeResize(container, (entries) => {
      if (!entries[0] || !container) {
        return;
      }
      update();
    });
  };
  const addItem = (item) => {
    if (overflowItems[item.id]) {
      return;
    }
    overflowItems[item.id] = item;
    if (observing) {
      forceDispatch = true;
      visibleItemQueue.enqueue(item.id);
    }
    if (item.groupId) {
      groupManager.addItem(item.id, item.groupId);
      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);
    }
    update();
  };
  const addOverflowMenu = (el) => {
    overflowMenu = el;
  };
  const addDivider = (divider) => {
    if (!divider.groupId || overflowDividers[divider.groupId]) {
      return;
    }
    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);
    overflowDividers[divider.groupId] = divider;
  };
  const removeOverflowMenu = () => {
    overflowMenu = void 0;
  };
  const removeDivider = (groupId) => {
    if (!overflowDividers[groupId]) {
      return;
    }
    const divider = overflowDividers[groupId];
    if (divider.groupId) {
      delete overflowDividers[groupId];
      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);
    }
  };
  const removeItem = (itemId) => {
    if (!overflowItems[itemId]) {
      return;
    }
    if (observing) {
      forceDispatch = true;
    }
    const item = overflowItems[itemId];
    visibleItemQueue.remove(itemId);
    invisibleItemQueue.remove(itemId);
    if (item.groupId) {
      groupManager.removeItem(item.id, item.groupId);
      item.element.removeAttribute(DATA_OVERFLOW_GROUP);
    }
    sizeCache.delete(item.element);
    delete overflowItems[itemId];
    update();
  };
  const disconnect = () => {
    disposeResizeObserver();
    container = void 0;
    observing = false;
    forceDispatch = true;
    Object.keys(overflowItems).forEach((itemId) => removeItem(itemId));
    Object.keys(overflowDividers).forEach((dividerId) => removeDivider(dividerId));
    removeOverflowMenu();
    sizeCache.clear();
  };
  return {
    addItem,
    disconnect,
    forceUpdate,
    observe,
    removeItem,
    update,
    addOverflowMenu,
    removeOverflowMenu,
    addDivider,
    removeDivider
  };
}
var createGroupManager = () => {
  const groupVisibility = {};
  const groups = {};
  function updateGroupVisibility(groupId) {
    const group = groups[groupId];
    if (group.invisibleItemIds.size && group.visibleItemIds.size) {
      groupVisibility[groupId] = "overflow";
    } else if (group.visibleItemIds.size === 0) {
      groupVisibility[groupId] = "hidden";
    } else {
      groupVisibility[groupId] = "visible";
    }
  }
  function isGroupVisible(groupId) {
    return groupVisibility[groupId] === "visible" || groupVisibility[groupId] === "overflow";
  }
  return {
    groupVisibility: () => groupVisibility,
    isSingleItemVisible(itemId, groupId) {
      return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;
    },
    addItem(itemId, groupId) {
      var _groups, _groupId;
      var _;
      (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {
        visibleItemIds: /* @__PURE__ */ new Set(),
        invisibleItemIds: /* @__PURE__ */ new Set()
      };
      groups[groupId].visibleItemIds.add(itemId);
      updateGroupVisibility(groupId);
    },
    removeItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.delete(itemId);
      groups[groupId].visibleItemIds.delete(itemId);
      updateGroupVisibility(groupId);
    },
    showItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.delete(itemId);
      groups[groupId].visibleItemIds.add(itemId);
      updateGroupVisibility(groupId);
    },
    hideItem(itemId, groupId) {
      groups[groupId].invisibleItemIds.add(itemId);
      groups[groupId].visibleItemIds.delete(itemId);
      updateGroupVisibility(groupId);
    }
  };
};

// node_modules/@fluentui/react-overflow/lib/constants.js
var DATA_OVERFLOWING2 = "data-overflowing";
var DATA_OVERFLOW_ITEM = "data-overflow-item";
var DATA_OVERFLOW_MENU = "data-overflow-menu";
var DATA_OVERFLOW_DIVIDER = "data-overflow-divider";

// node_modules/@fluentui/react-overflow/lib/useOverflowContainer.js
var noop4 = () => null;
var useOverflowContainer = (update, options) => {
  "use no memo";
  const { overflowAxis = "horizontal", overflowDirection = "end", padding = 10, minimumVisible = 0, onUpdateItemVisibility = noop4, hasHiddenItems = false } = options;
  const onUpdateOverflow = useEventCallback(update);
  const overflowOptions = React314.useMemo(() => ({
    overflowAxis,
    overflowDirection,
    padding,
    minimumVisible,
    onUpdateItemVisibility,
    onUpdateOverflow,
    hasHiddenItems
  }), [
    minimumVisible,
    onUpdateItemVisibility,
    overflowAxis,
    overflowDirection,
    padding,
    onUpdateOverflow,
    hasHiddenItems
  ]);
  const firstMount = useFirstMount();
  const containerRef = React314.useRef(null);
  const [overflowManager, setOverflowManager] = React314.useState(() => canUseDOM() ? createOverflowManager() : null);
  useIsomorphicLayoutEffect(() => {
    if (firstMount && containerRef.current) {
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.observe(containerRef.current, overflowOptions);
    }
  }, [
    firstMount,
    overflowManager,
    overflowOptions
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!containerRef.current || !canUseDOM() || firstMount) {
      return;
    }
    const newOverflowManager = createOverflowManager();
    newOverflowManager.observe(containerRef.current, overflowOptions);
    setOverflowManager(newOverflowManager);
  }, [
    overflowOptions
  ]);
  React314.useEffect(() => () => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.disconnect();
  }, [
    overflowManager
  ]);
  const registerItem = React314.useCallback((item) => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addItem(item);
    item.element.setAttribute(DATA_OVERFLOW_ITEM, "");
    return () => {
      item.element.removeAttribute(DATA_OVERFLOWING2);
      item.element.removeAttribute(DATA_OVERFLOW_ITEM);
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeItem(item.id);
    };
  }, [
    overflowManager
  ]);
  const registerDivider = React314.useCallback((divider) => {
    const el = divider.element;
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addDivider(divider);
    el.setAttribute(DATA_OVERFLOW_DIVIDER, "");
    return () => {
      divider.groupId && (overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeDivider(divider.groupId));
      el.removeAttribute(DATA_OVERFLOW_DIVIDER);
    };
  }, [
    overflowManager
  ]);
  const registerOverflowMenu = React314.useCallback((el) => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.addOverflowMenu(el);
    el.setAttribute(DATA_OVERFLOW_MENU, "");
    return () => {
      overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.removeOverflowMenu();
      el.removeAttribute(DATA_OVERFLOW_MENU);
    };
  }, [
    overflowManager
  ]);
  const updateOverflow = React314.useCallback(() => {
    overflowManager === null || overflowManager === void 0 ? void 0 : overflowManager.update();
  }, [
    overflowManager
  ]);
  return {
    registerItem,
    registerDivider,
    registerOverflowMenu,
    updateOverflow,
    containerRef
  };
};
var updateVisibilityAttribute = ({ item, visible }) => {
  if (visible) {
    item.element.removeAttribute(DATA_OVERFLOWING2);
  } else {
    item.element.setAttribute(DATA_OVERFLOWING2, "");
  }
};

// node_modules/@fluentui/react-overflow/lib/components/useOverflowStyles.styles.js
var useOverflowStyles = __styles2({
  overflowMenu: {
    Brvla84: "fyfkpbf"
  },
  overflowingItems: {
    zb22lx: "f10570jf"
  }
}, {
  d: [".fyfkpbf [data-overflow-menu]{flex-shrink:0;}", ".f10570jf [data-overflowing]{display:none;}"]
});

// node_modules/@fluentui/react-overflow/lib/components/Overflow.js
var Overflow = React315.forwardRef((props, ref) => {
  const styles = useOverflowStyles();
  const { children, minimumVisible, overflowAxis = "horizontal", overflowDirection, padding, onOverflowChange, hasHiddenItems } = props;
  const [overflowState, setOverflowState] = React315.useState({
    hasOverflow: false,
    itemVisibility: {},
    groupVisibility: {}
  });
  const update = (data) => {
    const { visibleItems, invisibleItems, groupVisibility } = data;
    const itemVisibility = {};
    visibleItems.forEach((item) => {
      itemVisibility[item.id] = true;
    });
    invisibleItems.forEach((x) => itemVisibility[x.id] = false);
    const newState = {
      hasOverflow: data.invisibleItems.length > 0,
      itemVisibility,
      groupVisibility
    };
    onOverflowChange === null || onOverflowChange === void 0 ? void 0 : onOverflowChange(null, {
      ...newState
    });
    setOverflowState(newState);
  };
  const { containerRef, registerItem, updateOverflow, registerOverflowMenu, registerDivider } = useOverflowContainer(update, {
    overflowDirection,
    overflowAxis,
    padding,
    minimumVisible,
    hasHiddenItems,
    onUpdateItemVisibility: updateVisibilityAttribute
  });
  const child = getTriggerChild(children);
  const clonedChild = applyTriggerPropsToChildren(children, {
    ref: useMergedRefs(containerRef, ref, getReactElementRef(child)),
    className: mergeClasses("fui-Overflow", styles.overflowMenu, styles.overflowingItems, child === null || child === void 0 ? void 0 : child.props.className)
  });
  return React315.createElement(OverflowContext.Provider, {
    value: {
      itemVisibility: overflowState.itemVisibility,
      groupVisibility: overflowState.groupVisibility,
      hasOverflow: overflowState.hasOverflow,
      registerItem,
      updateOverflow,
      registerOverflowMenu,
      registerDivider
    }
  }, clonedChild);
});

// node_modules/@fluentui/react-overflow/lib/useIsOverflowGroupVisible.js
function useIsOverflowGroupVisible(id) {
  return useOverflowContext((ctx) => ctx.groupVisibility[id]);
}

// node_modules/@fluentui/react-overflow/lib/useIsOverflowItemVisible.js
function useIsOverflowItemVisible(id) {
  return !!useOverflowContext((ctx) => ctx.itemVisibility[id]);
}

// node_modules/@fluentui/react-overflow/lib/useOverflowCount.js
var useOverflowCount = () => useOverflowContext((v) => {
  return Object.entries(v.itemVisibility).reduce((acc, [id, visible]) => {
    if (!visible) {
      acc++;
    }
    return acc;
  }, 0);
});

// node_modules/@fluentui/react-overflow/lib/useOverflowItem.js
var React316 = __toESM(require_react());
function useOverflowItem(id, priority, groupId) {
  const ref = React316.useRef(null);
  const registerItem = useOverflowContext((v) => v.registerItem);
  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      return registerItem({
        element: ref.current,
        id,
        priority: priority !== null && priority !== void 0 ? priority : 0,
        groupId
      });
    }
  }, [
    id,
    priority,
    registerItem,
    groupId
  ]);
  return ref;
}

// node_modules/@fluentui/react-overflow/lib/useOverflowMenu.js
var React317 = __toESM(require_react());
function useOverflowMenu(id) {
  const elementId = useId2("overflow-menu", id);
  const overflowCount = useOverflowCount();
  const registerOverflowMenu = useOverflowContext((v) => v.registerOverflowMenu);
  const updateOverflow = useOverflowContext((v) => v.updateOverflow);
  const ref = React317.useRef(null);
  const isOverflowing = overflowCount > 0;
  useIsomorphicLayoutEffect(() => {
    if (ref.current) {
      return registerOverflowMenu(ref.current);
    }
  }, [
    registerOverflowMenu,
    isOverflowing,
    elementId
  ]);
  useIsomorphicLayoutEffect(() => {
    if (isOverflowing) {
      updateOverflow();
    }
  }, [
    isOverflowing,
    updateOverflow,
    ref
  ]);
  return {
    ref,
    overflowCount,
    isOverflowing
  };
}

// node_modules/@fluentui/react-overflow/lib/useOverflowDivider.js
var React318 = __toESM(require_react());
function useOverflowDivider(groupId) {
  const ref = React318.useRef(null);
  const registerDivider = useOverflowContext((v) => v.registerDivider);
  useIsomorphicLayoutEffect(() => {
    if (ref.current && groupId) {
      return registerDivider({
        element: ref.current,
        groupId
      });
    }
  }, [
    registerDivider,
    groupId
  ]);
  return ref;
}

// node_modules/@fluentui/react-overflow/lib/useOverflowVisibility.js
var React319 = __toESM(require_react());
function useOverflowVisibility() {
  const itemVisibility = useOverflowContext((ctx) => ctx.itemVisibility);
  const groupVisibility = useOverflowContext((ctx) => ctx.groupVisibility);
  return React319.useMemo(() => ({
    itemVisibility,
    groupVisibility
  }), [
    itemVisibility,
    groupVisibility
  ]);
}

// node_modules/@fluentui/react-overflow/lib/components/OverflowItem/OverflowItem.js
var React320 = __toESM(require_react());
var OverflowItem = React320.forwardRef((props, ref) => {
  const { id, groupId, priority, children } = props;
  const containerRef = useOverflowItem(id, priority, groupId);
  const child = getTriggerChild(children);
  return applyTriggerPropsToChildren(children, {
    ref: useMergedRefs(containerRef, ref, getReactElementRef(child))
  });
});
OverflowItem.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-overflow/lib/components/OverflowDivider/OverflowDivider.js
var React321 = __toESM(require_react());
var OverflowDivider = React321.forwardRef((props, ref) => {
  const { groupId, children } = props;
  const containerRef = useOverflowDivider(groupId);
  return applyTriggerPropsToChildren(children, {
    ref: useMergedRefs(containerRef, ref)
  });
});

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/ToolbarContext.js
var ToolbarContext = createContext13(void 0);
var toolbarContextDefaultValue = {
  size: "medium",
  handleToggleButton: () => null,
  handleRadio: () => null,
  vertical: false,
  checkedValues: {}
};
var useToolbarContext_unstable = (selector) => useContextSelector(ToolbarContext, (ctx = toolbarContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/Toolbar.js
var React323 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbar.js
var React322 = __toESM(require_react());
var useToolbar_unstable = (props, ref) => {
  const { size: size3 = "medium" } = props;
  const state = useToolbarBase_unstable(props, ref);
  const arrowNavigationProps = useToolbarArrowNavigationProps_unstable();
  return {
    size: size3,
    ...state,
    root: {
      ...state.root,
      ...arrowNavigationProps
    }
  };
};
var useToolbarBase_unstable = (props, ref) => {
  const { vertical = false } = props;
  const initialState = {
    vertical,
    // TODO add appropriate props/defaults
    components: {
      // TODO add each slot's element type or component
      root: "div"
    },
    // TODO add appropriate slots, for example:
    // mySlot: resolveShorthand(props.mySlot),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      role: "toolbar",
      ref,
      ...vertical && {
        "aria-orientation": "vertical"
      },
      ...props
    }), {
      elementType: "div"
    })
  };
  const [checkedValues, onCheckedValueChange] = useToolbarSelectableState({
    checkedValues: props.checkedValues,
    defaultCheckedValues: props.defaultCheckedValues,
    onCheckedValueChange: props.onCheckedValueChange
  });
  const handleToggleButton = useEventCallback((e, name, value, checked) => {
    if (name && value) {
      const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];
      const newCheckedItems = [
        ...checkedItems
      ];
      if (checked) {
        newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
      } else {
        newCheckedItems.push(value);
      }
      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: newCheckedItems
      });
    }
  });
  const handleRadio = useEventCallback((e, name, value, checked) => {
    if (name && value) {
      onCheckedValueChange === null || onCheckedValueChange === void 0 ? void 0 : onCheckedValueChange(e, {
        name,
        checkedItems: [
          value
        ]
      });
    }
  });
  return {
    ...initialState,
    handleToggleButton,
    handleRadio,
    checkedValues: checkedValues !== null && checkedValues !== void 0 ? checkedValues : {}
  };
};
var useToolbarSelectableState = (state) => {
  const [checkedValues, setCheckedValues] = useControllableState({
    state: state.checkedValues,
    defaultState: state.defaultCheckedValues,
    initialState: {}
  });
  const { onCheckedValueChange: onCheckedValueChangeOriginal } = state;
  const onCheckedValueChange = useEventCallback((e, { name, checkedItems }) => {
    if (onCheckedValueChangeOriginal) {
      onCheckedValueChangeOriginal(e, {
        name,
        checkedItems
      });
    }
    setCheckedValues((s) => {
      return s ? {
        ...s,
        [name]: checkedItems
      } : {
        [name]: checkedItems
      };
    });
  });
  return [
    checkedValues,
    onCheckedValueChange
  ];
};
var useToolbarArrowNavigationProps_unstable = () => {
  return useArrowNavigationGroup({
    circular: true,
    axis: "both"
  });
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/renderToolbar.js
var renderToolbar_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ToolbarContext.Provider, {
    value: contextValues.toolbar,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarStyles.styles.js
var toolbarClassNames = {
  root: "fui-Toolbar"
};
var useStyles37 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yqiaad"
  },
  vertical: {
    Beiy3e4: "f1vx9l62",
    a9b677: "f1acs6jw"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fvz760z"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1yqiaad"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1ms6bdn"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", [".f1yqiaad{padding:4px 8px;}", {
    p: -1
  }], ".f1vx9l62{flex-direction:column;}", ".f1acs6jw{width:fit-content;}", [".fvz760z{padding:0px 4px;}", {
    p: -1
  }], [".f1yqiaad{padding:4px 8px;}", {
    p: -1
  }], [".f1ms6bdn{padding:4px 20px;}", {
    p: -1
  }]]
});
var useToolbarStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles37();
  const {
    vertical,
    size: size3
  } = state;
  state.root.className = mergeClasses(toolbarClassNames.root, styles.root, vertical && styles.vertical, size3 === "small" && !vertical && styles.small, size3 === "medium" && !vertical && styles.medium, size3 === "large" && !vertical && styles.large, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/useToolbarContextValues.js
function useToolbarContextValues_unstable(state) {
  const { size: size3, handleToggleButton, vertical, checkedValues, handleRadio } = state;
  const toolbar = {
    size: size3,
    vertical,
    handleToggleButton,
    handleRadio,
    checkedValues
  };
  return {
    toolbar
  };
}

// node_modules/@fluentui/react-toolbar/lib/components/Toolbar/Toolbar.js
var Toolbar = React323.forwardRef((props, ref) => {
  const state = useToolbar_unstable(props, ref);
  const contextValues = useToolbarContextValues_unstable(state);
  useToolbarStyles_unstable(state);
  useCustomStyleHook("useToolbarStyles_unstable")(state);
  return renderToolbar_unstable(state, contextValues);
});
Toolbar.displayName = "Toolbar";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/ToolbarButton.js
var React325 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButtonStyles.styles.js
var useBaseStyles2 = __styles2({
  vertical: {
    Beiy3e4: "f1vx9l62"
  },
  verticalIcon: {
    Be2twd7: "f1rt2boy",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao"
  }
}, {
  d: [".f1vx9l62{flex-direction:column;}", ".f1rt2boy{font-size:24px;}", [".f1s184ao{margin:0;}", {
    p: -1
  }]]
});
var useToolbarButtonStyles_unstable = (state) => {
  "use no memo";
  const buttonStyles = useBaseStyles2();
  state.root.className = mergeClasses(state.vertical && buttonStyles.vertical, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.vertical && buttonStyles.verticalIcon, state.icon.className);
  }
  useButtonStyles_unstable(state);
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/useToolbarButton.js
var React324 = __toESM(require_react());
var useToolbarButton_unstable = (props, ref) => {
  const state = useToolbarButtonBase_unstable(props, ref);
  return {
    appearance: "subtle",
    size: "medium",
    shape: "rounded",
    ...state
  };
};
var useToolbarButtonBase_unstable = (props, ref) => {
  const { vertical = false, ...buttonProps } = props;
  const state = useButton_unstable({
    appearance: "subtle",
    ...buttonProps,
    size: "medium"
  }, ref);
  return {
    vertical,
    ...state
  };
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarButton/ToolbarButton.js
var ToolbarButton = React325.forwardRef((props, ref) => {
  const state = useToolbarButton_unstable(props, ref);
  useToolbarButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarButton.displayName = "ToolbarButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/ToolbarDivider.js
var React327 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDividerStyles.styles.js
var useBaseStyles3 = __styles2({
  root: {
    mc9l5x: "ftuwxu6",
    B2u0y6b: "f1lwjmbk",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1oic3e7"
  },
  vertical: {
    B2u0y6b: "fe668z"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".f1lwjmbk{max-width:1px;}", [".f1oic3e7{padding:0 12px;}", {
    p: -1
  }], ".fe668z{max-width:initial;}"]
});
var useToolbarDividerStyles_unstable = (state) => {
  "use no memo";
  useDividerStyles_unstable(state);
  const {
    vertical
  } = state;
  const toolbarDividerStyles = useBaseStyles3();
  state.root.className = mergeClasses(toolbarDividerStyles.root, !vertical && toolbarDividerStyles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/useToolbarDivider.js
var React326 = __toESM(require_react());
var useToolbarDivider_unstable = (props, ref) => {
  const state = useToolbarDividerBase_unstable(props, ref);
  return {
    ...state,
    appearance: "default"
  };
};
var useToolbarDividerBase_unstable = (props, ref) => {
  const vertical = useToolbarContext_unstable((ctx) => ctx.vertical);
  return useDivider_unstable({
    vertical: !vertical,
    ...props
  }, ref);
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarDivider/ToolbarDivider.js
var ToolbarDivider = React327.forwardRef((props, ref) => {
  const state = useToolbarDivider_unstable(props, ref);
  useToolbarDividerStyles_unstable(state);
  useCustomStyleHook("useToolbarDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
ToolbarDivider.displayName = "ToolbarDivider";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/ToolbarToggleButton.js
var React329 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButton.js
var React328 = __toESM(require_react());
var useToolbarToggleButton_unstable = (props, ref) => {
  const state = useToolbarToggleButtonBase_unstable(props, ref);
  return {
    appearance: "subtle",
    ...state
  };
};
var useToolbarToggleButtonBase_unstable = (props, ref) => {
  const handleToggleButton = useToolbarContext_unstable((ctx) => ctx.handleToggleButton);
  const checked = useToolbarContext_unstable((ctx) => {
    var _ctx_checkedValues_props_name;
    return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
  });
  const { onClick: onClickOriginal } = props;
  const toggleButtonState = useToggleButton_unstable({
    checked,
    ...props
  }, ref);
  const state = {
    ...toggleButtonState,
    name: props.name,
    value: props.value
  };
  const handleOnClick = (e) => {
    if (state.disabled || state.disabledFocusable) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    handleToggleButton === null || handleToggleButton === void 0 ? void 0 : handleToggleButton(e, state.name, state.value, state.checked);
    onClickOriginal === null || onClickOriginal === void 0 ? void 0 : onClickOriginal(e);
  };
  state.root.onClick = handleOnClick;
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/useToolbarToggleButtonStyles.styles.js
var useBaseStyles4 = __styles2({
  selected: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  iconSelected: {
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useToolbarToggleButtonStyles_unstable = (state) => {
  "use no memo";
  const toggleButtonStyles = useBaseStyles4();
  state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
  }
  useToggleButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarToggleButton/ToolbarToggleButton.js
var ToolbarToggleButton = React329.forwardRef((props, ref) => {
  const state = useToolbarToggleButton_unstable(props, ref);
  useToolbarToggleButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarToggleButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarToggleButton.displayName = "ToolbarToggleButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/ToolbarRadioButton.js
var React331 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButton.js
var React330 = __toESM(require_react());
var useToolbarRadioButton_unstable = (props, ref) => {
  const { appearance = "secondary" } = props;
  const size3 = useToolbarContext_unstable((ctx) => ctx.size);
  const state = useToolbarRadioButtonBase_unstable(props, ref);
  return {
    ...state,
    appearance,
    size: props.size || size3
  };
};
var useToolbarRadioButtonBase_unstable = (props, ref) => {
  const handleRadio = useToolbarContext_unstable((ctx) => ctx.handleRadio);
  const checked = useToolbarContext_unstable((ctx) => {
    var _ctx_checkedValues_props_name;
    return !!((_ctx_checkedValues_props_name = ctx.checkedValues[props.name]) === null || _ctx_checkedValues_props_name === void 0 ? void 0 : _ctx_checkedValues_props_name.includes(props.value));
  });
  const { onClick: onClickOriginal } = props;
  const toggleButtonState = useToggleButton_unstable({
    checked,
    role: "radio",
    "aria-checked": checked,
    ...props
  }, ref);
  const state = {
    ...toggleButtonState,
    name: props.name,
    value: props.value
  };
  const handleOnClick = useEventCallback((e) => {
    handleRadio === null || handleRadio === void 0 ? void 0 : handleRadio(e, state.name, state.value, state.checked);
    onClickOriginal === null || onClickOriginal === void 0 ? void 0 : onClickOriginal(e);
  });
  state.root["aria-pressed"] = void 0;
  state.root.onClick = handleOnClick;
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/useToolbarRadioButtonStyles.styles.js
var useBaseStyles5 = __styles2({
  selected: {
    De3pzq: "fq5gl1p",
    sj55zd: "f1eryozh"
  },
  iconSelected: {
    sj55zd: "f1qj7y59"
  }
}, {
  d: [".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1eryozh{color:var(--colorNeutralForeground2Selected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}"]
});
var useToolbarRadioButtonStyles_unstable = (state) => {
  "use no memo";
  const toggleButtonStyles = useBaseStyles5();
  state.root.className = mergeClasses(state.checked && toggleButtonStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(state.checked && toggleButtonStyles.iconSelected, state.icon.className);
  }
  useToggleButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioButton/ToolbarRadioButton.js
var ToolbarRadioButton = React331.forwardRef((props, ref) => {
  const state = useToolbarRadioButton_unstable(props, ref);
  useToolbarRadioButtonStyles_unstable(state);
  useCustomStyleHook("useToolbarRadioButtonStyles_unstable")(state);
  return renderButton_unstable(state);
});
ToolbarRadioButton.displayName = "ToolbarRadioButton";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/ToolbarGroup.js
var React333 = __toESM(require_react());

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroup.js
var React332 = __toESM(require_react());
var useToolbarGroup_unstable = (props, ref) => {
  return useToolbarGroupBase_unstable(props, ref);
};
var useToolbarGroupBase_unstable = (props, ref) => {
  const vertical = useToolbarContext_unstable((ctx) => ctx.vertical);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "presentation",
      ...props
    }), {
      elementType: "div"
    }),
    vertical
  };
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/useToolbarGroupStyles.styles.js
var toolbarGroupClassNames = {
  root: "fui-ToolbarGroup"
};
var useStyles38 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  },
  vertical: {
    Beiy3e4: "f1vx9l62",
    a9b677: "f1acs6jw"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f1vx9l62{flex-direction:column;}", ".f1acs6jw{width:fit-content;}"]
});
var useToolbarGroupStyles_unstable = (state) => {
  "use no memo";
  const {
    vertical
  } = state;
  const styles = useStyles38();
  state.root.className = mergeClasses(toolbarGroupClassNames.root, styles.root, vertical && styles.vertical, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/renderToolbarGroup.js
var renderToolbarGroup_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children
  });
};

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarGroup/ToolbarGroup.js
var ToolbarGroup = React333.forwardRef((props, ref) => {
  const state = useToolbarGroup_unstable(props, ref);
  useToolbarGroupStyles_unstable(state);
  useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
  return renderToolbarGroup_unstable(state);
});
ToolbarGroup.displayName = "ToolbarGroup";

// node_modules/@fluentui/react-toolbar/lib/components/ToolbarRadioGroup/ToolbarRadioGroup.js
var React334 = __toESM(require_react());
var ToolbarRadioGroup = React334.forwardRef((props, ref) => {
  const state = useToolbarGroup_unstable({
    role: "radiogroup",
    ...props
  }, ref);
  useToolbarGroupStyles_unstable(state);
  useCustomStyleHook("useToolbarGroupStyles_unstable")(state);
  return renderToolbarGroup_unstable(state);
});
ToolbarRadioGroup.displayName = "ToolbarRadioGroup";

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var React344 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/hooks/useTableSelection.js
var React335 = __toESM(require_react());
var noop5 = () => void 0;
var defaultTableSelectionState = {
  allRowsSelected: false,
  clearRows: noop5,
  deselectRow: noop5,
  isRowSelected: () => false,
  selectRow: noop5,
  selectedRows: /* @__PURE__ */ new Set(),
  someRowsSelected: false,
  toggleAllRows: noop5,
  toggleRow: noop5,
  selectionMode: "multiselect"
};
function useTableSelection(options) {
  "use no memo";
  return (tableState) => useTableSelectionState(tableState, options);
}
function useTableSelectionState(tableState, options) {
  const { items, getRowId } = tableState;
  const { selectionMode, defaultSelectedItems, selectedItems, onSelectionChange } = options;
  const [selected, selectionMethods] = useSelection({
    selectionMode,
    defaultSelectedItems,
    selectedItems,
    onSelectionChange
  });
  const selectableRowIds = React335.useMemo(() => {
    const rowIds = /* @__PURE__ */ new Set();
    for (let i = 0; i < items.length; i++) {
      var _getRowId;
      rowIds.add((_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(items[i])) !== null && _getRowId !== void 0 ? _getRowId : i);
    }
    return rowIds;
  }, [
    items,
    getRowId
  ]);
  const allRowsSelected = React335.useMemo(() => {
    if (selectionMode === "single") {
      const selectedRow = Array.from(selected)[0];
      return selectableRowIds.has(selectedRow);
    }
    if (selected.size < selectableRowIds.size) {
      return false;
    }
    if (selectableRowIds.size === 0) {
      return false;
    }
    let res = true;
    selectableRowIds.forEach((selectableRowId) => {
      if (!selected.has(selectableRowId)) {
        res = false;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected,
    selectionMode
  ]);
  const someRowsSelected = React335.useMemo(() => {
    if (selected.size <= 0) {
      return false;
    }
    let res = false;
    selectableRowIds.forEach((selectableRowId) => {
      if (selected.has(selectableRowId)) {
        res = true;
      }
    });
    return res;
  }, [
    selectableRowIds,
    selected
  ]);
  const toggleAllRows = useEventCallback((e) => {
    selectionMethods.toggleAllItems(e, items.map((item, i) => {
      var _getRowId;
      return (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i;
    }));
  });
  const toggleRow = useEventCallback((e, rowId) => selectionMethods.toggleItem(e, rowId));
  const deselectRow = useEventCallback((e, rowId) => selectionMethods.deselectItem(e, rowId));
  const selectRow = useEventCallback((e, rowId) => selectionMethods.selectItem(e, rowId));
  const isRowSelected = (rowId) => selectionMethods.isSelected(rowId);
  const clearRows = useEventCallback((e) => selectionMethods.clearItems(e));
  return {
    ...tableState,
    selection: {
      selectionMode,
      someRowsSelected,
      allRowsSelected,
      selectedRows: selected,
      toggleRow,
      toggleAllRows,
      clearRows,
      deselectRow,
      selectRow,
      isRowSelected
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableSort.js
var React336 = __toESM(require_react());
var noop6 = () => void 0;
var defaultTableSortState = {
  getSortDirection: () => "ascending",
  setColumnSort: noop6,
  sort: (rows) => [
    ...rows
  ],
  sortColumn: void 0,
  sortDirection: "ascending",
  toggleColumnSort: noop6
};
function useTableSort(options) {
  "use no memo";
  return (tableState) => useTableSortState(tableState, options);
}
function useTableSortState(tableState, options) {
  const { columns } = tableState;
  const { sortState, defaultSortState, onSortChange: onSortChangeProp = noop6 } = options;
  const [sorted, setSorted] = useControllableState({
    initialState: {
      sortDirection: "ascending",
      sortColumn: void 0
    },
    defaultState: defaultSortState,
    state: sortState
  });
  const { sortColumn, sortDirection } = sorted;
  const onSortChange = useEventCallback(onSortChangeProp);
  const toggleColumnSort = React336.useCallback((e, columnId) => {
    setSorted((s) => {
      const newState = {
        ...s,
        sortColumn: columnId
      };
      if (s.sortColumn === columnId) {
        newState.sortDirection = s.sortDirection === "ascending" ? "descending" : "ascending";
      } else {
        newState.sortDirection = "ascending";
      }
      onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
      return newState;
    });
  }, [
    onSortChange,
    setSorted
  ]);
  const setColumnSort = (e, nextSortColumn, nextSortDirection) => {
    const newState = {
      sortColumn: nextSortColumn,
      sortDirection: nextSortDirection
    };
    onSortChange === null || onSortChange === void 0 ? void 0 : onSortChange(e, newState);
    setSorted(newState);
  };
  const sort = React336.useCallback((rows) => {
    return rows.slice().sort((a, b) => {
      const sortColumnDef = columns.find((column) => column.columnId === sortColumn);
      if (!(sortColumnDef === null || sortColumnDef === void 0 ? void 0 : sortColumnDef.compare)) {
        return 0;
      }
      const mod = sortDirection === "ascending" ? 1 : -1;
      return sortColumnDef.compare(a.item, b.item) * mod;
    });
  }, [
    columns,
    sortColumn,
    sortDirection
  ]);
  const getSortDirection = (columnId) => {
    return sortColumn === columnId ? sortDirection : void 0;
  };
  return {
    ...tableState,
    sort: {
      sort,
      sortColumn,
      sortDirection,
      setColumnSort,
      toggleColumnSort,
      getSortDirection
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var React343 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var React338 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandle.js
var React337 = __toESM(require_react());
var useTableResizeHandle_unstable = (props, ref) => {
  const onClick = useEventCallback((event) => {
    var _props_onClick;
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
    event.stopPropagation();
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props,
      onClick
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/renderTableResizeHandle.js
var renderTableResizeHandle_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/useTableResizeHandleStyles.styles.js
var tableResizeHandleClassNames = {
  root: "fui-TableResizeHandle"
};
var useStyles39 = __styles2({
  root: {
    qhf8xq: "f1euv43f",
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    Bhzewxz: "f15twtuk",
    B5kzvoi: "f1yab3r1",
    a9b677: "fjw5fx7",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "fg06o1j",
    Bceei9c: "fc3en1c",
    abs64n: "fk73vx1",
    Bmy1vo4: "f13u1uyl",
    B3o57yi: "fezquic",
    Bj3rh1h: "f19g0ac",
    B3cna0y: "f1tkae59",
    Brovlpu: "ftqa4ok",
    B7zu5sd: "f15pjodv",
    Bsft5z2: "f1rcdj94",
    ap17g6: "f2gz7yw",
    a2br6o: "ff2ryt5",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f10awi5f", "f1nzedbg"],
    bn5sak: "frwkxtg",
    By385i5: "fo72kxq",
    Bjyk6c5: "fdlpgxj"
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".fjw5fx7{width:16px;}", [".fg06o1j{margin:0 -8px;}", {
    p: -1
  }], ".fc3en1c{cursor:col-resize;}", ".fk73vx1{opacity:0;}", ".f13u1uyl{transition-property:opacity;}", ".fezquic{transition-duration:.2s;}", ".f19g0ac{z-index:1;}", '.f1rcdj94::after{content:" ";}', ".f2gz7yw::after{display:block;}", ".ff2ryt5::after{width:1px;}", ".f1mdlcz9::after{position:absolute;}", ".f10awi5f::after{left:50%;}", ".f1nzedbg::after{right:50%;}", ".frwkxtg::after{top:0;}", ".fo72kxq::after{bottom:0;}", ".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}"],
  f: [".f1tkae59:focus{opacity:1;}", ".ftqa4ok:focus{outline-style:none;}"],
  h: [".f15pjodv:hover{opacity:1;}"]
});
var useTableResizeHandleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles39();
  state.root.className = mergeClasses(tableResizeHandleClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableResizeHandle/TableResizeHandle.js
var TableResizeHandle = React338.forwardRef((props, ref) => {
  const state = useTableResizeHandle_unstable(props, ref);
  useTableResizeHandleStyles_unstable(state);
  useCustomStyleHook("useTableResizeHandleStyles_unstable")(state);
  return renderTableResizeHandle_unstable(state);
});
TableResizeHandle.displayName = "TableResizeHandle";

// node_modules/@fluentui/react-table/lib/hooks/useMeasureElement.js
var React339 = __toESM(require_react());
function useMeasureElement() {
  const [width, setWidth] = React339.useState(0);
  const container = React339.useRef(void 0);
  const resizeObserverRef = React339.useRef(null);
  const { targetDocument } = useFluent();
  const handleResize = React339.useCallback(() => {
    var _container_current;
    const containerWidth = (_container_current = container.current) === null || _container_current === void 0 ? void 0 : _container_current.getBoundingClientRect().width;
    setWidth(containerWidth || 0);
  }, []);
  const measureElementRef = React339.useCallback((el) => {
    if (!targetDocument) {
      return;
    }
    if (!el && resizeObserverRef.current && container.current) {
      resizeObserverRef.current.unobserve(container.current);
    }
    container.current = void 0;
    if (el === null || el === void 0 ? void 0 : el.parentElement) {
      var _resizeObserverRef_current;
      container.current = el.parentElement;
      handleResize();
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.observe(container.current);
    }
  }, [
    targetDocument,
    handleResize
  ]);
  React339.useEffect(() => {
    resizeObserverRef.current = createResizeObserverFromDocument(targetDocument, handleResize);
    if (!container.current || !resizeObserverRef.current) {
      return;
    }
    resizeObserverRef.current.observe(container.current);
    return () => {
      var _resizeObserverRef_current;
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    };
  }, [
    handleResize,
    targetDocument
  ]);
  return {
    width,
    measureElementRef
  };
}
function createResizeObserverFromDocument(targetDocument, callback) {
  var _targetDocument_defaultView;
  if (!(targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver)) {
    return null;
  }
  return new targetDocument.defaultView.ResizeObserver(callback);
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeMouseHandler.js
var React340 = __toESM(require_react());
function useTableColumnResizeMouseHandler(columnResizeState) {
  const mouseX = React340.useRef(0);
  const currentWidth = React340.useRef(0);
  const colId = React340.useRef(void 0);
  const [dragging, setDragging] = React340.useState(false);
  const { targetDocument } = useFluent();
  const { getColumnWidth: getColumnWidth2, setColumnWidth } = columnResizeState;
  const recalculatePosition = React340.useCallback((e) => {
    const { clientX } = getEventClientCoords(e);
    const dx = clientX - mouseX.current;
    currentWidth.current += dx;
    colId.current && setColumnWidth(e, {
      columnId: colId.current,
      width: currentWidth.current
    });
    mouseX.current = clientX;
  }, [
    setColumnWidth
  ]);
  const [requestRecalcFrame] = useAnimationFrame();
  const onDrag = React340.useCallback((e) => {
    requestRecalcFrame(() => recalculatePosition(e));
  }, [
    requestRecalcFrame,
    recalculatePosition
  ]);
  const onDragEnd = React340.useCallback((event) => {
    if (isMouseEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("mousemove", onDrag);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("touchmove", onDrag);
    }
    setDragging(false);
  }, [
    onDrag,
    targetDocument
  ]);
  const getOnMouseDown = React340.useCallback((columnId) => (event) => {
    currentWidth.current = getColumnWidth2(columnId);
    mouseX.current = getEventClientCoords(event).clientX;
    colId.current = columnId;
    if (isMouseEvent(event)) {
      if (event.target !== event.currentTarget || event.button !== 0) {
        return;
      }
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mouseup", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("mousemove", onDrag);
      setDragging(true);
    }
    if (isTouchEvent(event)) {
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchend", onDragEnd);
      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("touchmove", onDrag);
      setDragging(true);
    }
  }, [
    getColumnWidth2,
    onDrag,
    onDragEnd,
    targetDocument
  ]);
  return {
    getOnMouseDown,
    dragging
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var React341 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/columnResizeUtils.js
var DEFAULT_WIDTH = 150;
var DEFAULT_MIN_WIDTH = 100;
function columnDefinitionsToState(columns, state = [], columnSizingOptions = {}) {
  let updated = false;
  const stateMap = new Map(state.map((s) => [
    s.columnId,
    s
  ]));
  const updatedState = columns.map((column) => {
    const existingColumnState = stateMap.get(column.columnId);
    if (existingColumnState) {
      var _columnSizingOptions_column_columnId;
      const { idealWidth: idealWidth2 = existingColumnState.idealWidth, minWidth: minWidth2 = existingColumnState.minWidth, padding: padding2 = existingColumnState.padding } = (_columnSizingOptions_column_columnId = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId !== void 0 ? _columnSizingOptions_column_columnId : {};
      if (idealWidth2 !== existingColumnState.idealWidth || minWidth2 !== existingColumnState.minWidth || padding2 !== existingColumnState.padding) {
        updated = true;
        return {
          ...existingColumnState,
          idealWidth: idealWidth2,
          width: idealWidth2,
          minWidth: minWidth2,
          padding: padding2
        };
      }
      return existingColumnState;
    }
    var _columnSizingOptions_column_columnId1;
    const { defaultWidth, idealWidth = DEFAULT_WIDTH, minWidth = DEFAULT_MIN_WIDTH, padding } = (_columnSizingOptions_column_columnId1 = columnSizingOptions[column.columnId]) !== null && _columnSizingOptions_column_columnId1 !== void 0 ? _columnSizingOptions_column_columnId1 : {};
    updated = true;
    return {
      columnId: column.columnId,
      width: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      minWidth,
      idealWidth: Math.max(defaultWidth !== null && defaultWidth !== void 0 ? defaultWidth : idealWidth, minWidth),
      padding: padding !== null && padding !== void 0 ? padding : 16
    };
  });
  if (updatedState.length !== state.length || updated) {
    const column = updatedState.find((col) => col.width > col.idealWidth);
    if (column) {
      column.width = column.idealWidth;
    }
    updated = true;
  }
  return updated ? updatedState : state;
}
function getColumnById(state, columnId) {
  return state.find((c) => c.columnId === columnId);
}
function getColumnByIndex(state, index) {
  return state[index];
}
function getTotalWidth(state) {
  return state.reduce((sum, column) => sum + column.width + column.padding, 0);
}
function getColumnWidth(state, columnId) {
  const column = getColumnById(state, columnId);
  var _column_width;
  return (_column_width = column === null || column === void 0 ? void 0 : column.width) !== null && _column_width !== void 0 ? _column_width : 0;
}
function setColumnProperty(localState, columnId, property, value) {
  const currentColumn = getColumnById(localState, columnId);
  if (!currentColumn || (currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn[property]) === value) {
    return localState;
  }
  const updatedColumn = {
    ...currentColumn,
    [property]: value
  };
  const newState = localState.reduce((acc, current) => {
    if (current.columnId === updatedColumn.columnId) {
      return [
        ...acc,
        updatedColumn
      ];
    }
    return [
      ...acc,
      current
    ];
  }, []);
  return newState;
}
function adjustColumnWidthsToFitContainer(state, containerWidth) {
  let newState = state;
  const totalWidth = getTotalWidth(newState);
  if (totalWidth < containerWidth) {
    let difference = containerWidth - totalWidth;
    let i = 0;
    while (i < newState.length && difference > 0) {
      const currentCol = getColumnByIndex(newState, i);
      if (!currentCol) {
        break;
      }
      const colAdjustment = Math.min(currentCol.idealWidth - currentCol.width, difference);
      newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width + colAdjustment);
      difference -= colAdjustment;
      if (i === newState.length - 1 && difference !== 0) {
        const lastCol = getColumnByIndex(newState, i);
        if (lastCol) {
          newState = setColumnProperty(newState, lastCol.columnId, "width", lastCol.width + difference);
        }
      }
      i++;
    }
  } else if (totalWidth >= containerWidth) {
    let difference = totalWidth - containerWidth;
    let j = newState.length - 1;
    while (j >= 0 && difference > 0) {
      const currentCol = getColumnByIndex(newState, j);
      if (!currentCol) {
        j--;
        continue;
      }
      if (currentCol.width > currentCol.minWidth) {
        const colAdjustment = Math.min(currentCol.width - currentCol.minWidth, difference);
        difference -= colAdjustment;
        newState = setColumnProperty(newState, currentCol.columnId, "width", currentCol.width - colAdjustment);
      }
      j--;
    }
  }
  return newState;
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnResizeState.js
var createReducer = (autoFitColumns) => (state, action) => {
  switch (action.type) {
    case "CONTAINER_WIDTH_UPDATED":
      return {
        ...state,
        containerWidth: action.containerWidth,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(state.columnWidthState, action.containerWidth) : state.columnWidthState
      };
    case "COLUMNS_UPDATED":
      const newS = columnDefinitionsToState(action.columns, state.columnWidthState, state.columnSizingOptions);
      return {
        ...state,
        columns: action.columns,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newS, state.containerWidth) : newS
      };
    case "COLUMN_SIZING_OPTIONS_UPDATED":
      const newState = columnDefinitionsToState(state.columns, state.columnWidthState, action.columnSizingOptions);
      return {
        ...state,
        columnSizingOptions: action.columnSizingOptions,
        columnWidthState: autoFitColumns ? adjustColumnWidthsToFitContainer(newState, state.containerWidth) : newState
      };
    case "SET_COLUMN_WIDTH":
      const { columnId, width } = action;
      const { containerWidth } = state;
      const column = getColumnById(state.columnWidthState, columnId);
      let newColumnWidthState = [
        ...state.columnWidthState
      ];
      if (!column) {
        return state;
      }
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "width", width);
      newColumnWidthState = setColumnProperty(newColumnWidthState, columnId, "idealWidth", width);
      if (autoFitColumns) {
        newColumnWidthState = adjustColumnWidthsToFitContainer(newColumnWidthState, containerWidth);
      }
      return {
        ...state,
        columnWidthState: newColumnWidthState
      };
  }
};
function useTableColumnResizeState(columns, containerWidth, params = {}) {
  const { onColumnResize, columnSizingOptions, autoFitColumns = true } = params;
  const reducer = React341.useMemo(() => createReducer(autoFitColumns), [
    autoFitColumns
  ]);
  const [state, dispatch] = React341.useReducer(reducer, {
    columns,
    containerWidth: 0,
    columnWidthState: columnDefinitionsToState(columns, void 0, columnSizingOptions),
    columnSizingOptions
  });
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "CONTAINER_WIDTH_UPDATED",
      containerWidth
    });
  }, [
    containerWidth
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMNS_UPDATED",
      columns
    });
  }, [
    columns
  ]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: "COLUMN_SIZING_OPTIONS_UPDATED",
      columnSizingOptions
    });
  }, [
    columnSizingOptions
  ]);
  const setColumnWidth = useEventCallback((event, data) => {
    let { width } = data;
    const { columnId } = data;
    const col = getColumnById(state.columnWidthState, columnId);
    if (!col) {
      return;
    }
    width = Math.max(col.minWidth || 0, width);
    if (onColumnResize) {
      onColumnResize(event, {
        columnId,
        width
      });
    }
    dispatch({
      type: "SET_COLUMN_WIDTH",
      columnId,
      width
    });
  });
  return {
    getColumnById: React341.useCallback((colId) => getColumnById(state.columnWidthState, colId), [
      state.columnWidthState
    ]),
    getColumns: React341.useCallback(() => state.columnWidthState, [
      state.columnWidthState
    ]),
    getColumnWidth: React341.useCallback((colId) => getColumnWidth(state.columnWidthState, colId), [
      state.columnWidthState
    ]),
    setColumnWidth
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useKeyboardResizing.js
var React342 = __toESM(require_react());
var STEP = 20;
var PRECISION_MODIFIER = Shift;
var PRECISION_FACTOR = 1 / 4;
function useKeyboardResizing(columnResizeState) {
  const [columnId, setColumnId] = React342.useState();
  const onChangeRef = React342.useRef(void 0);
  const { findPrevFocusable } = useFocusFinders();
  const columnResizeStateRef = React342.useRef(columnResizeState);
  React342.useEffect(() => {
    columnResizeStateRef.current = columnResizeState;
  }, [
    columnResizeState
  ]);
  const [resizeHandleRefs] = React342.useState(() => /* @__PURE__ */ new Map());
  const keyboardHandler = useEventCallback((event) => {
    if (!columnId) {
      return;
    }
    const width = columnResizeStateRef.current.getColumnWidth(columnId);
    const precisionModifier = event.getModifierState(PRECISION_MODIFIER);
    const stopEvent = () => {
      event.preventDefault();
      event.stopPropagation();
    };
    switch (event.key) {
      case ArrowLeft:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width - (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case ArrowRight:
        stopEvent();
        columnResizeStateRef.current.setColumnWidth(event.nativeEvent, {
          columnId,
          width: width + (precisionModifier ? STEP * PRECISION_FACTOR : STEP)
        });
        return;
      case Space:
      case Enter:
      case Escape:
        var _resizeHandleRefs_get_current, _resizeHandleRefs_get;
        stopEvent();
        (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : (_resizeHandleRefs_get_current = _resizeHandleRefs_get.current) === null || _resizeHandleRefs_get_current === void 0 ? void 0 : _resizeHandleRefs_get_current.blur();
        break;
    }
  });
  const enableInteractiveMode = React342.useCallback((colId) => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    setColumnId(colId);
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, colId, true);
    const handle = (_resizeHandleRefs_get = resizeHandleRefs.get(colId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (handle) {
      handle.setAttribute("tabindex", "-1");
      handle.tabIndex = -1;
      handle.focus();
    }
  }, [
    resizeHandleRefs
  ]);
  const disableInteractiveMode = React342.useCallback(() => {
    var _onChangeRef_current, _resizeHandleRefs_get;
    if (!columnId) {
      return;
    }
    (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, columnId, false);
    const el = (_resizeHandleRefs_get = resizeHandleRefs.get(columnId)) === null || _resizeHandleRefs_get === void 0 ? void 0 : _resizeHandleRefs_get.current;
    if (el) {
      var _findPrevFocusable;
      (_findPrevFocusable = findPrevFocusable(el)) === null || _findPrevFocusable === void 0 ? void 0 : _findPrevFocusable.focus();
      el.removeAttribute("tabindex");
    }
    setColumnId(void 0);
  }, [
    columnId,
    findPrevFocusable,
    resizeHandleRefs
  ]);
  const toggleInteractiveMode = (colId, onChange) => {
    onChangeRef.current = onChange;
    if (!columnId) {
      enableInteractiveMode(colId);
    } else if (colId && columnId !== colId) {
      enableInteractiveMode(colId);
      setColumnId(colId);
    } else {
      disableInteractiveMode();
    }
  };
  const getKeyboardResizingRef = React342.useCallback((colId) => {
    const ref = resizeHandleRefs.get(colId) || React342.createRef();
    resizeHandleRefs.set(colId, ref);
    return ref;
  }, [
    resizeHandleRefs
  ]);
  const tabsterAttrs = useTabsterAttributes({
    focusable: {
      ignoreKeydown: {
        ArrowLeft: true,
        ArrowRight: true
      }
    }
  });
  return {
    toggleInteractiveMode,
    columnId,
    getKeyboardResizingProps: React342.useCallback((colId, currentWidth) => ({
      onKeyDown: keyboardHandler,
      onBlur: disableInteractiveMode,
      ref: getKeyboardResizingRef(colId),
      role: "separator",
      "aria-label": "Resize column",
      "aria-valuetext": `${currentWidth} pixels`,
      "aria-hidden": colId === columnId ? false : true,
      tabIndex: colId === columnId ? 0 : void 0,
      ...tabsterAttrs
    }), [
      columnId,
      disableInteractiveMode,
      getKeyboardResizingRef,
      keyboardHandler,
      tabsterAttrs
    ])
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableColumnSizing.js
var defaultColumnSizingState = {
  getColumnWidths: () => [],
  getOnMouseDown: () => () => null,
  setColumnWidth: () => null,
  getTableProps: () => ({}),
  getTableHeaderCellProps: () => ({
    style: {},
    columnId: ""
  }),
  getTableCellProps: () => ({
    style: {},
    columnId: ""
  }),
  enableKeyboardMode: () => () => null
};
function useTableColumnSizing_unstable(params) {
  "use no memo";
  return (tableState) => (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useTableColumnSizingState(tableState, {
      autoFitColumns: true,
      ...params
    })
  );
}
function getColumnStyles(column, dragging) {
  const width = column.width;
  return {
    // native styles
    width,
    // non-native element styles (flex layout)
    minWidth: width,
    maxWidth: width,
    // Fixed the unwanted sort: https://github.com/microsoft/fluentui/issues/27803
    ...dragging ? {
      pointerEvents: "none"
    } : {}
  };
}
function useTableColumnSizingState(tableState, params = {}) {
  const { columns } = tableState;
  const { width, measureElementRef } = useMeasureElement();
  const columnResizeState = useTableColumnResizeState(columns, width + ((params === null || params === void 0 ? void 0 : params.containerWidthOffset) || 0), params);
  const mouseHandler = useTableColumnResizeMouseHandler(columnResizeState);
  const { toggleInteractiveMode, getKeyboardResizingProps } = useKeyboardResizing(columnResizeState);
  const { autoFitColumns } = params;
  const enableKeyboardMode = React343.useCallback((columnId, onChange) => (e) => {
    e.preventDefault();
    e.nativeEvent.stopPropagation();
    toggleInteractiveMode(columnId, onChange);
  }, [
    toggleInteractiveMode
  ]);
  const { getColumnById: getColumnById2, setColumnWidth, getColumns } = columnResizeState;
  const { getOnMouseDown, dragging } = mouseHandler;
  return {
    ...tableState,
    tableRef: measureElementRef,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: {
      getOnMouseDown,
      setColumnWidth: (columnId, w) => setColumnWidth(void 0, {
        columnId,
        width: w
      }),
      getColumnWidths: getColumns,
      getTableProps: (props = {}) => {
        return {
          ...props,
          style: {
            minWidth: "fit-content",
            ...props.style || {}
          }
        };
      },
      getTableHeaderCellProps: React343.useCallback((columnId) => {
        var _columns_;
        const col = getColumnById2(columnId);
        const isLastColumn = ((_columns_ = columns[columns.length - 1]) === null || _columns_ === void 0 ? void 0 : _columns_.columnId) === columnId;
        const aside = isLastColumn && autoFitColumns ? null : React343.createElement(TableResizeHandle, {
          onMouseDown: getOnMouseDown(columnId),
          onTouchStart: getOnMouseDown(columnId),
          ...getKeyboardResizingProps(columnId, (col === null || col === void 0 ? void 0 : col.width) || 0)
        });
        return col ? {
          style: getColumnStyles(col, dragging),
          aside
        } : {};
      }, [
        getColumnById2,
        columns,
        dragging,
        getKeyboardResizingProps,
        getOnMouseDown,
        autoFitColumns
      ]),
      getTableCellProps: React343.useCallback((columnId) => {
        const col = getColumnById2(columnId);
        return col ? {
          style: getColumnStyles(col)
        } : {};
      }, [
        getColumnById2
      ]),
      enableKeyboardMode
    }
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableFeatures.js
var defaultRowEnhancer = (row) => row;
var defaultTableState = {
  selection: defaultTableSelectionState,
  sort: defaultTableSortState,
  getRows: () => [],
  getRowId: () => "",
  items: [],
  columns: [],
  // eslint-disable-next-line @typescript-eslint/naming-convention
  columnSizing_unstable: defaultColumnSizingState,
  tableRef: React344.createRef()
};
function useTableFeatures(options, plugins = []) {
  const { items, getRowId, columns } = options;
  const getRows = React344.useCallback((rowEnhancer = defaultRowEnhancer) => {
    return items.map((item, i) => {
      var _getRowId;
      return rowEnhancer({
        item,
        rowId: (_getRowId = getRowId === null || getRowId === void 0 ? void 0 : getRowId(item)) !== null && _getRowId !== void 0 ? _getRowId : i
      });
    });
  }, [
    items,
    getRowId
  ]);
  const initialState = {
    getRowId,
    items,
    columns,
    getRows,
    selection: defaultTableSelectionState,
    sort: defaultTableSortState,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    columnSizing_unstable: defaultColumnSizingState,
    tableRef: React344.createRef()
  };
  return plugins.reduce((state, plugin) => plugin(state), initialState);
}

// node_modules/@fluentui/react-table/lib/hooks/createColumn.js
var React345 = __toESM(require_react());
var defaultCompare = () => 0;
var defaultRenderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderCell function that renders null");
  }
  return null;
};
var defaultRenderHeaderCell = () => {
  if (true) {
    console.warn("@fluentui/react-table: You are using the default column renderHeaderCell function that renders null");
  }
  return null;
};
function createTableColumn(options) {
  const { columnId, renderCell = defaultRenderCell, renderHeaderCell = defaultRenderHeaderCell, compare = defaultCompare } = options;
  return {
    columnId,
    renderCell,
    renderHeaderCell,
    compare
  };
}

// node_modules/@fluentui/react-table/lib/hooks/useTableCompositeNavigation.js
var React346 = __toESM(require_react());
function useTableCompositeNavigation() {
  const horizontalAttr = useArrowNavigationGroup({
    axis: "horizontal"
  });
  const gridAttr = useArrowNavigationGroup({
    axis: "grid"
  });
  const groupperAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  const { findFirstFocusable } = useFocusFinders();
  const { targetDocument } = useFluent();
  const rowAttr = useMergedTabsterAttributes_unstable(horizontalAttr, groupperAttr);
  const onKeyDown = React346.useCallback((e) => {
    if (!targetDocument) {
      return;
    }
    let activeElement = targetDocument.activeElement;
    if (!activeElement || !e.currentTarget.contains(activeElement)) {
      return;
    }
    const activeElementRole = activeElement.getAttribute("role");
    if (e.key === ArrowRight && activeElementRole === "row" && isHTMLElement(activeElement)) {
      var _findFirstFocusable;
      (_findFirstFocusable = findFirstFocusable(activeElement)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
    }
    if (activeElementRole === "row") {
      return;
    }
    const isInCell = (() => {
      let cur = isHTMLElement(activeElement) ? activeElement : null;
      while (cur) {
        const curRole = cur.getAttribute("role");
        if (curRole === "cell" || curRole === "gridcell") {
          return true;
        }
        cur = cur.parentElement;
      }
      return false;
    })();
    if (e.key === ArrowLeft && isInCell) {
      activeElement.dispatchEvent(new GroupperMoveFocusEvent({
        action: GroupperMoveFocusActions.Escape
      }));
      return;
    }
    if ((e.key === ArrowDown || e.key === ArrowUp) && isInCell) {
      activeElement.dispatchEvent(new GroupperMoveFocusEvent({
        action: GroupperMoveFocusActions.Escape
      }));
      activeElement = targetDocument.activeElement;
      if (activeElement) {
        activeElement.dispatchEvent(new MoverMoveFocusEvent({
          key: MoverKeys[e.key]
        }));
      }
    }
  }, [
    targetDocument,
    findFirstFocusable
  ]);
  return {
    onTableKeyDown: onKeyDown,
    tableTabsterAttribute: gridAttr,
    tableRowTabsterAttribute: rowAttr
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var React349 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var React348 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableContext.js
var React347 = __toESM(require_react());
var tableContext = React347.createContext(void 0);
var tableContextDefaultValue = {
  size: "medium",
  noNativeElements: false,
  sortable: false
};
var TableContextProvider = tableContext.Provider;
var useTableContext = () => {
  var _React_useContext;
  return (_React_useContext = React347.useContext(tableContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableContextDefaultValue;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCell.js
var useTableCell_unstable = (props, ref) => {
  const { noNativeElements, size: size3 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "td";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "cell" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements,
    size: size3
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCell/renderTableCell.js
var renderTableCell_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCell/useTableCellStyles.styles.js
var tableCellClassName = "fui-TableCell";
var tableCellClassNames = {
  root: tableCellClassName
};
var useTableLayoutStyles = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  },
  medium: {
    Bqenvij: "f1ft4266"
  },
  small: {
    Bqenvij: "fbsu25e"
  },
  "extra-small": {
    Bqenvij: "frvgh55"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}", ".f1ft4266{height:44px;}", ".fbsu25e{height:34px;}", ".frvgh55{height:24px;}"]
});
var useFlexLayoutStyles = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bf4jedk: "f10tiqix",
    Bt984gj: "f122n59",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr"
  },
  medium: {
    sshi5w: "f5pgtk9"
  },
  small: {
    sshi5w: "fcep9tg"
  },
  "extra-small": {
    sshi5w: "f1pha7fy"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f10tiqix{min-width:0px;}", ".f122n59{align-items:center;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f5pgtk9{min-height:44px;}", ".fcep9tg{min-height:34px;}", ".f1pha7fy{min-height:24px;}"]
});
var useStyles40 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3gpkru",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  }
}, {
  d: [".f10pi13n{position:relative;}", [".f3gpkru{padding:0px var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }]]
});
var useTableCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles40();
  const layoutStyles = {
    table: useTableLayoutStyles(),
    flex: useFlexLayoutStyles()
  };
  state.root.className = mergeClasses(tableCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.noNativeElements ? layoutStyles.flex[state.size] : layoutStyles.table[state.size], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCell/TableCell.js
var TableCell = React349.forwardRef((props, ref) => {
  const state = useTableCell_unstable(props, ref);
  useTableCellStyles_unstable(state);
  useCustomStyleHook("useTableCellStyles_unstable")(state);
  return renderTableCell_unstable(state);
});
TableCell.displayName = "TableCell";

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var React352 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var React351 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/tableHeaderContext.js
var React350 = __toESM(require_react());
var tableHeaderContext = React350.createContext(void 0);
var tableHeaderContextDefaultValue = "";
var TableHeaderContextProvider = tableHeaderContext.Provider;
var useIsInTableHeader = () => React350.useContext(tableHeaderContext) === tableHeaderContextDefaultValue;

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRow.js
var useTableRow_unstable = (props, ref) => {
  const { noNativeElements, size: size3 } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tr";
  const focusVisibleRef = useFocusVisible();
  const focusWithinRef = useFocusWithin();
  const isHeaderRow = useIsInTableHeader();
  var _props_appearance;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, focusVisibleRef, focusWithinRef),
      role: rootComponent === "div" ? "row" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: size3,
    noNativeElements,
    appearance: (_props_appearance = props.appearance) !== null && _props_appearance !== void 0 ? _props_appearance : "none",
    isHeaderRow
  };
};

// node_modules/@fluentui/react-table/lib/components/TableRow/renderTableRow.js
var renderTableRow_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActionsStyles.styles.js
var tableCellActionsClassNames = {
  root: "fui-TableCellActions"
};
var useStyles41 = __styles2({
  root: {
    De3pzq: "f1u2r49w",
    qhf8xq: "f1euv43f",
    j35jbq: ["f10k790i", "f1xynx9j"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x",
    abs64n: "fk73vx1",
    Frg6f3: ["fcgxt0o", "f1ujusj6"]
  },
  visible: {
    abs64n: "f5p0z4x"
  }
}, {
  d: [".f1u2r49w{background-color:inherit;}", ".f1euv43f{position:absolute;}", ".f10k790i{right:0px;}", ".f1xynx9j{left:0px;}", ".f1i1t8d1{top:50%;}", ".f188r07x{transform:translateY(-50%);}", ".fk73vx1{opacity:0;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".f5p0z4x{opacity:1;}"]
});
var useTableCellActionsStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles41();
  state.root.className = mergeClasses(tableCellActionsClassNames.root, styles.root, state.visible && styles.visible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCellStyles.styles.js
var CELL_WIDTH = 44;
var tableSelectionCellClassNames = {
  root: "fui-TableSelectionCell",
  checkboxIndicator: "fui-TableSelectionCell__checkboxIndicator",
  radioIndicator: "fui-TableSelectionCell__radioIndicator"
};
var useTableLayoutStyles2 = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    a9b677: "fksc0bp"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fksc0bp{width:44px;}"]
});
var useFlexLayoutStyles2 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    Bf4jedk: "fvrlu0f",
    B2u0y6b: "f1c71y05",
    Brf1p80: "f4d9j23"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".fvrlu0f{min-width:44px;}", ".f1c71y05{max-width:44px;}", ".f4d9j23{justify-content:center;}"]
});
var useStyles42 = __styles2({
  root: {
    fsow6f: "f17mccla",
    Huce71: "fz5stix",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  radioIndicator: {
    mc9l5x: "f22iagw",
    Bh6795r: "fqerorx",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23"
  },
  subtle: {
    abs64n: "fk73vx1",
    B8a84jv: "f1y7ij6c"
  },
  hidden: {
    abs64n: "fk73vx1"
  }
}, {
  d: [".f17mccla{text-align:center;}", ".fz5stix{white-space:nowrap;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fk73vx1{opacity:0;}", ".f1y7ij6c[data-fui-focus-within]:focus-within{opacity:1;}"]
});
var useTableSelectionCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles42();
  const layoutStyles = {
    table: useTableLayoutStyles2(),
    flex: useFlexLayoutStyles2()
  };
  state.root.className = mergeClasses(tableSelectionCellClassNames.root, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.subtle && state.checked === false && styles.subtle, state.hidden && styles.hidden, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(tableSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(tableSelectionCellClassNames.radioIndicator, styles.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/useTableRowStyles.styles.js
var tableRowClassName = "fui-TableRow";
var tableRowClassNames = {
  root: tableRowClassName
};
var useTableLayoutStyles3 = __styles2({
  root: {
    mc9l5x: "f1u0rzck"
  }
}, {
  d: [".f1u0rzck{display:table-row;}"]
});
var useFlexLayoutStyles3 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}"]
});
var useStyles43 = __styles2({
  root: {
    sj55zd: "f19n0e5",
    B7ck84d: "f1ewtqcl",
    Bconypa: "f1jazu75",
    B6guboy: "f1xeqee6",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f1dxfoyt",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  rootInteractive: {
    B6guboy: "f1xeqee6",
    ecr2s2: "f1wfn5kd",
    lj723h: "f1g4hkjv",
    B43xm9u: "f15ngxrw",
    i921ia: "fjbbrdp",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "feu1g3u",
    Bpt6rm4: "f1uorfem",
    ff6mpl: "fw60kww",
    Bahaeuw: "f1v3eptx",
    F230oe: "f8gmj8i",
    Bdw8ktp: ["f1ap8nzx", "fjag8bx"],
    Bj1xduy: "f1igan7k",
    Bhh2cfd: ["fjag8bx", "f1ap8nzx"]
  },
  medium: {
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  },
  small: {
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f1facbz3"
  },
  "extra-small": {
    Be2twd7: "fy9rknc"
  },
  brand: {
    De3pzq: "f16xkysk",
    g2u3we: "f1bh3yvw",
    h3c5rm: ["fmi79ni", "f11fozsx"],
    B9xav0g: "fnzw4c6",
    zhjwy3: ["f11fozsx", "fmi79ni"],
    ecr2s2: "f7tkmfy",
    lj723h: "f1r2dosr",
    wmvzou: 0,
    sc4o1m: 0,
    wymq9i: 0,
    u9orzk: 0,
    puiv5t: 0,
    Bosien3: 0,
    b2z72d: 0,
    Beulxaw: 0,
    B57pkaw: 0,
    Jcjdmf: 0,
    B8qgbzl: 0,
    Bbmb0sr: 0,
    B14q8qp: 0,
    Bcq6wej: 0,
    Byz1pjr: 0,
    kr9cjb: 0,
    Ff9ifp: "f1msmgpi",
    Bmclvqj: 0,
    psczho: 0,
    B0tx59b: 0,
    sk7i8k: 0,
    zlwzm7: "fbo0xvd",
    Bkp2nk: "fjuvmhu",
    gy0h4g: "f1kvufhq"
  },
  neutral: {
    wmvzou: 0,
    sc4o1m: 0,
    wymq9i: 0,
    u9orzk: 0,
    puiv5t: 0,
    Bosien3: 0,
    b2z72d: 0,
    Beulxaw: 0,
    B57pkaw: 0,
    Jcjdmf: 0,
    B8qgbzl: 0,
    Bbmb0sr: 0,
    B14q8qp: 0,
    Bcq6wej: 0,
    Byz1pjr: 0,
    kr9cjb: 0,
    Ff9ifp: "f1msmgpi",
    Bmclvqj: 0,
    psczho: 0,
    B0tx59b: 0,
    sk7i8k: 0,
    zlwzm7: "fbo0xvd",
    Bkp2nk: "fjuvmhu",
    gy0h4g: "f1kvufhq",
    De3pzq: "fq5gl1p",
    sj55zd: "f1cgsbmv",
    ecr2s2: "fa9o754",
    g2u3we: "frmsihh",
    h3c5rm: ["frttxa5", "f11o2r7f"],
    B9xav0g: "fem5et0",
    zhjwy3: ["f11o2r7f", "frttxa5"]
  },
  none: {}
}, {
  d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}", ".f1xeqee6[data-fui-focus-within]:focus-within .fui-TableCellActions{opacity:1;}", [".f1dxfoyt[data-fui-focus-visible]{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], [".f1facbz3{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStroke2);}", {
    p: -1
  }], ".fy9rknc{font-size:var(--fontSizeBase200);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".f1bh3yvw{border-top-color:var(--colorTransparentStrokeInteractive);}", ".fmi79ni{border-right-color:var(--colorTransparentStrokeInteractive);}", ".f11fozsx{border-left-color:var(--colorTransparentStrokeInteractive);}", ".fnzw4c6{border-bottom-color:var(--colorTransparentStrokeInteractive);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1cgsbmv{color:var(--colorNeutralForeground1Hover);}", ".frmsihh{border-top-color:var(--colorNeutralStrokeOnBrand);}", ".frttxa5{border-right-color:var(--colorNeutralStrokeOnBrand);}", ".f11o2r7f{border-left-color:var(--colorNeutralStrokeOnBrand);}", ".fem5et0{border-bottom-color:var(--colorNeutralStrokeOnBrand);}"],
  a: [".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f15ngxrw:active .fui-TableCellActions{opacity:1;}", ".fjbbrdp:active .fui-TableSelectionCell{opacity:1;}", ".f7tkmfy:active{background-color:var(--colorBrandBackground2);}", ".f1r2dosr:active{color:var(--colorNeutralForeground1);}", ".fa9o754:active{background-color:var(--colorSubtleBackgroundSelected);}"],
  h: [".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1uorfem:hover .fui-TableCellActions{opacity:1;}", ".fw60kww:hover .fui-TableSelectionCell{opacity:1;}"],
  m: [["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f8gmj8i:hover{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ap8nzx:hover{border-right-color:Highlight;}.fjag8bx:hover{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1igan7k:hover{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1msmgpi{border:2px solid transparent;}}", {
    p: -2,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fbo0xvd{border-radius:var(--borderRadiusMedium);}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fjuvmhu{box-sizing:border-box;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1kvufhq:focus-visible{outline-offset:-4px;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTableRowStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles43();
  const layoutStyles = {
    table: useTableLayoutStyles3(),
    flex: useFlexLayoutStyles3()
  };
  state.root.className = mergeClasses(tableRowClassNames.root, styles.root, !state.isHeaderRow && styles.rootInteractive, styles[state.size], state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, styles[state.appearance], state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableRow/TableRow.js
var TableRow = React352.forwardRef((props, ref) => {
  const state = useTableRow_unstable(props, ref);
  useTableRowStyles_unstable(state);
  useCustomStyleHook("useTableRowStyles_unstable")(state);
  return renderTableRow_unstable(state);
});
TableRow.displayName = "TableRow";

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var React354 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBody.js
var React353 = __toESM(require_react());
var useTableBody_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "tbody";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableBody/renderTableBody.js
var renderTableBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableBody/useTableBodyStyles.styles.js
var useTableLayoutStyles4 = __styles2({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useFlexLayoutStyles4 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var tableBodyClassName = "fui-TableBody";
var tableBodyClassNames = {
  root: "fui-TableBody"
};
var useTableBodyStyles_unstable = (state) => {
  "use no memo";
  const layoutStyles = {
    table: useTableLayoutStyles4(),
    flex: useFlexLayoutStyles4()
  };
  state.root.className = mergeClasses(tableBodyClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableBody/TableBody.js
var TableBody = React354.forwardRef((props, ref) => {
  const state = useTableBody_unstable(props, ref);
  useTableBodyStyles_unstable(state);
  useCustomStyleHook("useTableBodyStyles_unstable")(state);
  return renderTableBody_unstable(state);
});
TableBody.displayName = "TableBody";

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var React357 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/Table/useTable.js
var React355 = __toESM(require_react());
var useTable_unstable = (props, ref) => {
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : props.noNativeElements) ? "div" : "table";
  var _props_size, _props_noNativeElements, _props_sortable;
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "table" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    size: (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : "medium",
    noNativeElements: (_props_noNativeElements = props.noNativeElements) !== null && _props_noNativeElements !== void 0 ? _props_noNativeElements : false,
    sortable: (_props_sortable = props.sortable) !== null && _props_sortable !== void 0 ? _props_sortable : false
  };
};

// node_modules/@fluentui/react-table/lib/components/Table/renderTable.js
var renderTable_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(TableContextProvider, {
    value: contextValues.table,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableStyles.styles.js
var tableClassName = "fui-Table";
var tableClassNames = {
  root: "fui-Table"
};
var useTableLayoutStyles5 = __styles2({
  root: {
    mc9l5x: "f1w4nmp0",
    ha4doy: "fmrv4ls",
    a9b677: "fly5x3f",
    B73mfa3: "f14m3nip"
  }
}, {
  d: [".f1w4nmp0{display:table;}", ".fmrv4ls{vertical-align:middle;}", ".fly5x3f{width:100%;}", ".f14m3nip{table-layout:fixed;}"]
});
var useFlexLayoutStyles5 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useStyles44 = __styles2({
  root: {
    po53p8: "fgkb47j",
    De3pzq: "fhovq9v"
  }
}, {
  d: [".fgkb47j{border-collapse:collapse;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}"]
});
var useTableStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles44();
  const layoutStyles = {
    table: useTableLayoutStyles5(),
    flex: useFlexLayoutStyles5()
  };
  state.root.className = mergeClasses(tableClassName, styles.root, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/Table/useTableContextValues.js
var React356 = __toESM(require_react());
function useTableContextValues_unstable(state) {
  const { size: size3, noNativeElements, sortable } = state;
  const tableContext2 = React356.useMemo(() => ({
    noNativeElements,
    size: size3,
    sortable
  }), [
    noNativeElements,
    size3,
    sortable
  ]);
  return {
    table: tableContext2
  };
}

// node_modules/@fluentui/react-table/lib/components/Table/Table.js
var Table = React357.forwardRef((props, ref) => {
  const state = useTable_unstable(props, ref);
  useTableStyles_unstable(state);
  useCustomStyleHook("useTableStyles_unstable")(state);
  return renderTable_unstable(state, useTableContextValues_unstable(state));
});
Table.displayName = "Table";

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var React359 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeader.js
var React358 = __toESM(require_react());
var useTableHeader_unstable = (props, ref) => {
  const { noNativeElements } = useTableContext();
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "thead";
  return {
    components: {
      root: rootComponent
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: rootComponent === "div" ? "rowgroup" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/renderTableHeader.js
var renderTableHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(TableHeaderContextProvider, {
    value: "",
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/useTableHeaderStyles.styles.js
var tableHeaderClassName = "fui-TableHeader";
var tableHeaderClassNames = {
  root: "fui-TableHeader"
};
var useFlexLayoutStyles6 = __styles2({
  root: {
    mc9l5x: "ftgm304"
  }
}, {
  d: [".ftgm304{display:block;}"]
});
var useTableLayoutStyles6 = __styles2({
  root: {
    mc9l5x: "f1tp1avn"
  }
}, {
  d: [".f1tp1avn{display:table-row-group;}"]
});
var useTableHeaderStyles_unstable = (state) => {
  "use no memo";
  const layoutStyles = {
    table: useTableLayoutStyles6(),
    flex: useFlexLayoutStyles6()
  };
  state.root.className = mergeClasses(tableHeaderClassName, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeader/TableHeader.js
var TableHeader = React359.forwardRef((props, ref) => {
  const state = useTableHeader_unstable(props, ref);
  useTableHeaderStyles_unstable(state);
  useCustomStyleHook("useTableHeaderStyles_unstable")(state);
  return renderTableHeader_unstable(state);
});
TableHeader.displayName = "TableHeader";

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var React361 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCell.js
var React360 = __toESM(require_react());
var sortIcons = {
  ascending: React360.createElement(ArrowUpRegular, {
    fontSize: 12
  }),
  descending: React360.createElement(ArrowDownRegular, {
    fontSize: 12
  })
};
var useTableHeaderCell_unstable = (props, ref) => {
  const { noNativeElements, sortable: contextSortable } = useTableContext();
  const { sortable = contextSortable } = props;
  var _props_as;
  const rootComponent = ((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : noNativeElements) ? "div" : "th";
  const buttonSlot = slot_exports.always(props.button, {
    elementType: "div",
    defaultProps: {
      as: "div"
    }
  });
  const ariaButtonProps = useARIAButtonProps(buttonSlot.as, buttonSlot);
  var _props_sortDirection;
  return {
    components: {
      root: rootComponent,
      button: "div",
      sortIcon: "span",
      aside: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(rootComponent, {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, useFocusWithin()),
      role: rootComponent === "div" ? "columnheader" : void 0,
      "aria-sort": sortable ? (_props_sortDirection = props.sortDirection) !== null && _props_sortDirection !== void 0 ? _props_sortDirection : "none" : void 0,
      ...props
    }), {
      elementType: rootComponent
    }),
    aside: slot_exports.optional(props.aside, {
      elementType: "span"
    }),
    sortIcon: slot_exports.optional(props.sortIcon, {
      renderByDefault: !!props.sortDirection,
      defaultProps: {
        children: props.sortDirection ? sortIcons[props.sortDirection] : void 0
      },
      elementType: "span"
    }),
    button: sortable ? ariaButtonProps : buttonSlot,
    sortable,
    noNativeElements
  };
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/renderTableHeaderCell.js
var renderTableHeaderCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsxs(state.button, {
        children: [
          state.root.children,
          state.sortIcon && jsx(state.sortIcon, {})
        ]
      }),
      state.aside && jsx(state.aside, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/useTableHeaderCellStyles.styles.js
var tableHeaderCellClassName = "fui-TableHeaderCell";
var tableHeaderCellClassNames = {
  root: "fui-TableHeaderCell",
  button: "fui-TableHeaderCell__button",
  sortIcon: "fui-TableHeaderCell__sortIcon",
  aside: "fui-TableHeaderCell__aside"
};
var useTableLayoutStyles7 = __styles2({
  root: {
    mc9l5x: "f15pt5es",
    ha4doy: "fmrv4ls"
  }
}, {
  d: [".f15pt5es{display:table-cell;}", ".fmrv4ls{vertical-align:middle;}"]
});
var useFlexLayoutStyles7 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    Bf4jedk: "f10tiqix"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f10tiqix{min-width:0px;}"]
});
var useStyles45 = __styles2({
  root: {
    Bhrd7zp: "figsok6",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3gpkru",
    robkg1: 0,
    Bmvh20x: 0,
    B3nxjsc: 0,
    Bmkhcsx: "f14ym4q2",
    B8osjzx: 0,
    pehzd3: 0,
    Blsv9te: 0,
    u7xebq: 0,
    Bsvwmf7: "f1euou18",
    qhf8xq: "f10pi13n"
  },
  rootInteractive: {
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1t94bn6",
    lj723h: "f1g4hkjv",
    ecr2s2: "f1wfn5kd"
  },
  resetButton: {
    B3rzk8w: "fq6nmtn",
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1u2r49w",
    sj55zd: "f1ym3bx4",
    Bahqtrf: "f1mo0ibp",
    Be2twd7: "fjoy568",
    Bg96gwp: "fytdu2e",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1gl81tg",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    fsow6f: "fgusgyc"
  },
  button: {
    qhf8xq: "f10pi13n",
    a9b677: "fly5x3f",
    mc9l5x: "f22iagw",
    Bh6795r: 0,
    Bqenvij: "f1l02sjl",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fkln5zr",
    sshi5w: "f1nxs5xn",
    xawz: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr",
    oeaueh: "f1s6fcnf"
  },
  sortable: {
    Bceei9c: "f1k6fduh"
  },
  sortIcon: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    z8tnut: "fclwglc"
  },
  resizeHandle: {}
}, {
  d: [".figsok6{font-weight:var(--fontWeightRegular);}", [".f3gpkru{padding:0px var(--spacingHorizontalS);}", {
    p: -1
  }], [".f14ym4q2[data-fui-focus-within]:focus-within{outline:2px solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f1euou18[data-fui-focus-within]:focus-within{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f10pi13n{position:relative;}", ".fq6nmtn{resize:horizontal;}", ".f1e4lqlz{box-sizing:content-box;}", ".f1u2r49w{background-color:inherit;}", ".f1ym3bx4{color:inherit;}", ".f1mo0ibp{font-family:inherit;}", ".fjoy568{font-size:inherit;}", ".fytdu2e{line-height:normal;}", [".f1gl81tg{overflow:visible;}", {
    p: -1
  }], [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f3bhgqh{border:none;}", {
    p: -2
  }], ".fgusgyc{text-align:unset;}", ".fly5x3f{width:100%;}", ".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}", ".f1l02sjl{height:100%;}", ".f122n59{align-items:center;}", [".fkln5zr{gap:var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f1nxs5xn{min-height:32px;}", [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f1s6fcnf{outline-style:none;}", ".f1k6fduh{cursor:pointer;}", ".fclwglc{padding-top:var(--spacingVerticalXXS);}"],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}"],
  a: [".f1g4hkjv:active{color:var(--colorNeutralForeground1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
});
var useTableHeaderCellStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles45();
  const layoutStyles = {
    table: useTableLayoutStyles7(),
    flex: useFlexLayoutStyles7()
  };
  state.root.className = mergeClasses(tableHeaderCellClassNames.root, styles.root, state.sortable && styles.rootInteractive, state.noNativeElements ? layoutStyles.flex.root : layoutStyles.table.root, state.root.className);
  state.button.className = mergeClasses(tableHeaderCellClassNames.button, styles.resetButton, styles.button, state.sortable && styles.sortable, state.button.className);
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(tableHeaderCellClassNames.sortIcon, styles.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(tableHeaderCellClassNames.aside, styles.resizeHandle, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableHeaderCell/TableHeaderCell.js
var TableHeaderCell = React361.forwardRef((props, ref) => {
  const state = useTableHeaderCell_unstable(props, ref);
  useTableHeaderCellStyles_unstable(state);
  useCustomStyleHook("useTableHeaderCellStyles_unstable")(state);
  return renderTableHeaderCell_unstable(state);
});
TableHeaderCell.displayName = "TableHeaderCell";

// node_modules/@fluentui/react-table/lib/contexts/columnIdContext.js
var React362 = __toESM(require_react());
var columnIdContext = React362.createContext(void 0);
var columnIdContextDefaultValue = "";
var useColumnIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React362.useContext(columnIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : columnIdContextDefaultValue;
};
var ColumnIdContextProvider = columnIdContext.Provider;

// node_modules/@fluentui/react-table/lib/contexts/rowIdContext.js
var React363 = __toESM(require_react());
var rowIdContext = React363.createContext(void 0);
var tableRowIdContextDefaultValue = "";
var useTableRowIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React363.useContext(rowIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tableRowIdContextDefaultValue;
};
var TableRowIdContextProvider = rowIdContext.Provider;

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var React365 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/useTableSelectionCell.js
var React364 = __toESM(require_react());
var useTableSelectionCell_unstable = (props, ref) => {
  const tableCellState = useTableCell_unstable(props, useMergedRefs(ref, useFocusWithin()));
  const { noNativeElements } = useTableContext();
  const {
    type = "checkbox",
    checked = false,
    subtle = false,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    hidden = false,
    invisible = false
  } = props;
  return {
    ...tableCellState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...tableCellState.components,
      checkboxIndicator: Checkbox,
      radioIndicator: Radio
    },
    checkboxIndicator: slot_exports.optional(props.checkboxIndicator, {
      renderByDefault: type === "checkbox",
      defaultProps: {
        checked: props.checked
      },
      elementType: Checkbox
    }),
    radioIndicator: slot_exports.optional(props.radioIndicator, {
      renderByDefault: type === "radio",
      defaultProps: {
        checked: !!checked,
        input: {
          name: useId2("table-selection-radio")
        }
      },
      elementType: Radio
    }),
    type,
    checked,
    noNativeElements,
    subtle,
    hidden: invisible || hidden
  };
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/renderTableSelectionCell.js
var renderTableSelectionCell_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.type === "checkbox" && state.checkboxIndicator && jsx(state.checkboxIndicator, {}),
      state.type === "radio" && state.radioIndicator && jsx(state.radioIndicator, {})
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableSelectionCell/TableSelectionCell.js
var TableSelectionCell = React365.forwardRef((props, ref) => {
  const state = useTableSelectionCell_unstable(props, ref);
  useTableSelectionCellStyles_unstable(state);
  useCustomStyleHook("useTableSelectionCellStyles_unstable")(state);
  return renderTableSelectionCell_unstable(state);
});
TableSelectionCell.displayName = "TableSelectionCell";

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var React367 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellActions/useTableCellActions.js
var React366 = __toESM(require_react());
var useTableCellActions_unstable = (props, ref) => {
  var _props_visible;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    visible: (_props_visible = props.visible) !== null && _props_visible !== void 0 ? _props_visible : false
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/renderTableCellActions.js
var renderTableCellActions_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-table/lib/components/TableCellActions/TableCellActions.js
var TableCellActions = React367.forwardRef((props, ref) => {
  const state = useTableCellActions_unstable(props, ref);
  useTableCellActionsStyles_unstable(state);
  useCustomStyleHook("useTableCellActionsStyles_unstable")(state);
  return renderTableCellActions_unstable(state);
});
TableCellActions.displayName = "TableCellActions";

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var React370 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayout.js
var React368 = __toESM(require_react());
var tableAvatarSizeMap = {
  medium: 32,
  small: 24,
  "extra-small": 20
};
var useTableCellLayout_unstable = (props, ref) => {
  const { size: size3 } = useTableContext();
  return {
    components: {
      root: "div",
      main: "span",
      description: "span",
      content: "div",
      media: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(
      "div",
      {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        ...props
      },
      // `content` is a slot and it's type clashes with the HTMLElement `content` attribute
      [
        "content"
      ]
    ), {
      elementType: "div"
    }),
    appearance: props.appearance,
    truncate: props.truncate,
    main: slot_exports.optional(props.main, {
      renderByDefault: true,
      elementType: "span"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    description: slot_exports.optional(props.description, {
      elementType: "span"
    }),
    content: slot_exports.optional(props.content, {
      renderByDefault: !!props.description || !!props.children,
      elementType: "div"
    }),
    avatarSize: tableAvatarSizeMap[size3],
    size: size3
  };
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/renderTableCellLayout.js
var renderTableCellLayout_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.content && jsxs(state.content, {
        children: [
          state.main && jsx(state.main, {
            children: state.root.children
          }),
          state.description && jsx(state.description, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutStyles.styles.js
var tableCellLayoutClassNames = {
  root: "fui-TableCellLayout",
  media: "fui-TableCellLayout__media",
  main: "fui-TableCellLayout__main",
  description: "fui-TableCellLayout__description",
  content: "fui-TableCellLayout__content"
};
var useStyles46 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "faqewft",
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "f1izfyrr"
  },
  rootTruncate: {
    B68tc82: "f1p9o1ba"
  },
  content: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  },
  contentTruncate: {
    B68tc82: "f1p9o1ba"
  },
  media: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59"
  },
  mediaExtraSmall: {
    Be2twd7: "f4ybsrx"
  },
  mediaSmallAndMedium: {
    Be2twd7: "fe5j1ua"
  },
  mediaPrimary: {
    Be2twd7: "f1rt2boy"
  },
  mainPrimary: {
    Bhrd7zp: "fl43uef"
  },
  mainTruncate: {
    B68tc82: "f1p9o1ba",
    Huce71: "fz5stix",
    ygn44y: "f1cmbuwj"
  },
  description: {
    sj55zd: "fkfq4zb",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", [".faqewft{gap:var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1izfyrr{flex:1 1 0px;}", {
    p: -1
  }], ".f1p9o1ba{overflow-x:hidden;}", ".f1vx9l62{flex-direction:column;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fz5stix{white-space:nowrap;}", ".f1cmbuwj{text-overflow:ellipsis;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});
var useTableCellLayoutStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles46();
  const {
    truncate
  } = state;
  state.root.className = mergeClasses(tableCellLayoutClassNames.root, styles.root, truncate && styles.rootTruncate, state.root.className);
  const primary = state.appearance === "primary";
  if (state.media) {
    const mediaSizedStyles = {
      small: styles.mediaSmallAndMedium,
      medium: styles.mediaSmallAndMedium,
      "extra-small": styles.mediaExtraSmall
    };
    state.media.className = mergeClasses(tableCellLayoutClassNames.media, styles.media, mediaSizedStyles[state.size], primary && styles.mediaPrimary, state.media.className);
  }
  if (state.main) {
    state.main.className = mergeClasses(tableCellLayoutClassNames.main, truncate && styles.mainTruncate, primary && styles.mainPrimary, state.main.className);
  }
  if (state.description) {
    state.description.className = mergeClasses(tableCellLayoutClassNames.description, styles.description, state.description.className);
  }
  if (state.content) {
    state.content.className = mergeClasses(tableCellLayoutClassNames.content, styles.content, truncate && styles.contentTruncate, state.content.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/useTableCellLayoutContextValues.js
var React369 = __toESM(require_react());
function useTableCellLayoutContextValues_unstable(state) {
  const { avatarSize } = state;
  const avatar = React369.useMemo(() => ({
    size: avatarSize
  }), [
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-table/lib/components/TableCellLayout/TableCellLayout.js
var TableCellLayout = React370.forwardRef((props, ref) => {
  const state = useTableCellLayout_unstable(props, ref);
  useTableCellLayoutStyles_unstable(state);
  useCustomStyleHook("useTableCellLayoutStyles_unstable")(state);
  return renderTableCellLayout_unstable(state, useTableCellLayoutContextValues_unstable(state));
});
TableCellLayout.displayName = "TableCellLayout";

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var React372 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var React371 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/contexts/dataGridContext.js
var dataGridContext = createContext13(void 0);
var dataGridContextDefaultValue = {
  ...defaultTableState,
  subtleSelection: false,
  selectableRows: false,
  selectionAppearance: "brand",
  focusMode: "none",
  compositeRowTabsterAttribute: {}
};
var DataGridContextProvider = dataGridContext.Provider;
var useDataGridContext_unstable = (selector) => useContextSelector(dataGridContext, (ctx = dataGridContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCell.js
var useDataGridCell_unstable = (props, ref) => {
  const { focusMode = "cell" } = props;
  const columnId = useColumnIdContext();
  const tabbable = useDataGridContext_unstable((ctx) => (ctx.focusMode === "cell" || ctx.focusMode === "composite") && focusMode !== "none");
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const getTableCellProps = useDataGridContext_unstable((ctx) => {
    return ctx.columnSizing_unstable.getTableCellProps;
  });
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  return useTableCell_unstable({
    as: "div",
    role: "gridcell",
    ...focusMode === "group" && focusableGroupAttr,
    tabIndex: tabbable ? 0 : void 0,
    ...resizableColumns ? getTableCellProps(columnId) : {},
    ...props
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/renderDataGridCell.js
var renderDataGridCell_unstable = (state) => {
  return renderTableCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/useDataGridCellStyles.styles.js
var dataGridCellClassNames = {
  root: "fui-DataGridCell"
};
var useDataGridCellStyles_unstable = (state) => {
  "use no memo";
  useTableCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridCellClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridCell/DataGridCell.js
var DataGridCell = React372.forwardRef((props, ref) => {
  const state = useDataGridCell_unstable(props, ref);
  useDataGridCellStyles_unstable(state);
  useCustomStyleHook("useDataGridCellStyles_unstable")(state);
  return renderDataGridCell_unstable(state);
});
DataGridCell.displayName = "DataGridCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var React376 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var React375 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var React374 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCell.js
var React373 = __toESM(require_react());
var useDataGridSelectionCell_unstable = (props, ref) => {
  const isHeader = useIsInTableHeader();
  const rowId = useTableRowIdContext();
  const subtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
  const checked = useDataGridContext_unstable((ctx) => {
    if (isHeader && ctx.selection.selectionMode === "multiselect") {
      return ctx.selection.allRowsSelected ? true : ctx.selection.someRowsSelected ? "mixed" : false;
    }
    return ctx.selection.isRowSelected(rowId);
  });
  const toggleAllRows = useDataGridContext_unstable((ctx) => ctx.selection.toggleAllRows);
  const type = useDataGridContext_unstable((ctx) => ctx.selection.selectionMode === "multiselect" ? "checkbox" : "radio");
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (isHeader) {
      toggleAllRows(e);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  return useTableSelectionCell_unstable({
    as: "div",
    role: "gridcell",
    checked,
    type,
    invisible: isHeader && type === "radio",
    "aria-selected": checked === "mixed" ? void 0 : checked,
    subtle,
    radioIndicator: isHeader ? null : void 0,
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/renderDataGridSelectionCell.js
var renderDataGridSelectionCell_unstable = (state) => {
  return renderTableSelectionCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/useDataGridSelectionCellStyles.styles.js
var dataGridSelectionCellClassNames = {
  root: "fui-DataGridSelectionCell",
  checkboxIndicator: "fui-DataGridSelectionCell__checkboxIndicator",
  radioIndicator: "fui-DataGridSelectionCell__radioIndicator"
};
var useDataGridSelectionCellStyles_unstable = (state) => {
  "use no memo";
  useTableSelectionCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridSelectionCellClassNames.root, state.root.className);
  if (state.checkboxIndicator) {
    state.checkboxIndicator.className = mergeClasses(dataGridSelectionCellClassNames.checkboxIndicator, state.checkboxIndicator.className);
  }
  if (state.radioIndicator) {
    state.radioIndicator.className = mergeClasses(dataGridSelectionCellClassNames.radioIndicator, state.radioIndicator.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridSelectionCell/DataGridSelectionCell.js
var DataGridSelectionCell = React374.forwardRef((props, ref) => {
  const state = useDataGridSelectionCell_unstable(props, ref);
  useDataGridSelectionCellStyles_unstable(state);
  useCustomStyleHook("useDataGridSelectionCellStyles_unstable")(state);
  return renderDataGridSelectionCell_unstable(state);
});
DataGridSelectionCell.displayName = "DataGridSelectionCell";

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRow.js
var useDataGridRow_unstable = (props, ref) => {
  const rowId = useTableRowIdContext();
  const isHeader = useIsInTableHeader();
  const columnDefs = useDataGridContext_unstable((ctx) => ctx.columns);
  const selectable = useDataGridContext_unstable((ctx) => ctx.selectableRows);
  const selected = useDataGridContext_unstable((ctx) => ctx.selection.isRowSelected(rowId));
  const focusMode = useDataGridContext_unstable((ctx) => ctx.focusMode);
  const compositeRowTabsterAttribute = useDataGridContext_unstable((ctx) => ctx.compositeRowTabsterAttribute);
  const tabbable = focusMode === "row_unstable" || focusMode === "composite";
  const appearance = useDataGridContext_unstable((ctx) => {
    if (!isHeader && selectable && ctx.selection.isRowSelected(rowId)) {
      return ctx.selectionAppearance;
    }
    return "none";
  });
  const toggleRow = useDataGridContext_unstable((ctx) => ctx.selection.toggleRow);
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (selectable && !isHeader) {
      toggleRow(e, rowId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  const onKeyDown = useEventCallback((e) => {
    var _props_onKeyDown;
    if (selectable && !isHeader && e.key === Space && !isInteractiveHTMLElement(e.target)) {
      e.preventDefault();
      toggleRow(e, rowId);
    }
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e);
  });
  const baseState = useTableRow_unstable({
    appearance,
    "aria-selected": selectable ? selected : void 0,
    tabIndex: tabbable && !isHeader ? 0 : void 0,
    ...focusMode === "composite" && !isHeader && compositeRowTabsterAttribute,
    ...props,
    onClick,
    onKeyDown,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...baseState.components,
      selectionCell: DataGridSelectionCell
    },
    selectionCell: slot_exports.optional(props.selectionCell, {
      renderByDefault: selectable,
      elementType: DataGridSelectionCell
    }),
    renderCell: props.children,
    columnDefs,
    // This context value should not be used internally
    // It's intended to help power user render functions
    dataGridContextValue: useStableDataGridContextValue()
  };
};
function useStableDataGridContextValue() {
  const ref = React375.useRef(dataGridContextDefaultValue);
  useDataGridContext_unstable((ctx) => {
    ref.current = ctx;
    return null;
  });
  return ref.current;
}

// node_modules/@fluentui/react-table/lib/components/DataGridRow/renderDataGridRow.js
var renderDataGridRow_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.selectionCell && jsx(state.selectionCell, {}),
      state.columnDefs.map((columnDef) => jsx(ColumnIdContextProvider, {
        value: columnDef.columnId,
        children: state.renderCell(columnDef, state.dataGridContextValue)
      }, columnDef.columnId))
    ]
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/useDataGridRowStyles.styles.js
var dataGridRowClassNames = {
  root: "fui-DataGridRow",
  selectionCell: "fui-DataGridRow__selectionCell"
};
var useStyles47 = __styles2({
  subtleSelection: {
    Bconypa: "f1jazu75",
    ff6mpl: "fw60kww"
  }
}, {
  d: [".f1jazu75[data-fui-focus-within]:focus-within .fui-TableSelectionCell{opacity:1;}"],
  h: [".fw60kww:hover .fui-TableSelectionCell{opacity:1;}"]
});
var useDataGridRowStyles_unstable = (state) => {
  "use no memo";
  const isSubtle = useDataGridContext_unstable((ctx) => ctx.subtleSelection);
  const styles = useStyles47();
  useTableRowStyles_unstable(state);
  state.root.className = mergeClasses(dataGridRowClassNames.root, state.root.className, isSubtle && styles.subtleSelection);
  if (state.selectionCell) {
    state.selectionCell.className = mergeClasses(dataGridRowClassNames.selectionCell, state.selectionCell.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridRow/DataGridRow.js
var DataGridRow = React376.forwardRef((props, ref) => {
  const state = useDataGridRow_unstable(props, ref);
  useDataGridRowStyles_unstable(state);
  useCustomStyleHook("useDataGridRowStyles_unstable")(state);
  return renderDataGridRow_unstable(state);
});
DataGridRow.displayName = "DataGridRow";

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var React378 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBody.js
var React377 = __toESM(require_react());
var useDataGridBody_unstable = (props, ref) => {
  const { sortable } = useTableContext();
  const getRows = useDataGridContext_unstable((ctx) => ctx.getRows);
  const sort = useDataGridContext_unstable((ctx) => ctx.sort.sort);
  const rows = sortable ? sort(getRows()) : getRows();
  const baseState = useTableBody_unstable({
    ...props,
    children: null,
    as: "div"
  }, ref);
  return {
    ...baseState,
    rows,
    renderRow: props.children
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/renderDataGridBody.js
var renderDataGridBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.rows.map((row) => jsx(TableRowIdContextProvider, {
      value: row.rowId,
      children: state.renderRow(row)
    }, row.rowId))
  });
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/useDataGridBodyStyles.styles.js
var dataGridBodyClassNames = {
  root: "fui-DataGridBody"
};
var useDataGridBodyStyles_unstable = (state) => {
  "use no memo";
  useTableBodyStyles_unstable(state);
  state.root.className = mergeClasses(dataGridBodyClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridBody/DataGridBody.js
var DataGridBody = React378.forwardRef((props, ref) => {
  const state = useDataGridBody_unstable(props, ref);
  useDataGridBodyStyles_unstable(state);
  useCustomStyleHook("useDataGridBodyStyles_unstable")(state);
  return renderDataGridBody_unstable(state);
});
DataGridBody.displayName = "DataGridBody";

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var React381 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGrid.js
var React379 = __toESM(require_react());
var useDataGrid_unstable = (props, ref) => {
  const { items, columns, focusMode = "cell", selectionMode, onSortChange, onSelectionChange, defaultSortState, sortState, selectedItems, defaultSelectedItems, subtleSelection = false, selectionAppearance = "brand", getRowId, resizableColumns, columnSizingOptions, onColumnResize, containerWidthOffset, resizableColumnsOptions = {} } = props;
  const widthOffset = containerWidthOffset !== null && containerWidthOffset !== void 0 ? containerWidthOffset : selectionMode ? -CELL_WIDTH : 0;
  const gridTabsterAttribute = useArrowNavigationGroup({
    axis: "grid"
  });
  const { onTableKeyDown: onCompositeKeyDown, tableTabsterAttribute: compositeTabsterAttribute, tableRowTabsterAttribute: compositeRowTabsterAttribute } = useTableCompositeNavigation();
  var _resizableColumnsOptions_autoFitColumns;
  const tableState = useTableFeatures({
    items,
    columns,
    getRowId
  }, [
    useTableSort({
      defaultSortState,
      sortState,
      onSortChange
    }),
    useTableSelection({
      defaultSelectedItems,
      selectedItems,
      onSelectionChange,
      selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : "multiselect"
    }),
    useTableColumnSizing_unstable({
      onColumnResize,
      columnSizingOptions,
      // The selection cell is not part of the columns, therefore its width needs to be subtracted
      // from the container to make sure the columns don't overflow the table.
      containerWidthOffset: widthOffset,
      // Disables automatic resizing of columns when the container overflows.
      // This allows the sum of the columns to be larger than the container.
      autoFitColumns: (_resizableColumnsOptions_autoFitColumns = resizableColumnsOptions.autoFitColumns) !== null && _resizableColumnsOptions_autoFitColumns !== void 0 ? _resizableColumnsOptions_autoFitColumns : true
    })
  ]);
  const innerRef = React379.useRef(null);
  const { findFirstFocusable, findLastFocusable } = useFocusFinders();
  const onKeyDown = useEventCallback((e) => {
    var _props_onKeyDown;
    (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, e);
    focusMode === "composite" && onCompositeKeyDown(e);
    if (!innerRef.current || !e.ctrlKey || e.defaultPrevented) {
      return;
    }
    if (e.key === Home) {
      const firstRow = innerRef.current.querySelector('[role="row"]');
      if (firstRow) {
        var _findFirstFocusable;
        (_findFirstFocusable = findFirstFocusable(firstRow)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
      }
    }
    if (e.key === End) {
      const rows = innerRef.current.querySelectorAll('[role="row"]');
      if (rows.length) {
        var _findLastFocusable;
        const lastRow = rows.item(rows.length - 1);
        (_findLastFocusable = findLastFocusable(lastRow)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      }
    }
  });
  const baseTableState = useTable_unstable({
    role: "grid",
    as: "div",
    noNativeElements: true,
    ...focusMode === "cell" && gridTabsterAttribute,
    ...focusMode === "composite" && compositeTabsterAttribute,
    ...props,
    onKeyDown,
    ...resizableColumns ? tableState.columnSizing_unstable.getTableProps(props) : {}
  }, useMergedRefs(ref, tableState.tableRef, innerRef));
  return {
    ...baseTableState,
    focusMode,
    tableState,
    selectableRows: !!selectionMode,
    subtleSelection,
    selectionAppearance,
    resizableColumns,
    compositeRowTabsterAttribute
  };
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/renderDataGrid.js
var React380 = __toESM(require_react());
var renderDataGrid_unstable = (state, contextValues) => {
  return React380.createElement(DataGridContextProvider, {
    value: contextValues.dataGrid
  }, renderTable_unstable(state, contextValues));
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridStyles.styles.js
var dataGridClassNames = {
  root: "fui-DataGrid"
};
var useDataGridStyles_unstable = (state) => {
  "use no memo";
  useTableStyles_unstable(state);
  state.root.className = mergeClasses(dataGridClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGrid/useDataGridContextValues.js
function useDataGridContextValues_unstable(state) {
  const tableContextValues = useTableContextValues_unstable(state);
  const { tableState, focusMode, selectableRows, subtleSelection, selectionAppearance, resizableColumns, compositeRowTabsterAttribute } = state;
  return {
    ...tableContextValues,
    dataGrid: {
      ...tableState,
      focusMode,
      selectableRows,
      subtleSelection,
      selectionAppearance,
      resizableColumns,
      compositeRowTabsterAttribute
    }
  };
}

// node_modules/@fluentui/react-table/lib/components/DataGrid/DataGrid.js
var DataGrid = React381.forwardRef((props, ref) => {
  const state = useDataGrid_unstable(props, ref);
  useDataGridStyles_unstable(state);
  useCustomStyleHook("useDataGridStyles_unstable")(state);
  return renderDataGrid_unstable(state, useDataGridContextValues_unstable(state));
});
DataGrid.displayName = "DataGrid";

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var React383 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeader.js
var React382 = __toESM(require_react());
var useDataGridHeader_unstable = (props, ref) => {
  return useTableHeader_unstable({
    ...props,
    as: "div"
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/renderDataGridHeader.js
var renderDataGridHeader_unstable = (state) => {
  return renderTableHeader_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/useDataGridHeaderStyles.styles.js
var dataGridHeaderClassNames = {
  root: "fui-DataGridHeader"
};
var useDataGridHeaderStyles_unstable = (state) => {
  "use no memo";
  useTableHeaderStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeader/DataGridHeader.js
var DataGridHeader = React383.forwardRef((props, ref) => {
  const state = useDataGridHeader_unstable(props, ref);
  useDataGridHeaderStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderStyles_unstable")(state);
  return renderDataGridHeader_unstable(state);
});
DataGridHeader.displayName = "DataGridHeader";

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var React385 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var React384 = __toESM(require_react());

// node_modules/@fluentui/react-table/lib/utils/isColumnSortable.js
function isColumnSortable(column) {
  return column.compare.length > 0;
}

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCell.js
var useDataGridHeaderCell_unstable = (props, ref) => {
  const columnId = useColumnIdContext();
  const { sortable: gridSortable } = useTableContext();
  const toggleColumnSort = useDataGridContext_unstable((ctx) => ctx.sort.toggleColumnSort);
  const sortable = useDataGridContext_unstable((ctx) => {
    const columnSortable = !!ctx.columns.find((c) => c.columnId === columnId && isColumnSortable(c));
    if (!gridSortable) {
      return false;
    }
    return columnSortable;
  });
  const sortDirection = useDataGridContext_unstable((ctx) => sortable ? ctx.sort.getSortDirection(columnId) : void 0);
  const resizableColumns = useDataGridContext_unstable((ctx) => ctx.resizableColumns);
  const getTableHeaderCellProps = useDataGridContext_unstable((ctx) => {
    return ctx.columnSizing_unstable.getTableHeaderCellProps;
  });
  const { focusMode = sortable ? "none" : "cell" } = props;
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus"
  });
  const onClick = useEventCallback((e) => {
    var _props_onClick;
    if (sortable) {
      toggleColumnSort(e, columnId);
    }
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, e);
  });
  return useTableHeaderCell_unstable({
    sortable,
    sortDirection,
    as: "div",
    tabIndex: focusMode !== "none" ? 0 : void 0,
    ...focusMode === "group" && focusableGroupAttr,
    ...resizableColumns ? getTableHeaderCellProps(columnId) : {},
    ...props,
    onClick
  }, ref);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/renderDataGridHeaderCell.js
var renderDataGridHeaderCell_unstable = (state) => {
  return renderTableHeaderCell_unstable(state);
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/useDataGridHeaderCellStyles.styles.js
var dataGridHeaderCellClassNames = {
  root: "fui-DataGridHeaderCell",
  button: "fui-DataGridHeaderCell__button",
  sortIcon: "fui-DataGridHeaderCell__sortIcon",
  aside: "fui-DataGridHeaderCell__aside"
};
var useDataGridHeaderCellStyles_unstable = (state) => {
  "use no memo";
  useTableHeaderCellStyles_unstable(state);
  state.root.className = mergeClasses(dataGridHeaderCellClassNames.root, state.root.className);
  if (state.button) {
    state.button.className = mergeClasses(dataGridHeaderCellClassNames.button, state.button.className);
  }
  if (state.sortIcon) {
    state.sortIcon.className = mergeClasses(dataGridHeaderCellClassNames.sortIcon, state.sortIcon.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(dataGridHeaderCellClassNames.aside, state.aside.className);
  }
  return state;
};

// node_modules/@fluentui/react-table/lib/components/DataGridHeaderCell/DataGridHeaderCell.js
var DataGridHeaderCell = React385.forwardRef((props, ref) => {
  const state = useDataGridHeaderCell_unstable(props, ref);
  useDataGridHeaderCellStyles_unstable(state);
  useCustomStyleHook("useDataGridHeaderCellStyles_unstable")(state);
  return renderDataGridHeaderCell_unstable(state);
});
DataGridHeaderCell.displayName = "DataGridHeaderCell";

// node_modules/@fluentui/react-card/lib/components/Card/Card.js
var React390 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/Card/useCard.js
var React388 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/Card/useCardSelectable.js
var React386 = __toESM(require_react());
var useCardSelectable = (props, { referenceLabel, referenceId }, cardRef) => {
  const { checkbox = {}, onSelectionChange, floatingAction, onClick, onKeyDown, disabled } = props;
  const { findAllFocusable } = useFocusFinders();
  const checkboxRef = React386.useRef(null);
  const [selected, setSelected] = useControllableState({
    state: props.selected,
    defaultState: props.defaultSelected,
    initialState: false
  });
  const selectable = [
    props.selected,
    props.defaultSelected,
    onSelectionChange
  ].some((prop) => typeof prop !== "undefined");
  const [selectFocused, setSelectFocused] = React386.useState(false);
  const shouldRestrictTriggerAction = React386.useCallback((event) => {
    if (!cardRef.current) {
      return false;
    }
    const focusableElements = findAllFocusable(cardRef.current);
    const target = event.target;
    const isElementInFocusableGroup = focusableElements.some((element) => element.contains(target));
    const isCheckboxSlot = (checkboxRef === null || checkboxRef === void 0 ? void 0 : checkboxRef.current) === target;
    return isElementInFocusableGroup && !isCheckboxSlot;
  }, [
    cardRef,
    findAllFocusable
  ]);
  const onChangeHandler = React386.useCallback((event) => {
    if (disabled || shouldRestrictTriggerAction(event)) {
      return;
    }
    const newCheckedValue = !selected;
    setSelected(newCheckedValue);
    if (onSelectionChange) {
      onSelectionChange(event, {
        selected: newCheckedValue
      });
    }
  }, [
    disabled,
    onSelectionChange,
    selected,
    setSelected,
    shouldRestrictTriggerAction
  ]);
  const onKeyDownHandler = React386.useCallback((event) => {
    if ([
      Enter
    ].includes(event.key)) {
      event.preventDefault();
      onChangeHandler(event);
    }
  }, [
    onChangeHandler
  ]);
  const checkboxSlot = React386.useMemo(() => {
    if (!selectable || floatingAction) {
      return;
    }
    const selectableCheckboxProps = {};
    if (referenceId) {
      selectableCheckboxProps["aria-labelledby"] = referenceId;
    } else if (referenceLabel) {
      selectableCheckboxProps["aria-label"] = referenceLabel;
    }
    return slot_exports.optional(checkbox, {
      defaultProps: {
        ref: checkboxRef,
        type: "checkbox",
        checked: selected,
        disabled,
        onChange: (event) => onChangeHandler(event),
        onFocus: () => setSelectFocused(true),
        onBlur: () => setSelectFocused(false),
        ...selectableCheckboxProps
      },
      elementType: "input"
    });
  }, [
    checkbox,
    disabled,
    floatingAction,
    selected,
    selectable,
    onChangeHandler,
    referenceId,
    referenceLabel
  ]);
  const floatingActionSlot = React386.useMemo(() => {
    if (!floatingAction) {
      return;
    }
    return slot_exports.optional(floatingAction, {
      defaultProps: {
        ref: checkboxRef
      },
      elementType: "div"
    });
  }, [
    floatingAction
  ]);
  const selectableCardProps = React386.useMemo(() => {
    if (!selectable) {
      return null;
    }
    return {
      onClick: mergeCallbacks(onClick, onChangeHandler),
      onKeyDown: mergeCallbacks(onKeyDown, onKeyDownHandler)
    };
  }, [
    selectable,
    onChangeHandler,
    onClick,
    onKeyDown,
    onKeyDownHandler
  ]);
  return {
    selected,
    selectable,
    selectFocused,
    selectableCardProps,
    checkboxSlot,
    floatingActionSlot
  };
};

// node_modules/@fluentui/react-card/lib/components/Card/CardContext.js
var React387 = __toESM(require_react());
var cardContext = React387.createContext(void 0);
var cardContextDefaultValue = {
  selectableA11yProps: {
    referenceId: void 0,
    setReferenceId() {
    },
    referenceLabel: void 0,
    setReferenceLabel() {
    }
  }
};
var CardProvider = cardContext.Provider;
var useCardContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React387.useContext(cardContext)) !== null && _React_useContext !== void 0 ? _React_useContext : cardContextDefaultValue;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCard.js
var focusMap = {
  off: void 0,
  "no-tab": "limited-trap-focus",
  "tab-exit": "limited",
  "tab-only": "unlimited"
};
var useCardInteractive = ({ focusMode: initialFocusMode, disabled = false, ...props }) => {
  const interactive = [
    "onClick",
    "onDoubleClick",
    "onMouseUp",
    "onMouseDown",
    "onPointerUp",
    "onPointerDown",
    "onTouchStart",
    "onTouchEnd",
    "onDragStart",
    "onDragEnd"
  ].some((prop) => props[prop]);
  const focusMode = initialFocusMode !== null && initialFocusMode !== void 0 ? initialFocusMode : interactive ? "no-tab" : "off";
  const groupperAttrs = useFocusableGroup({
    tabBehavior: focusMap[focusMode]
  });
  if (disabled) {
    return {
      interactive: false,
      focusAttributes: null
    };
  }
  if (focusMode === "off") {
    return {
      interactive,
      focusAttributes: null
    };
  }
  return {
    interactive,
    focusAttributes: {
      ...groupperAttrs,
      tabIndex: 0
    }
  };
};
var useCard_unstable = (props, ref) => {
  const { appearance = "filled", orientation = "vertical", size: size3 = "medium", disabled = false, ...restProps } = props;
  const [referenceId, setReferenceId] = React388.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
  const [referenceLabel, setReferenceLabel] = React388.useState(cardContextDefaultValue.selectableA11yProps.referenceId);
  const cardBaseRef = useFocusWithin();
  const { selectable, selected, selectableCardProps, selectFocused, checkboxSlot, floatingActionSlot } = useCardSelectable(props, {
    referenceId,
    referenceLabel
  }, cardBaseRef);
  const cardRef = useMergedRefs(cardBaseRef, ref);
  const { interactive, focusAttributes } = useCardInteractive(props);
  let cardRootProps = {
    ...!selectable ? focusAttributes : null,
    ...restProps,
    ...selectableCardProps
  };
  if (disabled) {
    cardRootProps = {
      ...restProps,
      "aria-disabled": true,
      onClick: void 0
    };
  }
  return {
    appearance,
    orientation,
    size: size3,
    interactive,
    selectable,
    selectFocused,
    selected,
    disabled,
    selectableA11yProps: {
      setReferenceId,
      referenceId,
      referenceLabel,
      setReferenceLabel
    },
    components: {
      root: "div",
      floatingAction: "div",
      checkbox: "input"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: cardRef,
      role: "group",
      ...cardRootProps
    }), {
      elementType: "div"
    }),
    floatingAction: floatingActionSlot,
    checkbox: checkboxSlot
  };
};

// node_modules/@fluentui/react-card/lib/components/Card/renderCard.js
var renderCard_unstable = (state, cardContextValue) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsxs(CardProvider, {
      value: cardContextValue,
      children: [
        state.checkbox ? jsx(state.checkbox, {}) : null,
        state.floatingAction ? jsx(state.floatingAction, {}) : null,
        state.root.children
      ]
    })
  });
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
var React389 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreviewStyles.styles.js
var cardPreviewClassNames = {
  root: "fui-CardPreview",
  logo: "fui-CardPreview__logo"
};
var useStyles48 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Byfpedg: "fgourly",
    Btj6oj6: "f1vui7lx",
    B1m4t4s: "fda5zwx"
  },
  logo: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1gcvs1y",
    oyh7mz: ["f1t6tvco", "ffrfxm3"],
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".fgourly>:not(.fui-CardPreview__logo){display:block;}", ".f1vui7lx>:not(.fui-CardPreview__logo){height:100%;}", ".fda5zwx>:not(.fui-CardPreview__logo){width:100%;}", ".f1euv43f{position:absolute;}", ".f1gcvs1y{bottom:12px;}", ".f1t6tvco{left:12px;}", ".ffrfxm3{right:12px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useCardPreviewStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles48();
  state.root.className = mergeClasses(cardPreviewClassNames.root, styles.root, state.root.className);
  if (state.logo) {
    state.logo.className = mergeClasses(cardPreviewClassNames.logo, styles.logo, state.logo.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeaderStyles.styles.js
var cardHeaderClassNames = {
  root: "fui-CardHeader",
  image: "fui-CardHeader__image",
  header: "fui-CardHeader__header",
  description: "fui-CardHeader__description",
  action: "fui-CardHeader__action"
};
var cardHeaderCSSVars = {
  cardHeaderGapVar: "--fui-CardHeader--gap"
};
var useStyles49 = __styles2({
  root: {
    Bkc6ea2: "fkufhic",
    Bt984gj: "f122n59"
  },
  image: {
    mc9l5x: "ftuwxu6",
    t21cq0: ["fql5097", "f6yss9k"]
  },
  header: {
    mc9l5x: "f22iagw"
  },
  description: {
    mc9l5x: "f22iagw"
  },
  action: {
    Frg6f3: ["f6yss9k", "fql5097"],
    rjrqlh: "fs9eatd",
    Boue1pl: ["fxoo9ru", "f1g0ekvh"],
    Bhz1vi0: "f1m6zfxz",
    etxrgc: ["f1g0ekvh", "fxoo9ru"],
    Bdua9ef: "f1sret3r",
    cbfxhg: "fs4gbcv"
  }
}, {
  d: [".fkufhic{--fui-CardHeader--gap:12px;}", ".f122n59{align-items:center;}", ".ftuwxu6{display:inline-flex;}", ".fql5097{margin-right:var(--fui-CardHeader--gap);}", ".f6yss9k{margin-left:var(--fui-CardHeader--gap);}", ".f22iagw{display:flex;}"],
  m: [["@media (forced-colors: active){.fs9eatd .fui-Button,.fs9eatd .fui-Link{border-top-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1g0ekvh .fui-Button,.f1g0ekvh .fui-Link{border-left-color:currentColor;}.fxoo9ru .fui-Button,.fxoo9ru .fui-Link{border-right-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1m6zfxz .fui-Button,.f1m6zfxz .fui-Link{border-bottom-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1sret3r .fui-Button,.f1sret3r .fui-Link{color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fs4gbcv .fui-Button,.fs4gbcv .fui-Link{outline-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useStylesGrid = __styles2({
  root: {
    mc9l5x: "f13qh94s",
    t4k1zu: "f8a668j"
  },
  image: {
    Br312pm: "fwpfdsa",
    Ijaq50: "fldnz9j"
  },
  header: {
    Br312pm: "fd46tj4",
    Ijaq50: "f16hsg94"
  },
  description: {
    Br312pm: "fd46tj4",
    Ijaq50: "faunodf"
  },
  action: {
    Br312pm: "fis13di",
    Ijaq50: "fldnz9j"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".f8a668j{grid-auto-columns:min-content 1fr min-content;}", ".fwpfdsa{grid-column-start:1;}", ".fldnz9j{grid-row-start:span 2;}", ".fd46tj4{grid-column-start:2;}", ".f16hsg94{grid-row-start:1;}", ".faunodf{grid-row-start:2;}", ".fis13di{grid-column-start:3;}"]
});
var useStylesFlex = __styles2({
  root: {
    mc9l5x: "f22iagw"
  },
  header: {
    Bh6795r: "fqerorx"
  },
  image: {},
  description: {},
  action: {}
}, {
  d: [".f22iagw{display:flex;}", ".fqerorx{flex-grow:1;}"]
});
var useCardHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles49();
  const stylesGrid = useStylesGrid();
  const stylesFlex = useStylesFlex();
  const boxModelStyles = state.description ? stylesGrid : stylesFlex;
  const getSlotStyles = (slotName) => {
    var _state_slotName;
    return mergeClasses(cardHeaderClassNames[slotName], styles[slotName], boxModelStyles[slotName], (_state_slotName = state[slotName]) === null || _state_slotName === void 0 ? void 0 : _state_slotName.className);
  };
  state.root.className = getSlotStyles("root");
  if (state.image) {
    state.image.className = getSlotStyles("image");
  }
  if (state.header) {
    state.header.className = getSlotStyles("header");
  }
  if (state.description) {
    state.description.className = getSlotStyles("description");
  }
  if (state.action) {
    state.action.className = getSlotStyles("action");
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooterStyles.styles.js
var cardFooterClassNames = {
  root: "fui-CardFooter",
  action: "fui-CardFooter__action"
};
var useStyles50 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fsbu5mz"
  },
  action: {
    Frg6f3: ["fcgxt0o", "f1ujusj6"],
    rjrqlh: "fs9eatd",
    Boue1pl: ["fxoo9ru", "f1g0ekvh"],
    Bhz1vi0: "f1m6zfxz",
    etxrgc: ["f1g0ekvh", "fxoo9ru"],
    Bdua9ef: "f1sret3r",
    cbfxhg: "fs4gbcv"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", [".fsbu5mz{gap:12px;}", {
    p: -1
  }], ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}"],
  m: [["@media (forced-colors: active){.fs9eatd .fui-Button,.fs9eatd .fui-Link{border-top-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1g0ekvh .fui-Button,.f1g0ekvh .fui-Link{border-left-color:currentColor;}.fxoo9ru .fui-Button,.fxoo9ru .fui-Link{border-right-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1m6zfxz .fui-Button,.f1m6zfxz .fui-Link{border-bottom-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1sret3r .fui-Button,.f1sret3r .fui-Link{color:currentColor;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fs4gbcv .fui-Button,.fs4gbcv .fui-Link{outline-color:currentColor;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useCardFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles50();
  state.root.className = mergeClasses(cardFooterClassNames.root, styles.root, state.root.className);
  if (state.action) {
    state.action.className = mergeClasses(cardFooterClassNames.action, styles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardStyles.styles.js
var cardClassNames = {
  root: "fui-Card",
  floatingAction: "fui-Card__floatingAction",
  checkbox: "fui-Card__checkbox"
};
var cardCSSVars = {
  cardSizeVar: "--fui-Card--size",
  cardBorderRadiusVar: "--fui-Card--border-radius"
};
var focusOutlineStyle = {
  outlineRadius: `var(${cardCSSVars.cardBorderRadiusVar})`,
  outlineWidth: tokens.strokeWidthThick,
  outlineOffset: "-2px"
};
var useCardResetStyles = __resetStyles("rfxo2k2", "rgle7w9", [".rfxo2k2{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rfxo2k2::after{position:absolute;top:0;left:0;right:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rfxo2k2>.fui-CardHeader,.rfxo2k2>.fui-CardFooter{flex-shrink:0;}", ".rgle7w9{overflow:hidden;border-radius:var(--fui-Card--border-radius);padding:var(--fui-Card--size);gap:var(--fui-Card--size);display:flex;position:relative;box-sizing:border-box;color:var(--colorNeutralForeground1);}", '.rgle7w9::after{position:absolute;top:0;right:0;left:0;bottom:0;content:"";pointer-events:none;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:var(--strokeWidthThin);border-left-width:var(--strokeWidthThin);border-bottom-width:var(--strokeWidthThin);border-right-width:var(--strokeWidthThin);border-radius:var(--fui-Card--border-radius);}', ".rgle7w9>.fui-CardHeader,.rgle7w9>.fui-CardFooter{flex-shrink:0;}"]);
var disabledStyles = {
  cursor: "not-allowed",
  userSelect: "none",
  color: tokens.colorNeutralForegroundDisabled,
  backgroundColor: tokens.colorNeutralBackgroundDisabled,
  boxShadow: tokens.shadow2,
  ...shorthands.borderColor(tokens.colorNeutralStrokeDisabled),
  "::before": {
    content: '""',
    position: "absolute",
    inset: 0,
    zIndex: `calc(${tokens.zIndexContent} + 1)`
  },
  "::after": {
    ...shorthands.borderColor(tokens.colorNeutralStrokeDisabled)
  }
};
var useCardStyles = __styles2({
  focused: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bqhya38: "f1j6vpng",
    Bwxa6fj: ["f1pniga2", "f1ffjurs"],
    Bdhvstf: "f987i1v",
    B7zbvrb: ["f1ffjurs", "f1pniga2"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "fpqizxz",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "fnd8nzh",
    J0r882: "f15fr7a0",
    Bule8hv: ["fwsq40z", "fy0y4wt"],
    Bjwuhne: "f34ld9f",
    Ghsupd: ["fy0y4wt", "fwsq40z"]
  },
  selectableFocused: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    h6p2u: "f1ufm4qn",
    I6qiy5: ["f1qnwcb4", "fgrk5zm"],
    yzno9d: "fi52z01",
    By0wis0: ["fgrk5zm", "f1qnwcb4"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "f1i978nd",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1nh8hsq",
    B2pnrqr: "f1amxum7",
    B29w5g4: ["f1cec8w7", "f554mv0"],
    Bhhzhcn: "f1sj6kbr",
    Bec0n69: ["f554mv0", "f1cec8w7"]
  },
  orientationHorizontal: {
    Beiy3e4: "f1063pyq",
    Bt984gj: "f122n59",
    Binpb3b: "ftrw7vg",
    qrt8p2: "f18opajm",
    k6ws3r: ["f13002it", "fqo182t"],
    Btcwela: ["f18yna97", "f1kd6wh7"],
    Fer9m8: "f4i4759"
  },
  orientationVertical: {
    Beiy3e4: "f1vx9l62",
    B5nvv7i: ["f14k419y", "f1fgo9fz"],
    Baxg94k: ["f1fgo9fz", "f14k419y"],
    tn21ii: "fvqmfsm",
    B0ud6bj: "f3am6yf",
    Bgdo4j: "f1r5wgso"
  },
  sizeSmall: {
    B7balbw: "f1pi9uxy",
    B1h88n7: "f1h1zgly"
  },
  sizeMedium: {
    B7balbw: "frsmuga",
    B1h88n7: "fuldkky"
  },
  sizeLarge: {
    B7balbw: "f1qua4xo",
    B1h88n7: "fimkt6v"
  },
  interactive: {
    rhjd8f: "f1epqm3e"
  },
  filled: {
    De3pzq: "fxugw4r",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  filledInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "fxugw4r",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1knas48",
    Bvxd0ez: "f1m145df",
    ecr2s2: "fb40n2d"
  },
  filledInteractiveSelected: {
    De3pzq: "f1nfm20t",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "f1kz6goq"
  },
  filledAlternative: {
    De3pzq: "f1dmdbja",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  filledAlternativeInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "f1dmdbja",
    E5pizo: "f1whvlc6",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "fnwyq0v",
    Jwef8y: "f1uvynv3",
    Bvxd0ez: "f1m145df",
    ecr2s2: "f1yhgkbh"
  },
  filledAlternativeInteractiveSelected: {
    De3pzq: "fjxa0vh",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "f1luvkty",
    Jwef8y: "fehi0vp"
  },
  outline: {
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"]
  },
  outlineInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    B0n5ga8: "ft83z1f",
    s924m2: ["f1g4150c", "f192dr6e"],
    B1q35kw: "f1qnawh6",
    Gp14am: ["f192dr6e", "f1g4150c"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "fjxutwb",
    Be0v6ae: "f1llr77y",
    B5kxglz: ["fzk0khw", "fjj8tog"],
    B3pwyw6: "fb1u8ub",
    Bymgtzf: ["fjj8tog", "fzk0khw"],
    ecr2s2: "fophhak",
    dmfk: "f1uohb70",
    B4ofi8: ["f1jm7v1n", "f1bus3rq"],
    jgq6uv: "f1fbu7rr",
    Baxewws: ["f1bus3rq", "f1jm7v1n"]
  },
  outlineInteractiveSelected: {
    De3pzq: "f1q9pm1r",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "fg59vm4"
  },
  outlineDisabled: {
    De3pzq: "f1c21dwh",
    E5pizo: "f1couhl3",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    ezxybo: "f1ls5moo",
    wc7uws: "f1qiza15",
    B0n5ga8: "f13dj02",
    s924m2: ["f9wngki", "f17v59j0"],
    B1q35kw: "f1vxzwsp",
    Gp14am: ["f17v59j0", "f9wngki"]
  },
  subtle: {
    De3pzq: "fhovq9v",
    E5pizo: "f1couhl3",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"]
  },
  subtleInteractive: {
    Bceei9c: "f1k6fduh",
    De3pzq: "fhovq9v",
    E5pizo: "f1couhl3",
    B0n5ga8: "f16gxe2i",
    s924m2: ["fpgykix", "fzybk4o"],
    B1q35kw: "f1osi826",
    Gp14am: ["fzybk4o", "fpgykix"],
    Bi91k9c: "feu1g3u",
    Jwef8y: "f1t94bn6",
    ecr2s2: "f1wfn5kd"
  },
  subtleInteractiveSelected: {
    De3pzq: "fq5gl1p",
    B0n5ga8: "f16eln5f",
    s924m2: ["fa2okxs", "fg4zq3l"],
    B1q35kw: "ff6932p",
    Gp14am: ["fg4zq3l", "fa2okxs"],
    Bi91k9c: "fx9teim",
    Jwef8y: "f1uqaxdt"
  },
  highContrastSelected: {
    B8gzw0y: "f1h3a8gf",
    By8wz76: "f1nz3ub2",
    B7iucu3: "fqc85l4",
    Boo9lyk: "f1ucc5z8",
    sga51p: "fyj59f4",
    qj1yg9: ["f19v95gn", "f1n69f6i"],
    B8acmzm: "f16q7dot",
    Gezqo6: ["f1n69f6i", "f19v95gn"]
  },
  highContrastInteractive: {
    waf3gn: "f1quqgnd",
    B96h8j5: "f193utb4",
    Bpd3jnq: "f1io67iv",
    uhbujs: "f3n01jk",
    sga51p: "fyj59f4",
    qj1yg9: ["f19v95gn", "f1n69f6i"],
    B8acmzm: "f16q7dot",
    Gezqo6: ["f1n69f6i", "f19v95gn"]
  },
  select: {
    qhf8xq: "f1euv43f",
    Bhzewxz: "fqclxi7",
    j35jbq: ["fiv86kb", "f36uhnt"],
    Bj3rh1h: "fom9my7"
  },
  hiddenCheckbox: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    a9b677: "frkrog8",
    Bqenvij: "f1mpe4l3",
    qhf8xq: "f1euv43f",
    Bh84pgu: "fmf1zke",
    Bgl5zvf: "f1wch0ki",
    Huce71: "fz5stix"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    famaaq: "f1xqy1su",
    sj55zd: "f1s2aq7o",
    De3pzq: "f1bg9a2p",
    E5pizo: "fyed02w",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Ftih45: "f1wl9k8s",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f13vvzas",
    Ehzi8l: "f198lalb",
    B0n5ga8: "f13dj02",
    s924m2: ["f9wngki", "f17v59j0"],
    B1q35kw: "f1vxzwsp",
    Gp14am: ["f17v59j0", "f9wngki"],
    Bikrtoi: "f11og98d",
    G8qf51: "f1rg3h4v",
    Brxh4y7: "fbm2y3b",
    ezxybo: "f4yodeu",
    wc7uws: "fcwfbwp",
    gp3uxg: "f1repx37",
    Fohawp: ["f1ybi8ct", "f1h4eg6q"],
    Bxulg6k: "f18mejnb",
    vcjq4m: ["f1h4eg6q", "f1ybi8ct"],
    Bsqkqe9: "f1nift3m",
    fskg1g: "f1wu3i8x",
    iwiei9: 0,
    Effecx: 0,
    Bkt1b9m: 0,
    jfmxvr: 0,
    orauir: "f6v4vfa",
    B2yd9ot: "folrdqs",
    Fn9tzk: "f168z5yf",
    Bv0wker: ["fpor7gj", "fzextn6"],
    Bp2dl5b: "f1yaw79v",
    pzn0iz: ["fzextn6", "fpor7gj"]
  }
}, {
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  d: [".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".fpqizxz[data-fui-focus-visible]::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".fnd8nzh[data-fui-focus-visible]::after{border-radius:var(--fui-Card--border-radius);}", {
    p: -1
  }], ".f15fr7a0[data-fui-focus-visible]::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".fwsq40z[data-fui-focus-visible]::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".fy0y4wt[data-fui-focus-visible]::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f34ld9f[data-fui-focus-visible]::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1nh8hsq[data-fui-focus-within]:focus-within::after{border-radius:var(--fui-Card--border-radius);}", {
    p: -1
  }], ".f1amxum7[data-fui-focus-within]:focus-within::after{top:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1cec8w7[data-fui-focus-within]:focus-within::after{right:calc(0px - var(--strokeWidthThick) - -2px);}", ".f554mv0[data-fui-focus-within]:focus-within::after{left:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1sj6kbr[data-fui-focus-within]:focus-within::after{bottom:calc(0px - var(--strokeWidthThick) - -2px);}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".ftrw7vg>.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", ".f18opajm>.fui-CardPreview{margin-bottom:calc(var(--fui-Card--size) * -1);}", '.f13002it>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', '.fqo182t>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f18yna97>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-right:calc(var(--fui-Card--size) * -1);}', '.f1kd6wh7>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-left:calc(var(--fui-Card--size) * -1);}', ".f4i4759>.fui-CardHeader:last-of-type,.f4i4759>.fui-CardFooter:last-of-type{flex-grow:1;}", ".f1vx9l62{flex-direction:column;}", ".f14k419y>.fui-CardPreview{margin-left:calc(var(--fui-Card--size) * -1);}", ".f1fgo9fz>.fui-CardPreview{margin-right:calc(var(--fui-Card--size) * -1);}", '.fvqmfsm>:not([aria-hidden="true"]).fui-CardPreview:first-of-type{margin-top:calc(var(--fui-Card--size) * -1);}', ".f3am6yf>.fui-Card__floatingAction+.fui-CardPreview{margin-top:calc(var(--fui-Card--size) * -1);}", '.f1r5wgso>:not([aria-hidden="true"]).fui-CardPreview:last-of-type{margin-bottom:calc(var(--fui-Card--size) * -1);}', ".f1pi9uxy{--fui-Card--size:8px;}", ".f1h1zgly{--fui-Card--border-radius:var(--borderRadiusSmall);}", ".frsmuga{--fui-Card--size:12px;}", ".fuldkky{--fui-Card--border-radius:var(--borderRadiusMedium);}", ".f1qua4xo{--fui-Card--size:16px;}", ".fimkt6v{--fui-Card--border-radius:var(--borderRadiusLarge);}", ".f1epqm3e .fui-Text{color:currentColor;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1whvlc6{box-shadow:var(--shadow4);}", ".f16gxe2i::after{border-top-color:var(--colorTransparentStroke);}", ".fpgykix::after{border-right-color:var(--colorTransparentStroke);}", ".fzybk4o::after{border-left-color:var(--colorTransparentStroke);}", ".f1osi826::after{border-bottom-color:var(--colorTransparentStroke);}", ".f1k6fduh{cursor:pointer;}", ".f1nfm20t{background-color:var(--colorNeutralBackground1Selected);}", ".f16eln5f::after{border-top-color:var(--colorNeutralStroke1Selected);}", ".fa2okxs::after{border-right-color:var(--colorNeutralStroke1Selected);}", ".fg4zq3l::after{border-left-color:var(--colorNeutralStroke1Selected);}", ".ff6932p::after{border-bottom-color:var(--colorNeutralStroke1Selected);}", ".f1dmdbja{background-color:var(--colorNeutralBackground2);}", ".fjxa0vh{background-color:var(--colorNeutralBackground2Selected);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1couhl3{box-shadow:none;}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f13dj02::after{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f9wngki::after{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f17v59j0::after{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1vxzwsp::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fq5gl1p{background-color:var(--colorSubtleBackgroundSelected);}", ".f1euv43f{position:absolute;}", ".fqclxi7{top:4px;}", ".fiv86kb{right:4px;}", ".f36uhnt{left:4px;}", ".fom9my7{z-index:var(--zIndexContent, 1);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1mpe4l3{height:1px;}", ".fmf1zke{clip:rect(0 0 0 0);}", ".f1wch0ki{clip-path:inset(50%);}", ".fz5stix{white-space:nowrap;}", ".fdrzuqr{cursor:not-allowed;}", ".f1xqy1su{-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".fyed02w{box-shadow:var(--shadow2);}", '.f1wl9k8s::before{content:"";}', ".f1j7ml58::before{position:absolute;}", [".f13vvzas::before{inset:0;}", {
    p: -1
  }], ".f198lalb::before{z-index:calc(var(--zIndexContent, 1) + 1);}"],
  m: [["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ucc5z8 .fui-CardPreview,.f1ucc5z8 .fui-CardFooter{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fyj59f4::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f19v95gn::after{border-right-color:Highlight;}.f1n69f6i::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16q7dot::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1quqgnd:hover,.f1quqgnd :active{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f193utb4:hover,.f193utb4 :active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1io67iv:hover,.f1io67iv :active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3n01jk:hover .fui-CardPreview,.f3n01jk :active .fui-CardPreview,.f3n01jk:hover .fui-CardFooter,.f3n01jk :active .fui-CardFooter{forced-color-adjust:auto;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".feu1g3u:hover{color:var(--colorNeutralForeground1Hover);}", ".f1knas48:hover{background-color:var(--colorNeutralBackground1Hover);}", ".f1m145df:hover{box-shadow:var(--shadow8);}", ".fx9teim:hover{color:var(--colorNeutralForeground1Selected);}", ".f1kz6goq:hover{background-color:var(--colorNeutralBackground1Selected);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1uvynv3:hover{background-color:var(--colorNeutralBackground2Hover);}", ".f1luvkty:hover{color:var(--colorNeutralForeground2Selected);}", ".fehi0vp:hover{background-color:var(--colorNeutralBackground2Selected);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f1llr77y:hover::after{border-top-color:var(--colorNeutralStroke1Hover);}", ".fzk0khw:hover::after{border-right-color:var(--colorNeutralStroke1Hover);}", ".fjj8tog:hover::after{border-left-color:var(--colorNeutralStroke1Hover);}", ".fb1u8ub:hover::after{border-bottom-color:var(--colorNeutralStroke1Hover);}", ".fg59vm4:hover{background-color:var(--colorTransparentBackgroundSelected);}", ".f1ls5moo:hover,.f1ls5moo:active{background-color:var(--colorTransparentBackground);}", ".f1qiza15:hover,.f1qiza15:active{box-shadow:none;}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1uqaxdt:hover{background-color:var(--colorSubtleBackgroundSelected);}", ".f11og98d:hover,.f11og98d:active{cursor:not-allowed;}", ".f1rg3h4v:hover,.f1rg3h4v:active{-webkit-user-select:none;-moz-user-select:none;user-select:none;}", ".fbm2y3b:hover,.fbm2y3b:active{color:var(--colorNeutralForegroundDisabled);}", ".f4yodeu:hover,.f4yodeu:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".fcwfbwp:hover,.fcwfbwp:active{box-shadow:var(--shadow2);}", ".f1repx37:hover,.f1repx37:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ybi8ct:hover,.f1ybi8ct:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1h4eg6q:hover,.f1h4eg6q:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f18mejnb:hover,.f18mejnb:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", '.f1nift3m:hover::before,.f1nift3m:active::before{content:"";}', ".f1wu3i8x:hover::before,.f1wu3i8x:active::before{position:absolute;}", [".f6v4vfa:hover::before,.f6v4vfa:active::before{inset:0;}", {
    p: -1
  }], ".folrdqs:hover::before,.folrdqs:active::before{z-index:calc(var(--zIndexContent, 1) + 1);}", ".f168z5yf:hover::after,.f168z5yf:active::after{border-top-color:var(--colorNeutralStrokeDisabled);}", ".fpor7gj:hover::after,.fpor7gj:active::after{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fzextn6:hover::after,.fzextn6:active::after{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1yaw79v:hover::after,.f1yaw79v:active::after{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  a: [".fb40n2d:active{background-color:var(--colorNeutralBackground1Pressed);}", ".f1yhgkbh:active{background-color:var(--colorNeutralBackground2Pressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1uohb70:active::after{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1jm7v1n:active::after{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1bus3rq:active::after{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1fbu7rr:active::after{border-bottom-color:var(--colorNeutralStroke1Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}"]
});
var useCardStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useCardResetStyles();
  const styles = useCardStyles();
  const orientationMap = {
    horizontal: styles.orientationHorizontal,
    vertical: styles.orientationVertical
  };
  const sizeMap = {
    small: styles.sizeSmall,
    medium: styles.sizeMedium,
    large: styles.sizeLarge
  };
  const appearanceMap = {
    filled: styles.filled,
    "filled-alternative": styles.filledAlternative,
    outline: styles.outline,
    subtle: styles.subtle
  };
  const selectedMap = {
    filled: styles.filledInteractiveSelected,
    "filled-alternative": styles.filledAlternativeInteractiveSelected,
    outline: styles.outlineInteractiveSelected,
    subtle: styles.subtleInteractiveSelected
  };
  const interactiveMap = {
    filled: styles.filledInteractive,
    "filled-alternative": styles.filledAlternativeInteractive,
    outline: styles.outlineInteractive,
    subtle: styles.subtleInteractive
  };
  const isSelectableOrInteractive = !state.disabled && (state.interactive || state.selectable);
  const focusedClassName = React389.useMemo(() => {
    if (state.disabled) {
      return "";
    }
    if (state.selectable) {
      if (state.selectFocused) {
        return styles.selectableFocused;
      }
      return "";
    }
    return styles.focused;
  }, [state.disabled, state.selectFocused, state.selectable, styles.focused, styles.selectableFocused]);
  state.root.className = mergeClasses(cardClassNames.root, resetStyles, orientationMap[state.orientation], sizeMap[state.size], appearanceMap[state.appearance], isSelectableOrInteractive && styles.interactive, isSelectableOrInteractive && interactiveMap[state.appearance], state.selected && selectedMap[state.appearance], focusedClassName, isSelectableOrInteractive && styles.highContrastInteractive, state.selected && styles.highContrastSelected, state.disabled && styles.disabled, state.disabled && state.appearance === "outline" && styles.outlineDisabled, state.root.className);
  if (state.floatingAction) {
    state.floatingAction.className = mergeClasses(cardClassNames.floatingAction, styles.select, state.floatingAction.className);
  }
  if (state.checkbox) {
    state.checkbox.className = mergeClasses(cardClassNames.checkbox, styles.hiddenCheckbox, state.checkbox.className);
  }
  return state;
};

// node_modules/@fluentui/react-card/lib/components/Card/useCardContextValue.js
function useCardContextValue({ selectableA11yProps }) {
  return {
    selectableA11yProps
  };
}

// node_modules/@fluentui/react-card/lib/components/Card/Card.js
var Card = React390.forwardRef((props, ref) => {
  const state = useCard_unstable(props, ref);
  const cardContextValue = useCardContextValue(state);
  useCardStyles_unstable(state);
  useCustomStyleHook("useCardStyles_unstable")(state);
  return renderCard_unstable(state, cardContextValue);
});
Card.displayName = "Card";

// node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
var React392 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardFooter/useCardFooter.js
var React391 = __toESM(require_react());
var useCardFooter_unstable = (props, ref) => {
  const { action } = props;
  return {
    components: {
      root: "div",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    action: slot_exports.optional(action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/renderCardFooter.js
var renderCardFooter_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardFooter/CardFooter.js
var CardFooter = React392.forwardRef((props, ref) => {
  const state = useCardFooter_unstable(props, ref);
  useCardFooterStyles_unstable(state);
  useCustomStyleHook("useCardFooterStyles_unstable")(state);
  return renderCardFooter_unstable(state);
});
CardFooter.displayName = "CardFooter";

// node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
var React394 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardHeader/useCardHeader.js
var React393 = __toESM(require_react());
function getChildWithId(header) {
  function isReactElementWithIdProp(element) {
    return React393.isValidElement(element) && Boolean(element.props.id);
  }
  return React393.Children.toArray(header).find(isReactElementWithIdProp);
}
function getReferenceId(headerId, childWithId, generatedId) {
  if (headerId) {
    return headerId;
  }
  if (childWithId === null || childWithId === void 0 ? void 0 : childWithId.props.id) {
    return childWithId.props.id;
  }
  return generatedId;
}
var useCardHeader_unstable = (props, ref) => {
  const { image, header, description, action } = props;
  const { selectableA11yProps: { referenceId, setReferenceId } } = useCardContext_unstable();
  const headerRef = React393.useRef(null);
  const hasChildId = React393.useRef(false);
  const generatedId = useId2(cardHeaderClassNames.header, referenceId);
  const headerSlot = slot_exports.optional(header, {
    renderByDefault: true,
    defaultProps: {
      ref: headerRef,
      id: !hasChildId.current ? referenceId : void 0
    },
    elementType: "div"
  });
  React393.useEffect(() => {
    var _headerRef_current;
    const headerId = !hasChildId.current ? (_headerRef_current = headerRef.current) === null || _headerRef_current === void 0 ? void 0 : _headerRef_current.id : void 0;
    const childWithId = getChildWithId(headerSlot === null || headerSlot === void 0 ? void 0 : headerSlot.children);
    hasChildId.current = Boolean(childWithId);
    setReferenceId(getReferenceId(headerId, childWithId, generatedId));
  }, [
    generatedId,
    header,
    headerSlot,
    setReferenceId
  ]);
  return {
    components: {
      root: "div",
      image: "div",
      header: "div",
      description: "div",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    image: slot_exports.optional(image, {
      elementType: "div"
    }),
    header: headerSlot,
    description: slot_exports.optional(description, {
      elementType: "div"
    }),
    action: slot_exports.optional(action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/renderCardHeader.js
var renderCardHeader_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.image && jsx(state.image, {}),
      state.header && jsx(state.header, {}),
      state.description && jsx(state.description, {}),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardHeader/CardHeader.js
var CardHeader = React394.forwardRef((props, ref) => {
  const state = useCardHeader_unstable(props, ref);
  useCardHeaderStyles_unstable(state);
  useCustomStyleHook("useCardHeaderStyles_unstable")(state);
  return renderCardHeader_unstable(state);
});
CardHeader.displayName = "CardHeader";

// node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
var React396 = __toESM(require_react());

// node_modules/@fluentui/react-card/lib/components/CardPreview/useCardPreview.js
var React395 = __toESM(require_react());
var useCardPreview_unstable = (props, ref) => {
  const { logo } = props;
  const { selectableA11yProps: { referenceLabel, referenceId, setReferenceLabel, setReferenceId } } = useCardContext_unstable();
  const previewRef = useMergedRefs(ref, React395.useRef(null));
  React395.useEffect(() => {
    if (referenceLabel && referenceId) {
      return;
    }
    if (previewRef.current && previewRef.current.parentNode) {
      const img = previewRef.current.parentNode.querySelector(`.${cardPreviewClassNames.root} > img`);
      if (img) {
        const ariaLabel = img.getAttribute("aria-label");
        const ariaDescribedby = img.getAttribute("aria-describedby");
        if (ariaDescribedby) {
          setReferenceId(ariaDescribedby);
        } else if (img.alt) {
          setReferenceLabel(img.alt);
        } else if (ariaLabel) {
          setReferenceLabel(ariaLabel);
        }
      }
    }
  }, [
    setReferenceLabel,
    referenceLabel,
    previewRef,
    referenceId,
    setReferenceId
  ]);
  return {
    components: {
      root: "div",
      logo: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: previewRef,
      ...props
    }), {
      elementType: "div"
    }),
    logo: slot_exports.optional(logo, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-card/lib/components/CardPreview/renderCardPreview.js
var renderCardPreview_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.logo && jsx(state.logo, {})
    ]
  });
};

// node_modules/@fluentui/react-card/lib/components/CardPreview/CardPreview.js
var CardPreview = React396.forwardRef((props, ref) => {
  const state = useCardPreview_unstable(props, ref);
  useCardPreviewStyles_unstable(state);
  useCustomStyleHook("useCardPreviewStyles_unstable")(state);
  return renderCardPreview_unstable(state);
});
CardPreview.displayName = "CardPreview";

// node_modules/@fluentui/react-toast/lib/state/useToaster.js
var React398 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/state/constants.js
var EVENTS = {
  show: "fui-toast-show",
  dismiss: "fui-toast-dismiss",
  dismissAll: "fui-toast-dismiss-all",
  update: "fui-toast-update",
  pause: "fui-toast-pause",
  play: "fui-toast-play"
};
var TOAST_POSITIONS = {
  bottom: "bottom",
  bottomEnd: "bottom-end",
  bottomStart: "bottom-start",
  top: "top",
  topEnd: "top-end",
  topStart: "top-start"
};

// node_modules/@fluentui/react-toast/lib/state/vanilla/dispatchToast.js
var counter2 = 0;
function dispatchToast(content, options = {}, targetDocument) {
  var _options_toastId;
  const detail = {
    ...options,
    content,
    toastId: (_options_toastId = options.toastId) !== null && _options_toastId !== void 0 ? _options_toastId : (counter2++).toString()
  };
  const event = new CustomEvent(EVENTS.show, {
    bubbles: false,
    cancelable: false,
    detail
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/dismissToast.js
function dismissToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.dismiss, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/dismissAllToasts.js
function dismissAllToasts(toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.dismissAll, {
    bubbles: false,
    cancelable: false,
    detail: {
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/updateToast.js
function updateToast(options, targetDocument) {
  const event = new CustomEvent(EVENTS.update, {
    bubbles: false,
    cancelable: false,
    detail: options
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/pauseToast.js
function pauseToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.pause, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/playToast.js
function playToast(toastId, toasterId = void 0, targetDocument) {
  const event = new CustomEvent(EVENTS.play, {
    bubbles: false,
    cancelable: false,
    detail: {
      toastId,
      toasterId
    }
  });
  targetDocument.dispatchEvent(event);
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/createToaster.js
var React397 = __toESM(require_react());
function assignDefined(a, b) {
  for (const [key, prop] of Object.entries(b)) {
    if (prop != void 0) {
      a[key] = prop;
    }
  }
}
var defaulToastOptions = {
  onStatusChange: void 0,
  priority: 0,
  pauseOnHover: false,
  pauseOnWindowBlur: false,
  position: "bottom-end",
  timeout: 3e3
};
var counter3 = 0;
function createToaster(options) {
  const { limit = Number.POSITIVE_INFINITY } = options;
  const visibleToasts = /* @__PURE__ */ new Set();
  const toasts = /* @__PURE__ */ new Map();
  const queue = createPriorityQueue((ta, tb) => {
    const a = toasts.get(ta);
    const b = toasts.get(tb);
    if (!a || !b) {
      return 0;
    }
    if (a.priority === b.priority) {
      return a.order - b.order;
    }
    return a.priority - b.priority;
  });
  const isToastVisible = (toastId) => {
    return visibleToasts.has(toastId);
  };
  const updateToast2 = (toastOptions) => {
    const { toastId } = toastOptions;
    const toastToUpdate = toasts.get(toastId);
    if (!toastToUpdate) {
      return;
    }
    Object.assign(toastToUpdate, toastOptions);
    toastToUpdate.updateId++;
  };
  const dismissToast2 = (toastId) => {
    visibleToasts.delete(toastId);
  };
  const dismissAllToasts2 = () => {
    visibleToasts.clear();
    queue.clear();
  };
  const buildToast = (toastOptions, onUpdate) => {
    var _toast_onStatusChange;
    const { toastId, content, toasterId } = toastOptions;
    if (toasts.has(toastId)) {
      return;
    }
    const close = () => {
      var _toast_onStatusChange2;
      const toast2 = toasts.get(toastId);
      if (!toast2) {
        return;
      }
      visibleToasts.delete(toastId);
      onUpdate();
      (_toast_onStatusChange2 = toast2.onStatusChange) === null || _toast_onStatusChange2 === void 0 ? void 0 : _toast_onStatusChange2.call(toast2, null, {
        status: "dismissed",
        ...toast2
      });
    };
    const remove = () => {
      const toast2 = toasts.get(toastId);
      if (!toast2) {
        return;
      }
      toasts.delete(toastId);
      if (visibleToasts.size < limit && queue.peek()) {
        const nextToast = toasts.get(queue.dequeue());
        if (!nextToast) {
          return;
        }
        visibleToasts.add(nextToast.toastId);
      }
      onUpdate();
    };
    const toast = {
      ...defaulToastOptions,
      close,
      remove,
      toastId,
      content,
      updateId: 0,
      toasterId,
      order: counter3++,
      data: {},
      imperativeRef: React397.createRef()
    };
    assignDefined(toast, options);
    assignDefined(toast, toastOptions);
    toasts.set(toastId, toast);
    (_toast_onStatusChange = toast.onStatusChange) === null || _toast_onStatusChange === void 0 ? void 0 : _toast_onStatusChange.call(toast, null, {
      status: "queued",
      ...toast
    });
    if (visibleToasts.size >= limit) {
      queue.enqueue(toastId);
    } else {
      visibleToasts.add(toastId);
    }
  };
  return {
    buildToast,
    dismissAllToasts: dismissAllToasts2,
    dismissToast: dismissToast2,
    isToastVisible,
    updateToast: updateToast2,
    visibleToasts,
    toasts
  };
}

// node_modules/@fluentui/react-toast/lib/state/vanilla/getPositionStyles.js
var getPositionStyles = (position, dir, offset4) => {
  const positionStyles = {};
  var _offset_position;
  const offsetStyles = offset4 ? isShorthandOffset(offset4) ? offset4 : (_offset_position = offset4[position]) !== null && _offset_position !== void 0 ? _offset_position : {} : {};
  const centered = position === "top" || position === "bottom";
  const { horizontal = centered ? 0 : 20, vertical = 16 } = offsetStyles;
  const start = dir === "ltr" ? "left" : "right";
  const end = dir === "ltr" ? "right" : "left";
  switch (position) {
    case "top":
      Object.assign(positionStyles, {
        top: vertical,
        left: `calc(50% + ${horizontal}px)`,
        transform: "translateX(-50%)"
      });
      break;
    case "bottom":
      Object.assign(positionStyles, {
        bottom: vertical,
        left: `calc(50% + ${horizontal}px)`,
        transform: "translateX(-50%)"
      });
      break;
    case "top-start":
      Object.assign(positionStyles, {
        top: vertical,
        [start]: horizontal
      });
      break;
    case "top-end":
      Object.assign(positionStyles, {
        top: vertical,
        [end]: horizontal
      });
      break;
    case "bottom-start":
      Object.assign(positionStyles, {
        bottom: vertical,
        [start]: horizontal
      });
      break;
    case "bottom-end":
      Object.assign(positionStyles, {
        bottom: vertical,
        [end]: horizontal
      });
      break;
  }
  return positionStyles;
};
function isShorthandOffset(offset4) {
  return "horizontal" in offset4 || "vertical" in offset4;
}

// node_modules/@fluentui/react-toast/lib/state/useToaster.js
function useToaster(options = {}) {
  const forceUpdate = useForceUpdate();
  const { toasterId: userToasterId, shortcuts } = options;
  const [toaster] = React398.useState(() => createToaster(options));
  const { targetDocument } = useFluent();
  const lastActiveElementRef = React398.useRef(null);
  const isCorrectToaster = useEventCallback((toasterId) => {
    return toasterId === userToasterId;
  });
  const isFocusShortcut = useEventCallback((e) => {
    if (shortcuts === null || shortcuts === void 0 ? void 0 : shortcuts.focus) {
      return shortcuts.focus(e);
    }
  });
  const pauseAllToasts = React398.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      var _toast_imperativeRef_current;
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.pause();
    });
  }, [
    toaster
  ]);
  const playAllToasts = React398.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      var _toast_imperativeRef_current;
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.play();
    });
  }, [
    toaster
  ]);
  const getMostRecentVisibleToast = React398.useCallback(() => {
    return Array.from(toaster.visibleToasts).reduce((cur, next) => {
      const toast = toaster.toasts.get(next);
      if (!toast) {
        return cur;
      }
      if (!cur) {
        return toast;
      }
      if (cur.order < (toast === null || toast === void 0 ? void 0 : toast.order)) {
        return toast;
      }
      return cur;
    }, void 0);
  }, [
    toaster
  ]);
  const tryRestoreFocus = React398.useCallback(() => {
    const mostRecentToast = getMostRecentVisibleToast();
    if (mostRecentToast === null || mostRecentToast === void 0 ? void 0 : mostRecentToast.imperativeRef.current) {
      mostRecentToast.imperativeRef.current.focus();
    } else {
      var _lastActiveElementRef_current;
      (_lastActiveElementRef_current = lastActiveElementRef.current) === null || _lastActiveElementRef_current === void 0 ? void 0 : _lastActiveElementRef_current.focus();
      lastActiveElementRef.current = null;
    }
  }, [
    getMostRecentVisibleToast
  ]);
  const closeAllToasts = React398.useCallback(() => {
    toaster.visibleToasts.forEach((toastId) => {
      const toast = toaster.toasts.get(toastId);
      toast === null || toast === void 0 ? void 0 : toast.close();
    });
    tryRestoreFocus();
  }, [
    toaster,
    tryRestoreFocus
  ]);
  React398.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    const addToastListener = (eventType, callback) => {
      const listener = (e) => {
        if (!isCorrectToaster(e.detail.toasterId)) {
          return;
        }
        callback(e);
        forceUpdate();
      };
      targetDocument.addEventListener(eventType, listener);
      return () => targetDocument.removeEventListener(eventType, listener);
    };
    const buildToast = (e) => {
      toaster.buildToast(e.detail, forceUpdate);
    };
    const dismissToast2 = (e) => {
      toaster.dismissToast(e.detail.toastId);
    };
    const updateToast2 = (e) => {
      toaster.updateToast(e.detail);
    };
    const dismissAllToasts2 = (e) => {
      toaster.dismissAllToasts();
    };
    const pauseToast2 = (e) => {
      const toast = toaster.toasts.get(e.detail.toastId);
      if (toast) {
        var _toast_imperativeRef_current;
        (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.pause();
      }
    };
    const playToast2 = (e) => {
      const toast = toaster.toasts.get(e.detail.toastId);
      if (toast) {
        var _toast_imperativeRef_current;
        (_toast_imperativeRef_current = toast.imperativeRef.current) === null || _toast_imperativeRef_current === void 0 ? void 0 : _toast_imperativeRef_current.play();
      }
    };
    const cleanupBuildListener = addToastListener(EVENTS.show, buildToast);
    const cleanupUpdateListener = addToastListener(EVENTS.update, updateToast2);
    const cleanupDismissListener = addToastListener(EVENTS.dismiss, dismissToast2);
    const cleanupDismissAllListener = addToastListener(EVENTS.dismissAll, dismissAllToasts2);
    const cleanupPauseListener = addToastListener(EVENTS.pause, pauseToast2);
    const cleanupPlayListener = addToastListener(EVENTS.play, playToast2);
    const focusShortcutListener = (e) => {
      if (isFocusShortcut(e)) {
        pauseAllToasts();
        const mostRecentToast = getMostRecentVisibleToast();
        if (mostRecentToast) {
          var _mostRecentToast_imperativeRef_current;
          lastActiveElementRef.current = isHTMLElement(targetDocument.activeElement) ? targetDocument.activeElement : null;
          (_mostRecentToast_imperativeRef_current = mostRecentToast.imperativeRef.current) === null || _mostRecentToast_imperativeRef_current === void 0 ? void 0 : _mostRecentToast_imperativeRef_current.focus();
        }
      }
    };
    targetDocument.addEventListener("keydown", focusShortcutListener);
    return () => {
      cleanupBuildListener();
      cleanupDismissAllListener();
      cleanupUpdateListener();
      cleanupDismissListener();
      cleanupPauseListener();
      cleanupPlayListener();
      targetDocument.removeEventListener("keydown", focusShortcutListener);
    };
  }, [
    toaster,
    forceUpdate,
    targetDocument,
    isCorrectToaster,
    pauseAllToasts,
    getMostRecentVisibleToast,
    isFocusShortcut
  ]);
  const toastsToRender = (() => {
    if (!toaster) {
      return /* @__PURE__ */ new Map();
    }
    const toRender = /* @__PURE__ */ new Map();
    const toasts = Array.from(toaster.toasts.values());
    toasts.forEach((toast) => {
      const { position } = toast;
      toRender.has(position) || toRender.set(position, []);
      if (position.startsWith("bottom")) {
        toRender.get(position).push(toast);
      } else {
        toRender.get(position).unshift(toast);
      }
    });
    return toRender;
  })();
  return {
    isToastVisible: toaster.isToastVisible,
    toastsToRender,
    pauseAllToasts,
    playAllToasts,
    tryRestoreFocus,
    closeAllToasts
  };
}

// node_modules/@fluentui/react-toast/lib/state/useToastController.js
var React399 = __toESM(require_react());
var noop7 = () => void 0;
function useToastController(toasterId) {
  const { targetDocument } = useFluent();
  return React399.useMemo(() => {
    if (!targetDocument) {
      return {
        dispatchToast: noop7,
        dismissToast: noop7,
        dismissAllToasts: noop7,
        updateToast: noop7,
        pauseToast: noop7,
        playToast: noop7
      };
    }
    return {
      dispatchToast: (content, options) => {
        dispatchToast(content, {
          ...options,
          toasterId,
          data: {
            root: options === null || options === void 0 ? void 0 : options.root
          }
        }, targetDocument);
      },
      dismissToast: (toastId) => {
        dismissToast(toastId, toasterId, targetDocument);
      },
      dismissAllToasts: () => {
        dismissAllToasts(toasterId, targetDocument);
      },
      updateToast: (options) => {
        updateToast({
          ...options,
          data: {
            root: options.root
          },
          toasterId
        }, targetDocument);
      },
      pauseToast: (toastId) => {
        pauseToast(toastId, toasterId, targetDocument);
      },
      playToast: (toastId) => {
        playToast(toastId, toasterId, targetDocument);
      }
    };
  }, [
    targetDocument,
    toasterId
  ]);
}

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/ToastTrigger.js
var React402 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/useToastTrigger.js
var React401 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/contexts/toastContainerContext.js
var React400 = __toESM(require_react());
var toastContainerContextDefaultValue = {
  close: () => null,
  intent: void 0,
  bodyId: "",
  titleId: ""
};
var ToastContainerContext = React400.createContext(void 0);
var ToastContainerContextProvider = ToastContainerContext.Provider;
var useToastContainerContext = () => {
  var _React_useContext;
  return (_React_useContext = React400.useContext(ToastContainerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : toastContainerContextDefaultValue;
};

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/useToastTrigger.js
var useToastTrigger_unstable = (props) => {
  const { children, disableButtonEnhancement = false } = props;
  const { close } = useToastContainerContext();
  const child = getTriggerChild(children);
  const handleClick = useEventCallback((e) => {
    var _child_props_onClick, _child_props;
    child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, e);
    if (!e.isDefaultPrevented()) {
      close();
    }
  });
  const triggerChildProps = {
    ...child === null || child === void 0 ? void 0 : child.props,
    ref: getReactElementRef(child),
    onClick: handleClick
  };
  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
    ...triggerChildProps,
    type: "button"
  });
  return {
    children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/renderToastTrigger.js
var renderToastTrigger_unstable = (state) => state.children;

// node_modules/@fluentui/react-toast/lib/components/ToastTrigger/ToastTrigger.js
var ToastTrigger = (props) => {
  const state = useToastTrigger_unstable(props);
  return renderToastTrigger_unstable(state);
};
ToastTrigger.displayName = "ToastTrigger";

// node_modules/@fluentui/react-toast/lib/components/Toaster/Toaster.js
var React412 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToaster.js
var React409 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/ToastContainer.js
var React406 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainer.js
var React404 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Timer/Timer.js
var React403 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Timer/useTimerStyles.styles.js
var useBaseAnimationStyles = __resetStyles("r16zaflb", "r75casi", [".r16zaflb{animation-name:rsacmq1;}", "@keyframes rsacmq1{from{opacity:0;}to{opacity:0;}}", ".r75casi{animation-name:rsacmq1;}"]);

// node_modules/@fluentui/react-toast/lib/components/Timer/Timer.js
var Timer = React403.forwardRef((props, ref) => {
  const baseAnimationStyles = useBaseAnimationStyles();
  const { running, timeout, onTimeout } = props;
  const style = {
    animationDuration: `${timeout}ms`,
    animationPlayState: running ? "running" : "paused"
  };
  if (timeout < 0) {
    return null;
  }
  return React403.createElement("span", {
    onAnimationEnd: onTimeout,
    "data-timer-status": style.animationPlayState,
    ref,
    style,
    className: baseAnimationStyles
  });
});
Timer.displayName = "Timer";

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainer.js
var intentPolitenessMap = {
  success: "assertive",
  warning: "assertive",
  error: "assertive",
  info: "polite"
};
var useToastContainer_unstable = (props, ref) => {
  const { visible, children, close: closeProp, remove, updateId, announce, data, timeout: timerTimeout, politeness: desiredPoliteness, intent = "info", pauseOnHover, pauseOnWindowBlur, imperativeRef, tryRestoreFocus, content: _content, ...rest } = props;
  const titleId = useId2("toast-title");
  const bodyId = useId2("toast-body");
  const toastRef = React404.useRef(null);
  const { targetDocument } = useFluent();
  const [running, setRunning] = React404.useState(false);
  const imperativePauseRef = React404.useRef(false);
  const focusedToastBeforeClose = React404.useRef(false);
  const focusableGroupAttribute = useFocusableGroup({
    tabBehavior: "limited-trap-focus",
    // Users should only use Tab to focus into the toast
    // Escape is already reserved to dismiss all toasts
    ignoreDefaultKeydown: {
      Tab: true,
      Escape: true,
      Enter: true
    }
  });
  const close = useEventCallback(() => {
    var _toastRef_current;
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if (activeElement && ((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains(activeElement))) {
      focusedToastBeforeClose.current = true;
    }
    closeProp();
  });
  const onStatusChange = useEventCallback((status) => {
    var _props_onStatusChange;
    return (_props_onStatusChange = props.onStatusChange) === null || _props_onStatusChange === void 0 ? void 0 : _props_onStatusChange.call(props, null, {
      status,
      ...props
    });
  });
  const pause = useEventCallback(() => setRunning(false));
  const play = useEventCallback(() => {
    var _toastRef_current;
    if (imperativePauseRef.current) {
      return;
    }
    var _targetDocument_activeElement;
    const containsActive = !!((_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.contains((_targetDocument_activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) !== null && _targetDocument_activeElement !== void 0 ? _targetDocument_activeElement : null));
    if (timerTimeout < 0) {
      setRunning(true);
      return;
    }
    if (!containsActive) {
      setRunning(true);
    }
  });
  React404.useImperativeHandle(imperativeRef, () => ({
    focus: () => {
      if (!toastRef.current) {
        return;
      }
      toastRef.current.focus();
    },
    play: () => {
      imperativePauseRef.current = false;
      play();
    },
    pause: () => {
      imperativePauseRef.current = true;
      pause();
    }
  }));
  React404.useEffect(() => {
    return () => onStatusChange("unmounted");
  }, [
    onStatusChange
  ]);
  React404.useEffect(() => {
    if (!targetDocument) {
      return;
    }
    if (pauseOnWindowBlur) {
      var _targetDocument_defaultView, _targetDocument_defaultView1;
      (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.addEventListener("focus", play);
      (_targetDocument_defaultView1 = targetDocument.defaultView) === null || _targetDocument_defaultView1 === void 0 ? void 0 : _targetDocument_defaultView1.addEventListener("blur", pause);
      return () => {
        var _targetDocument_defaultView2, _targetDocument_defaultView12;
        (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.removeEventListener("focus", play);
        (_targetDocument_defaultView12 = targetDocument.defaultView) === null || _targetDocument_defaultView12 === void 0 ? void 0 : _targetDocument_defaultView12.removeEventListener("blur", pause);
      };
    }
  }, [
    targetDocument,
    pause,
    play,
    pauseOnWindowBlur
  ]);
  const userRootSlot = data.root;
  const onMotionFinish = React404.useCallback((_, { direction }) => {
    if (direction === "exit") {
      remove();
    }
    if (direction === "enter") {
      play();
      onStatusChange("visible");
    }
  }, [
    onStatusChange,
    play,
    remove
  ]);
  const onMouseEnter = useEventCallback((e) => {
    var _userRootSlot_onMouseEnter;
    pause();
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
  });
  const onMouseLeave = useEventCallback((e) => {
    var _userRootSlot_onMouseEnter;
    play();
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onMouseEnter = userRootSlot.onMouseEnter) === null || _userRootSlot_onMouseEnter === void 0 ? void 0 : _userRootSlot_onMouseEnter.call(userRootSlot, e);
  });
  const { findFirstFocusable, findLastFocusable } = useFocusFinders();
  const onKeyDown = useEventCallback((e) => {
    var _userRootSlot_onKeyDown;
    if (e.key === Delete) {
      e.preventDefault();
      close();
    }
    if (e.key === Tab && e.currentTarget === e.target) {
      e.preventDefault();
      if (e.shiftKey) {
        var _findLastFocusable;
        (_findLastFocusable = findLastFocusable(e.currentTarget)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      } else {
        var _findFirstFocusable;
        (_findFirstFocusable = findFirstFocusable(e.currentTarget)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
      }
    }
    userRootSlot === null || userRootSlot === void 0 ? void 0 : (_userRootSlot_onKeyDown = userRootSlot.onKeyDown) === null || _userRootSlot_onKeyDown === void 0 ? void 0 : _userRootSlot_onKeyDown.call(userRootSlot, e);
  });
  React404.useEffect(() => {
    var _toastRef_current;
    if (!visible) {
      return;
    }
    const politeness = desiredPoliteness !== null && desiredPoliteness !== void 0 ? desiredPoliteness : intentPolitenessMap[intent];
    var _toastRef_current_textContent;
    announce((_toastRef_current_textContent = (_toastRef_current = toastRef.current) === null || _toastRef_current === void 0 ? void 0 : _toastRef_current.textContent) !== null && _toastRef_current_textContent !== void 0 ? _toastRef_current_textContent : "", {
      politeness
    });
  }, [
    announce,
    desiredPoliteness,
    toastRef,
    visible,
    updateId,
    intent
  ]);
  React404.useEffect(() => {
    return () => {
      if (focusedToastBeforeClose.current) {
        focusedToastBeforeClose.current = false;
        tryRestoreFocus();
      }
    };
  }, [
    tryRestoreFocus
  ]);
  return {
    components: {
      timer: Timer,
      root: "div"
    },
    timer: slot_exports.always({
      onTimeout: close,
      running,
      timeout: timerTimeout !== null && timerTimeout !== void 0 ? timerTimeout : -1
    }, {
      elementType: Timer
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, toastRef),
      children,
      tabIndex: 0,
      role: "listitem",
      "aria-labelledby": titleId,
      "aria-describedby": bodyId,
      ...rest,
      ...userRootSlot,
      ...focusableGroupAttribute,
      onMouseEnter,
      onMouseLeave,
      onKeyDown
    }), {
      elementType: "div"
    }),
    timerTimeout,
    transitionTimeout: 0,
    running,
    visible,
    remove,
    close,
    onTransitionEntering: () => {
    },
    updateId,
    nodeRef: toastRef,
    intent,
    titleId,
    bodyId,
    onMotionFinish
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/renderToastContainer.js
var renderToastContainer_unstable = (state, contextValues) => {
  const { onMotionFinish, visible, updateId } = state;
  assertSlots(state);
  return jsx(ToastContainerContextProvider, {
    value: contextValues.toast,
    children: jsx(CollapseDelayed, {
      appear: true,
      onMotionFinish,
      visible,
      unmountOnExit: true,
      children: jsxs(state.root, {
        children: [
          state.root.children,
          jsx(state.timer, {}, updateId)
        ]
      })
    })
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerStyles.styles.js
var toastContainerClassNames = {
  root: "fui-ToastContainer",
  timer: "fui-ToastContainer__timer"
};
var useRootBaseClassName6 = __resetStyles("r98b696", null, [".r98b696{box-sizing:border-box;margin-top:16px;pointer-events:all;border-radius:var(--borderRadiusMedium);}", ".r98b696[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"]);
var useToastContainerStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName6();
  state.root.className = mergeClasses(toastContainerClassNames.root, rootBaseClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/useToastContainerContextValues.js
var React405 = __toESM(require_react());
function useToastContainerContextValues_unstable(state) {
  const { close, intent, titleId, bodyId } = state;
  const toastContainerContext = React405.useMemo(() => ({
    close,
    intent,
    titleId,
    bodyId
  }), [
    close,
    intent,
    titleId,
    bodyId
  ]);
  return {
    toast: toastContainerContext
  };
}

// node_modules/@fluentui/react-toast/lib/components/ToastContainer/ToastContainer.js
var ToastContainer = React406.forwardRef((props, ref) => {
  const state = useToastContainer_unstable(props, ref);
  useToastContainerStyles_unstable(state);
  useCustomStyleHook("useToastContainerStyles_unstable")(state);
  return renderToastContainer_unstable(state, useToastContainerContextValues_unstable(state));
});
ToastContainer.displayName = "ToastContainer";

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterFocusManagement.js
var React407 = __toESM(require_react());
var noop8 = () => void 0;
function useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts) {
  const { targetDocument } = useFluent();
  const cleanupListenersRef = React407.useRef(noop8);
  return React407.useCallback((el) => {
    if (!el || !targetDocument) {
      cleanupListenersRef.current();
      cleanupListenersRef.current = noop8;
      return;
    }
    const toastContainerWalker = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (isHTMLElement(node) && node.classList.contains(toastContainerClassNames.root)) {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
    const keydownListener = (e) => {
      const { target, key } = e;
      if (!isHTMLElement(target)) {
        return;
      }
      if (key === ArrowDown) {
        toastContainerWalker.currentNode = target;
        let nextToastContainer = toastContainerWalker.nextNode();
        if (!nextToastContainer) {
          toastContainerWalker.currentNode = el;
          nextToastContainer = toastContainerWalker.nextNode();
        }
        if (isHTMLElement(nextToastContainer)) {
          nextToastContainer.focus();
        }
      }
      if (key === ArrowUp) {
        toastContainerWalker.currentNode = target;
        let prevToastContainer = toastContainerWalker.previousNode();
        if (prevToastContainer && prevToastContainer.contains(target)) {
          prevToastContainer = toastContainerWalker.previousNode();
        }
        if (!prevToastContainer) {
          toastContainerWalker.currentNode = el;
          prevToastContainer = toastContainerWalker.lastChild();
        }
        if (isHTMLElement(prevToastContainer)) {
          prevToastContainer.focus();
        }
      }
    };
    const focusInListener = (e) => {
      if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        pauseAllToasts();
      }
    };
    const focusOutListener = (e) => {
      if (isHTMLElement(e.currentTarget) && !e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        playAllToasts();
      }
    };
    el.addEventListener("keydown", keydownListener);
    el.addEventListener("focusin", focusInListener);
    el.addEventListener("focusout", focusOutListener);
    cleanupListenersRef.current = () => {
      el.removeEventListener("keydown", keydownListener);
      el.removeEventListener("focusin", focusInListener);
      el.removeEventListener("focusout", focusOutListener);
    };
  }, [
    targetDocument,
    pauseAllToasts,
    playAllToasts
  ]);
}

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToastAnnounce.js
var React408 = __toESM(require_react());
function useToastAnnounce(announce) {
  const activeRef = React408.useRef(true);
  const cleanupRef = React408.useRef(() => void 0);
  const announceToast = React408.useCallback((message, options) => {
    if (activeRef.current) {
      announce(message, options);
    }
  }, [
    announce
  ]);
  const toasterRef = React408.useCallback((el) => {
    if (!el) {
      cleanupRef.current();
      return;
    }
    const onFocusIn = (e) => {
      if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        return;
      }
      activeRef.current = false;
    };
    const onFocusOut = (e) => {
      if (isHTMLElement(e.currentTarget) && e.currentTarget.contains(isHTMLElement(e.relatedTarget) ? e.relatedTarget : null)) {
        return;
      }
      activeRef.current = true;
    };
    el.addEventListener("focusin", onFocusIn);
    el.addEventListener("focusout", onFocusOut);
    cleanupRef.current = () => {
      el.removeEventListener("focusin", onFocusIn);
      el.removeEventListener("focusout", onFocusOut);
    };
  }, []);
  return {
    announceToast,
    toasterRef
  };
}

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToaster.js
var useToaster_unstable = (props) => {
  "use no memo";
  const { offset: offset4, announce: announceProp, mountNode, inline: inline2 = false, ...rest } = props;
  const announceRef = React409.useRef(() => null);
  const { toastsToRender, isToastVisible, pauseAllToasts, playAllToasts, tryRestoreFocus, closeAllToasts } = useToaster(rest);
  const announce = React409.useCallback((message, options) => announceRef.current(message, options), []);
  const { dir } = useFluent();
  const { onKeyDown: onKeyDownProp, ...rootProps } = slot_exports.always(getIntrinsicElementProps("div", rest), {
    elementType: "div"
  });
  const focusableGroupAttr = useFocusableGroup({
    tabBehavior: "limited-trap-focus",
    ignoreDefaultKeydown: {
      Escape: true
    }
  });
  const onKeyDown = useEventCallback((e) => {
    if (e.key === Escape) {
      e.preventDefault();
      closeAllToasts();
    }
    onKeyDownProp === null || onKeyDownProp === void 0 ? void 0 : onKeyDownProp(e);
  });
  const usePositionSlot = (toastPosition) => {
    var _toastsToRender_get;
    const focusManagementRef = useToasterFocusManagement_unstable(pauseAllToasts, playAllToasts);
    const { announceToast, toasterRef } = useToastAnnounce(announceProp !== null && announceProp !== void 0 ? announceProp : announce);
    return slot_exports.optional(toastsToRender.has(toastPosition) ? rootProps : null, {
      defaultProps: {
        ref: useMergedRefs(focusManagementRef, toasterRef),
        children: (_toastsToRender_get = toastsToRender.get(toastPosition)) === null || _toastsToRender_get === void 0 ? void 0 : _toastsToRender_get.map((toast) => React409.createElement(ToastContainer, {
          ...toast,
          tryRestoreFocus,
          intent: toast.intent,
          announce: announceToast,
          key: toast.toastId,
          visible: isToastVisible(toast.toastId)
        }, toast.content)),
        onKeyDown,
        ...focusableGroupAttr,
        "data-toaster-position": toastPosition,
        role: "list"
      },
      elementType: "div"
    });
  };
  return {
    dir,
    mountNode,
    components: {
      root: "div",
      bottomStart: "div",
      bottomEnd: "div",
      topStart: "div",
      topEnd: "div",
      top: "div",
      bottom: "div"
    },
    root: slot_exports.always(rootProps, {
      elementType: "div"
    }),
    bottomStart: usePositionSlot(TOAST_POSITIONS.bottomStart),
    bottomEnd: usePositionSlot(TOAST_POSITIONS.bottomEnd),
    topStart: usePositionSlot(TOAST_POSITIONS.topStart),
    topEnd: usePositionSlot(TOAST_POSITIONS.topEnd),
    top: usePositionSlot(TOAST_POSITIONS.top),
    bottom: usePositionSlot(TOAST_POSITIONS.bottom),
    announceRef,
    offset: offset4,
    announce: announceProp !== null && announceProp !== void 0 ? announceProp : announce,
    renderAriaLive: !announceProp,
    inline: inline2
  };
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/AriaLive.js
var React411 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLive.js
var React410 = __toESM(require_react());
var MESSAGE_DURATION2 = 500;
var useAriaLive_unstable = (props) => {
  const [currentMessage, setCurrentMessage] = React410.useState(void 0);
  const order = React410.useRef(0);
  const [messageQueue] = React410.useState(() => createPriorityQueue((a, b) => {
    if (a.politeness === b.politeness) {
      return a.createdAt - b.createdAt;
    }
    return a.politeness === "assertive" ? -1 : 1;
  }));
  const announce = useEventCallback((message, options) => {
    const { politeness } = options;
    if (message === (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.message)) {
      return;
    }
    const liveMessage = {
      message,
      politeness,
      createdAt: order.current++
    };
    if (!currentMessage) {
      setCurrentMessage(liveMessage);
    } else {
      messageQueue.enqueue(liveMessage);
    }
  });
  const [setMessageTimeout, clearMessageTimeout] = useTimeout();
  React410.useEffect(() => {
    setMessageTimeout(() => {
      if (messageQueue.peek()) {
        setCurrentMessage(messageQueue.dequeue());
      } else {
        setCurrentMessage(void 0);
      }
    }, MESSAGE_DURATION2);
    return () => clearMessageTimeout();
  }, [
    currentMessage,
    messageQueue,
    setMessageTimeout,
    clearMessageTimeout
  ]);
  React410.useImperativeHandle(props.announceRef, () => announce);
  const politeMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "polite" ? currentMessage.message : void 0;
  const assertiveMessage = (currentMessage === null || currentMessage === void 0 ? void 0 : currentMessage.politeness) === "assertive" ? currentMessage.message : void 0;
  return {
    components: {
      assertive: "div",
      polite: "div"
    },
    assertive: slot_exports.always(props.assertive, {
      defaultProps: {
        "aria-live": "assertive",
        children: assertiveMessage
      },
      elementType: "div"
    }),
    polite: slot_exports.always(props.polite, {
      defaultProps: {
        "aria-live": "polite",
        children: politeMessage
      },
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/renderAriaLive.js
var renderAriaLive_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.assertive, {}),
      jsx(state.polite, {})
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/useAriaLiveStyles.styles.js
var ariaLiveClassNames = {
  assertive: "fui-AriaLive__assertive",
  polite: "fui-AriaLive__polite"
};
var useResetStyles3 = __resetStyles("rrd10u0", null, [".rrd10u0{clip:rect(0px, 0px, 0px, 0px);height:1px;margin:-1px;overflow:hidden;padding:0px;width:1px;position:absolute;}"]);
var useAriaLiveStyles_unstable = (state) => {
  "use no memo";
  const visuallyHidden = useResetStyles3();
  state.assertive.className = mergeClasses(visuallyHidden, ariaLiveClassNames.assertive, state.assertive.className);
  state.polite.className = mergeClasses(visuallyHidden, ariaLiveClassNames.polite, state.polite.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/AriaLive/AriaLive.js
var AriaLive = (props) => {
  const state = useAriaLive_unstable(props);
  useAriaLiveStyles_unstable(state);
  return renderAriaLive_unstable(state);
};
AriaLive.displayName = "AriaLive";

// node_modules/@fluentui/react-toast/lib/components/Toaster/renderToaster.js
var renderToaster_unstable = (state) => {
  const { announceRef, renderAriaLive, inline: inline2, mountNode } = state;
  assertSlots(state);
  const hasToasts = !!state.bottomStart || !!state.bottomEnd || !!state.topStart || !!state.topEnd || !!state.top || !!state.bottom;
  const ariaLive = renderAriaLive ? jsx(AriaLive, {
    announceRef
  }) : null;
  const positionSlots = jsxs(import_react.Fragment, {
    children: [
      state.bottom ? jsx(state.bottom, {}) : null,
      state.bottomStart ? jsx(state.bottomStart, {}) : null,
      state.bottomEnd ? jsx(state.bottomEnd, {}) : null,
      state.topStart ? jsx(state.topStart, {}) : null,
      state.topEnd ? jsx(state.topEnd, {}) : null,
      state.top ? jsx(state.top, {}) : null
    ]
  });
  if (inline2) {
    return jsxs(import_react.Fragment, {
      children: [
        ariaLive,
        hasToasts ? positionSlots : null
      ]
    });
  }
  return jsxs(import_react.Fragment, {
    children: [
      ariaLive,
      hasToasts ? jsx(Portal, {
        mountNode,
        children: positionSlots
      }) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/Toaster/useToasterStyles.styles.js
var toasterClassNames = {
  root: "fui-Toaster"
};
var useRootBaseClassName7 = __resetStyles("r3hfdjz", null, [".r3hfdjz{position:fixed;width:292px;pointer-events:none;}"]);
var useToasterStyles = __styles2({
  inline: {
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f1euv43f{position:absolute;}"]
});
var useToasterStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName7();
  const styles = useToasterStyles();
  const className = mergeClasses(toasterClassNames.root, rootBaseClassName, state.inline && styles.inline, state.root.className);
  if (state.bottomStart) {
    var _state_bottomStart;
    state.bottomStart.className = className;
    var _style;
    (_style = (_state_bottomStart = state.bottomStart).style) !== null && _style !== void 0 ? _style : _state_bottomStart.style = {};
    Object.assign(state.bottomStart.style, getPositionStyles(TOAST_POSITIONS.bottomStart, state.dir, state.offset));
  }
  if (state.bottomEnd) {
    var _state_bottomEnd;
    state.bottomEnd.className = className;
    var _style1;
    (_style1 = (_state_bottomEnd = state.bottomEnd).style) !== null && _style1 !== void 0 ? _style1 : _state_bottomEnd.style = {};
    Object.assign(state.bottomEnd.style, getPositionStyles(TOAST_POSITIONS.bottomEnd, state.dir, state.offset));
  }
  if (state.topStart) {
    var _state_topStart;
    state.topStart.className = className;
    var _style2;
    (_style2 = (_state_topStart = state.topStart).style) !== null && _style2 !== void 0 ? _style2 : _state_topStart.style = {};
    Object.assign(state.topStart.style, getPositionStyles(TOAST_POSITIONS.topStart, state.dir, state.offset));
  }
  if (state.topEnd) {
    var _state_topEnd;
    state.topEnd.className = className;
    var _style3;
    (_style3 = (_state_topEnd = state.topEnd).style) !== null && _style3 !== void 0 ? _style3 : _state_topEnd.style = {};
    Object.assign(state.topEnd.style, getPositionStyles(TOAST_POSITIONS.topEnd, state.dir, state.offset));
  }
  if (state.top) {
    var _state_top;
    state.top.className = className;
    var _style4;
    (_style4 = (_state_top = state.top).style) !== null && _style4 !== void 0 ? _style4 : _state_top.style = {};
    Object.assign(state.top.style, getPositionStyles(TOAST_POSITIONS.top, state.dir, state.offset));
  }
  if (state.bottom) {
    var _state_bottom;
    state.bottom.className = className;
    var _style5;
    (_style5 = (_state_bottom = state.bottom).style) !== null && _style5 !== void 0 ? _style5 : _state_bottom.style = {};
    Object.assign(state.bottom.style, getPositionStyles(TOAST_POSITIONS.bottom, state.dir, state.offset));
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/Toaster/Toaster.js
var Toaster = (props) => {
  const state = useToaster_unstable(props);
  useToasterStyles_unstable(state);
  useCustomStyleHook("useToasterStyles_unstable")(state);
  return renderToaster_unstable(state);
};
Toaster.displayName = "Toaster";

// node_modules/@fluentui/react-toast/lib/components/Toast/Toast.js
var React414 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/Toast/useToast.js
var React413 = __toESM(require_react());
var useToast_unstable = (props, ref) => {
  const { intent } = useToastContainerContext();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    backgroundAppearance: props.appearance,
    intent
  };
};

// node_modules/@fluentui/react-toast/lib/components/Toast/renderToast.js
var renderToast_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(BackgroundAppearanceProvider, {
    value: contextValues.backgroundAppearance,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-toast/lib/components/Toast/useToastStyles.styles.js
var toastClassNames = {
  root: "fui-Toast"
};
var useRootBaseClassName8 = __resetStyles("rhf7k35", null, [".rhf7k35{display:grid;grid-template-columns:auto 1fr auto;padding:12px;border-radius:var(--borderRadiusMedium);border:1px solid var(--colorTransparentStroke);box-shadow:var(--shadow8);font-size:var(--fontSizeBase300);line-height:20px;font-weight:var(--fontWeightSemibold);color:var(--colorNeutralForeground1);background-color:var(--colorNeutralBackground1);}"]);
var useStyles51 = __styles2({
  inverted: {
    sj55zd: "f1w7i9ko",
    De3pzq: "f5pduvr"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f5pduvr{background-color:var(--colorNeutralBackgroundInverted);}"]
});
var useToastStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName8();
  const styles = useStyles51();
  state.root.className = mergeClasses(toastClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && styles.inverted, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/Toast/useToastContextValues.js
function useToastContextValues_unstable(state) {
  const { backgroundAppearance } = state;
  return {
    backgroundAppearance
  };
}

// node_modules/@fluentui/react-toast/lib/components/Toast/Toast.js
var Toast = React414.forwardRef((props, ref) => {
  const state = useToast_unstable(props, ref);
  useToastStyles_unstable(state);
  useCustomStyleHook("useToastStyles_unstable")(state);
  return renderToast_unstable(state, useToastContextValues_unstable(state));
});
Toast.displayName = "Toast";

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/ToastTitle.js
var React416 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitle.js
var React415 = __toESM(require_react());
var useToastTitle_unstable = (props, ref) => {
  const { intent, titleId } = useToastContainerContext();
  const backgroundAppearance = useBackgroundAppearance();
  let defaultIcon;
  switch (intent) {
    case "success":
      defaultIcon = React415.createElement(CheckmarkCircleFilled, null);
      break;
    case "error":
      defaultIcon = React415.createElement(DismissCircleFilled, null);
      break;
    case "warning":
      defaultIcon = React415.createElement(WarningFilled, null);
      break;
    case "info":
      defaultIcon = React415.createElement(InfoFilled, null);
      break;
  }
  return {
    action: slot_exports.optional(props.action, {
      elementType: "div"
    }),
    components: {
      root: "div",
      media: "div",
      action: "div"
    },
    media: slot_exports.optional(props.media, {
      renderByDefault: !!intent,
      defaultProps: {
        children: defaultIcon
      },
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      children: props.children,
      id: titleId,
      ...props
    }), {
      elementType: "div"
    }),
    intent,
    backgroundAppearance
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/renderToastTitle.js
var renderToastTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      state.media ? jsx(state.media, {}) : null,
      jsx(state.root, {}),
      state.action ? jsx(state.action, {}) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/useToastTitleStyles.styles.js
var toastTitleClassNames = {
  root: "fui-ToastTitle",
  media: "fui-ToastTitle__media",
  action: "fui-ToastTitle__action"
};
var useRootBaseClassName9 = __resetStyles("rdjap1e", null, [".rdjap1e{display:flex;grid-column-end:3;color:var(--colorNeutralForeground1);word-break:break-word;}"]);
var useMediaBaseClassName = __resetStyles("r8x5mrd", "r1soj19y", [".r8x5mrd{display:flex;padding-top:2px;grid-column-end:2;padding-right:8px;font-size:16px;color:var(--colorNeutralForeground1);}", ".r1soj19y{display:flex;padding-top:2px;grid-column-end:2;padding-left:8px;font-size:16px;color:var(--colorNeutralForeground1);}"]);
var useActionBaseClassName = __resetStyles("r2j19ip", "rjfozdo", [".r2j19ip{display:flex;align-items:start;padding-left:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}", ".rjfozdo{display:flex;align-items:start;padding-right:12px;grid-column-end:-1;color:var(--colorBrandForeground1);}"]);
var useInvertedStyles = __styles2({
  root: {
    sj55zd: "f1w7i9ko"
  },
  action: {
    sj55zd: "f1qz2gb0"
  },
  media: {
    sj55zd: "fqpbvvt"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}", ".f1qz2gb0{color:var(--colorBrandForegroundInverted);}", ".fqpbvvt{color:var(--colorNeutralForegroundInverted);}"]
});
var useIntentIconStyles = __styles2({
  success: {
    sj55zd: "f36rra6"
  },
  error: {
    sj55zd: "f1ca9wz"
  },
  warning: {
    sj55zd: "f13isgzr"
  },
  info: {
    sj55zd: "fkfq4zb"
  }
}, {
  d: [".f36rra6{color:var(--colorStatusSuccessForeground1);}", ".f1ca9wz{color:var(--colorStatusDangerForeground1);}", ".f13isgzr{color:var(--colorStatusWarningForeground1);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}"]
});
var useIntentIconStylesInverted = __styles2({
  success: {
    sj55zd: "ff3wk4x"
  },
  error: {
    sj55zd: "fbq2gqr"
  },
  warning: {
    sj55zd: "fx6hq1t"
  },
  info: {
    sj55zd: "f1w7i9ko"
  }
}, {
  d: [".ff3wk4x{color:var(--colorStatusSuccessForegroundInverted);}", ".fbq2gqr{color:var(--colorStatusDangerForegroundInverted);}", ".fx6hq1t{color:var(--colorStatusWarningForegroundInverted);}", ".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
});
var useToastTitleStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName9();
  const actionBaseClassName = useActionBaseClassName();
  const mediaBaseClassName = useMediaBaseClassName();
  const intentIconStyles = useIntentIconStyles();
  const intentIconStylesInverted = useIntentIconStylesInverted();
  const {
    intent
  } = state;
  const invertedStyles = useInvertedStyles();
  state.root.className = mergeClasses(toastTitleClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(toastTitleClassNames.media, mediaBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.media, intent && intentIconStyles[intent], intent && state.backgroundAppearance === "inverted" && intentIconStylesInverted[intent], state.media.className);
  }
  if (state.action) {
    state.action.className = mergeClasses(toastTitleClassNames.action, actionBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastTitle/ToastTitle.js
var ToastTitle = React416.forwardRef((props, ref) => {
  const state = useToastTitle_unstable(props, ref);
  useToastTitleStyles_unstable(state);
  useCustomStyleHook("useToastTitleStyles_unstable")(state);
  return renderToastTitle_unstable(state);
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@fluentui/react-toast/lib/components/ToastBody/ToastBody.js
var React418 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBody.js
var React417 = __toESM(require_react());
var useToastBody_unstable = (props, ref) => {
  const backgroundAppearance = useBackgroundAppearance();
  const { bodyId } = useToastContainerContext();
  return {
    components: {
      root: "div",
      subtitle: "div"
    },
    subtitle: slot_exports.optional(props.subtitle, {
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      id: bodyId,
      ...props
    }), {
      elementType: "div"
    }),
    backgroundAppearance
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/renderToastBody.js
var renderToastBody_unstable = (state) => {
  assertSlots(state);
  return jsxs(import_react.Fragment, {
    children: [
      jsx(state.root, {}),
      state.subtitle ? jsx(state.subtitle, {}) : null
    ]
  });
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/useToastBodyStyles.styles.js
var toastBodyClassNames = {
  root: "fui-ToastBody",
  subtitle: "fui-ToastBody__subtitle"
};
var useRootBaseClassName10 = __resetStyles("r1u44l4o", null, [".r1u44l4o{grid-column-start:2;grid-column-end:3;padding-top:6px;font-size:var(--fontSizeBase300);line-height:var(--lineHeightBase300);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground1);word-break:break-word;}"]);
var useSubtitleBaseClassName = __resetStyles("rzjw1xk", null, [".rzjw1xk{padding-top:4px;grid-column-start:2;grid-column-end:3;font-size:var(--fontSizeBase200);line-height:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);color:var(--colorNeutralForeground2);}"]);
var useInvertedStyles2 = __styles2({
  root: {
    sj55zd: "f1w7i9ko"
  },
  subtitle: {
    sj55zd: "f1w7i9ko"
  }
}, {
  d: [".f1w7i9ko{color:var(--colorNeutralForegroundInverted2);}"]
});
var useToastBodyStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName10();
  const subtitleBaseClassName = useSubtitleBaseClassName();
  const invertedStyles = useInvertedStyles2();
  state.root.className = mergeClasses(toastBodyClassNames.root, rootBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.root, state.root.className);
  if (state.subtitle) {
    state.subtitle.className = mergeClasses(toastBodyClassNames.subtitle, subtitleBaseClassName, state.backgroundAppearance === "inverted" && invertedStyles.subtitle, state.subtitle.className);
  }
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastBody/ToastBody.js
var ToastBody = React418.forwardRef((props, ref) => {
  const state = useToastBody_unstable(props, ref);
  useToastBodyStyles_unstable(state);
  useCustomStyleHook("useToastBodyStyles_unstable")(state);
  return renderToastBody_unstable(state);
});
ToastBody.displayName = "ToastBody";

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/ToastFooter.js
var React420 = __toESM(require_react());

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooter.js
var React419 = __toESM(require_react());
var useToastFooter_unstable = (props, ref) => {
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/renderToastFooter.js
var renderToastFooter_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/useToastFooterStyles.styles.js
var toastFooterClassNames = {
  root: "fui-ToastFooter"
};
var useRootBaseClassName11 = __resetStyles("r56x6h2", null, [".r56x6h2{padding-top:16px;grid-column-start:2;grid-column-end:3;display:flex;align-items:center;gap:14px;}"]);
var useToastFooterStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName11();
  state.root.className = mergeClasses(toastFooterClassNames.root, rootBaseClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-toast/lib/components/ToastFooter/ToastFooter.js
var ToastFooter = React420.forwardRef((props, ref) => {
  const state = useToastFooter_unstable(props, ref);
  useToastFooterStyles_unstable(state);
  useCustomStyleHook("useToastFooterStyles_unstable")(state);
  return renderToastFooter_unstable(state);
});
ToastFooter.displayName = "ToastFooter";

// node_modules/@fluentui/react-tree/lib/components/Tree/Tree.js
var React436 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/Tree/useTree.js
var React433 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/hooks/useControllableOpenItems.js
var React421 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/ImmutableSet.js
var internalSetSymbol = Symbol("#internalSet");
var _internalSetSymbol = internalSetSymbol;
var ImmutableSet = class _ImmutableSet {
  static dangerouslyGetInternalSet(set) {
    return set[internalSetSymbol];
  }
  static copy(immutableSet) {
    return new _ImmutableSet(new Set(immutableSet[internalSetSymbol]));
  }
  /**
  * Creates a new {@link ImmutableSet} from an iterable.
  * If the iterable is undefined, {@link ImmutableSet.empty} will be returned.
  * If the iterable is already an {@link ImmutableSet}, it will be returned as is no copy will be made.
  */
  static from(iterable) {
    if (iterable === void 0) {
      return this.empty;
    }
    if (iterable instanceof this) {
      return iterable;
    }
    return new this(new Set(iterable));
  }
  static [Symbol.hasInstance](instance) {
    return Boolean(typeof instance === "object" && instance && internalSetSymbol in instance);
  }
  add(value) {
    if (this.has(value)) {
      return this;
    }
    const copy = _ImmutableSet.copy(this);
    copy[internalSetSymbol].add(value);
    return copy;
  }
  delete(value) {
    if (!this.has(value)) {
      return this;
    }
    const copy = _ImmutableSet.copy(this);
    copy[internalSetSymbol].delete(value);
    return copy;
  }
  has(value) {
    return this[internalSetSymbol].has(value);
  }
  [Symbol.iterator]() {
    return this[internalSetSymbol].values();
  }
  /**
  * Do not use this constructor directly, use {@link ImmutableSet.from} instead.
  * {@link ImmutableSet.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
  * avoid unnecessary copies, supports iterables and ensures that the internal set is never exposed.
  *
  *  _By using this constructor directly, you might end up with a mutable set, as it is not guaranteed that the internal set is not exposed._ 
  */
  constructor(internalSet) {
    _define_property(this, "size", void 0);
    _define_property(this, _internalSetSymbol, void 0);
    this[internalSetSymbol] = internalSet;
    this.size = this[internalSetSymbol].size;
  }
};
_define_property(ImmutableSet, "empty", new ImmutableSet(/* @__PURE__ */ new Set()));

// node_modules/@fluentui/react-tree/lib/hooks/useControllableOpenItems.js
function useControllableOpenItems(props) {
  return useControllableState({
    state: React421.useMemo(() => props.openItems && ImmutableSet.from(props.openItems), [
      props.openItems
    ]),
    defaultState: props.defaultOpenItems && (() => ImmutableSet.from(props.defaultOpenItems)),
    initialState: ImmutableSet.empty
  });
}
function createNextOpenItems(data, previousOpenItems) {
  return data.open ? previousOpenItems.add(data.value) : previousOpenItems.delete(data.value);
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useNestedControllableCheckedItems.js
var React422 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/ImmutableMap.js
var internalMapSymbol = Symbol("#internalMap");
var _internalMapSymbol = internalMapSymbol;
var ImmutableMap = class _ImmutableMap {
  static dangerouslyGetInternalMap(immutableMap) {
    return immutableMap[internalMapSymbol];
  }
  static copy(immutableMap) {
    return this.from(immutableMap[internalMapSymbol]);
  }
  static from(iterable, mapFn) {
    if (iterable === void 0) {
      return this.empty;
    }
    if (!mapFn) {
      if (iterable instanceof this) {
        return iterable;
      }
      const iterableAsTuple = iterable;
      return new this(new Map(iterableAsTuple));
    }
    const map = /* @__PURE__ */ new Map();
    for (const value of iterable) {
      map.set(...mapFn(value));
    }
    return new this(map);
  }
  static [Symbol.hasInstance](instance) {
    return Boolean(typeof instance === "object" && instance && internalMapSymbol in instance);
  }
  delete(key) {
    if (!this.has(key)) {
      return this;
    }
    const copy = _ImmutableMap.copy(this);
    copy[internalMapSymbol].delete(key);
    return copy;
  }
  get(key) {
    return this[internalMapSymbol].get(key);
  }
  has(key) {
    return this[internalMapSymbol].has(key);
  }
  set(key, value) {
    if (this.get(key) === value) {
      return this;
    }
    const copy = _ImmutableMap.copy(this);
    copy[internalMapSymbol].set(key, value);
    return copy;
  }
  [Symbol.iterator]() {
    return this[internalMapSymbol].entries();
  }
  /**
  * Do not use this constructor directly, use {@link ImmutableMap.from} instead.
  * {@link ImmutableMap.from} handles instance verification (which might be problematic on {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof#instanceof_and_multiple_realms | multiple realms}),
  * avoid unnecessary copies, supports iterables and ensures that the internal map is never exposed.
  *
  *  _By using this constructor directly, you might end up with a mutable map, as it is not guaranteed that the internal map is not exposed._ 
  */
  constructor(internalMap) {
    _define_property(this, "size", void 0);
    _define_property(this, _internalMapSymbol, void 0);
    this[internalMapSymbol] = internalMap;
    this.size = this[internalMapSymbol].size;
  }
};
_define_property(ImmutableMap, "empty", new ImmutableMap(/* @__PURE__ */ new Map()));

// node_modules/@fluentui/react-tree/lib/utils/createCheckedItems.js
var tuplifyCheckedItem = (value) => Array.isArray(value) ? value : [
  value,
  true
];
var createCheckedItems = (iterable) => ImmutableMap.from(iterable, tuplifyCheckedItem);

// node_modules/@fluentui/react-tree/lib/components/Tree/useNestedControllableCheckedItems.js
function useNestedCheckedItems(props) {
  return React422.useMemo(() => createCheckedItems(props.checkedItems), [
    props.checkedItems
  ]);
}
function createNextNestedCheckedItems(data, previousCheckedItems) {
  if (data.selectionMode === "single") {
    return ImmutableMap.from([
      [
        data.value,
        data.checked
      ]
    ]);
  }
  if (data.selectionMode === "multiselect") {
    return previousCheckedItems.set(data.value, data.checked);
  }
  return previousCheckedItems;
}

// node_modules/@fluentui/react-tree/lib/contexts/subtreeContext.js
var React423 = __toESM(require_react());
var defaultSubTreeContextValue = {
  level: 0,
  contextType: "subtree"
};
var SubtreeContext = React423.createContext(void 0);
var useSubtreeContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React423.useContext(SubtreeContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSubTreeContextValue;
};

// node_modules/@fluentui/react-tree/lib/hooks/useRootTree.js
var React424 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/tokens.js
var treeItemLevelToken = "--fluent-TreeItem--level";
var treeAvatarSize = {
  medium: 32,
  small: 24
};
var treeDataTypes = {
  ArrowLeft,
  ArrowRight,
  Enter,
  Click: "Click",
  ExpandIconClick: "ExpandIconClick",
  End,
  Home,
  ArrowUp,
  ArrowDown,
  TypeAhead: "TypeAhead",
  Change: "Change"
};

// node_modules/@fluentui/react-tree/lib/hooks/useRootTree.js
function useRootTree(props, ref) {
  warnIfNoProperPropsRootTree(props);
  const { appearance = "subtle", size: size3 = "medium", selectionMode = "none" } = props;
  const openItems = React424.useMemo(() => ImmutableSet.from(props.openItems), [
    props.openItems
  ]);
  const checkedItems = React424.useMemo(() => createCheckedItems(props.checkedItems), [
    props.checkedItems
  ]);
  const requestOpenChange = (request) => {
    var _props_onOpenChange;
    (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, request.event, {
      ...request,
      openItems: ImmutableSet.dangerouslyGetInternalSet(createNextOpenItems(request, openItems))
    });
  };
  const requestCheckedChange = (request) => {
    var _props_onCheckedChange;
    if (selectionMode === "none") {
      return;
    }
    (_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 ? void 0 : _props_onCheckedChange.call(props, request.event, {
      ...request,
      selectionMode,
      checkedItems: ImmutableMap.dangerouslyGetInternalMap(checkedItems)
    });
  };
  const requestNavigation = (request) => {
    var _props_onNavigation;
    let isScrollPrevented = false;
    (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, request.event, {
      ...request,
      preventScroll: () => {
        isScrollPrevented = true;
      },
      isScrollPrevented: () => isScrollPrevented
    });
    switch (request.type) {
      case treeDataTypes.ArrowDown:
      case treeDataTypes.ArrowUp:
      case treeDataTypes.Home:
      case treeDataTypes.End:
        request.event.preventDefault();
    }
  };
  const requestTreeResponse = useEventCallback((request) => {
    switch (request.requestType) {
      case "navigate":
        return requestNavigation(request);
      case "open":
        return requestOpenChange(request);
      case "selection":
        return requestCheckedChange(request);
    }
  });
  var _props_navigationMode;
  return {
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    contextType: "root",
    selectionMode,
    navigationMode: (_props_navigationMode = props.navigationMode) !== null && _props_navigationMode !== void 0 ? _props_navigationMode : "tree",
    open: true,
    appearance,
    size: size3,
    level: 1,
    openItems,
    checkedItems,
    requestTreeResponse,
    forceUpdateRovingTabIndex: () => {
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref,
      role: "tree",
      "aria-multiselectable": selectionMode === "multiselect" ? true : void 0,
      ...props
    }), {
      elementType: "div"
    }),
    collapseMotion: void 0
  };
}
function warnIfNoProperPropsRootTree(props) {
  if (true) {
    if (!props["aria-label"] && !props["aria-labelledby"]) {
      console.warn(`@fluentui/react-tree [useRootTree]:
Tree must have either a \`aria-label\` or \`aria-labelledby\` property defined`);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/hooks/useSubtree.js
var React426 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/contexts/treeContext.js
var defaultTreeContextValue = {
  level: 0,
  contextType: "root",
  treeType: "nested",
  selectionMode: "none",
  openItems: ImmutableSet.empty,
  checkedItems: ImmutableMap.empty,
  requestTreeResponse: noop9,
  forceUpdateRovingTabIndex: noop9,
  appearance: "subtle",
  size: "medium",
  navigationMode: "tree"
};
function noop9() {
}
var TreeContext = createContext13(void 0);
var useTreeContext_unstable = (selector) => useContextSelector(TreeContext, (ctx = defaultTreeContextValue) => selector(ctx));

// node_modules/@fluentui/react-tree/lib/contexts/treeItemContext.js
var React425 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/createHeadlessTree.js
function createHeadlessTree(initialProps = []) {
  const root = createHeadlessTreeRootItem();
  const itemsPerValue = /* @__PURE__ */ new Map([
    [
      root.value,
      root
    ]
  ]);
  const headlessTree = {
    root,
    get size() {
      return itemsPerValue.size;
    },
    getParent: (key) => {
      var _itemsPerValue_get;
      var _itemsPerValue_get_parentValue, _itemsPerValue_get1;
      return (_itemsPerValue_get1 = itemsPerValue.get((_itemsPerValue_get_parentValue = (_itemsPerValue_get = itemsPerValue.get(key)) === null || _itemsPerValue_get === void 0 ? void 0 : _itemsPerValue_get.parentValue) !== null && _itemsPerValue_get_parentValue !== void 0 ? _itemsPerValue_get_parentValue : root.value)) !== null && _itemsPerValue_get1 !== void 0 ? _itemsPerValue_get1 : root;
    },
    get: (key) => itemsPerValue.get(key),
    has: (key) => itemsPerValue.has(key),
    add(props) {
      const { parentValue = headlessTreeRootId, ...propsWithoutParentValue } = props;
      const parentItem = itemsPerValue.get(parentValue);
      if (!parentItem) {
        if (true) {
          console.error(`@fluentui/react-tree [createHeadlessTree]:
TreeItem "${props.value}" is wrongly positioned, did you properly ordered provided item props? make sure provided items are organized, parents should come before children`);
        }
        return;
      }
      parentItem.itemType = "branch";
      var _propsWithoutParentValue_itemType;
      const item = {
        value: props.value,
        getTreeItemProps: () => ({
          ...propsWithoutParentValue,
          parentValue,
          "aria-level": item.level,
          "aria-posinset": item.position,
          "aria-setsize": parentItem.childrenValues.length,
          itemType: item.itemType
        }),
        itemType: (_propsWithoutParentValue_itemType = propsWithoutParentValue.itemType) !== null && _propsWithoutParentValue_itemType !== void 0 ? _propsWithoutParentValue_itemType : "leaf",
        level: parentItem.level + 1,
        parentValue,
        childrenValues: [],
        index: -1,
        position: parentItem.childrenValues.push(props.value)
      };
      itemsPerValue.set(item.value, item);
    },
    subtree: (key) => HeadlessTreeSubtreeGenerator(key, headlessTree),
    children: (key) => HeadlessTreeChildrenGenerator(key, headlessTree),
    ancestors: (key) => HeadlessTreeAncestorsGenerator(key, headlessTree),
    visibleItems: (openItems) => HeadlessTreeVisibleItemsGenerator(openItems, headlessTree)
  };
  initialProps.forEach(headlessTree.add);
  return headlessTree;
}
var headlessTreeRootId = "__fuiHeadlessTreeRoot";
function createHeadlessTreeRootItem() {
  return {
    parentValue: void 0,
    value: headlessTreeRootId,
    itemType: "branch",
    getTreeItemProps: () => {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return {
        id: headlessTreeRootId,
        parentValue: void 0,
        value: headlessTreeRootId,
        "aria-setsize": -1,
        "aria-level": -1,
        "aria-posinset": -1,
        itemType: "branch"
      };
    },
    childrenValues: [],
    get index() {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return -1;
    },
    get position() {
      if (true) {
        console.error(`@fluentui/react-tree [createHeadlessTree]:
Internal error, trying to access treeitem props from invalid root element`);
      }
      return -1;
    },
    level: 0
  };
}
function* HeadlessTreeSubtreeGenerator(key, virtualTreeItems) {
  const item = virtualTreeItems.get(key);
  if (!item || item.childrenValues.length === 0) {
    return;
  }
  for (const childValue of item.childrenValues) {
    yield virtualTreeItems.get(childValue);
    yield* HeadlessTreeSubtreeGenerator(childValue, virtualTreeItems);
  }
}
function* HeadlessTreeChildrenGenerator(key, virtualTreeItems) {
  const item = virtualTreeItems.get(key);
  if (!item || item.childrenValues.length === 0) {
    return;
  }
  for (const childValue of item.childrenValues) {
    yield virtualTreeItems.get(childValue);
  }
}
function* HeadlessTreeAncestorsGenerator(key, virtualTreeItems) {
  let parent2 = virtualTreeItems.getParent(key);
  while (parent2 !== virtualTreeItems.root) {
    yield parent2;
    parent2 = virtualTreeItems.getParent(parent2.value);
  }
}
function* HeadlessTreeVisibleItemsGenerator(openItems, virtualTreeItems) {
  let index = 0;
  for (const item of recursiveVisibleItems(virtualTreeItems.root.value, openItems, virtualTreeItems)) {
    item.index = index++;
    yield item;
  }
}
function* recursiveVisibleItems(parentValue, openItems, virtualTreeItems) {
  const parent2 = virtualTreeItems.get(parentValue);
  if (!parent2 || parent2.childrenValues.length === 0) {
    return;
  }
  for (const childValue of parent2.childrenValues) {
    const child = virtualTreeItems.get(childValue);
    if (!child) {
      continue;
    }
    if (isItemVisible(child, openItems, virtualTreeItems)) {
      yield child;
      if (openItems.has(childValue)) {
        yield* recursiveVisibleItems(childValue, openItems, virtualTreeItems);
      }
    }
  }
}
function isItemVisible(item, openItems, virtualTreeItems) {
  if (item.level === 1) {
    return true;
  }
  while (item.parentValue && item.parentValue !== virtualTreeItems.root.value) {
    if (!openItems.has(item.parentValue)) {
      return false;
    }
    const parent2 = virtualTreeItems.get(item.parentValue);
    if (!parent2) {
      return false;
    }
    item = parent2;
  }
  return true;
}

// node_modules/@fluentui/react-tree/lib/contexts/treeItemContext.js
var defaultContextValue3 = {
  value: headlessTreeRootId,
  selectionRef: React425.createRef(),
  layoutRef: React425.createRef(),
  treeItemRef: React425.createRef(),
  subtreeRef: React425.createRef(),
  actionsRef: React425.createRef(),
  expandIconRef: React425.createRef(),
  isActionsVisible: false,
  isAsideVisible: false,
  itemType: "leaf",
  open: false,
  checked: false
};
var TreeItemContext = createContext13(void 0);
var { Provider: TreeItemProvider } = TreeItemContext;
var useTreeItemContext_unstable = (selector) => useContextSelector(TreeItemContext, (ctx = defaultContextValue3) => selector(ctx));

// node_modules/@fluentui/react-tree/lib/hooks/useSubtree.js
function useSubtree(props, ref) {
  const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
  const { level: parentLevel } = useSubtreeContext_unstable();
  const open = useTreeItemContext_unstable((ctx) => ctx.open);
  return {
    contextType: "subtree",
    open,
    components: {
      root: "div",
      collapseMotion: Collapse
    },
    level: parentLevel + 1,
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, subtreeRef),
      role: "group",
      ...props
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: Collapse,
      defaultProps: {
        visible: open,
        unmountOnExit: true
      }
    })
  };
}

// node_modules/@fluentui/react-tree/lib/utils/nextTypeAheadElement.js
function nextTypeAheadElement(treeWalker, key) {
  const keyToLowerCase = key.toLowerCase();
  const typeAheadFilter = (element) => {
    var _element_textContent;
    return ((_element_textContent = element.textContent) === null || _element_textContent === void 0 ? void 0 : _element_textContent.trim().charAt(0).toLowerCase()) === keyToLowerCase ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  };
  let nextElement = treeWalker.nextElement(typeAheadFilter);
  if (!nextElement) {
    treeWalker.currentElement = treeWalker.root;
    nextElement = treeWalker.nextElement(typeAheadFilter);
  }
  return nextElement;
}

// node_modules/@fluentui/react-tree/lib/hooks/useRovingTabIndexes.js
var React427 = __toESM(require_react());
var findTreeItemRoot = (element) => {
  let parent2 = element.parentElement;
  while (parent2 && parent2.getAttribute("role") !== "tree") {
    parent2 = parent2.parentElement;
  }
  return parent2;
};
function useRovingTabIndex() {
  const currentElementRef = React427.useRef(null);
  const walkerRef = React427.useRef(null);
  const { targetDocument } = useFluent();
  useFocusedElementChange((element) => {
    if ((element === null || element === void 0 ? void 0 : element.getAttribute("role")) === "treeitem" && walkerRef.current && walkerRef.current.root.contains(element)) {
      const treeitemRoot = findTreeItemRoot(element);
      if (walkerRef.current.root !== treeitemRoot) {
        return;
      }
      rove(element);
    }
  });
  const initialize = React427.useCallback((walker) => {
    walkerRef.current = walker;
    walker.currentElement = walker.root;
    let tabbableChild = walker.firstChild((element) => element.tabIndex === 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);
    walker.currentElement = walker.root;
    tabbableChild !== null && tabbableChild !== void 0 ? tabbableChild : tabbableChild = walker.firstChild();
    if (!tabbableChild) {
      return;
    }
    tabbableChild.tabIndex = 0;
    currentElementRef.current = tabbableChild;
    let nextElement = null;
    while ((nextElement = walker.nextElement()) && nextElement !== tabbableChild) {
      nextElement.tabIndex = -1;
    }
  }, []);
  const rove = React427.useCallback((nextElement, focusOptions) => {
    if (!currentElementRef.current) {
      return;
    }
    currentElementRef.current.tabIndex = -1;
    nextElement.tabIndex = 0;
    nextElement.focus(focusOptions);
    currentElementRef.current = nextElement;
  }, []);
  const forceUpdate = React427.useCallback(() => {
    if ((currentElementRef.current === null || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body.contains(currentElementRef.current))) && walkerRef.current) {
      initialize(walkerRef.current);
    }
  }, [
    targetDocument,
    initialize
  ]);
  return {
    rove,
    initialize,
    forceUpdate
  };
}

// node_modules/@fluentui/react-tree/lib/hooks/useTreeNavigation.js
var React432 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/hooks/useHTMLElementWalkerRef.js
var React428 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/createHTMLElementWalker.js
function createHTMLElementWalker(root, targetDocument, filter = () => NodeFilter.FILTER_ACCEPT) {
  let temporaryFilter;
  const treeWalker = targetDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      if (!isHTMLElement(node)) {
        return NodeFilter.FILTER_REJECT;
      }
      const filterResult = filter(node);
      var _temporaryFilter;
      return filterResult === NodeFilter.FILTER_ACCEPT ? (_temporaryFilter = temporaryFilter === null || temporaryFilter === void 0 ? void 0 : temporaryFilter(node)) !== null && _temporaryFilter !== void 0 ? _temporaryFilter : filterResult : filterResult;
    }
  });
  return {
    get root() {
      return treeWalker.root;
    },
    get currentElement() {
      return treeWalker.currentNode;
    },
    set currentElement(element) {
      treeWalker.currentNode = element;
    },
    firstChild: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.firstChild();
      temporaryFilter = void 0;
      return result;
    },
    lastChild: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.lastChild();
      temporaryFilter = void 0;
      return result;
    },
    nextElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.nextNode();
      temporaryFilter = void 0;
      return result;
    },
    nextSibling: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.nextSibling();
      temporaryFilter = void 0;
      return result;
    },
    parentElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.parentNode();
      temporaryFilter = void 0;
      return result;
    },
    previousElement: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.previousNode();
      temporaryFilter = void 0;
      return result;
    },
    previousSibling: (localFilter) => {
      temporaryFilter = localFilter;
      const result = treeWalker.previousSibling();
      temporaryFilter = void 0;
      return result;
    }
  };
}

// node_modules/@fluentui/react-tree/lib/utils/treeItemFilter.js
var treeItemFilter = (element) => {
  return element.getAttribute("role") === "treeitem" ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
};

// node_modules/@fluentui/react-tree/lib/hooks/useHTMLElementWalkerRef.js
function useHTMLElementWalkerRef() {
  const { targetDocument } = useFluent();
  const walkerRef = React428.useRef(void 0);
  const rootRef = React428.useCallback((root) => {
    walkerRef.current = targetDocument && root ? createHTMLElementWalker(root, targetDocument, treeItemFilter) : void 0;
  }, [
    targetDocument
  ]);
  return {
    walkerRef,
    rootRef
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/TreeItemLayout.js
var React431 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js
var React430 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemChevron.js
var React429 = __toESM(require_react());
var TreeItemChevron = React429.memo(() => {
  const open = useTreeItemContext_unstable((ctx) => ctx.open);
  const { dir } = useFluent();
  const expandIconRotation = open ? 90 : dir !== "rtl" ? 0 : 180;
  return React429.createElement(ChevronRight12Regular, {
    style: {
      ...expandIconInlineStyles[expandIconRotation],
      transition: `transform ${durations2.durationNormal}ms ${curves2.curveEasyEaseMax}`
    }
  });
});
TreeItemChevron.displayName = "TreeItemChevron";
var expandIconInlineStyles = {
  90: {
    transform: `rotate(90deg)`
  },
  0: {
    transform: `rotate(0deg)`
  },
  180: {
    transform: `rotate(180deg)`
  }
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js
var useTreeItemLayout_unstable = (props, ref) => {
  "use no memo";
  const { main, iconAfter, iconBefore } = props;
  const layoutRef = useTreeItemContext_unstable((ctx) => ctx.layoutRef);
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  const navigationMode = useTreeContext_unstable((ctx) => {
    var _ctx_navigationMode;
    return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
  });
  const [isActionsVisibleFromProps, onActionVisibilityChange] = isResolvedShorthand(props.actions) ? [
    props.actions.visible,
    props.actions.onVisibilityChange
  ] : [
    void 0,
    void 0
  ];
  const [isActionsVisible, setIsActionsVisible] = useControllableState({
    state: isActionsVisibleFromProps,
    initialState: false
  });
  const selectionRef = useTreeItemContext_unstable((ctx) => ctx.selectionRef);
  const expandIconRef = useTreeItemContext_unstable((ctx) => ctx.expandIconRef);
  const actionsRef = useTreeItemContext_unstable((ctx) => ctx.actionsRef);
  const actionsRefInternal = React430.useRef(null);
  const treeItemRef = useTreeItemContext_unstable((ctx) => ctx.treeItemRef);
  const subtreeRef = useTreeItemContext_unstable((ctx) => ctx.subtreeRef);
  const checked = useTreeItemContext_unstable((ctx) => ctx.checked);
  const isBranch = useTreeItemContext_unstable((ctx) => ctx.itemType === "branch");
  assertIsRefObject(treeItemRef);
  assertIsRefObject(subtreeRef);
  const setActionsVisibleIfNotFromSubtree = React430.useCallback((event) => {
    const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));
    if (!isTargetFromSubtree) {
      onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
        visible: true,
        event,
        type: event.type
      });
      if (event.defaultPrevented) {
        return;
      }
      setIsActionsVisible(true);
    }
  }, [
    subtreeRef,
    setIsActionsVisible,
    onActionVisibilityChange
  ]);
  const { targetDocument } = useFluent();
  const isNavigatingWithKeyboard = useIsNavigatingWithKeyboard();
  const setActionsInvisibleIfNotFromSubtree = React430.useCallback((event) => {
    const isRelatedTargetFromActions = () => Boolean(actionsRefInternal.current && elementContains(actionsRefInternal.current, event.relatedTarget));
    const isRelatedTargetFromTreeItem = () => Boolean(treeItemRef.current && elementContains(treeItemRef.current, event.relatedTarget));
    const isTargetFromActions = () => {
      var _actionsRefInternal_current;
      return Boolean((_actionsRefInternal_current = actionsRefInternal.current) === null || _actionsRefInternal_current === void 0 ? void 0 : _actionsRefInternal_current.contains(event.target));
    };
    if (isRelatedTargetFromActions()) {
      onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
        visible: true,
        event,
        type: event.type
      });
      if (event.defaultPrevented) {
        return;
      }
      setIsActionsVisible(true);
      return;
    }
    if (isTargetFromActions() && isRelatedTargetFromTreeItem()) {
      return;
    }
    if (event.type === "mouseout" && isNavigatingWithKeyboard() && ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === treeItemRef.current || elementContains(actionsRefInternal.current, targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement))) {
      return;
    }
    onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
      visible: false,
      event,
      type: event.type
    });
    if (event.defaultPrevented) {
      return;
    }
    setIsActionsVisible(false);
  }, [
    setIsActionsVisible,
    onActionVisibilityChange,
    treeItemRef,
    isNavigatingWithKeyboard,
    targetDocument
  ]);
  const expandIcon = slot_exports.optional(props.expandIcon, {
    renderByDefault: isBranch,
    defaultProps: {
      children: React430.createElement(TreeItemChevron, null),
      "aria-hidden": true
    },
    elementType: "div"
  });
  const expandIconRefs = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
  if (expandIcon) {
    expandIcon.ref = expandIconRefs;
  }
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: navigationMode === "tree",
    axis: "horizontal"
  });
  const actions = isActionsVisible ? slot_exports.optional(props.actions, {
    defaultProps: {
      ...arrowNavigationProps,
      role: "toolbar"
    },
    elementType: "div"
  }) : void 0;
  actions === null || actions === void 0 ? true : delete actions.visible;
  actions === null || actions === void 0 ? true : delete actions.onVisibilityChange;
  const actionsRefs = useMergedRefs(actions === null || actions === void 0 ? void 0 : actions.ref, actionsRef, actionsRefInternal);
  const handleActionsBlur = useEventCallback((event) => {
    if (isResolvedShorthand(props.actions)) {
      var _props_actions_onBlur, _props_actions;
      (_props_actions_onBlur = (_props_actions = props.actions).onBlur) === null || _props_actions_onBlur === void 0 ? void 0 : _props_actions_onBlur.call(_props_actions, event);
    }
    const isRelatedTargetFromActions = Boolean(elementContains(event.currentTarget, event.relatedTarget));
    onActionVisibilityChange === null || onActionVisibilityChange === void 0 ? void 0 : onActionVisibilityChange(event, {
      visible: isRelatedTargetFromActions,
      event,
      type: event.type
    });
    setIsActionsVisible(isRelatedTargetFromActions);
  });
  if (actions) {
    actions.ref = actionsRefs;
    actions.onBlur = handleActionsBlur;
  }
  const hasActions = Boolean(props.actions);
  React430.useEffect(() => {
    if (treeItemRef.current && hasActions) {
      const treeItemElement = treeItemRef.current;
      const handleMouseOver = setActionsVisibleIfNotFromSubtree;
      const handleMouseOut = setActionsInvisibleIfNotFromSubtree;
      const handleFocus = setActionsVisibleIfNotFromSubtree;
      const handleBlur = setActionsInvisibleIfNotFromSubtree;
      treeItemElement.addEventListener("mouseover", handleMouseOver);
      treeItemElement.addEventListener("mouseout", handleMouseOut);
      treeItemElement.addEventListener("focus", handleFocus);
      treeItemElement.addEventListener("blur", handleBlur);
      return () => {
        treeItemElement.removeEventListener("mouseover", handleMouseOver);
        treeItemElement.removeEventListener("mouseout", handleMouseOut);
        treeItemElement.removeEventListener("focus", handleFocus);
        treeItemElement.removeEventListener("blur", handleBlur);
      };
    }
  }, [
    hasActions,
    treeItemRef,
    setActionsVisibleIfNotFromSubtree,
    setActionsInvisibleIfNotFromSubtree
  ]);
  return {
    components: {
      root: "div",
      expandIcon: "div",
      iconBefore: "div",
      main: "div",
      iconAfter: "div",
      actions: "div",
      aside: "div",
      // Casting here to a union between checkbox and radio
      selector: selectionMode === "multiselect" ? Checkbox : Radio
    },
    buttonContextValue: {
      size: "small"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, layoutRef)
    }), {
      elementType: "div"
    }),
    iconBefore: slot_exports.optional(iconBefore, {
      elementType: "div"
    }),
    main: slot_exports.always(main, {
      elementType: "div"
    }),
    iconAfter: slot_exports.optional(iconAfter, {
      elementType: "div"
    }),
    aside: !isActionsVisible ? slot_exports.optional(props.aside, {
      elementType: "div"
    }) : void 0,
    actions,
    expandIcon,
    selector: slot_exports.optional(props.selector, {
      renderByDefault: selectionMode !== "none",
      defaultProps: {
        checked,
        tabIndex: -1,
        "aria-hidden": true,
        ref: selectionRef
      },
      elementType: selectionMode === "multiselect" ? Checkbox : Radio
    })
  };
};
function assertIsRefObject(ref) {
  if (true) {
    if (typeof ref !== "object" || ref === null || !("current" in ref)) {
      throw new Error(`
        @fluentui/react-tree [${useTreeItemLayout_unstable.name}]:
        Internal Error: contextual ref is not a RefObject! Please report this bug immediately, as contextual refs should be RefObjects.
      `);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/renderTreeItemLayout.js
var renderTreeItemLayout_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.expandIcon && jsx(state.expandIcon, {}),
      state.selector && jsx(state.selector, {}),
      state.iconBefore && jsx(state.iconBefore, {}),
      jsx(state.main, {
        children: state.root.children
      }),
      state.iconAfter && jsx(state.iconAfter, {}),
      jsxs(ButtonContextProvider, {
        value: state.buttonContextValue,
        children: [
          state.actions && jsx(state.actions, {}),
          state.aside && jsx(state.aside, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayoutStyles.styles.js
var treeItemLayoutClassNames = {
  root: "fui-TreeItemLayout",
  iconBefore: "fui-TreeItemLayout__iconBefore",
  main: "fui-TreeItemLayout__main",
  iconAfter: "fui-TreeItemLayout__iconAfter",
  expandIcon: "fui-TreeItemLayout__expandIcon",
  aside: "fui-TreeItemLayout__aside",
  actions: "fui-TreeItemLayout__actions",
  selector: "fui-TreeItemLayout__selector"
};
var useRootBaseStyles2 = __resetStyles("ryb8khq", null, [".ryb8khq{display:flex;align-items:center;min-height:32px;box-sizing:border-box;grid-area:layout;}", ".ryb8khq:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}", ".ryb8khq:hover .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}", ".ryb8khq:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".ryb8khq:active .fui-TreeItemLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}"]);
var useRootStyles18 = __styles2({
  leaf: {
    uwmqm3: ["f1k1erfc", "faevyjx"]
  },
  branch: {
    uwmqm3: ["fo100m9", "f6yw3pu"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  subtle: {},
  "subtle-alpha": {
    Jwef8y: "f146ro5n",
    ecr2s2: "fkam630"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    Jwef8y: "fjxutwb",
    ecr2s2: "fophhak"
  }
}, {
  d: [".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1pha7fy{min-height:24px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}"],
  h: [".f146ro5n:hover{background-color:var(--colorSubtleBackgroundLightAlphaHover);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}"],
  a: [".fkam630:active{background-color:var(--colorSubtleBackgroundLightAlphaPressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}"]
});
var useActionsBaseStyles = __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
var useAsideBaseStyles = __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
var useExpandIconBaseStyles = __resetStyles("rh4pu5o", null, [".rh4pu5o{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
var useMainBaseStyles = __resetStyles("rklbe47", null, [".rklbe47{padding:0 var(--spacingHorizontalXXS);}"]);
var useIconBaseStyles2 = __resetStyles("rphzgg1", null, [".rphzgg1{display:flex;align-items:center;color:var(--colorNeutralForeground2);line-height:var(--lineHeightBase500);font-size:var(--fontSizeBase500);}"]);
var useIconBeforeStyles = __styles2({
  medium: {
    z189sj: ["f7x41pl", "fruq291"]
  },
  small: {
    z189sj: ["ffczdla", "fgiv446"]
  }
}, {
  d: [".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}"]
});
var useIconAfterStyles = __styles2({
  medium: {
    uwmqm3: ["fruq291", "f7x41pl"]
  },
  small: {
    uwmqm3: ["fgiv446", "ffczdla"]
  }
}, {
  d: [".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}"]
});
var useTreeItemLayoutStyles_unstable = (state) => {
  "use no memo";
  const {
    main,
    iconAfter,
    iconBefore,
    expandIcon,
    root,
    aside,
    actions,
    selector
  } = state;
  const rootStyles = useRootStyles18();
  const rootBaseStyles = useRootBaseStyles2();
  const actionsBaseStyles = useActionsBaseStyles();
  const asideBaseStyles = useAsideBaseStyles();
  const mainBaseStyles = useMainBaseStyles();
  const expandIconBaseStyles = useExpandIconBaseStyles();
  const iconBaseStyles = useIconBaseStyles2();
  const iconBeforeStyles = useIconBeforeStyles();
  const iconAfterStyles = useIconAfterStyles();
  const size3 = useTreeContext_unstable((ctx) => ctx.size);
  const appearance = useTreeContext_unstable((ctx) => ctx.appearance);
  const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
  root.className = mergeClasses(treeItemLayoutClassNames.root, rootBaseStyles, rootStyles[appearance], rootStyles[size3], rootStyles[itemType], root.className);
  main.className = mergeClasses(treeItemLayoutClassNames.main, mainBaseStyles, main.className);
  if (expandIcon) {
    expandIcon.className = mergeClasses(treeItemLayoutClassNames.expandIcon, expandIconBaseStyles, expandIcon.className);
  }
  if (iconBefore) {
    iconBefore.className = mergeClasses(treeItemLayoutClassNames.iconBefore, iconBaseStyles, iconBeforeStyles[size3], iconBefore.className);
  }
  if (iconAfter) {
    iconAfter.className = mergeClasses(treeItemLayoutClassNames.iconAfter, iconBaseStyles, iconAfterStyles[size3], iconAfter.className);
  }
  if (actions) {
    actions.className = mergeClasses(treeItemLayoutClassNames.actions, actionsBaseStyles, actions.className);
  }
  if (aside) {
    aside.className = mergeClasses(treeItemLayoutClassNames.aside, asideBaseStyles, aside.className);
  }
  if (selector) {
    selector.className = mergeClasses(treeItemLayoutClassNames.selector, selector.className);
  }
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/TreeItemLayout.js
var TreeItemLayout = React431.forwardRef((props, ref) => {
  const state = useTreeItemLayout_unstable(props, ref);
  useTreeItemLayoutStyles_unstable(state);
  useCustomStyleHook("useTreeItemLayoutStyles_unstable")(state);
  return renderTreeItemLayout_unstable(state);
});
TreeItemLayout.displayName = "TreeItemLayout";

// node_modules/@fluentui/react-tree/lib/hooks/useTreeNavigation.js
function useTreeNavigation(navigationMode = "tree") {
  "use no memo";
  const { rove, initialize: initializeRovingTabIndex, forceUpdate: forceUpdateRovingTabIndex } = useRovingTabIndex();
  const { findFirstFocusable } = useFocusFinders();
  const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
  const rootRefCallback = React432.useCallback((root) => {
    if (root && walkerRef.current) {
      initializeRovingTabIndex(walkerRef.current);
    }
  }, [
    walkerRef,
    initializeRovingTabIndex
  ]);
  const getNextElement = (data) => {
    if (!walkerRef.current) {
      return null;
    }
    switch (data.type) {
      case treeDataTypes.Click:
        return data.target;
      case treeDataTypes.TypeAhead:
        walkerRef.current.currentElement = data.target;
        return nextTypeAheadElement(walkerRef.current, data.event.key);
      case treeDataTypes.ArrowLeft: {
        const actions = queryActions(data.target);
        if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) {
          return data.target;
        }
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.parentElement();
      }
      case treeDataTypes.ArrowRight:
        if (navigationMode === "treegrid") {
          const actions = queryActions(data.target);
          if (actions) {
            var _findFirstFocusable;
            (_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
          }
          return null;
        }
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.firstChild();
      case treeDataTypes.End:
        walkerRef.current.currentElement = walkerRef.current.root;
        return lastChildRecursive(walkerRef.current);
      case treeDataTypes.Home:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.firstChild();
      case treeDataTypes.ArrowDown:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.nextElement();
      case treeDataTypes.ArrowUp:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.previousElement();
    }
  };
  function navigate(data, focusOptions) {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement, focusOptions);
    }
    return nextElement;
  }
  return {
    navigate,
    treeRef: useMergedRefs(walkerRootRef, rootRefCallback),
    forceUpdateRovingTabIndex
  };
}
function lastChildRecursive(walker) {
  let lastElement = null;
  let nextElement = null;
  while (nextElement = walker.lastChild()) {
    lastElement = nextElement;
  }
  return lastElement;
}
var queryActions = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

// node_modules/@fluentui/react-tree/lib/components/Tree/useTree.js
var useTree_unstable = (props, ref) => {
  "use no memo";
  const isRoot = React433.useContext(SubtreeContext) === void 0;
  return isRoot ? useNestedRootTree(props, ref) : useNestedSubtree(props, ref);
};
function useNestedRootTree(props, ref) {
  "use no memo";
  const [openItems, setOpenItems] = useControllableOpenItems(props);
  const checkedItems = useNestedCheckedItems(props);
  const navigation = useTreeNavigation(props.navigationMode);
  return Object.assign(useRootTree({
    ...props,
    openItems,
    checkedItems,
    onOpenChange: useEventCallback((event, data) => {
      var _props_onOpenChange;
      const nextOpenItems = createNextOpenItems(data, openItems);
      (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, {
        ...data,
        openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
      });
      setOpenItems(nextOpenItems);
    }),
    onNavigation: useEventCallback((event, data) => {
      var _props_onNavigation;
      (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, event, data);
      if (!event.isDefaultPrevented()) {
        navigation.navigate(data, {
          preventScroll: data.isScrollPrevented()
        });
      }
    }),
    onCheckedChange: useEventCallback((event, data) => {
      var _props_onCheckedChange;
      const nextCheckedItems = createNextNestedCheckedItems(data, checkedItems);
      (_props_onCheckedChange = props.onCheckedChange) === null || _props_onCheckedChange === void 0 ? void 0 : _props_onCheckedChange.call(props, event, {
        ...data,
        checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
      });
    })
  }, useMergedRefs(ref, navigation.treeRef)), {
    treeType: "nested",
    forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
  });
}
function useNestedSubtree(props, ref) {
  "use no memo";
  if (true) {
    const treeType = useTreeContext_unstable((ctx) => ctx.treeType);
    if (treeType === "flat") {
      throw new Error(`@fluentui/react-tree [useTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <Tree> component inside of a <FlatTree> component!`);
    }
  }
  return useSubtree(props, ref);
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useTreeContextValues.js
var React434 = __toESM(require_react());
function useTreeContextValues_unstable(state) {
  "use no memo";
  if (state.contextType === "root") {
    const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size3, requestTreeResponse, forceUpdateRovingTabIndex } = state;
    const tree = {
      treeType,
      size: size3,
      openItems,
      appearance,
      checkedItems,
      selectionMode,
      navigationMode,
      contextType,
      level,
      requestTreeResponse,
      forceUpdateRovingTabIndex
    };
    return {
      tree
    };
  }
  return {
    // contextType is statically determined by the context
    // eslint-disable-next-line react-hooks/rules-of-hooks
    tree: React434.useMemo(() => ({
      level: state.level,
      contextType: "subtree"
    }), [
      state.level
    ])
  };
}

// node_modules/@fluentui/react-tree/lib/components/Tree/useTreeStyles.styles.js
var treeClassNames = {
  root: "fui-Tree"
};
var useBaseStyles6 = __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
var useStyles52 = __styles2({
  subtree: {
    z8tnut: "fclwglc"
  }
}, {
  d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}"]
});
var useTreeStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles6();
  const styles = useStyles52();
  const isSubTree = state.level > 1;
  state.root.className = mergeClasses(treeClassNames.root, baseStyles3, isSubTree && styles.subtree, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeProvider.js
var React435 = __toESM(require_react());
var rootSubtreeContextValue = {
  level: 1,
  contextType: "subtree"
};
var TreeProvider = (props) => {
  if (props.value.contextType === "subtree") {
    return React435.createElement(SubtreeContext.Provider, {
      value: props.value
    }, props.children);
  }
  return React435.createElement(TreeContext.Provider, {
    value: props.value
  }, React435.createElement(SubtreeContext.Provider, {
    value: rootSubtreeContextValue
  }, props.children));
};
TreeProvider.displayName = "TreeProvider";
var TreeRootReset = (props) => React435.createElement(SubtreeContext.Provider, {
  value: void 0
}, props.children);

// node_modules/@fluentui/react-tree/lib/components/Tree/renderTree.js
var renderTree_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(TreeProvider, {
    value: contextValues.tree,
    children: state.collapseMotion ? jsx(state.collapseMotion, {
      children: jsx(state.root, {})
    }) : jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tree/lib/components/Tree/Tree.js
var Tree = React436.forwardRef((props, ref) => {
  const state = useTree_unstable(props, ref);
  const contextValues = useTreeContextValues_unstable(state);
  useTreeStyles_unstable(state);
  useCustomStyleHook("useTreeStyles_unstable")(state);
  return renderTree_unstable(state, contextValues);
});
Tree.displayName = "Tree";

// node_modules/@fluentui/react-tree/lib/components/FlatTree/FlatTree.js
var React439 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTree.js
var React438 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/utils/getTreeItemValueFromElement.js
var dataTreeItemValueAttrName = "data-fui-tree-item-value";

// node_modules/@fluentui/react-tree/lib/hooks/useFlatTreeNavigation.js
var React437 = __toESM(require_react());
function useFlatTreeNavigation(navigationMode = "tree") {
  "use no memo";
  const { walkerRef, rootRef: walkerRootRef } = useHTMLElementWalkerRef();
  const { rove, forceUpdate: forceUpdateRovingTabIndex, initialize: initializeRovingTabIndex } = useRovingTabIndex();
  const { findFirstFocusable } = useFocusFinders();
  const rootRefCallback = React437.useCallback((root) => {
    if (walkerRef.current && root) {
      initializeRovingTabIndex(walkerRef.current);
    }
  }, [
    initializeRovingTabIndex,
    walkerRef
  ]);
  function getNextElement(data) {
    if (!walkerRef.current) {
      return null;
    }
    switch (data.type) {
      case treeDataTypes.Click:
        return data.target;
      case treeDataTypes.TypeAhead:
        walkerRef.current.currentElement = data.target;
        return nextTypeAheadElement(walkerRef.current, data.event.key);
      case treeDataTypes.ArrowLeft: {
        const actions = queryActions2(data.target);
        if (navigationMode === "treegrid" && (actions === null || actions === void 0 ? void 0 : actions.contains(data.target.ownerDocument.activeElement))) {
          return data.target;
        }
        const nextElement = parentElement(data.parentValue, walkerRef.current);
        if (!nextElement && true) {
          console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
'ArrowLeft' navigation was not possible.
No parent element found for the current element:`, data.target);
        }
        return nextElement;
      }
      case treeDataTypes.ArrowRight: {
        if (navigationMode === "treegrid") {
          const actions = queryActions2(data.target);
          if (actions) {
            var _findFirstFocusable;
            (_findFirstFocusable = findFirstFocusable(actions)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
          }
          return null;
        }
        walkerRef.current.currentElement = data.target;
        const nextElement = firstChild(data.target, walkerRef.current);
        if (!nextElement && true) {
          const ariaLevel = Number(data.target.getAttribute("aria-level"));
          console.warn(`@fluentui/react-tree [useFlatTreeNavigation]:
'ArrowRight' navigation was not possible.
No element with "aria-posinset=1" and "aria-level=${ariaLevel + 1}"
was found after the current element!`, data.target);
        }
        return nextElement;
      }
      case treeDataTypes.End:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.lastChild();
      case treeDataTypes.Home:
        walkerRef.current.currentElement = walkerRef.current.root;
        return walkerRef.current.firstChild();
      case treeDataTypes.ArrowDown:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.nextElement();
      case treeDataTypes.ArrowUp:
        walkerRef.current.currentElement = data.target;
        return walkerRef.current.previousElement();
    }
  }
  const navigate = useEventCallback((data) => {
    const nextElement = getNextElement(data);
    if (nextElement) {
      rove(nextElement);
    }
  });
  return {
    navigate,
    rootRef: useMergedRefs(walkerRootRef, rootRefCallback),
    forceUpdateRovingTabIndex
  };
}
function firstChild(target, treeWalker) {
  const nextElement = treeWalker.nextElement();
  if (!nextElement) {
    return null;
  }
  const nextElementAriaPosInSet = nextElement.getAttribute("aria-posinset");
  const nextElementAriaLevel = nextElement.getAttribute("aria-level");
  const targetAriaLevel = target.getAttribute("aria-level");
  if (nextElementAriaPosInSet === "1" && Number(nextElementAriaLevel) === Number(targetAriaLevel) + 1) {
    return nextElement;
  }
  return null;
}
function parentElement(parentValue, treeWalker) {
  if (parentValue === void 0) {
    return null;
  }
  return treeWalker.root.querySelector(`[${dataTreeItemValueAttrName}="${parentValue}"]`);
}
var queryActions2 = (target) => target.querySelector(`:scope > .${treeItemLayoutClassNames.root} > .${treeItemLayoutClassNames.actions}`);

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTree.js
var useFlatTree_unstable = (props, ref) => {
  "use no memo";
  const isRoot = React438.useContext(SubtreeContext) === void 0;
  return isRoot ? useRootFlatTree(props, ref) : useSubFlatTree(props, ref);
};
function useRootFlatTree(props, ref) {
  const navigation = useFlatTreeNavigation(props.navigationMode);
  return Object.assign(useRootTree({
    ...props,
    onNavigation: useEventCallback((event, data) => {
      var _props_onNavigation;
      (_props_onNavigation = props.onNavigation) === null || _props_onNavigation === void 0 ? void 0 : _props_onNavigation.call(props, event, data);
      if (!event.isDefaultPrevented()) {
        navigation.navigate(data);
      }
    })
  }, useMergedRefs(ref, navigation.rootRef)), {
    treeType: "flat",
    forceUpdateRovingTabIndex: navigation.forceUpdateRovingTabIndex
  });
}
function useSubFlatTree(props, ref) {
  if (true) {
    throw new Error(`@fluentui/react-tree [useFlatTree]:
Subtrees are not allowed in a FlatTree!
You cannot use a <FlatTree> component inside of another <FlatTree> nor a <Tree> component!`);
  }
  return {
    ...useSubtree(props, ref),
    // ------ defaultTreeContextValue
    level: 0,
    contextType: "root",
    treeType: "nested",
    selectionMode: "none",
    openItems: ImmutableSet.empty,
    checkedItems: ImmutableMap.empty,
    requestTreeResponse: noop10,
    forceUpdateRovingTabIndex: noop10,
    appearance: "subtle",
    size: "medium",
    // ------ defaultTreeContextValue
    open: false
  };
}
function noop10() {
}

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeStyles.styles.js
var flatTreeClassNames = {
  root: "fui-FlatTree"
};
var useBaseStyles7 = __resetStyles("rnv2ez3", null, [".rnv2ez3{display:flex;flex-direction:column;row-gap:var(--spacingVerticalXXS);}"]);
var useFlatTreeStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles7();
  state.root.className = mergeClasses(flatTreeClassNames.root, baseStyles3, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatTreeContextValues.js
var useFlatTreeContextValues_unstable = (state) => {
  const { openItems, level, contextType, treeType, checkedItems, selectionMode, navigationMode, appearance, size: size3, requestTreeResponse, forceUpdateRovingTabIndex } = state;
  const tree = {
    treeType,
    size: size3,
    openItems,
    appearance,
    checkedItems,
    selectionMode,
    navigationMode,
    contextType,
    level,
    requestTreeResponse,
    forceUpdateRovingTabIndex
  };
  return {
    tree
  };
};

// node_modules/@fluentui/react-tree/lib/components/FlatTree/renderFlatTree.js
var renderFlatTree_unstable = renderTree_unstable;

// node_modules/@fluentui/react-tree/lib/components/FlatTree/FlatTree.js
var FlatTree = React439.forwardRef((props, ref) => {
  const state = useFlatTree_unstable(props, ref);
  const contextValues = useFlatTreeContextValues_unstable(state);
  useFlatTreeStyles_unstable(state);
  useCustomStyleHook("useFlatTreeStyles_unstable")(state);
  return renderFlatTree_unstable(state, contextValues);
});
FlatTree.displayName = "FlatTree";

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useHeadlessFlatTree.js
var React441 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useFlatControllableCheckedItems.js
var React440 = __toESM(require_react());
function useFlatControllableCheckedItems(props, headlessTree) {
  return useControllableState({
    initialState: ImmutableMap.empty,
    state: React440.useMemo(() => props.selectionMode ? props.checkedItems && createCheckedItems(props.checkedItems) : void 0, [
      props.checkedItems,
      props.selectionMode
    ]),
    defaultState: props.defaultCheckedItems ? () => initializeCheckedItems(props, headlessTree) : void 0
  });
}
function createNextFlatCheckedItems(data, previousCheckedItems, headlessTree) {
  if (data.selectionMode === "single") {
    return ImmutableMap.from([
      [
        data.value,
        data.checked
      ]
    ]);
  }
  const treeItem = headlessTree.get(data.value);
  if (!treeItem) {
    if (true) {
      console.error(`@fluentui/react-tree [useHeadlessFlatTree]:
Tree item ${data.value} not found.`);
    }
    return previousCheckedItems;
  }
  const nextCheckedItemsMap = new Map(ImmutableMap.dangerouslyGetInternalMap(previousCheckedItems));
  nextCheckedItemsMap.set(data.value, data.checked);
  for (const children of headlessTree.subtree(data.value)) {
    nextCheckedItemsMap.set(children.value, data.checked);
  }
  let isAncestorsMixed = false;
  for (const ancestor of headlessTree.ancestors(treeItem.value)) {
    if (isAncestorsMixed) {
      nextCheckedItemsMap.set(ancestor.value, "mixed");
      continue;
    }
    let childrenWithSameState = 0;
    for (const child of headlessTree.children(ancestor.value)) {
      if ((nextCheckedItemsMap.get(child.value) || false) === data.checked) {
        childrenWithSameState++;
      }
    }
    if (childrenWithSameState === ancestor.childrenValues.length) {
      nextCheckedItemsMap.set(ancestor.value, data.checked);
    } else {
      nextCheckedItemsMap.set(ancestor.value, "mixed");
      isAncestorsMixed = true;
    }
  }
  const nextCheckedItems = ImmutableMap.from(nextCheckedItemsMap);
  return nextCheckedItems;
}
function initializeCheckedItems(props, headlessTree) {
  if (!props.selectionMode) {
    return ImmutableMap.empty;
  }
  let state = createCheckedItems(props.defaultCheckedItems);
  if (props.selectionMode === "multiselect") {
    for (const [value, checked] of state) {
      state = createNextFlatCheckedItems({
        value,
        checked,
        selectionMode: props.selectionMode
      }, state, headlessTree);
    }
  }
  return state;
}

// node_modules/@fluentui/react-tree/lib/components/FlatTree/useHeadlessFlatTree.js
function useHeadlessFlatTree_unstable(props, options = {}) {
  "use no memo";
  const headlessTree = React441.useMemo(() => createHeadlessTree(props), [
    props
  ]);
  const [openItems, setOpenItems] = useControllableOpenItems(options);
  const [checkedItems, setCheckedItems] = useFlatControllableCheckedItems(options, headlessTree);
  const navigation = useFlatTreeNavigation();
  const treeRef = React441.useRef(null);
  const handleOpenChange = useEventCallback((event, data) => {
    var _options_onOpenChange;
    const nextOpenItems = createNextOpenItems(data, openItems);
    (_options_onOpenChange = options.onOpenChange) === null || _options_onOpenChange === void 0 ? void 0 : _options_onOpenChange.call(options, event, {
      ...data,
      openItems: ImmutableSet.dangerouslyGetInternalSet(nextOpenItems)
    });
    setOpenItems(nextOpenItems);
  });
  const handleCheckedChange = useEventCallback((event, data) => {
    var _options_onCheckedChange;
    const nextCheckedItems = createNextFlatCheckedItems(data, checkedItems, headlessTree);
    (_options_onCheckedChange = options.onCheckedChange) === null || _options_onCheckedChange === void 0 ? void 0 : _options_onCheckedChange.call(options, event, {
      ...data,
      checkedItems: ImmutableMap.dangerouslyGetInternalMap(nextCheckedItems)
    });
    setCheckedItems(nextCheckedItems);
  });
  const getNextNavigableItem = useEventCallback((visibleItems, data) => {
    const item = headlessTree.get(data.value);
    if (item) {
      switch (data.type) {
        case treeDataTypes.TypeAhead:
          return item;
        case treeDataTypes.ArrowLeft:
          return headlessTree.get(item.parentValue);
        case treeDataTypes.ArrowRight:
          return visibleItems[item.index + 1];
        case treeDataTypes.End:
          return visibleItems[visibleItems.length - 1];
        case treeDataTypes.Home:
          return visibleItems[0];
        case treeDataTypes.ArrowDown:
          return visibleItems[item.index + 1];
        case treeDataTypes.ArrowUp:
          return visibleItems[item.index - 1];
      }
    }
  });
  const getElementFromItem = React441.useCallback((item) => {
    var _treeRef_current;
    return (_treeRef_current = treeRef.current) === null || _treeRef_current === void 0 ? void 0 : _treeRef_current.querySelector(`[${dataTreeItemValueAttrName}="${item.value}"]`);
  }, []);
  const ref = useMergedRefs(treeRef, navigation.rootRef);
  const getTreeProps = React441.useCallback(
    () => {
      var _options_onNavigation;
      return {
        ref,
        openItems,
        selectionMode: options.selectionMode,
        checkedItems,
        onOpenChange: handleOpenChange,
        onCheckedChange: handleCheckedChange,
        onNavigation: (_options_onNavigation = options.onNavigation) !== null && _options_onNavigation !== void 0 ? _options_onNavigation : noop11
      };
    },
    // ref, handleOpenChange - useEventCallback, handleCheckedChange - useEventCallback
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      openItems,
      checkedItems,
      options.selectionMode,
      options.onNavigation
    ]
  );
  const items = React441.useCallback(() => headlessTree.visibleItems(openItems), [
    openItems,
    headlessTree
  ]);
  const getItem = React441.useCallback((value) => headlessTree.get(value), [
    headlessTree
  ]);
  return React441.useMemo(() => ({
    navigate: navigation.navigate,
    getTreeProps,
    getNextNavigableItem,
    getElementFromItem,
    items,
    getItem
  }), [
    navigation.navigate,
    getTreeProps,
    getNextNavigableItem,
    getElementFromItem,
    items,
    getItem
  ]);
}
function noop11() {
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/TreeItem.js
var React443 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItem.js
var React442 = __toESM(require_react());
var ReactDOM3 = __toESM(require_react_dom());
function useTreeItem_unstable(props, ref) {
  "use no memo";
  const treeType = useTreeContext_unstable((ctx) => ctx.treeType);
  if (treeType === "flat") {
    warnIfNoProperPropsFlatTreeItem(props);
  }
  const requestTreeResponse = useTreeContext_unstable((ctx) => ctx.requestTreeResponse);
  const navigationMode = useTreeContext_unstable((ctx) => {
    var _ctx_navigationMode;
    return (_ctx_navigationMode = ctx.navigationMode) !== null && _ctx_navigationMode !== void 0 ? _ctx_navigationMode : "tree";
  });
  const forceUpdateRovingTabIndex = useTreeContext_unstable((ctx) => ctx.forceUpdateRovingTabIndex);
  const { level: contextLevel } = useSubtreeContext_unstable();
  const parentValue = useTreeItemContext_unstable((ctx) => {
    var _props_parentValue;
    return (_props_parentValue = props.parentValue) !== null && _props_parentValue !== void 0 ? _props_parentValue : ctx.value;
  });
  const internalValue = useId2("fuiTreeItemValue-");
  var _props_value;
  const value = (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : internalValue;
  const { onClick, onKeyDown, onChange, as = "div", itemType = "leaf", "aria-level": level = contextLevel, "aria-selected": ariaSelected, "aria-expanded": ariaExpanded, ...rest } = props;
  const actionsRef = React442.useRef(null);
  const expandIconRef = React442.useRef(null);
  const layoutRef = React442.useRef(null);
  const subtreeRef = React442.useRef(null);
  const selectionRef = React442.useRef(null);
  const treeItemRef = React442.useRef(null);
  if (true) {
    const hasTreeContext = useHasParentContext(TreeContext);
    React442.useEffect(() => {
      var _treeItemRef_current;
      if (hasTreeContext) {
        return;
      }
      if ((_treeItemRef_current = treeItemRef.current) === null || _treeItemRef_current === void 0 ? void 0 : _treeItemRef_current.querySelector(`.${treeClassNames.root}`)) {
        console.error(`@fluentui/react-tree [useTreeItem]:
<TreeItem> should be declared inside a <Tree> component.`);
      }
    }, [
      hasTreeContext
    ]);
  }
  React442.useEffect(() => {
    forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 ? void 0 : forceUpdateRovingTabIndex();
    const treeItem = treeItemRef.current;
    return () => {
      if (treeItem && treeItem.tabIndex === 0) {
        forceUpdateRovingTabIndex === null || forceUpdateRovingTabIndex === void 0 ? void 0 : forceUpdateRovingTabIndex();
      }
    };
  }, [
    forceUpdateRovingTabIndex
  ]);
  const open = useTreeContext_unstable((ctx) => {
    var _props_open;
    return (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : ctx.openItems.has(value);
  });
  const getNextOpen = () => itemType === "branch" ? !open : open;
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  const checked = useTreeContext_unstable((ctx) => {
    var _ctx_checkedItems_get;
    return (_ctx_checkedItems_get = ctx.checkedItems.get(value)) !== null && _ctx_checkedItems_get !== void 0 ? _ctx_checkedItems_get : false;
  });
  const handleClick = useEventCallback((event) => {
    var _expandIconRef_current;
    const isEventFromActions = () => actionsRef.current && elementContains(actionsRef.current, event.target);
    const isEventFromSubtree = () => subtreeRef.current && elementContains(subtreeRef.current, event.target);
    const isEventFromSelection = () => {
      var _selectionRef_current;
      return (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.contains(event.target);
    };
    const isEventFromExpandIcon = (_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 ? void 0 : _expandIconRef_current.contains(event.target);
    if (isEventFromActions() || isEventFromSubtree() || isEventFromSelection()) {
      return;
    } else if (!isEventFromExpandIcon) {
      onClick === null || onClick === void 0 ? void 0 : onClick(event);
    }
    if (event.isDefaultPrevented()) {
      return;
    }
    ReactDOM3.unstable_batchedUpdates(() => {
      const data = {
        event,
        value,
        open: getNextOpen(),
        target: event.currentTarget,
        type: isEventFromExpandIcon ? treeDataTypes.ExpandIconClick : treeDataTypes.Click
      };
      if (itemType !== "leaf") {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, data);
        requestTreeResponse({
          ...data,
          itemType,
          requestType: "open"
        });
      }
      requestTreeResponse({
        ...data,
        itemType,
        parentValue,
        requestType: "navigate",
        type: treeDataTypes.Click
      });
    });
  });
  const handleKeyDown = useEventCallback((event) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
    if (event.isDefaultPrevented() || !treeItemRef.current) {
      return;
    }
    const isEventFromTreeItem = event.currentTarget === event.target;
    const isEventFromActions = actionsRef.current && actionsRef.current.contains(event.target);
    switch (event.key) {
      case Space: {
        if (!isEventFromTreeItem) {
          return;
        }
        if (selectionMode !== "none") {
          var _selectionRef_current;
          (_selectionRef_current = selectionRef.current) === null || _selectionRef_current === void 0 ? void 0 : _selectionRef_current.click();
          event.preventDefault();
        }
        return;
      }
      case treeDataTypes.Enter: {
        if (!isEventFromTreeItem) {
          return;
        }
        return event.currentTarget.click();
      }
      case treeDataTypes.End:
      case treeDataTypes.Home:
      case treeDataTypes.ArrowUp: {
        if (!isEventFromTreeItem && !isEventFromActions) {
          return;
        }
        return requestTreeResponse({
          requestType: "navigate",
          event,
          value,
          itemType,
          parentValue,
          type: event.key,
          target: event.currentTarget
        });
      }
      case treeDataTypes.ArrowDown: {
        if (!isEventFromTreeItem && !isEventFromActions) {
          return;
        }
        if (isEventFromActions && (!isHTMLElement(event.target) || event.target.hasAttribute("aria-haspopup"))) {
          return;
        }
        return requestTreeResponse({
          requestType: "navigate",
          event,
          value,
          itemType,
          parentValue,
          type: event.key,
          target: event.currentTarget
        });
      }
      case treeDataTypes.ArrowLeft: {
        if (event.altKey) {
          return;
        }
        const data = {
          value,
          event,
          open: getNextOpen(),
          type: event.key,
          itemType,
          parentValue,
          target: event.currentTarget
        };
        if (isEventFromActions && navigationMode === "treegrid") {
          requestTreeResponse({
            ...data,
            requestType: "navigate"
          });
          return;
        }
        if (!isEventFromTreeItem) {
          return;
        }
        if (level === 1 && !open) {
          return;
        }
        if (open) {
          var _props_onOpenChange;
          (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, data);
        }
        requestTreeResponse({
          ...data,
          requestType: open ? "open" : "navigate"
        });
        return;
      }
      case treeDataTypes.ArrowRight: {
        if (!isEventFromTreeItem) {
          return;
        }
        if (event.altKey) {
          return;
        }
        const data = {
          value,
          event,
          open: getNextOpen(),
          type: event.key,
          target: event.currentTarget
        };
        if (itemType === "branch" && !open) {
          var _props_onOpenChange1;
          (_props_onOpenChange1 = props.onOpenChange) === null || _props_onOpenChange1 === void 0 ? void 0 : _props_onOpenChange1.call(props, event, data);
          requestTreeResponse({
            ...data,
            itemType,
            requestType: "open"
          });
        } else {
          requestTreeResponse({
            ...data,
            itemType,
            parentValue,
            requestType: "navigate"
          });
        }
        return;
      }
    }
    if (!isEventFromTreeItem) {
      return;
    }
    const isTypeAheadCharacter = event.key.length === 1 && event.key.match(/\w/) && !event.altKey && !event.ctrlKey && !event.metaKey;
    if (isTypeAheadCharacter) {
      requestTreeResponse({
        requestType: "navigate",
        event,
        target: event.currentTarget,
        value,
        itemType,
        type: treeDataTypes.TypeAhead,
        parentValue
      });
    }
  });
  const handleChange = useEventCallback((event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(event);
    if (event.isDefaultPrevented()) {
      return;
    }
    const isEventFromSubtree = subtreeRef.current && elementContains(subtreeRef.current, event.target);
    if (isEventFromSubtree) {
      return;
    }
    requestTreeResponse({
      requestType: "selection",
      event,
      value,
      itemType,
      type: "Change",
      target: event.currentTarget,
      checked: checked === "mixed" ? true : !checked
    });
  });
  return {
    value,
    open,
    checked,
    subtreeRef,
    layoutRef,
    selectionRef,
    expandIconRef,
    treeItemRef,
    actionsRef,
    itemType,
    level,
    components: {
      root: "div"
    },
    // FIXME: this property is not necessary anymore, but as removing it would be a breaking change, we need to keep it as false
    isAsideVisible: false,
    // FIXME: this property is not necessary anymore, but as removing it would be a breaking change, we need to keep it as false
    isActionsVisible: false,
    root: slot_exports.always(getIntrinsicElementProps(as, {
      tabIndex: -1,
      [dataTreeItemValueAttrName]: value,
      role: "treeitem",
      ...rest,
      ref: useMergedRefs(ref, treeItemRef),
      "aria-level": level,
      "aria-checked": selectionMode === "multiselect" ? checked : void 0,
      "aria-selected": ariaSelected !== void 0 ? ariaSelected : selectionMode === "single" ? !!checked : void 0,
      "aria-expanded": ariaExpanded !== void 0 ? ariaExpanded : itemType === "branch" ? open : void 0,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      onChange: handleChange
    }), {
      elementType: "div"
    })
  };
}
function warnIfNoProperPropsFlatTreeItem(props) {
  if (true) {
    if (props["aria-posinset"] === void 0 || props["aria-setsize"] === void 0 || props["aria-level"] === void 0 || props.parentValue === void 0 && props["aria-level"] !== 1) {
      console.error(`@fluentui/react-tree [${useTreeItem_unstable.name}]:
A flat treeitem must have "aria-posinset", "aria-setsize", "aria-level"
and "parentValue" (if "aria-level" > 1) to ensure a11y and navigation.

- "aria-posinset": the position of this treeitem in the current level of the tree.
- "aria-setsize": the number of siblings in this level of the tree.
- "aria-level": the current level of the treeitem.
- "parentValue": the "value" property of the parent item of this item.`);
    }
  }
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/renderTreeItem.js
var renderTreeItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(TreeItemProvider, {
      value: contextValues.treeItem,
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutStyles.styles.js
var treeItemPersonaLayoutClassNames = {
  root: "fui-TreeItemPersonaLayout",
  media: "fui-TreeItemPersonaLayout__media",
  description: "fui-TreeItemPersonaLayout__description",
  main: "fui-TreeItemPersonaLayout__main",
  expandIcon: "fui-TreeItemPersonaLayout__expandIcon",
  aside: "fui-TreeItemPersonaLayout__aside",
  actions: "fui-TreeItemPersonaLayout__actions",
  selector: "fui-TreeItemPersonaLayout__selector"
};
var useRootBaseStyles3 = __resetStyles("r1r98egg", null, ['.r1r98egg{display:grid;grid-template-rows:1fr auto;grid-template-columns:auto auto 1fr auto;grid-template-areas:"expandIcon media main        aside" "expandIcon media description aside";align-items:center;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}', ".r1r98egg:active{color:var(--colorNeutralForeground2Pressed);background-color:var(--colorSubtleBackgroundPressed);}", ".r1r98egg:active .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Pressed);}", ".r1r98egg:hover{color:var(--colorNeutralForeground2Hover);background-color:var(--colorSubtleBackgroundHover);}", ".r1r98egg:hover .fui-TreeItemPersonaLayout__expandIcon{color:var(--colorNeutralForeground3Hover);}"]);
var useRootStyles19 = __styles2({
  leaf: {
    uwmqm3: ["f1k1erfc", "faevyjx"]
  },
  branch: {
    uwmqm3: ["fo100m9", "f6yw3pu"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    sshi5w: "f1pha7fy",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  subtle: {},
  "subtle-alpha": {
    Jwef8y: "f146ro5n",
    ecr2s2: "fkam630"
  },
  transparent: {
    De3pzq: "f1c21dwh",
    Jwef8y: "fjxutwb",
    ecr2s2: "fophhak"
  }
}, {
  d: [".f1k1erfc{padding-left:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".faevyjx{padding-right:calc(var(--fluent-TreeItem--level, 1) * var(--spacingHorizontalXXL));}", ".fo100m9{padding-left:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".f6yw3pu{padding-right:calc((var(--fluent-TreeItem--level, 1) - 1) * var(--spacingHorizontalXXL));}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1pha7fy{min-height:24px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}"],
  h: [".f146ro5n:hover{background-color:var(--colorSubtleBackgroundLightAlphaHover);}", ".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}"],
  a: [".fkam630:active{background-color:var(--colorSubtleBackgroundLightAlphaPressed);}", ".fophhak:active{background-color:var(--colorTransparentBackgroundPressed);}"]
});
var useMediaBaseStyles = __resetStyles("rkcde6g", "r1e986zr", [".rkcde6g{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalXXS);}", ".r1e986zr{display:flex;align-items:center;width:32px;height:32px;grid-area:media;padding:0 var(--spacingHorizontalXXS) 0 var(--spacingHorizontalXS);}"]);
var useMainBaseStyles2 = __resetStyles("r1qjtz99", "rob5fcp", [".r1qjtz99{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".rob5fcp{grid-area:main;padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
var useMainStyles = __styles2({
  withDescription: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1625emv", "f5y9hxg"]
  }
}, {
  d: [[".f1625emv{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalXS) 0 var(--spacingHorizontalS);}", {
    p: -1
  }], [".f5y9hxg{padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) 0 var(--spacingHorizontalXS);}", {
    p: -1
  }]]
});
var useDescriptionBaseStyles = __resetStyles("r1bnsn1b", "r13x7gq", [".r1bnsn1b{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalXS) var(--spacingVerticalMNudge) var(--spacingHorizontalS);}", ".r13x7gq{grid-area:description;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);padding:0 var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalXS);}"]);
var useActionsBaseStyles2 = __resetStyles("rzvs2in", "r17h8a29", [".rzvs2in{display:flex;margin-left:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}", ".r17h8a29{display:flex;margin-right:auto;position:relative;z-index:1;grid-area:aside;padding:0 var(--spacingHorizontalS);}"]);
var useAsideBaseStyles2 = __resetStyles("r1825u21", "rezy0yk", [".r1825u21{display:flex;margin-left:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}", ".rezy0yk{display:flex;margin-right:auto;align-items:center;z-index:0;grid-area:aside;padding:0 var(--spacingHorizontalM);gap:var(--spacingHorizontalXS);}"]);
var useExpandIconBaseStyles2 = __resetStyles("rn61xvs", null, [".rn61xvs{display:flex;align-items:center;justify-content:center;min-width:24px;box-sizing:border-box;color:var(--colorNeutralForeground3);grid-area:expandIcon;flex:0 0 auto;padding:var(--spacingVerticalXS) 0;}"]);
var useTreeItemPersonaLayoutStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles3();
  const rootStyles = useRootStyles19();
  const mediaBaseStyles = useMediaBaseStyles();
  const descriptionBaseStyles = useDescriptionBaseStyles();
  const actionsBaseStyles = useActionsBaseStyles2();
  const asideBaseStyles = useAsideBaseStyles2();
  const expandIconBaseStyles = useExpandIconBaseStyles2();
  const mainBaseStyles = useMainBaseStyles2();
  const mainStyles = useMainStyles();
  const size3 = useTreeContext_unstable((ctx) => ctx.size);
  const appearance = useTreeContext_unstable((ctx) => ctx.appearance);
  const itemType = useTreeItemContext_unstable((ctx) => ctx.itemType);
  state.root.className = mergeClasses(treeItemPersonaLayoutClassNames.root, rootBaseStyles, rootStyles[itemType], rootStyles[appearance], rootStyles[size3], state.root.className);
  state.media.className = mergeClasses(treeItemPersonaLayoutClassNames.media, mediaBaseStyles, state.media.className);
  if (state.main) {
    state.main.className = mergeClasses(treeItemPersonaLayoutClassNames.main, mainBaseStyles, state.description && mainStyles.withDescription, state.main.className);
  }
  if (state.description) {
    state.description.className = mergeClasses(treeItemPersonaLayoutClassNames.description, descriptionBaseStyles, state.description.className);
  }
  if (state.actions) {
    state.actions.className = mergeClasses(treeItemPersonaLayoutClassNames.actions, actionsBaseStyles, state.actions.className);
  }
  if (state.aside) {
    state.aside.className = mergeClasses(treeItemPersonaLayoutClassNames.aside, asideBaseStyles, state.aside.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(treeItemPersonaLayoutClassNames.expandIcon, expandIconBaseStyles, state.expandIcon.className);
  }
  if (state.selector) {
    state.selector.className = mergeClasses(treeItemPersonaLayoutClassNames.selector, state.selector.className);
  }
  return state;
};

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemStyles.styles.js
var treeItemClassNames = {
  root: "fui-TreeItem"
};
var useBaseStyles8 = __resetStyles("r15xhw3a", "r2f6k57", [".r15xhw3a{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-right:var(--spacingHorizontalNone);}", ".r15xhw3a:focus{outline-style:none;}", ".r15xhw3a:focus-visible{outline-style:none;}", ".r15xhw3a[data-fui-focus-visible]>.fui-TreeItemLayout,.r15xhw3a[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}", ".r2f6k57{position:relative;cursor:pointer;display:flex;flex-direction:column;box-sizing:border-box;background-color:var(--colorSubtleBackground);color:var(--colorNeutralForeground2);padding-left:var(--spacingHorizontalNone);}", ".r2f6k57:focus{outline-style:none;}", ".r2f6k57:focus-visible{outline-style:none;}", ".r2f6k57[data-fui-focus-visible]>.fui-TreeItemLayout,.r2f6k57[data-fui-focus-visible]>.fui-TreeItemPersonaLayout{border-radius:var(--borderRadiusMedium);outline-color:var(--colorStrokeFocus2);outline-radius:var(--borderRadiusMedium);outline-width:2px;outline-style:solid;}"]);
var useStyles53 = __styles2({
  level1: {
    iytv0q: "f10bgyvd"
  },
  level2: {
    iytv0q: "f1h0rod3"
  },
  level3: {
    iytv0q: "fgoqafk"
  },
  level4: {
    iytv0q: "f75dvuh"
  },
  level5: {
    iytv0q: "fqk7yw6"
  },
  level6: {
    iytv0q: "f1r3z17b"
  },
  level7: {
    iytv0q: "f1hrpd1h"
  },
  level8: {
    iytv0q: "f1iy65d0"
  },
  level9: {
    iytv0q: "ftg42e5"
  },
  level10: {
    iytv0q: "fyat3t"
  }
}, {
  d: [".f10bgyvd{--fluent-TreeItem--level:1;}", ".f1h0rod3{--fluent-TreeItem--level:2;}", ".fgoqafk{--fluent-TreeItem--level:3;}", ".f75dvuh{--fluent-TreeItem--level:4;}", ".fqk7yw6{--fluent-TreeItem--level:5;}", ".f1r3z17b{--fluent-TreeItem--level:6;}", ".f1hrpd1h{--fluent-TreeItem--level:7;}", ".f1iy65d0{--fluent-TreeItem--level:8;}", ".ftg42e5{--fluent-TreeItem--level:9;}", ".fyat3t{--fluent-TreeItem--level:10;}"]
});
var useTreeItemStyles_unstable = (state) => {
  "use no memo";
  const baseStyles3 = useBaseStyles8();
  const styles = useStyles53();
  const {
    level
  } = state;
  state.root.className = mergeClasses(treeItemClassNames.root, baseStyles3, isStaticallyDefinedLevel(level) && styles[`level${level}`], state.root.className);
  return state;
};
function isStaticallyDefinedLevel(level) {
  return level >= 1 && level <= 10;
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/useTreeItemContextValues.js
function useTreeItemContextValues_unstable(state) {
  const {
    value,
    itemType,
    layoutRef,
    subtreeRef,
    open,
    expandIconRef,
    actionsRef,
    treeItemRef,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isActionsVisible,
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    isAsideVisible,
    selectionRef,
    checked
  } = state;
  const treeItem = {
    value,
    checked,
    itemType,
    layoutRef,
    subtreeRef,
    open,
    selectionRef,
    isActionsVisible,
    isAsideVisible,
    actionsRef,
    treeItemRef,
    expandIconRef
  };
  return {
    treeItem
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItem/TreeItem.js
var TreeItem = React443.forwardRef((props, ref) => {
  const state = useTreeItem_unstable(props, ref);
  useTreeItemStyles_unstable(state);
  useCustomStyleHook("useTreeItemStyles_unstable")(state);
  const contextValues = useTreeItemContextValues_unstable(state);
  return renderTreeItem_unstable(state, contextValues);
});
TreeItem.displayName = "TreeItem";

// node_modules/@fluentui/react-tree/lib/components/FlatTreeItem/FlatTreeItem.js
var FlatTreeItem = TreeItem;

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/TreeItemPersonaLayout.js
var React446 = __toESM(require_react());

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayout.js
var React444 = __toESM(require_react());
var useTreeItemPersonaLayout_unstable = (props, ref) => {
  const { media, children, main, description } = props;
  const treeItemLayoutState = useTreeItemLayout_unstable({
    ...props,
    iconBefore: null,
    iconAfter: null
  }, ref);
  const size3 = useTreeContext_unstable((ctx) => ctx.size);
  const selectionMode = useTreeContext_unstable((ctx) => ctx.selectionMode);
  return {
    ...treeItemLayoutState,
    components: {
      expandIcon: "div",
      main: "div",
      description: "div",
      root: "div",
      media: "div",
      aside: "div",
      actions: "div",
      // Casting here to a union between checkbox and radio
      selector: selectionMode === "multiselect" ? Checkbox : Radio
    },
    avatarSize: treeAvatarSize[size3],
    main: slot_exports.always(main, {
      defaultProps: {
        children
      },
      elementType: "div"
    }),
    media: slot_exports.always(media, {
      elementType: "div"
    }),
    description: slot_exports.optional(description, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/renderTreeItemPersonaLayout.js
var renderTreeItemPersonaLayout_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.expandIcon && jsx(state.expandIcon, {}),
      state.selector && jsx(state.selector, {}),
      jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      jsx(state.main, {}),
      state.description && jsx(state.description, {}),
      jsxs(ButtonContextProvider, {
        value: state.buttonContextValue,
        children: [
          state.actions && jsx(state.actions, {}),
          state.aside && jsx(state.aside, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/useTreeItemPersonaLayoutContextValues.js
var React445 = __toESM(require_react());
function useTreeItemPersonaLayoutContextValues_unstable(state) {
  const { avatarSize } = state;
  const avatar = React445.useMemo(() => ({
    size: avatarSize
  }), [
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-tree/lib/components/TreeItemPersonaLayout/TreeItemPersonaLayout.js
var TreeItemPersonaLayout = React446.forwardRef((props, ref) => {
  const state = useTreeItemPersonaLayout_unstable(props, ref);
  useTreeItemPersonaLayoutStyles_unstable(state);
  useCustomStyleHook("useTreeItemPersonaLayoutStyles_unstable")(state);
  const contextValues = useTreeItemPersonaLayoutContextValues_unstable(state);
  return renderTreeItemPersonaLayout_unstable(state, contextValues);
});
TreeItemPersonaLayout.displayName = "TreeItemPersonaLayout";

// node_modules/@fluentui/react-tree/lib/utils/flattenTree.js
function flattenTreeRecursive(items, parent2, level = 1) {
  return items.reduce((acc, { subtree, ...item }, index) => {
    const flatTreeItem = {
      "aria-level": level,
      "aria-posinset": index + 1,
      "aria-setsize": items.length,
      parentValue: parent2 === null || parent2 === void 0 ? void 0 : parent2.value,
      ...item
    };
    acc.push(flatTreeItem);
    if (subtree !== void 0) {
      acc.push(...flattenTreeRecursive(subtree, flatTreeItem, level + 1));
    }
    return acc;
  }, []);
}
var flattenTree_unstable = (items) => flattenTreeRecursive(items);

// node_modules/@fluentui/react-tags/lib/components/Tag/Tag.js
var React450 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/Tag/useTag.js
var React448 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/contexts/tagGroupContext.js
var React447 = __toESM(require_react());
var TagGroupContext = React447.createContext(void 0);
var tagGroupContextDefaultValue = {
  handleTagDismiss: () => ({}),
  size: "medium",
  role: "toolbar",
  handleTagSelect: void 0
};
var TagGroupContextProvider = TagGroupContext.Provider;
var useTagGroupContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React447.useContext(TagGroupContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tagGroupContextDefaultValue;
};

// node_modules/@fluentui/react-tags/lib/components/Tag/useTag.js
var tagAvatarSizeMap = {
  medium: 28,
  small: 20,
  "extra-small": 16
};
var tagAvatarShapeMap = {
  rounded: "square",
  circular: "circular"
};
var useTag_unstable = (props, ref) => {
  const { handleTagDismiss, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, dismissible: contextDismissible, role: tagGroupRole } = useTagGroupContext_unstable();
  const id = useId2("fui-Tag", props.id);
  const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, dismissible = contextDismissible !== null && contextDismissible !== void 0 ? contextDismissible : false, selected, shape = "rounded", size: size3 = contextSize, value = id } = props;
  const dismissOnClick = useEventCallback((ev) => {
    var _props_onClick;
    (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, ev);
    if (!ev.defaultPrevented) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const dismissOnKeyDown = useEventCallback((ev) => {
    var _props_onKeyDown;
    props === null || props === void 0 ? void 0 : (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, ev);
    if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const elementType = dismissible ? "button" : "span";
  const selectedProp = tagGroupRole === "listbox" ? "aria-selected" : "aria-pressed";
  const selectable = typeof selected === "boolean" || tagGroupRole === "listbox";
  return {
    appearance,
    avatarShape: tagAvatarShapeMap[shape],
    avatarSize: tagAvatarSizeMap[size3],
    disabled: contextDisabled ? true : disabled,
    dismissible,
    selected: !!selected,
    shape,
    size: size3,
    components: {
      root: elementType,
      media: "span",
      icon: "span",
      primaryText: "span",
      secondaryText: "span",
      dismissIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps(elementType, {
      ref,
      role: tagGroupRole === "listbox" ? "option" : void 0,
      [selectedProp]: selectable ? selected : void 0,
      ...props,
      disabled: contextDisabled ? true : disabled,
      id,
      ...dismissible && {
        onClick: dismissOnClick,
        onKeyDown: dismissOnKeyDown
      }
    }), {
      defaultProps: {
        type: elementType === "button" ? "button" : void 0
      },
      elementType
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    }),
    primaryText: slot_exports.optional(props.primaryText, {
      renderByDefault: true,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryText: slot_exports.optional(props.secondaryText, {
      elementType: "span"
    }),
    dismissIcon: slot_exports.optional(props.dismissIcon, {
      renderByDefault: dismissible,
      defaultProps: {
        children: React448.createElement(DismissRegular, null)
      },
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/Tag/renderTag.js
var renderTag_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.icon && jsx(state.icon, {}),
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {}),
      state.dismissIcon && state.dismissible && jsx(state.dismissIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-tags/lib/components/Tag/useTagStyles.styles.js
var tagClassNames = {
  root: "fui-Tag",
  media: "fui-Tag__media",
  icon: "fui-Tag__icon",
  primaryText: "fui-Tag__primaryText",
  secondaryText: "fui-Tag__secondaryText",
  dismissIcon: "fui-Tag__dismissIcon"
};
var baseStyles = {
  // reset default button style:
  fontFamily: "inherit",
  padding: "0px",
  appearance: "button",
  textAlign: "unset",
  display: "inline-grid",
  alignItems: "center",
  gridTemplateAreas: `
  "media primary   dismissIcon"
  "media secondary dismissIcon"
  `,
  boxSizing: "border-box",
  width: "fit-content",
  border: `${tokens.strokeWidthThin} solid ${tokens.colorTransparentStroke}`
};
var useRootRoundedBaseClassName = __resetStyles("r18f5o0q", "r1u2q8zc", {
  r: ['.r18f5o0q{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r18f5o0q[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", '.r1u2q8zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r1u2q8zc[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"],
  s: ['@media (forced-colors: active){.r18f5o0q{position:relative;}.r18f5o0q::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}', '@media (forced-colors: active){.r1u2q8zc{position:relative;}.r1u2q8zc::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}']
});
var useRootCircularBaseClassName = __resetStyles("r1mko7zc", "r1wx1e29", {
  r: ['.r1mko7zc{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r1mko7zc[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", '.r1wx1e29{font-family:inherit;padding:0px;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;display:inline-grid;align-items:center;grid-template-areas:"media primary   dismissIcon" "media secondary dismissIcon";box-sizing:border-box;width:fit-content;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r1wx1e29[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"],
  s: ['@media (forced-colors: active){.r1mko7zc{position:relative;}.r1mko7zc::before{content:"";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}', '@media (forced-colors: active){.r1wx1e29{position:relative;}.r1wx1e29::before{content:"";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-radius:var(--borderRadiusCircular);}}']
});
var useRootStyles20 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"]
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0"
  },
  selected: {
    De3pzq: "ffp7eso",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f1qpacp7", "f1vfbj5f"],
    B8gzw0y: "f1h3a8gf",
    By8wz76: "f1nz3ub2",
    B7iucu3: "fqc85l4"
  },
  medium: {
    Bqenvij: "f1d2rq10"
  },
  small: {
    Bqenvij: "frvgh55"
  },
  "extra-small": {
    qhf8xq: "f10pi13n",
    Bqenvij: "fjamq6b",
    Ie5t1m: "fru8nlv",
    G6hvz8: "f5nasji",
    wgw0td: "f45hpys",
    Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
    m3mfg4: "fq6y7a1",
    B9s7hj8: "f1jr4pq3",
    B9e1dac: "f1tfer7m"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f1d2rq10{height:32px;}", ".frvgh55{height:24px;}", ".f10pi13n{position:relative;}", ".fjamq6b{height:20px;}"],
  m: [["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledStyles3 = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useRootWithoutMediaStyles = __styles2({
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"]
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  }
}, {
  d: [".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}"]
});
var useRootWithoutDismissStyles = __styles2({
  medium: {
    z189sj: ["f18k1jr3", "f1rtp3s9"]
  },
  small: {
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  "extra-small": {
    z189sj: ["fwiuce9", "f15vdbe4"]
  }
}, {
  d: [".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}"]
});
var useIconStyles8 = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    mc9l5x: "f22iagw",
    B7ck84d: "f1e4lqlz"
  },
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"],
    z189sj: ["f7x41pl", "fruq291"],
    a9b677: "f64fuq3",
    Be2twd7: "fe5j1ua"
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["ffczdla", "fgiv446"],
    a9b677: "fjw5fx7",
    Be2twd7: "f4ybsrx"
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["ffczdla", "fgiv446"],
    a9b677: "frx94fk",
    Be2twd7: "f1ugzwwg"
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1e4lqlz{box-sizing:content-box;}", ".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f64fuq3{width:20px;}", ".fe5j1ua{font-size:20px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".fjw5fx7{width:16px;}", ".f4ybsrx{font-size:16px;}", ".frx94fk{width:12px;}", ".f1ugzwwg{font-size:12px;}"]
});
var useMediaStyles = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    mc9l5x: "f22iagw",
    uwmqm3: ["f10xn8zz", "f136y8j8"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  "extra-small": {
    z189sj: ["fdw0yi8", "fk8j09s"]
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f10xn8zz{padding-left:1px;}", ".f136y8j8{padding-right:1px;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"]
});
var useDismissIconStyles = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "f1k1gsvr",
    mc9l5x: "f22iagw",
    Bahaeuw: "f1v3eptx",
    Boo3t63: "f1rfz71x"
  },
  medium: {
    uwmqm3: ["fruq291", "f7x41pl"],
    z189sj: ["f18k1jr3", "f1rtp3s9"],
    Be2twd7: "fe5j1ua"
  },
  small: {
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    Be2twd7: "f4ybsrx"
  },
  "extra-small": {
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    Be2twd7: "f1ugzwwg"
  },
  filled: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  outline: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  brand: {
    eoavqd: "f8491dx",
    Bi91k9c: "f3ymbdj",
    lj723h: "fryz5bw"
  },
  selected: {
    Bi91k9c: "f1rq72xc",
    lj723h: "f18otbis"
  }
}, {
  d: [[".f1k1gsvr{grid-area:dismissIcon;}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}", ".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fe5j1ua{font-size:20px;}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}", ".f4ybsrx{font-size:16px;}", ".f1ugzwwg{font-size:12px;}"],
  m: [["@media (forced-colors: active){.f1v3eptx:hover{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1rfz71x:active{color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".f8491dx:hover{cursor:pointer;}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"]
});
var usePrimaryTextStyles = __styles2({
  base: {
    Huce71: "fz5stix",
    uwmqm3: ["fgiv446", "ffczdla"],
    z189sj: ["ffczdla", "fgiv446"]
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  },
  small: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  "extra-small": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  withoutSecondaryText: {
    Br312pm: "faqcfhe",
    Ijaq50: "f1q3ipgb",
    nk6f5a: "fc0ab3q",
    Byoj8tv: "f1g03r3y"
  },
  withSecondaryText: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "f1ebragv",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    B6of3ja: "f1ryq6si"
  }
}, {
  d: [".fz5stix{white-space:nowrap;}", ".fgiv446{padding-left:var(--spacingHorizontalXXS);}", ".ffczdla{padding-right:var(--spacingHorizontalXXS);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".faqcfhe{grid-column-start:primary;}", ".f1q3ipgb{grid-row-start:primary;}", ".fc0ab3q{grid-row-end:secondary;}", ".f1g03r3y{padding-bottom:var(--spacingHorizontalXXS);}", [".f1ebragv{grid-area:primary;}", {
    p: -1
  }], ".f1ryq6si{margin-top:-2px;}"]
});
var useSecondaryTextBaseClassName2 = __resetStyles("r7hv1ps", "rnrslm9", [".r7hv1ps{grid-area:secondary;padding-left:var(--spacingHorizontalXXS);padding-right:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}", ".rnrslm9{grid-area:secondary;padding-right:var(--spacingHorizontalXXS);padding-left:var(--spacingHorizontalXXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase100);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase100);white-space:nowrap;}"]);
var useTagStyles_unstable = (state) => {
  "use no memo";
  const rootRoundedBaseClassName = useRootRoundedBaseClassName();
  const rootCircularBaseClassName = useRootCircularBaseClassName();
  const rootStyles = useRootStyles20();
  const rootDisabledStyles = useRootDisabledStyles3();
  const rootWithoutMediaStyles = useRootWithoutMediaStyles();
  const rootWithoutDismissStyles = useRootWithoutDismissStyles();
  const iconStyles = useIconStyles8();
  const mediaStyles = useMediaStyles();
  const dismissIconStyles = useDismissIconStyles();
  const primaryTextStyles = usePrimaryTextStyles();
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName2();
  const {
    disabled,
    shape,
    size: size3,
    appearance,
    selected
  } = state;
  state.root.className = mergeClasses(tagClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size3], !state.media && !state.icon && rootWithoutMediaStyles[size3], !state.dismissIcon && rootWithoutDismissStyles[size3], state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(tagClassNames.media, mediaStyles.base, mediaStyles[size3], state.media.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(tagClassNames.icon, iconStyles.base, iconStyles[size3], state.icon.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(tagClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size3], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(tagClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
  }
  if (state.dismissIcon) {
    state.dismissIcon.className = mergeClasses(tagClassNames.dismissIcon, dismissIconStyles.base, dismissIconStyles[size3], !disabled && dismissIconStyles[appearance], selected && !disabled && dismissIconStyles.selected, state.dismissIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-tags/lib/utils/useTagAvatarContextValues.js
var React449 = __toESM(require_react());
function useTagAvatarContextValues_unstable(state) {
  const { avatarSize, avatarShape } = state;
  const avatar = React449.useMemo(() => ({
    size: avatarSize,
    shape: avatarShape
  }), [
    avatarShape,
    avatarSize
  ]);
  return {
    avatar
  };
}

// node_modules/@fluentui/react-tags/lib/components/Tag/Tag.js
var Tag = React450.forwardRef((props, ref) => {
  const state = useTag_unstable(props, ref);
  useTagStyles_unstable(state);
  useCustomStyleHook("useTagStyles_unstable")(state);
  return renderTag_unstable(state, useTagAvatarContextValues_unstable(state));
});
Tag.displayName = "Tag";

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/InteractionTag.js
var React454 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTag.js
var React451 = __toESM(require_react());
var useInteractionTag_unstable = (props, ref) => {
  const { handleTagDismiss, handleTagSelect, size: contextSize, disabled: contextDisabled, appearance: contextAppearance, selectedValues = [] } = useTagGroupContext_unstable();
  const id = useId2("fui-InteractionTag-", props.id);
  const interactionTagPrimaryId = useId2("fui-InteractionTagPrimary-");
  const { appearance = contextAppearance !== null && contextAppearance !== void 0 ? contextAppearance : "filled", disabled = false, selected = false, shape = "rounded", size: size3 = contextSize, value = id } = props;
  return {
    appearance,
    disabled: contextDisabled ? true : disabled,
    handleTagDismiss,
    handleTagSelect,
    interactionTagPrimaryId,
    selected: selectedValues.includes(value) || selected,
    selectedValues,
    shape,
    size: size3,
    value,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      disabled: contextDisabled ? true : disabled,
      id
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/contexts/interactionTagContext.js
var React452 = __toESM(require_react());
var InteractionTagContext = React452.createContext(void 0);
var interactionTagContextDefaultValue = {
  appearance: "filled",
  disabled: false,
  handleTagDismiss: () => ({}),
  handleTagSelect: () => ({}),
  interactionTagPrimaryId: "",
  selected: false,
  selectedValues: [],
  shape: "rounded",
  size: "medium",
  value: ""
};
var InteractionTagContextProvider = InteractionTagContext.Provider;
var useInteractionTagContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React452.useContext(InteractionTagContext)) !== null && _React_useContext !== void 0 ? _React_useContext : interactionTagContextDefaultValue;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/renderInteractionTag.js
var renderInteractionTag_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(InteractionTagContextProvider, {
    value: contextValues.interactionTag,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagStyles.styles.js
var interactionTagClassNames = {
  root: "fui-InteractionTag"
};
var useRootBaseClassName12 = __resetStyles("r1y684pp", null, [".r1y684pp{display:inline-flex;align-items:center;box-sizing:border-box;width:fit-content;}"]);
var useRootStyles21 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9"
  },
  medium: {
    Bqenvij: "f1d2rq10"
  },
  small: {
    Bqenvij: "frvgh55"
  },
  "extra-small": {
    Bqenvij: "fjamq6b"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".f1d2rq10{height:32px;}", ".frvgh55{height:24px;}", ".fjamq6b{height:20px;}"]
});
var useInteractionTagStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName12();
  const rootStyles = useRootStyles21();
  const {
    shape,
    size: size3
  } = state;
  state.root.className = mergeClasses(interactionTagClassNames.root, rootBaseClassName, rootStyles[shape], rootStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/useInteractionTagContextValues.js
var React453 = __toESM(require_react());
function useInteractionTagContextValues_unstable(state) {
  const { appearance, disabled, handleTagDismiss, handleTagSelect, interactionTagPrimaryId, selected, selectedValues, shape, size: size3, value } = state;
  return {
    interactionTag: React453.useMemo(() => ({
      appearance,
      disabled,
      handleTagDismiss,
      handleTagSelect,
      interactionTagPrimaryId,
      selected,
      selectedValues,
      shape,
      size: size3,
      value
    }), [
      appearance,
      disabled,
      handleTagDismiss,
      handleTagSelect,
      interactionTagPrimaryId,
      selected,
      selectedValues,
      shape,
      size3,
      value
    ])
  };
}

// node_modules/@fluentui/react-tags/lib/components/InteractionTag/InteractionTag.js
var InteractionTag = React454.forwardRef((props, ref) => {
  const state = useInteractionTag_unstable(props, ref);
  useInteractionTagStyles_unstable(state);
  useCustomStyleHook("useInteractionTagStyles_unstable")(state);
  return renderInteractionTag_unstable(state, useInteractionTagContextValues_unstable(state));
});
InteractionTag.displayName = "InteractionTag";

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/InteractionTagPrimary.js
var React456 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimary.js
var React455 = __toESM(require_react());
var avatarSizeMap = {
  medium: 28,
  small: 20,
  "extra-small": 16
};
var avatarShapeMap = {
  rounded: "square",
  circular: "circular"
};
var useInteractionTagPrimary_unstable = (props, ref) => {
  const { appearance, disabled, handleTagSelect, interactionTagPrimaryId, selected: contextSelected, selectedValues, shape, size: size3, value } = useInteractionTagContext_unstable();
  const { hasSecondaryAction = false } = props;
  const onClick = useEventCallback(mergeCallbacks(props === null || props === void 0 ? void 0 : props.onClick, (event) => handleTagSelect === null || handleTagSelect === void 0 ? void 0 : handleTagSelect(event, {
    type: "click",
    event,
    value,
    selectedValues
  })));
  return {
    appearance,
    avatarShape: avatarShapeMap[shape],
    avatarSize: avatarSizeMap[size3],
    disabled,
    hasSecondaryAction,
    selected: contextSelected,
    shape,
    size: size3,
    components: {
      root: "button",
      media: "span",
      icon: "span",
      primaryText: "span",
      secondaryText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      disabled,
      id: interactionTagPrimaryId,
      ...handleTagSelect !== void 0 && {
        "aria-pressed": contextSelected
      },
      onClick,
      ...props
    }), {
      elementType: "button"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    icon: slot_exports.optional(props.icon, {
      elementType: "span"
    }),
    primaryText: slot_exports.optional(props.primaryText, {
      renderByDefault: true,
      defaultProps: {
        children: props.children
      },
      elementType: "span"
    }),
    secondaryText: slot_exports.optional(props.secondaryText, {
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/renderInteractionTagPrimary.js
var renderInteractionTagPrimary_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(AvatarContextProvider, {
        value: contextValues.avatar,
        children: jsx(state.media, {})
      }),
      state.icon && jsx(state.icon, {}),
      state.primaryText && jsx(state.primaryText, {}),
      state.secondaryText && jsx(state.secondaryText, {})
    ]
  });
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/useInteractionTagPrimaryStyles.styles.js
var interactionTagPrimaryClassNames = {
  root: "fui-InteractionTagPrimary",
  media: "fui-InteractionTagPrimary__media",
  icon: "fui-InteractionTagPrimary__icon",
  primaryText: "fui-InteractionTagPrimary__primaryText",
  secondaryText: "fui-InteractionTagPrimary__secondaryText"
};
var baseStyles2 = {
  // reset default button style:
  color: "inherit",
  fontFamily: "inherit",
  padding: "0px",
  borderStyle: "none",
  appearance: "button",
  textAlign: "unset",
  backgroundColor: "transparent",
  display: "inline-grid",
  height: "100%",
  alignItems: "center",
  gridTemplateAreas: `
  "media primary  "
  "media secondary"
  `,
  border: `${tokens.strokeWidthThin} solid ${tokens.colorTransparentStroke}`,
  ...createCustomFocusIndicatorStyle({
    outline: `${tokens.strokeWidthThick} solid ${tokens.colorStrokeFocus2}`,
    zIndex: 1
  })
};
var useRootRoundedBaseClassName2 = __resetStyles("r22quyo", "r1yd8tpa", {
  r: ['.r22quyo{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r22quyo[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}", '.r1yd8tpa{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusMedium);}', ".r1yd8tpa[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"],
  s: ['@media (forced-colors: active){.r22quyo{position:relative;}.r22quyo::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);}}', '@media (forced-colors: active){.r1yd8tpa{position:relative;}.r1yd8tpa::before{content:"";border-top:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);}}']
});
var useRootCircularBaseClassName2 = __resetStyles("r132q0f6", "r15qe99u", {
  r: ['.r132q0f6{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r132q0f6[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}", '.r15qe99u{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:inline-grid;height:100%;align-items:center;grid-template-areas:"media primary  " "media secondary";border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-radius:var(--borderRadiusCircular);}', ".r15qe99u[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);z-index:1;}"],
  s: ['@media (forced-colors: active){.r132q0f6{position:relative;}.r132q0f6::before{content:"";border-top:var(--strokeWidthThin) solid;border-left:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-left-radius:var(--borderRadiusCircular);border-bottom-left-radius:var(--borderRadiusCircular);}}', '@media (forced-colors: active){.r15qe99u{position:relative;}.r15qe99u::before{content:"";border-top:var(--strokeWidthThin) solid;border-right:var(--strokeWidthThin) solid;position:absolute;inset:-1px;border-top-right-radius:var(--borderRadiusCircular);border-bottom-right-radius:var(--borderRadiusCircular);}}']
});
var useRootCircularContrastStyles = __styles2({
  withoutSecondaryAction: {
    Bvgf1ty: "f135udas",
    Cqojjj: 0,
    dd5wkx: 0,
    Bdzpf8n: 0,
    ibz501: ["f1i3lrd2", "fbpt94e"],
    Bs8828g: ["f14bn3u", "fdhx3t9"],
    Bn0yx1x: ["fu87gj3", "f631p13"]
  }
}, {
  m: [["@media (forced-colors: active){.f135udas{position:relative;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1i3lrd2::before{border-right:var(--strokeWidthThin) solid transparent;}.fbpt94e::before{border-left:var(--strokeWidthThin) solid transparent;}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f14bn3u::before{border-top-right-radius:var(--borderRadiusCircular);}.fdhx3t9::before{border-top-left-radius:var(--borderRadiusCircular);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f631p13::before{border-bottom-left-radius:var(--borderRadiusCircular);}.fu87gj3::before{border-bottom-right-radius:var(--borderRadiusCircular);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRootStyles22 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    eoavqd: "f8491dx",
    Jwef8y: "f1h648pw",
    Bi91k9c: "fnwyq0v",
    ecr2s2: "fwdzr64",
    lj723h: "flvvhsy",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    eoavqd: "f8491dx",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "fnwyq0v",
    Bk3fhr4: "ft1hn21",
    I6i3kg: "fqbfmpb",
    Bmfj8id: "fuxngvv",
    ecr2s2: "f1wfn5kd",
    lj723h: "flvvhsy",
    Bnrwwps: "fvpl5sy",
    weioyw: "f1xblose",
    Bpre390: "f8upcvr",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    eoavqd: "f8491dx",
    Jwef8y: "f1yj72w4",
    Bi91k9c: "f3ymbdj",
    ecr2s2: "fy3sl2y",
    lj723h: "fryz5bw",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  selected: {
    Bgh53k4: 0,
    B2eet1l: 0,
    De3pzq: 0,
    Bcmaq0h: 0,
    gk0gix: 0,
    B20660r: 0,
    B8a6bjv: 0,
    Bpptf2m: 0,
    e5kdtc: 0,
    Bkjc3bi: 0,
    ayd6f0: "f1tdnksq",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f1qpacp7", "f1vfbj5f"],
    B8gzw0y: "f1h3a8gf",
    By8wz76: "f1nz3ub2",
    B7iucu3: "fqc85l4",
    Jwef8y: "f15wkkf3",
    Bi91k9c: "f1rq72xc",
    I6i3kg: "f10jvnl4",
    Bbkh6qg: "f1tx4pjd",
    Bahaeuw: "fu37p9p",
    ecr2s2: "fsp1bjw",
    lj723h: "f18otbis",
    weioyw: "f3wpj5r",
    Cnge2b: "f16z8z4r",
    Boo3t63: "f7ydw7o"
  },
  medium: {
    z189sj: ["f18k1jr3", "f1rtp3s9"]
  },
  small: {
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  "extra-small": {
    z189sj: ["fwiuce9", "f15vdbe4"],
    qhf8xq: "f10pi13n",
    Ie5t1m: "fru8nlv",
    G6hvz8: "f5nasji",
    wgw0td: "f45hpys",
    Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
    m3mfg4: "fq6y7a1",
    B9s7hj8: "f1jr4pq3",
    B9e1dac: "f1tfer7m"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", [".f1tdnksq{background:var(--colorBrandBackground);}", {
    p: -2
  }], ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}", ".f10pi13n{position:relative;}"],
  h: [".f8491dx:hover{cursor:pointer;}", ".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fqbfmpb:hover .fui-Icon-filled{color:var(--colorNeutralForeground2BrandHover);}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f10jvnl4:hover .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}", ".flvvhsy:active{color:var(--colorNeutralForeground2Pressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fvpl5sy:active .fui-Icon-filled{display:inline;}", ".f1xblose:active .fui-Icon-filled{color:var(--colorNeutralForeground2BrandPressed);}", ".f8upcvr:active .fui-Icon-regular{display:none;}", ".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}", ".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}", ".f3wpj5r:active .fui-Icon-filled{color:var(--colorNeutralForegroundOnBrand);}"],
  m: [["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f8zknr1:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1tx4pjd:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fu37p9p:hover{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16z8z4r:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f7ydw7o:active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledAppearances = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fziff3p", "f1mxt3zg"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useRootWithoutMediaStyles2 = __styles2({
  medium: {
    uwmqm3: ["f1rtp3s9", "f18k1jr3"]
  },
  small: {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  },
  "extra-small": {
    uwmqm3: ["f15vdbe4", "fwiuce9"]
  }
}, {
  d: [".f1rtp3s9{padding-left:7px;}", ".f18k1jr3{padding-right:7px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}"]
});
var useRootWithSecondaryActionStyles = __styles2({
  base: {
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    vrafjx: ["f1n71otn", "f1deefiw"],
    B6xbmo0: ["f146y5a9", "f1k2ftg"],
    kdpuga: ["f1ndz5i7", "f1co4qro"],
    Bs8828g: ["fyvfifd", "fbkbt8g"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  "extra-small": {
    z189sj: ["fdw0yi8", "fk8j09s"]
  }
}, {
  d: [".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f146y5a9[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusNone);}", ".f1k2ftg[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusNone);}", ".f1ndz5i7[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusNone);}", ".f1co4qro[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}"],
  m: [["@media (forced-colors: active){.fbkbt8g::before{border-top-left-radius:0;}.fyvfifd::before{border-top-right-radius:0;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInteractionTagPrimaryStyles_unstable = (state) => {
  "use no memo";
  const rootRoundedBaseClassName = useRootRoundedBaseClassName2();
  const rootCircularBaseClassName = useRootCircularBaseClassName2();
  const rootStyles = useRootStyles22();
  const rootDisabledAppearances = useRootDisabledAppearances();
  const rootWithoutMediaStyles = useRootWithoutMediaStyles2();
  const rootWithSecondaryActionStyles = useRootWithSecondaryActionStyles();
  const iconStyles = useIconStyles8();
  const mediaStyles = useMediaStyles();
  const primaryTextStyles = usePrimaryTextStyles();
  const secondaryTextBaseClassName = useSecondaryTextBaseClassName2();
  const rootCircularContrastStyles = useRootCircularContrastStyles();
  const {
    disabled,
    shape,
    size: size3,
    appearance,
    selected
  } = state;
  state.root.className = mergeClasses(interactionTagPrimaryClassNames.root, shape === "rounded" ? rootRoundedBaseClassName : rootCircularBaseClassName, shape === "circular" && !state.hasSecondaryAction && rootCircularContrastStyles.withoutSecondaryAction, disabled ? rootDisabledAppearances[appearance] : rootStyles[appearance], selected && !disabled && rootStyles.selected, rootStyles[size3], !state.media && !state.icon && rootWithoutMediaStyles[size3], state.hasSecondaryAction && rootWithSecondaryActionStyles.base, state.hasSecondaryAction && rootWithSecondaryActionStyles[size3], state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(interactionTagPrimaryClassNames.media, mediaStyles.base, mediaStyles[size3], state.media.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(interactionTagPrimaryClassNames.icon, iconStyles.base, iconStyles[size3], state.icon.className);
  }
  if (state.primaryText) {
    state.primaryText.className = mergeClasses(interactionTagPrimaryClassNames.primaryText, primaryTextStyles.base, primaryTextStyles[size3], state.secondaryText ? primaryTextStyles.withSecondaryText : primaryTextStyles.withoutSecondaryText, state.primaryText.className);
  }
  if (state.secondaryText) {
    state.secondaryText.className = mergeClasses(interactionTagPrimaryClassNames.secondaryText, secondaryTextBaseClassName, state.secondaryText.className);
  }
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagPrimary/InteractionTagPrimary.js
var InteractionTagPrimary = React456.forwardRef((props, ref) => {
  const state = useInteractionTagPrimary_unstable(props, ref);
  useInteractionTagPrimaryStyles_unstable(state);
  useCustomStyleHook("useInteractionTagPrimaryStyles_unstable")(state);
  return renderInteractionTagPrimary_unstable(state, useTagAvatarContextValues_unstable(state));
});
InteractionTagPrimary.displayName = "InteractionTagPrimary";

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/InteractionTagSecondary.js
var React458 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondary.js
var React457 = __toESM(require_react());
var useInteractionTagSecondary_unstable = (props, ref) => {
  const { appearance, disabled, handleTagDismiss, interactionTagPrimaryId, selected, shape, size: size3, value } = useInteractionTagContext_unstable();
  const id = useId2("fui-InteractionTagSecondary-", props.id);
  const onClick = useEventCallback((ev) => {
    var _props_onClick;
    props === null || props === void 0 ? void 0 : (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, ev);
    if (!ev.defaultPrevented) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  const onKeyDown = useEventCallback((ev) => {
    var _props_onKeyDown;
    props === null || props === void 0 ? void 0 : (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, ev);
    if (!ev.defaultPrevented && (ev.key === Delete || ev.key === Backspace)) {
      handleTagDismiss === null || handleTagDismiss === void 0 ? void 0 : handleTagDismiss(ev, {
        value
      });
    }
  });
  return {
    appearance,
    disabled,
    selected,
    shape,
    size: size3,
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      children: React457.createElement(DismissRegular, null),
      type: "button",
      disabled,
      ref,
      "aria-labelledby": `${interactionTagPrimaryId} ${id}`,
      ...props,
      id,
      onClick,
      onKeyDown
    }), {
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/renderInteractionTagSecondary.js
var renderInteractionTagSecondary_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/useInteractionTagSecondaryStyles.styles.js
var interactionTagSecondaryClassNames = {
  root: "fui-InteractionTagSecondary"
};
var useRootBaseClassName13 = __resetStyles("rxqbxwz", "rdjx360", [".rxqbxwz{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-left-color:var(--colorNeutralStroke1);border-top-left-radius:var(--borderRadiusNone);border-bottom-left-radius:var(--borderRadiusNone);}", ".rxqbxwz[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", ".rdjx360{color:inherit;font-family:inherit;padding:0px;border-style:none;-webkit-appearance:button;-moz-appearance:button;appearance:button;text-align:unset;background-color:transparent;display:flex;height:100%;align-items:center;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);border-right-color:var(--colorNeutralStroke1);border-top-right-radius:var(--borderRadiusNone);border-bottom-right-radius:var(--borderRadiusNone);}", ".rdjx360[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}"]);
var useRootStyles23 = __styles2({
  filled: {
    De3pzq: "f16xq7d1",
    sj55zd: "fkfq4zb",
    B4j52fo: "fre7gi1",
    Bn0qgzm: "fqdk4by",
    eoavqd: "f8491dx",
    Jwef8y: "f1h648pw",
    Bi91k9c: "f139oj5f",
    ecr2s2: "fwdzr64",
    lj723h: "f19au66r",
    kr9cjb: "fmvl6o9",
    u9orzk: "fb8cdra",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  outline: {
    De3pzq: "fhovq9v",
    sj55zd: "fkfq4zb",
    g2u3we: "fj3muxo",
    h3c5rm: ["f1akhkt", "f1lxtadh"],
    B9xav0g: "f1aperda",
    zhjwy3: ["f1lxtadh", "f1akhkt"],
    eoavqd: "f8491dx",
    Jwef8y: "f1t94bn6",
    Bi91k9c: "f139oj5f",
    ecr2s2: "f1wfn5kd",
    lj723h: "f19au66r",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  brand: {
    De3pzq: "f16xkysk",
    sj55zd: "faj9fo0",
    zhjwy3: ["f1sl6hi9", "f1c8dzaj"],
    B4j52fo: "fre7gi1",
    Bn0qgzm: "fqdk4by",
    eoavqd: "f8491dx",
    Jwef8y: "f1yj72w4",
    Bi91k9c: "f3ymbdj",
    ecr2s2: "fy3sl2y",
    lj723h: "fryz5bw",
    kr9cjb: "fmvl6o9",
    u9orzk: "fb8cdra",
    Bbkh6qg: "fkiggi6",
    Cnge2b: "f8zknr1"
  },
  selected: {
    Bgh53k4: 0,
    B2eet1l: 0,
    De3pzq: 0,
    Bcmaq0h: 0,
    gk0gix: 0,
    B20660r: 0,
    B8a6bjv: 0,
    Bpptf2m: 0,
    e5kdtc: 0,
    Bkjc3bi: 0,
    ayd6f0: "f1tdnksq",
    sj55zd: "f1phragk",
    g2u3we: "fk9qgl1",
    h3c5rm: ["f1vfbj5f", "f1qpacp7"],
    B9xav0g: "fdf0ba2",
    zhjwy3: ["f4j9k2g", "f1mg2euo"],
    B8gzw0y: "f1h3a8gf",
    By8wz76: "f1nz3ub2",
    B7iucu3: "fqc85l4",
    Jwef8y: "f15wkkf3",
    Bi91k9c: "f1rq72xc",
    Bbkh6qg: "f1tx4pjd",
    Bahaeuw: "fu37p9p",
    ecr2s2: "fsp1bjw",
    lj723h: "f18otbis",
    Cnge2b: "f16z8z4r",
    Boo3t63: "f7ydw7o"
  },
  rounded: {
    B7oj6ja: ["f1jar5jt", "fyu767a"],
    Bbmb7ep: ["f1aa9q02", "f16jpd5f"]
  },
  circular: {
    B7oj6ja: ["f1djnp8u", "f1s8kh49"],
    Bbmb7ep: ["f8fbkgy", "f1nfllo7"]
  },
  medium: {
    Be2twd7: "fe5j1ua",
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["fwiuce9", "f15vdbe4"]
  },
  small: {
    Be2twd7: "f4ybsrx",
    uwmqm3: ["f2lugmd", "f6zblan"],
    z189sj: ["f6zblan", "f2lugmd"]
  },
  "extra-small": {
    Be2twd7: "f1ugzwwg",
    uwmqm3: ["f15vdbe4", "fwiuce9"],
    z189sj: ["fwiuce9", "f15vdbe4"],
    qhf8xq: "f10pi13n",
    Ie5t1m: "fru8nlv",
    G6hvz8: "f5nasji",
    wgw0td: "f45hpys",
    Bbwa3xj: ["f1sbfcjn", "f1le4i14"],
    m3mfg4: "fq6y7a1",
    B9s7hj8: "f1jr4pq3",
    B9e1dac: "f1tfer7m"
  }
}, {
  d: [".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fre7gi1{border-top-width:0;}", ".fqdk4by{border-bottom-width:0;}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".f16xkysk{background-color:var(--colorBrandBackground2);}", ".faj9fo0{color:var(--colorBrandForeground2);}", ".f1sl6hi9{border-left-color:var(--colorBrandStroke2);}", ".f1c8dzaj{border-right-color:var(--colorBrandStroke2);}", [".f1tdnksq{background:var(--colorBrandBackground);}", {
    p: -2
  }], ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fk9qgl1{border-top-color:var(--colorBrandStroke1);}", ".f1vfbj5f{border-right-color:var(--colorBrandStroke1);}", ".f1qpacp7{border-left-color:var(--colorBrandStroke1);}", ".fdf0ba2{border-bottom-color:var(--colorBrandStroke1);}", ".f4j9k2g{border-left-color:var(--colorNeutralStrokeOnBrand2);}", ".f1mg2euo{border-right-color:var(--colorNeutralStrokeOnBrand2);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".fe5j1ua{font-size:20px;}", ".f15vdbe4{padding-left:5px;}", ".fwiuce9{padding-right:5px;}", ".f4ybsrx{font-size:16px;}", ".f2lugmd{padding-left:3px;}", ".f6zblan{padding-right:3px;}", ".f1ugzwwg{font-size:12px;}", ".f10pi13n{position:relative;}"],
  h: [".f8491dx:hover{cursor:pointer;}", ".f1h648pw:hover{background-color:var(--colorNeutralBackground3Hover);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".f1yj72w4:hover{background-color:var(--colorBrandBackground2Hover);}", ".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}"],
  a: [".fwdzr64:active{background-color:var(--colorNeutralBackground3Pressed);}", ".f19au66r:active{color:var(--colorNeutralForeground2BrandPressed);}", ".f1wfn5kd:active{background-color:var(--colorSubtleBackgroundPressed);}", ".fy3sl2y:active{background-color:var(--colorBrandBackground2Pressed);}", ".fryz5bw:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".fsp1bjw:active{background-color:var(--colorBrandBackgroundPressed);}", ".f18otbis:active{color:var(--colorNeutralForegroundOnBrand);}"],
  m: [["@media (forced-colors: active){.fmvl6o9{border-top-width:var(--strokeWidthThin);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fb8cdra{border-bottom-width:var(--strokeWidthThin);}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fkiggi6:hover{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f8zknr1:active{background-color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1h3a8gf{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqc85l4{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1tx4pjd:hover{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fu37p9p:hover{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f16z8z4r:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f7ydw7o:active{color:HighlightText;}}", {
    m: "(forced-colors: active)"
  }], ['@media (forced-colors: none){.fru8nlv:before,.fru8nlv:after{content:"";}}', {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f5nasji:before,.f5nasji:after{position:absolute;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f45hpys:before,.f45hpys:after{height:2px;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1le4i14:before,.f1le4i14:after{right:0;}.f1sbfcjn:before,.f1sbfcjn:after{left:0;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.fq6y7a1:before,.fq6y7a1:after{width:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1jr4pq3:before{bottom:100%;}}", {
    m: "(forced-colors: none)"
  }], ["@media (forced-colors: none){.f1tfer7m:after{top:100%;}}", {
    m: "(forced-colors: none)"
  }]]
});
var useRootDisabledStyles4 = __styles2({
  filled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  outline: {
    Bceei9c: "fdrzuqr",
    De3pzq: "fhovq9v",
    sj55zd: "f1s2aq7o",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"]
  },
  brand: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1bg9a2p",
    sj55zd: "f1s2aq7o",
    g2u3we: "fgig46g",
    h3c5rm: ["f1mxt3zg", "fziff3p"],
    B9xav0g: "f250w3l",
    zhjwy3: ["fy0fskl", "f15xbau"]
  }
}, {
  d: [".fdrzuqr{cursor:not-allowed;}", ".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fgig46g{border-top-color:var(--colorTransparentStrokeDisabled);}", ".f1mxt3zg{border-right-color:var(--colorTransparentStrokeDisabled);}", ".fziff3p{border-left-color:var(--colorTransparentStrokeDisabled);}", ".f250w3l{border-bottom-color:var(--colorTransparentStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"]
});
var useInteractionTagSecondaryStyles_unstable = (state) => {
  "use no memo";
  const rootBaseClassName = useRootBaseClassName13();
  const rootStyles = useRootStyles23();
  const rootDisabledStyles = useRootDisabledStyles4();
  const {
    disabled,
    selected,
    shape,
    size: size3,
    appearance
  } = state;
  state.root.className = mergeClasses(interactionTagSecondaryClassNames.root, rootBaseClassName, disabled ? rootDisabledStyles[appearance] : rootStyles[appearance], rootStyles[shape], rootStyles[size3], selected && !disabled && rootStyles.selected, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/InteractionTagSecondary/InteractionTagSecondary.js
var InteractionTagSecondary = React458.forwardRef((props, ref) => {
  const state = useInteractionTagSecondary_unstable(props, ref);
  useInteractionTagSecondaryStyles_unstable(state);
  useCustomStyleHook("useInteractionTagSecondaryStyles_unstable")(state);
  return renderInteractionTagSecondary_unstable(state);
});
InteractionTagSecondary.displayName = "InteractionTagSecondary";

// node_modules/@fluentui/react-tags/lib/components/TagGroup/TagGroup.js
var React461 = __toESM(require_react());

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroup.js
var React459 = __toESM(require_react());
var useTagGroup_unstable = (props, ref) => {
  const { onDismiss, disabled = false, defaultSelectedValues, size: size3 = "medium", appearance = "filled", dismissible = false, role = "toolbar", onTagSelect, selectedValues, ...rest } = props;
  const innerRef = React459.useRef(void 0);
  const { targetDocument } = useFluent();
  const { findNextFocusable, findPrevFocusable } = useFocusFinders();
  const [items, setItems] = useControllableState({
    defaultState: defaultSelectedValues,
    state: selectedValues,
    initialState: []
  });
  const handleTagDismiss = useEventCallback((e, data) => {
    var _innerRef_current;
    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(e, data);
    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
    if ((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement)) {
      const next = findNextFocusable(activeElement, {
        container: innerRef.current
      });
      if (next) {
        next.focus();
        return;
      }
      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.className.includes(interactionTagSecondaryClassNames.root)) {
        const prev = findPrevFocusable(activeElement.parentElement, {
          container: innerRef.current
        });
        prev === null || prev === void 0 ? void 0 : prev.focus();
      } else {
        const prev = findPrevFocusable(activeElement, {
          container: innerRef.current
        });
        prev === null || prev === void 0 ? void 0 : prev.focus();
      }
    }
  });
  const handleTagSelect = useEventCallback(mergeCallbacks(onTagSelect, (_, data) => {
    if (items.includes(data.value)) {
      setItems(items.filter((item) => item !== data.value));
    } else {
      setItems([
        ...items,
        data.value
      ]);
    }
  }));
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: true,
    axis: "both",
    memorizeCurrent: true
  });
  return {
    handleTagDismiss,
    handleTagSelect: onTagSelect ? handleTagSelect : void 0,
    selectedValues: items,
    role,
    size: size3,
    disabled,
    appearance,
    dismissible,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      // FIXME:
      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
      // but since it would be a breaking change to fix it, we are casting ref to it's proper type
      ref: useMergedRefs(ref, innerRef),
      role,
      "aria-disabled": disabled,
      ...arrowNavigationProps,
      ...rest
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/renderTagGroup.js
var renderTagGroup_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(TagGroupContextProvider, {
    value: contextValue.tagGroup,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupStyles.styles.js
var tagGroupClassNames = {
  root: "fui-TagGroup"
};
var useRootStyles24 = __styles2({
  base: {
    mc9l5x: "ftuwxu6"
  },
  medium: {
    i8kkvl: "fsnqrgy"
  },
  small: {
    i8kkvl: "f1rjii52"
  },
  "extra-small": {
    i8kkvl: "f1ufnopg"
  }
}, {
  d: [".ftuwxu6{display:inline-flex;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}"]
});
var useTagGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useRootStyles24();
  const {
    size: size3
  } = state;
  state.root.className = mergeClasses(tagGroupClassNames.root, styles.base, styles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroupContextValues.js
var React460 = __toESM(require_react());
function useTagGroupContextValues_unstable(state) {
  const { handleTagDismiss, handleTagSelect, selectedValues, size: size3, disabled, appearance, dismissible, role } = state;
  return {
    tagGroup: React460.useMemo(() => ({
      handleTagDismiss,
      handleTagSelect,
      selectedValues,
      size: size3,
      disabled,
      appearance,
      dismissible,
      role
    }), [
      handleTagDismiss,
      handleTagSelect,
      selectedValues,
      size3,
      disabled,
      appearance,
      dismissible,
      role
    ])
  };
}

// node_modules/@fluentui/react-tags/lib/components/TagGroup/TagGroup.js
var TagGroup = React461.forwardRef((props, ref) => {
  const state = useTagGroup_unstable(props, ref);
  useTagGroupStyles_unstable(state);
  useCustomStyleHook("useTagGroupStyles_unstable")(state);
  return renderTagGroup_unstable(state, useTagGroupContextValues_unstable(state));
});
TagGroup.displayName = "TagGroup";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/MessageBar.js
var React469 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBar.js
var React466 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/getIntentIcon.js
var React462 = __toESM(require_react());
function getIntentIcon(intent) {
  switch (intent) {
    case "info":
      return React462.createElement(InfoFilled, null);
    case "warning":
      return React462.createElement(WarningFilled, null);
    case "error":
      return React462.createElement(DismissCircleFilled, null);
    case "success":
      return React462.createElement(CheckmarkCircleFilled, null);
    default:
      return null;
  }
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarReflow.js
var React463 = __toESM(require_react());
function useMessageBarReflow(enabled = false) {
  const { targetDocument } = useFluent();
  const forceUpdate = React463.useReducer(() => ({}), {})[1];
  const reflowingRef = React463.useRef(false);
  const resizeObserverRef = React463.useRef(null);
  const prevInlineSizeRef = React463.useRef(-1);
  const handleResize = React463.useCallback((entries) => {
    var _entry_borderBoxSize_, _entry_borderBoxSize;
    if (entries.length > 1) {
      console.error([
        "useMessageBarReflow: Resize observer should only have one entry. ",
        "If multiple entries are observed, the first entry will be used.",
        "This is a bug, please report it to the Fluent UI team."
      ].join(" "));
    }
    const entry = entries[0];
    var _entry_borderBoxSize__inlineSize;
    const inlineSize = (_entry_borderBoxSize__inlineSize = entry === null || entry === void 0 ? void 0 : (_entry_borderBoxSize = entry.borderBoxSize) === null || _entry_borderBoxSize === void 0 ? void 0 : (_entry_borderBoxSize_ = _entry_borderBoxSize[0]) === null || _entry_borderBoxSize_ === void 0 ? void 0 : _entry_borderBoxSize_.inlineSize) !== null && _entry_borderBoxSize__inlineSize !== void 0 ? _entry_borderBoxSize__inlineSize : entry === null || entry === void 0 ? void 0 : entry.target.getBoundingClientRect().width;
    if (inlineSize === void 0 || !entry) {
      return;
    }
    const { target } = entry;
    if (!isHTMLElement(target)) {
      return;
    }
    let nextReflowing;
    if (reflowingRef.current) {
      if (prevInlineSizeRef.current < inlineSize) {
        nextReflowing = false;
      }
    } else {
      const scrollWidth = target.scrollWidth;
      if (inlineSize < scrollWidth) {
        nextReflowing = true;
      }
    }
    prevInlineSizeRef.current = inlineSize;
    if (typeof nextReflowing !== "undefined" && reflowingRef.current !== nextReflowing) {
      reflowingRef.current = nextReflowing;
      forceUpdate();
    }
  }, [
    forceUpdate
  ]);
  const ref = React463.useCallback((el) => {
    var _resizeObserverRef_current;
    if (!enabled || !el || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
      return;
    }
    (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    const win = targetDocument.defaultView;
    const resizeObserver = new win.ResizeObserver(handleResize);
    resizeObserverRef.current = resizeObserver;
    resizeObserver.observe(el, {
      box: "border-box"
    });
  }, [
    targetDocument,
    handleResize,
    enabled
  ]);
  React463.useEffect(() => {
    return () => {
      var _resizeObserverRef_current;
      (_resizeObserverRef_current = resizeObserverRef.current) === null || _resizeObserverRef_current === void 0 ? void 0 : _resizeObserverRef_current.disconnect();
    };
  }, []);
  return {
    ref,
    reflowing: reflowingRef.current
  };
}

// node_modules/@fluentui/react-message-bar/lib/contexts/messageBarTransitionContext.js
var React464 = __toESM(require_react());
var messageBarTransitionContext = React464.createContext(void 0);
var messageBarTransitionContextDefaultValue = {
  className: "",
  nodeRef: React464.createRef()
};
var MessageBarTransitionContextProvider = messageBarTransitionContext.Provider;
var useMessageBarTransitionContext = () => {
  var _React_useContext;
  return (_React_useContext = React464.useContext(messageBarTransitionContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarTransitionContextDefaultValue;
};

// node_modules/@fluentui/react-message-bar/lib/components/MotionRefForwarder.js
var React465 = __toESM(require_react());
var MotionRefForwarderContext2 = React465.createContext(void 0);
function useMotionForwardedRef2() {
  return React465.useContext(MotionRefForwarderContext2);
}
var MotionRefForwarder2 = React465.forwardRef((props, ref) => {
  return React465.createElement(MotionRefForwarderContext2.Provider, {
    value: ref
  }, props.children);
});

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBar.js
var useMessageBar_unstable = (props, ref) => {
  const { layout = "auto", intent = "info", politeness, shape = "rounded" } = props;
  const computedPoliteness = (politeness !== null && politeness !== void 0 ? politeness : intent === "info") ? "polite" : "assertive";
  const autoReflow = layout === "auto";
  const { ref: reflowRef, reflowing } = useMessageBarReflow(autoReflow);
  const computedLayout = autoReflow ? reflowing ? "multiline" : "singleline" : layout;
  const { className: transitionClassName, nodeRef } = useMessageBarTransitionContext();
  const motionRef = useMotionForwardedRef2();
  const actionsRef = React466.useRef(null);
  const bodyRef = React466.useRef(null);
  const { announce } = useAnnounce();
  const titleId = useId2();
  React466.useEffect(() => {
    var _bodyRef_current, _actionsRef_current;
    const bodyMessage = (_bodyRef_current = bodyRef.current) === null || _bodyRef_current === void 0 ? void 0 : _bodyRef_current.textContent;
    const actionsMessage = (_actionsRef_current = actionsRef.current) === null || _actionsRef_current === void 0 ? void 0 : _actionsRef_current.textContent;
    const message = [
      bodyMessage,
      actionsMessage
    ].filter(Boolean).join(",");
    announce(message, {
      polite: computedPoliteness === "polite",
      alert: computedPoliteness === "assertive"
    });
  }, [
    bodyRef,
    actionsRef,
    announce,
    computedPoliteness
  ]);
  return {
    components: {
      root: "div",
      icon: "div",
      bottomReflowSpacer: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, reflowRef, nodeRef, motionRef),
      role: "group",
      "aria-labelledby": titleId,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(props.icon, {
      renderByDefault: true,
      elementType: "div",
      defaultProps: {
        children: getIntentIcon(intent)
      }
    }),
    bottomReflowSpacer: slot_exports.optional(props.bottomReflowSpacer, {
      renderByDefault: computedLayout === "multiline",
      elementType: "div"
    }),
    layout: computedLayout,
    intent,
    transitionClassName,
    actionsRef,
    bodyRef,
    titleId,
    shape
  };
};

// node_modules/@fluentui/react-message-bar/lib/contexts/messageBarContext.js
var React467 = __toESM(require_react());
var messageBarContext = React467.createContext(void 0);
var messageBarContextDefaultValue = {
  titleId: "",
  layout: "singleline",
  actionsRef: React467.createRef(),
  bodyRef: React467.createRef()
};
var MessageBarContextProvider = messageBarContext.Provider;
var useMessageBarContext = () => {
  var _React_useContext;
  return (_React_useContext = React467.useContext(messageBarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : messageBarContextDefaultValue;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/renderMessageBar.js
var renderMessageBar_unstable = (state, contexts) => {
  assertSlots(state);
  return jsx(MessageBarContextProvider, {
    value: contexts.messageBar,
    children: jsxs(state.root, {
      children: [
        state.icon && jsx(state.icon, {}),
        state.root.children,
        state.bottomReflowSpacer && jsx(state.bottomReflowSpacer, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarStyles.styles.js
var messageBarClassNames = {
  root: "fui-MessageBar",
  icon: "fui-MessageBar__icon",
  bottomReflowSpacer: "fui-MessageBar__bottomReflowSpacer"
};
var useRootBaseStyles4 = __resetStyles("r2oyxsj", "r1wuyrhw", ['.r2oyxsj{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:"icon body secondaryActions actions";padding-left:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}', '.r1wuyrhw{white-space:nowrap;display:grid;grid-template-columns:auto 1fr auto auto;grid-template-rows:1fr;grid-template-areas:"icon body secondaryActions actions";padding-right:var(--spacingHorizontalM);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);border-radius:var(--borderRadiusMedium);align-items:center;min-height:36px;box-sizing:border-box;background-color:var(--colorNeutralBackground3);}']);
var useIconBaseStyles3 = __resetStyles("r1df1z33", "rivnfjc", [".r1df1z33{grid-area:icon;font-size:var(--fontSizeBase500);margin-right:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}", ".rivnfjc{grid-area:icon;font-size:var(--fontSizeBase500);margin-left:var(--spacingHorizontalS);color:var(--colorNeutralForeground3);display:flex;align-items:center;}"]);
var useReflowSpacerBaseStyles = __resetStyles("r1vx593n", null, [".r1vx593n{margin-bottom:var(--spacingVerticalS);grid-area:secondaryActions;}"]);
var useStyles54 = __styles2({
  rootMultiline: {
    Huce71: "f6juhto",
    Bt984gj: "f1s2louj",
    z8tnut: "f1ngh7ph",
    Budl1dq: "f17g0uqy",
    zoa1oz: "f1w7oly7"
  },
  secondaryActionsMultiline: {
    Brf1p80: "f1e8xxv9",
    B6of3ja: "f1gaxbfw",
    jrapky: "fqcjy3b",
    t21cq0: ["fibjyge", "f9yszdx"]
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  }
}, {
  d: [".f6juhto{white-space:normal;}", ".f1s2louj{align-items:start;}", ".f1ngh7ph{padding-top:var(--spacingVerticalMNudge);}", ".f17g0uqy{grid-template-columns:auto 1fr auto;}", '.f1w7oly7{grid-template-areas:"icon body actions" "secondaryActions secondaryActions secondaryActions";}', ".f1e8xxv9{justify-content:end;}", ".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}", ".fqcjy3b{margin-bottom:var(--spacingVerticalS);}", ".fibjyge{margin-right:0px;}", ".f9yszdx{margin-left:0px;}", [".fokr779{border-radius:0;}", {
    p: -1
  }]]
});
var useIconIntentStyles = __styles2({
  info: {},
  error: {
    sj55zd: "f1ca9wz"
  },
  warning: {
    sj55zd: "f14a4cve"
  },
  success: {
    sj55zd: "f36rra6"
  }
}, {
  d: [".f1ca9wz{color:var(--colorStatusDangerForeground1);}", ".f14a4cve{color:var(--colorStatusWarningForeground3);}", ".f36rra6{color:var(--colorStatusSuccessForeground1);}"]
});
var useRootIntentStyles = __styles2({
  info: {},
  error: {
    De3pzq: "f1eon7jj",
    g2u3we: "f1f8dvr7",
    h3c5rm: ["f1g1ijmo", "f1nxacbt"],
    B9xav0g: "fo25q1j",
    zhjwy3: ["f1nxacbt", "f1g1ijmo"]
  },
  warning: {
    De3pzq: "f13ftzij",
    g2u3we: "frd1ypx",
    h3c5rm: ["f1gyjrma", "f18qd5xz"],
    B9xav0g: "fqyqtrt",
    zhjwy3: ["f18qd5xz", "f1gyjrma"]
  },
  success: {
    De3pzq: "f64thcm",
    g2u3we: "f1b4u7v",
    h3c5rm: ["f1nyd2b1", "f70v3om"],
    B9xav0g: "fk173vo",
    zhjwy3: ["f70v3om", "f1nyd2b1"]
  }
}, {
  d: [".f1eon7jj{background-color:var(--colorStatusDangerBackground1);}", ".f1f8dvr7{border-top-color:var(--colorStatusDangerBorder1);}", ".f1g1ijmo{border-right-color:var(--colorStatusDangerBorder1);}", ".f1nxacbt{border-left-color:var(--colorStatusDangerBorder1);}", ".fo25q1j{border-bottom-color:var(--colorStatusDangerBorder1);}", ".f13ftzij{background-color:var(--colorStatusWarningBackground1);}", ".frd1ypx{border-top-color:var(--colorStatusWarningBorder1);}", ".f1gyjrma{border-right-color:var(--colorStatusWarningBorder1);}", ".f18qd5xz{border-left-color:var(--colorStatusWarningBorder1);}", ".fqyqtrt{border-bottom-color:var(--colorStatusWarningBorder1);}", ".f64thcm{background-color:var(--colorStatusSuccessBackground1);}", ".f1b4u7v{border-top-color:var(--colorStatusSuccessBorder1);}", ".f1nyd2b1{border-right-color:var(--colorStatusSuccessBorder1);}", ".f70v3om{border-left-color:var(--colorStatusSuccessBorder1);}", ".fk173vo{border-bottom-color:var(--colorStatusSuccessBorder1);}"]
});
var useMessageBarStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles4();
  const iconBaseStyles = useIconBaseStyles3();
  const iconIntentStyles = useIconIntentStyles();
  const rootIntentStyles = useRootIntentStyles();
  const reflowSpacerStyles = useReflowSpacerBaseStyles();
  const styles = useStyles54();
  state.root.className = mergeClasses(messageBarClassNames.root, rootBaseStyles, state.layout === "multiline" && styles.rootMultiline, state.shape === "square" && styles.square, rootIntentStyles[state.intent], state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(messageBarClassNames.icon, iconBaseStyles, iconIntentStyles[state.intent], state.icon.className);
  }
  if (state.bottomReflowSpacer) {
    state.bottomReflowSpacer.className = mergeClasses(messageBarClassNames.bottomReflowSpacer, reflowSpacerStyles);
  }
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/useMessageBarContextValues.js
var React468 = __toESM(require_react());
function useMessageBarContextValue_unstable(state) {
  const { layout, actionsRef, bodyRef, titleId } = state;
  const messageBarContext2 = React468.useMemo(() => ({
    layout,
    actionsRef,
    bodyRef,
    titleId
  }), [
    layout,
    actionsRef,
    bodyRef,
    titleId
  ]);
  return {
    messageBar: messageBarContext2
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBar/MessageBar.js
var MessageBar = React469.forwardRef((props, ref) => {
  const state = useMessageBar_unstable(props, ref);
  useMessageBarStyles_unstable(state);
  useCustomStyleHook("useMessageBarStyles_unstable")(state);
  return renderMessageBar_unstable(state, useMessageBarContextValue_unstable(state));
});
MessageBar.displayName = "MessageBar";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/MessageBarTitle.js
var React471 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitle.js
var React470 = __toESM(require_react());
var useMessageBarTitle_unstable = (props, ref) => {
  const { titleId } = useMessageBarContext();
  return {
    components: {
      root: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("span", {
      ref,
      id: titleId,
      ...props
    }), {
      elementType: "span"
    })
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/renderMessageBarTitle.js
var renderMessageBarTitle_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/useMessageBarTitleStyles.styles.js
var messageBarTitleClassNames = {
  root: "fui-MessageBarTitle"
};
var useRootBaseStyles5 = __resetStyles("r168xkm9", null, [".r168xkm9{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);}", '.r168xkm9::after{content:" ";}']);
var useMessageBarTitleStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles5();
  state.root.className = mergeClasses(messageBarTitleClassNames.root, rootBaseStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarTitle/MessageBarTitle.js
var MessageBarTitle = React471.forwardRef((props, ref) => {
  const state = useMessageBarTitle_unstable(props, ref);
  useMessageBarTitleStyles_unstable(state);
  useCustomStyleHook("useMessageBarTitleStyles_unstable")(state);
  return renderMessageBarTitle_unstable(state);
});
MessageBarTitle.displayName = "MessageBarTitle";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/MessageBarActions.js
var React474 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActions.js
var React472 = __toESM(require_react());
var useMessageBarActions_unstable = (props, ref) => {
  const { layout = "singleline", actionsRef } = useMessageBarContext();
  return {
    components: {
      root: "div",
      containerAction: "div"
    },
    containerAction: slot_exports.optional(props.containerAction, {
      renderByDefault: false,
      elementType: "div"
    }),
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, actionsRef),
      ...props
    }), {
      elementType: "div"
    }),
    layout,
    hasActions: !!props.children
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/renderMessageBarActions.js
var renderMessageBarActions_unstable = (state, contexts) => {
  assertSlots(state);
  return jsxs(ButtonContextProvider, {
    value: contexts.button,
    children: [
      state.layout === "multiline" && state.containerAction && jsx(state.containerAction, {}, "containerAction"),
      jsx(state.root, {}),
      state.layout !== "multiline" && state.containerAction && jsx(state.containerAction, {}, "containerAction")
    ]
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsStyles.styles.js
var messageBarActionsClassNames = {
  root: "fui-MessageBarActions",
  containerAction: "fui-MessageBarActions__containerAction"
};
var useRootBaseStyles6 = __resetStyles("r1t4x98y", "r15utzv5", [".r1t4x98y{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-right:var(--spacingHorizontalM);}", ".r15utzv5{grid-area:secondaryActions;display:flex;column-gap:var(--spacingHorizontalM);padding-left:var(--spacingHorizontalM);}"]);
var useContainerActionBaseStyles = __resetStyles("rgzw8nq", "r13ur29z", [".rgzw8nq{grid-area:actions;padding-right:var(--spacingHorizontalM);}", ".r13ur29z{grid-area:actions;padding-left:var(--spacingHorizontalM);}"]);
var useMultilineStyles3 = __styles2({
  root: {
    Brf1p80: "f1e8xxv9",
    B6of3ja: "f1gaxbfw",
    jrapky: "fqcjy3b",
    t21cq0: ["fibjyge", "f9yszdx"],
    z189sj: ["f1p3vkop", "f8cewkv"]
  },
  noActions: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".f1e8xxv9{justify-content:end;}", ".f1gaxbfw{margin-top:var(--spacingVerticalMNudge);}", ".fqcjy3b{margin-bottom:var(--spacingVerticalS);}", ".fibjyge{margin-right:0px;}", ".f9yszdx{margin-left:0px;}", ".f1p3vkop{padding-right:var(--spacingVerticalM);}", ".f8cewkv{padding-left:var(--spacingVerticalM);}", ".fjseox{display:none;}"]
});
var useMessageBarActionsStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles6();
  const containerActionBaseStyles = useContainerActionBaseStyles();
  const multilineStyles = useMultilineStyles3();
  state.root.className = mergeClasses(messageBarActionsClassNames.root, rootBaseStyles, state.layout === "multiline" && multilineStyles.root, !state.hasActions && multilineStyles.noActions, state.root.className);
  if (state.containerAction) {
    state.containerAction.className = mergeClasses(messageBarActionsClassNames.containerAction, containerActionBaseStyles, state.containerAction.className);
  }
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/useMessageBarActionsContextValues.js
var React473 = __toESM(require_react());
function useMessageBarActionsContextValue_unstable() {
  const buttonContext2 = React473.useMemo(() => ({
    size: "small"
  }), []);
  return {
    button: buttonContext2
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarActions/MessageBarActions.js
var MessageBarActions = React474.forwardRef((props, ref) => {
  const state = useMessageBarActions_unstable(props, ref);
  useMessageBarActionsStyles_unstable(state);
  useCustomStyleHook("useMessageBarActionsStyles_unstable")(state);
  return renderMessageBarActions_unstable(state, useMessageBarActionsContextValue_unstable());
});
MessageBarActions.displayName = "MessageBarActions";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/MessageBarBody.js
var React477 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBody.js
var React475 = __toESM(require_react());
var useMessageBarBody_unstable = (props, ref) => {
  const { bodyRef } = useMessageBarContext();
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, bodyRef),
      ...props
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/renderMessageBarBody.js
var renderMessageBarBody_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(LinkContextProvider, {
    value: contextValues.link,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyStyles.styles.js
var messageBarBodyClassNames = {
  root: "fui-MessageBarBody"
};
var useRootBaseStyles7 = __resetStyles("rtatq2b", "re2rary", [".rtatq2b{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-right:var(--spacingHorizontalM);}", ".re2rary{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);grid-area:body;padding-left:var(--spacingHorizontalM);}"]);
var useMessageBarBodyStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles7();
  state.root.className = mergeClasses(messageBarBodyClassNames.root, rootBaseStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/useMessageBarBodyContextValues.js
var React476 = __toESM(require_react());
function useMessageBarBodyContextValues_unstable(state) {
  const link = React476.useMemo(() => ({
    inline: true
  }), []);
  return {
    link
  };
}

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarBody/MessageBarBody.js
var MessageBarBody = React477.forwardRef((props, ref) => {
  const state = useMessageBarBody_unstable(props, ref);
  const ctx = useMessageBarBodyContextValues_unstable(state);
  useMessageBarBodyStyles_unstable(state);
  useCustomStyleHook("useMessageBarBodyStyles_unstable")(state);
  return renderMessageBarBody_unstable(state, ctx);
});
MessageBarBody.displayName = "MessageBarBody";

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.js
var React479 = __toESM(require_react());

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroup.js
var React478 = __toESM(require_react());
var useMessageBarGroup_unstable = (props, ref) => {
  if (true) {
    React478.Children.forEach(props.children, (c) => {
      if (!React478.isValidElement(c) || c.type === React478.Fragment) {
        throw new Error("MessageBarGroup: children must be valid MessageBar components. Please ensure you're not using fragments. ");
      }
    });
  }
  var _props_children;
  const children = React478.Children.map((_props_children = props.children) !== null && _props_children !== void 0 ? _props_children : [], (c) => React478.isValidElement(c) && c.type !== React478.Fragment ? c : null).filter(Boolean);
  var _props_animate;
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    children,
    animate: (_props_animate = props.animate) !== null && _props_animate !== void 0 ? _props_animate : "exit-only",
    enterStyles: "",
    exitStyles: ""
  };
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.motions.js
var MessageBarMotion = createPresenceComponent(({ animate }) => {
  const duration = motionTokens.durationGentle;
  return {
    enter: animate === "both" ? [
      fadeAtom({
        direction: "enter",
        duration
      }),
      slideAtom({
        direction: "enter",
        outY: "-100%",
        duration
      })
    ] : [],
    // Always exit with a fade
    exit: fadeAtom({
      direction: "exit",
      duration
    })
  };
});

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/renderMessageBarGroup.js
var renderMessageBarGroup_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(PresenceGroup, {
      children: state.children.map((child) => jsx(MessageBarMotion, {
        animate: state.animate,
        unmountOnExit: true,
        children: jsx(MotionRefForwarder2, {
          children: child
        })
      }, child.key))
    })
  });
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/useMessageBarGroupStyles.styles.js
var messageBarGroupClassNames = {
  root: "fui-MessageBarGroup"
};
var useMessageBarGroupStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(messageBarGroupClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-message-bar/lib/components/MessageBarGroup/MessageBarGroup.js
var MessageBarGroup = React479.forwardRef((props, ref) => {
  const state = useMessageBarGroup_unstable(props, ref);
  useMessageBarGroupStyles_unstable(state);
  useCustomStyleHook("useMessageBarGroupStyles_unstable")(state);
  return renderMessageBarGroup_unstable(state);
});
MessageBarGroup.displayName = "MessageBarGroup";

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/InfoLabel.js
var React483 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/renderInfoLabel.js
var renderInfoLabel_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.label, {}),
      state.infoButton && jsx(state.infoButton, {})
    ]
  });
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabel.js
var React482 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/InfoButton.js
var React481 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/renderInfoButton.js
var renderInfoButton_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.popover, {
    children: [
      jsx(PopoverTrigger, {
        children: jsx(state.root, {})
      }),
      jsx(state.info, {})
    ]
  });
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButton.js
var React480 = __toESM(require_react());

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/DefaultInfoButtonIcons.js
var DefaultInfoButtonIcon12 = bundleIcon(Info12Filled, Info12Regular);
var DefaultInfoButtonIcon16 = bundleIcon(Info16Filled, Info16Regular);
var DefaultInfoButtonIcon20 = bundleIcon(Info20Filled, Info20Regular);

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButton.js
var infoButtonIconMap = {
  small: React480.createElement(DefaultInfoButtonIcon12, null),
  medium: React480.createElement(DefaultInfoButtonIcon16, null),
  large: React480.createElement(DefaultInfoButtonIcon20, null)
};
var popoverSizeMap = {
  small: "small",
  medium: "small",
  large: "medium"
};
var useInfoButton_unstable = (props, ref) => {
  const { size: size3 = "medium", inline: inline2 = true, popover, info, ...rest } = props;
  const rootRef = useMergedRefs(ref);
  const state = {
    inline: inline2,
    size: size3,
    components: {
      root: "button",
      popover: Popover,
      info: PopoverSurface
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      children: infoButtonIconMap[size3],
      type: "button",
      "aria-label": "information",
      ...rest,
      ref: rootRef
    }), {
      elementType: "button"
    }),
    popover: slot_exports.always(popover, {
      defaultProps: {
        inline: inline2,
        positioning: "above-start",
        size: popoverSizeMap[size3],
        withArrow: true
      },
      elementType: Popover
    }),
    info: slot_exports.always(info, {
      defaultProps: {
        role: "note",
        tabIndex: -1
      },
      elementType: PopoverSurface
    })
  };
  const [popoverOpen, setPopoverOpen] = useControllableState({
    state: state.popover.open,
    defaultState: state.popover.defaultOpen,
    initialState: false
  });
  state.popover.open = popoverOpen;
  state.popover.onOpenChange = mergeCallbacks(state.popover.onOpenChange, (e, data) => setPopoverOpen(data.open));
  const infoRef = useMergedRefs(state.info.ref);
  state.info.ref = infoRef;
  const onBlurButtonOrInfo = (e) => {
    const nextFocused = e.relatedTarget;
    if (nextFocused && rootRef.current !== nextFocused && !elementContains(infoRef.current, nextFocused)) {
      setPopoverOpen(false);
    }
  };
  state.root.onBlur = useEventCallback(mergeCallbacks(state.root.onBlur, onBlurButtonOrInfo));
  state.info.onBlurCapture = useEventCallback(mergeCallbacks(state.info.onBlurCapture, onBlurButtonOrInfo));
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/useInfoButtonStyles.styles.js
var infoButtonClassNames = {
  root: "fui-InfoButton",
  // this className won't be used, but it's needed to satisfy the type checker
  popover: "fui-InfoButton__popover",
  info: "fui-InfoButton__info"
};
var useButtonStyles2 = __styles2({
  base: {
    Bt984gj: "f122n59",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    w71qe1: "f1iuv45f",
    ha4doy: "fmrv4ls",
    qhf8xq: "f10pi13n",
    De3pzq: "f1c21dwh",
    sj55zd: "fkfq4zb",
    icvyot: "f1ern45e",
    vrafjx: ["f1n71otn", "f1deefiw"],
    oivjwe: "f1h8hb77",
    wvpqe5: ["f1deefiw", "f1n71otn"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd",
    D0sxk3: "f16u1re",
    t6yez3: "f1rw4040",
    Jwef8y: "fjxutwb",
    Bi91k9c: "f139oj5f",
    eoavqd: "f8491dx",
    Bk3fhr4: "f1jpd6y0",
    Bmfj8id: "fuxngvv",
    iro3zm: "fwiml72",
    B2d53fq: "f1fg1p5m"
  },
  selected: {
    De3pzq: "f1q9pm1r",
    sj55zd: "f1qj7y59",
    D0sxk3: "fgzdkf0",
    t6yez3: "f15q0o9g",
    By8wz76: "f1nz3ub2",
    B7iucu3: "f1205bnn"
  },
  highContrast: {
    B7iucu3: "fslfhp6",
    Bfsdueo: "f11s1vgy",
    pb71ee: "f12b7wpn",
    ik86qs: "f1u668rv"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Bqhya38: "f1j6vpng",
    Bwxa6fj: ["f1pniga2", "f1ffjurs"],
    Bdhvstf: "f987i1v",
    B7zbvrb: ["f1ffjurs", "f1pniga2"],
    Bm4h7ae: "f15bsgw9",
    B7ys5i9: "f14e48fq",
    Busjfv9: "f18yb2kv",
    Bhk32uz: "fd6o370",
    f6g5ot: 0,
    Boxcth7: 0,
    Bhdgwq3: 0,
    hgwjuy: 0,
    Bshpdp8: 0,
    Bsom6fd: 0,
    Blkhhs4: 0,
    Bonggc9: 0,
    Ddfuxk: 0,
    i03rao: 0,
    kclons: 0,
    clg4pj: 0,
    Bpqj9nj: 0,
    B6dhp37: 0,
    Bf4ptjt: 0,
    Bqtpl0w: 0,
    i4rwgc: "ffwy5si",
    Dah5zi: 0,
    B1tsrr9: 0,
    qqdqy8: 0,
    Bkh64rk: 0,
    e3fwne: "f3znvyf",
    J0r882: "f57olzd",
    Bule8hv: ["f4stah7", "fs1por5"],
    Bjwuhne: "f480a47",
    Ghsupd: ["fs1por5", "f4stah7"]
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1kx978o"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", ".f1iuv45f{text-decoration-line:none;}", ".fmrv4ls{vertical-align:middle;}", ".f10pi13n{position:relative;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f16u1re .fui-Icon-filled{display:none;}", ".f1rw4040 .fui-Icon-regular{display:inline-flex;}", ".f1q9pm1r{background-color:var(--colorTransparentBackgroundSelected);}", ".f1qj7y59{color:var(--colorNeutralForeground2BrandSelected);}", ".fgzdkf0 .fui-Icon-filled{display:inline-flex;}", ".f15q0o9g .fui-Icon-regular{display:none;}", ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", '.f15bsgw9[data-fui-focus-visible]::after{content:"";}', ".f14e48fq[data-fui-focus-visible]::after{position:absolute;}", ".f18yb2kv[data-fui-focus-visible]::after{pointer-events:none;}", ".fd6o370[data-fui-focus-visible]::after{z-index:1;}", [".ffwy5si[data-fui-focus-visible]::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f3znvyf[data-fui-focus-visible]::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f57olzd[data-fui-focus-visible]::after{top:calc(2px * -1);}", ".f4stah7[data-fui-focus-visible]::after{right:calc(2px * -1);}", ".fs1por5[data-fui-focus-visible]::after{left:calc(2px * -1);}", ".f480a47[data-fui-focus-visible]::after{bottom:calc(2px * -1);}", [".f1kx978o{padding:var(--spacingVerticalXXS) var(--spacingVerticalXXS);}", {
    p: -1
  }]],
  h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f8491dx:hover{cursor:pointer;}", ".f1jpd6y0:hover .fui-Icon-filled{display:inline-flex;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
  m: [["@media (forced-colors: active){.f1nz3ub2{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1205bnn{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fslfhp6{color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f11s1vgy:hover,.f11s1vgy:hover:active{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f12b7wpn:hover,.f12b7wpn:hover:active{background-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1u668rv:hover,.f1u668rv:hover:active{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1j6vpng[data-fui-focus-visible]::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1ffjurs[data-fui-focus-visible]::after{border-left-color:Highlight;}.f1pniga2[data-fui-focus-visible]::after{border-right-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f987i1v[data-fui-focus-visible]::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"]
});
var usePopoverSurfaceStyles2 = __styles2({
  base: {
    B2u0y6b: "f1qmtlvf"
  },
  smallMedium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f1qmtlvf{max-width:264px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useInfoButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const {
    open
  } = state.popover;
  const buttonStyles = useButtonStyles2();
  const popoverSurfaceStyles = usePopoverSurfaceStyles2();
  state.info.className = mergeClasses(infoButtonClassNames.info, popoverSurfaceStyles.base, size3 === "large" ? popoverSurfaceStyles.large : popoverSurfaceStyles.smallMedium, state.info.className);
  state.root.className = mergeClasses(infoButtonClassNames.root, buttonStyles.base, buttonStyles.highContrast, buttonStyles.focusIndicator, open && buttonStyles.selected, size3 === "large" && buttonStyles.large, state.root.className);
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoButton/InfoButton.js
var InfoButton = React481.forwardRef((props, ref) => {
  const state = useInfoButton_unstable(props, ref);
  useInfoButtonStyles_unstable(state);
  useCustomStyleHook("useInfoButtonStyles_unstable")(state);
  return renderInfoButton_unstable(state);
});
InfoButton.displayName = "InfoButton";

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabel.js
var useInfoLabel_unstable = (props, ref) => {
  const { root: rootShorthand, label: labelShorthand, infoButton: infoButtonShorthand, info, size: size3, className, style, ...labelProps } = props;
  const baseId = useId2("infolabel-");
  const [open, setOpen] = React482.useState(false);
  const root = slot_exports.always(rootShorthand, {
    defaultProps: {
      className,
      style
    },
    elementType: "span"
  });
  const label = slot_exports.always(labelShorthand, {
    defaultProps: {
      id: baseId + "__label",
      ref,
      size: size3,
      ...labelProps
    },
    elementType: Label
  });
  const infoButton = slot_exports.optional(infoButtonShorthand, {
    renderByDefault: !!info,
    defaultProps: {
      id: baseId + "__infoButton",
      size: size3,
      info
    },
    elementType: InfoButton
  });
  const infoButtonPopover = slot_exports.always(infoButton === null || infoButton === void 0 ? void 0 : infoButton.popover, {
    elementType: "div"
  });
  infoButtonPopover.onOpenChange = useEventCallback(mergeCallbacks(infoButtonPopover.onOpenChange, (_2, data) => {
    setOpen(data.open);
  }));
  if (infoButton) {
    var _infoButton, _arialabelledby;
    infoButton.popover = infoButtonPopover;
    const infoPopupId = baseId + "__info";
    infoButton.info = slot_exports.optional(infoButton === null || infoButton === void 0 ? void 0 : infoButton.info, {
      defaultProps: {
        id: infoPopupId,
        "aria-labelledby": infoPopupId
      },
      elementType: "div"
    });
    var _;
    (_ = (_infoButton = infoButton)[_arialabelledby = "aria-labelledby"]) !== null && _ !== void 0 ? _ : _infoButton[_arialabelledby] = `${label.id} ${infoButton.id}`;
    if (open) {
      var _infoButton_info;
      var _root, _ariaowns;
      var _1;
      (_1 = (_root = root)[_ariaowns = "aria-owns"]) !== null && _1 !== void 0 ? _1 : _root[_ariaowns] = (_infoButton_info = infoButton.info) === null || _infoButton_info === void 0 ? void 0 : _infoButton_info.id;
    }
  }
  return {
    size: size3,
    components: {
      root: "span",
      label: Label,
      infoButton: InfoButton
    },
    root,
    label,
    infoButton
  };
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/useInfoLabelStyles.styles.js
var infoLabelClassNames = {
  root: "fui-InfoLabel",
  label: "fui-InfoLabel__label",
  infoButton: "fui-InfoLabel__infoButton"
};
var useLabelStyles6 = __styles2({
  base: {
    ha4doy: "f12kltsn",
    Bceei9c: "fpo1scq",
    sj55zd: "f1ym3bx4"
  }
}, {
  d: [".f12kltsn{vertical-align:top;}", ".fpo1scq{cursor:inherit;}", ".f1ym3bx4{color:inherit;}"]
});
var useInfoButtonStyles = __styles2({
  base: {
    ha4doy: "f12kltsn",
    B6of3ja: "f1bmzb36",
    jrapky: "f1nyzk09"
  },
  large: {
    B6of3ja: "fkrn0sh",
    jrapky: "fmxx68s"
  }
}, {
  d: [".f12kltsn{vertical-align:top;}", ".f1bmzb36{margin-top:calc(0px - var(--spacingVerticalXXS));}", ".f1nyzk09{margin-bottom:calc(0px - var(--spacingVerticalXXS));}", ".fkrn0sh{margin-top:-1px;}", ".fmxx68s{margin-bottom:-1px;}"]
});
var useInfoLabelStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(infoLabelClassNames.root, state.root.className);
  const labelStyles = useLabelStyles6();
  state.label.className = mergeClasses(infoLabelClassNames.label, labelStyles.base, state.label.className);
  const infoButtonStyles = useInfoButtonStyles();
  if (state.infoButton) {
    state.infoButton.className = mergeClasses(infoLabelClassNames.infoButton, infoButtonStyles.base, state.size === "large" && infoButtonStyles.large, state.infoButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-infolabel/lib/components/InfoLabel/InfoLabel.js
var InfoLabel = React483.forwardRef((props, ref) => {
  const state = useInfoLabel_unstable(props, ref);
  useInfoLabelStyles_unstable(state);
  useCustomStyleHook("useInfoLabelStyles_unstable")(state);
  return renderInfoLabel_unstable(state);
});
InfoLabel.displayName = "InfoLabel";

// node_modules/@fluentui/react-drawer/lib/contexts/drawerContext.js
var React484 = __toESM(require_react());
var defaultContextValue4 = {
  scrollState: "none",
  setScrollState: () => ({})
};
var drawerContext = React484.createContext(void 0);
var DrawerProvider = drawerContext.Provider;
var useDrawerContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React484.useContext(drawerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue4;
};
var useDrawerContextValue = () => {
  const [scrollState, setScrollState] = React484.useState("none");
  return {
    setScrollState,
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/Drawer.js
var React493 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawer.js
var React492 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawer.js
var React489 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawer.js
var React487 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/shared/useDrawerBaseStyles.styles.js
var drawerCSSVars = {
  drawerSizeVar: "--fui-Drawer--size"
};
var drawerDefaultStyles = {
  overflow: "hidden",
  width: `var(${drawerCSSVars.drawerSizeVar})`,
  maxWidth: "100vw",
  height: "auto",
  maxHeight: "100vh",
  boxSizing: "border-box",
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start",
  justifyContent: "flex-start",
  backgroundColor: tokens.colorNeutralBackground1,
  color: tokens.colorNeutralForeground1
};
var useDrawerStyles = __styles2({
  start: {
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    u1mtju: ["f1xteiwb", "fsqykmd"],
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    j35jbq: ["fvfyk4", "frppm18"]
  },
  end: {
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    B4g9neb: ["fsqykmd", "f1xteiwb"],
    j35jbq: ["f1e31b4d", "f1vgc2s3"],
    oyh7mz: ["frppm18", "fvfyk4"]
  },
  bottom: {
    B5kzvoi: "f1yab3r1",
    Bhzewxz: "f198g47y"
  },
  small: {
    Bjr0ffy: "f1exhnwo"
  },
  medium: {
    Bjr0ffy: "fqofjzu"
  },
  large: {
    Bjr0ffy: "fce6y3m"
  },
  full: {
    Bjr0ffy: "fsdmzs6"
  }
}, {
  d: [[".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".fvfyk4{right:auto;}", ".frppm18{left:auto;}", [".fsqykmd{border-left:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1xteiwb{border-right:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -1
  }], ".f1yab3r1{bottom:0;}", ".f198g47y{top:auto;}", ".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".fsdmzs6{--fui-Drawer--size:100vw;}"]
});
var useDrawerBottomBaseStyles = __styles2({
  small: {
    Bjr0ffy: "f1exhnwo"
  },
  medium: {
    Bjr0ffy: "fqofjzu"
  },
  large: {
    Bjr0ffy: "fce6y3m"
  },
  full: {
    Bjr0ffy: "f1rat34m"
  }
}, {
  d: [".f1exhnwo{--fui-Drawer--size:320px;}", ".fqofjzu{--fui-Drawer--size:592px;}", ".fce6y3m{--fui-Drawer--size:940px;}", ".f1rat34m{--fui-Drawer--size:100%;}"]
});
var useDrawerBaseClassNames = ({
  position,
  size: size3
}) => {
  const baseStyles3 = useDrawerStyles();
  const bottomBaseStyles = useDrawerBottomBaseStyles();
  return mergeClasses(baseStyles3[position], position === "bottom" && bottomBaseStyles[size3], position !== "bottom" && baseStyles3[size3]);
};

// node_modules/@fluentui/react-drawer/lib/shared/drawerMotions.js
var durations3 = {
  small: motionTokens.durationGentle,
  medium: motionTokens.durationSlow,
  large: motionTokens.durationSlower,
  full: motionTokens.durationUltraSlow
};
function getPositionTransform(position, sizeVar, dir) {
  const leftToRightTransform = `translate3d(var(${sizeVar}), 0, 0)`;
  const rightToLeftTransform = `translate3d(calc(var(${sizeVar}) * -1), 0, 0)`;
  const bottomToTopTransform = `translate3d(0, var(${sizeVar}), 0)`;
  if (position === "start") {
    return dir === "ltr" ? rightToLeftTransform : leftToRightTransform;
  }
  if (position === "end") {
    return dir === "ltr" ? leftToRightTransform : rightToLeftTransform;
  }
  if (position === "bottom") {
    return bottomToTopTransform;
  }
  return "translate3d(0, 0, 0)";
}
var InlineDrawerMotion = createPresenceComponent(({ position, size: size3, dir }) => {
  const keyframes = [
    {
      /**
      * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
      * The work will be done in the #32817
      */
      transform: getPositionTransform(position, drawerCSSVars.drawerSizeVar, dir),
      opacity: 0
    },
    {
      transform: "translate3d(0, 0, 0)",
      opacity: 1
    }
  ];
  const duration = durations3[size3];
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var OverlayDrawerMotion = createPresenceComponent(({ position, size: size3, dir }) => {
  const keyframes = [
    {
      /**
      * TODO: Once the #31663 lands, we should update the RTL logic to use Motion APIs
      * The work will be done in the #32817
      */
      transform: getPositionTransform(position, drawerCSSVars.drawerSizeVar, dir),
      boxShadow: `0px ${tokens.colorTransparentBackground}`,
      opacity: 0
    },
    {
      transform: "translate3d(0, 0, 0)",
      boxShadow: tokens.shadow64,
      opacity: 1
    }
  ];
  const duration = durations3[size3];
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var OverlaySurfaceBackdropMotion = createPresenceComponent(({ size: size3 }) => {
  const duration = durations3[size3];
  const easing = motionTokens.curveLinear;
  return {
    enter: fadeAtom({
      direction: "enter",
      duration,
      easing
    }),
    exit: fadeAtom({
      direction: "exit",
      duration,
      easing
    })
  };
});

// node_modules/@fluentui/react-drawer/lib/shared/useDrawerDefaultProps.js
function useDrawerDefaultProps(props) {
  const { open = false, size: size3 = "small", position = "start", unmountOnClose = true } = props;
  return {
    size: size3,
    position,
    open,
    unmountOnClose
  };
}

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/OverlayDrawerSurface.js
var React485 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/useOverlayDrawerSurfaceStyles.styles.js
var useBackdropResetStyles = __resetStyles("rl76ifk", null, [".rl76ifk{inset:0px;position:fixed;background-color:var(--colorBackgroundOverlay);}"]);
var useBackdropStyles = __styles2({
  nested: {
    De3pzq: "f1c21dwh"
  },
  drawerHidden: {
    Bkecrkj: "f1aehjj5"
  }
}, {
  d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1aehjj5{pointer-events:none;}"]
});
var useOverlayDrawerSurfaceStyles_unstable = (state) => {
  "use no memo";
  const {
    isNestedDialog,
    backdrop,
    open,
    unmountOnClose
  } = state;
  const backdropResetStyles = useBackdropResetStyles();
  const backdropStyles = useBackdropStyles();
  const mountedAndClosed = !unmountOnClose && !open;
  if (backdrop) {
    backdrop.className = mergeClasses(backdropResetStyles, isNestedDialog && backdropStyles.nested, mountedAndClosed && backdropStyles.drawerHidden, backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawerSurface/OverlayDrawerSurface.js
var OverlayDrawerSurface = React485.forwardRef((props, ref) => {
  const dialogSurfaceState = useDialogSurface_unstable({
    ...props,
    /**
    * Drawer accepts a `div` or `aside` element type, but Dialog only accepts a `div` element type.
    * We need to cast the ref to a `div` element type to not break Dialog's ref type.
    *
    * FIXME: Evaluate the possibility to remove this cast when Dialog is refactored to accept `aside` elements.
    */
    as: props.as
  }, ref);
  const dialogSurfaceContextValues = useDialogSurfaceContextValues_unstable(dialogSurfaceState);
  useOverlayDrawerSurfaceStyles_unstable(dialogSurfaceState);
  useCustomStyleHook("useOverlayDrawerSurfaceStyles_unstable")(dialogSurfaceState);
  return renderDialogSurface_unstable(dialogSurfaceState, dialogSurfaceContextValues);
});
OverlayDrawerSurface.displayName = "OverlayDrawerSurface";

// node_modules/@fluentui/react-drawer/lib/shared/drawerMotionUtils.js
var React486 = __toESM(require_react());
function mergePresenceSlots(inputSlot, Component2, params) {
  if (inputSlot === null) {
    return null;
  }
  return {
    ...inputSlot,
    children: (_, props) => {
      if (inputSlot === null || inputSlot === void 0 ? void 0 : inputSlot.children) {
        return inputSlot.children(Component2, {
          ...props,
          ...params
        });
      }
      return React486.createElement(Component2, {
        ...props,
        ...params
      }, props.children);
    }
  };
}

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawer.js
var STATIC_MOTION = {
  active: true,
  canRender: true,
  ref: React487.createRef(),
  type: "idle"
};
var useOverlayDrawer_unstable = (props, ref) => {
  const { open, size: size3, position, unmountOnClose } = useDrawerDefaultProps(props);
  const { modalType = "modal", inertTrapFocus, onOpenChange, backdropMotion, surfaceMotion, mountNode } = props;
  const { dir, targetDocument } = useFluent();
  const { element: mountNodeElement } = toMountNodeProps(mountNode);
  const hasMountNodeElement = Boolean(mountNodeElement && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body) !== mountNodeElement);
  const backdropProps = slot_exports.resolveShorthand(props.backdrop);
  const hasCustomBackdrop = modalType !== "non-modal" && backdropProps !== null;
  const root = slot_exports.always({
    ...props,
    ref,
    unmountOnClose,
    backdrop: hasCustomBackdrop ? {
      ...backdropProps
    } : null,
    backdropMotion: mergePresenceSlots(backdropMotion, OverlaySurfaceBackdropMotion, {
      size: size3
    })
  }, {
    elementType: OverlayDrawerSurface
  });
  const dialog = slot_exports.always({
    open,
    onOpenChange,
    inertTrapFocus,
    modalType,
    unmountOnClose,
    surfaceMotion: mergePresenceSlots(surfaceMotion, OverlayDrawerMotion, {
      position,
      size: size3,
      dir
    }),
    /**
    * children is not needed here because we construct the children in the render function,
    * but it's required by DialogProps
    */
    children: null
  }, {
    elementType: Dialog
  });
  return {
    components: {
      root: OverlayDrawerSurface,
      dialog: Dialog
    },
    root,
    dialog,
    open,
    size: size3,
    position,
    hasMountNodeElement,
    unmountOnClose,
    // Deprecated props
    mountNode,
    motion: STATIC_MOTION
  };
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/renderOverlayDrawer.js
var renderOverlayDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.dialog, {
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/useOverlayDrawerStyles.styles.js
var React488 = __toESM(require_react());
var overlayDrawerClassNames = {
  root: "fui-OverlayDrawer",
  backdrop: "fui-OverlayDrawer__backdrop"
};
var useDrawerResetStyles = __resetStyles("r7dfyj8", "rmx02j7", {
  r: [".r7dfyj8{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}", ".r7dfyj8:focus{outline-style:none;}", ".r7dfyj8:focus-visible{outline-style:none;}", ".r7dfyj8[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r7dfyj8[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rmx02j7{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:fixed;top:0;bottom:0;}", ".rmx02j7:focus{outline-style:none;}", ".rmx02j7:focus-visible{outline-style:none;}", ".rmx02j7[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rmx02j7[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border:2px solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
  s: ["@media (forced-colors: active){.r7dfyj8[data-fui-focus-visible]::after{border-top-color:Highlight;border-right-color:Highlight;border-bottom-color:Highlight;border-left-color:Highlight;}}", "@media (forced-colors: active){.rmx02j7[data-fui-focus-visible]::after{border-top-color:Highlight;border-left-color:Highlight;border-bottom-color:Highlight;border-right-color:Highlight;}}"]
});
var useDrawerRootStyles = __styles2({
  start: {},
  end: {},
  bottom: {
    Bhzewxz: "f198g47y",
    Bqenvij: "fub80nq",
    a9b677: "fr97h3j"
  },
  absolute: {
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f198g47y{top:auto;}", ".fub80nq{height:var(--fui-Drawer--size);}", ".fr97h3j{width:100vw;}", ".f1euv43f{position:absolute;}"]
});
var useOverlayDrawerStyles_unstable = (state) => {
  "use no memo";
  const baseClassNames = useDrawerBaseClassNames(state);
  const resetStyles = useDrawerResetStyles();
  const rootStyles = useDrawerRootStyles();
  const absoluteStyles = state.hasMountNodeElement && rootStyles.absolute;
  const backdrop = state.root.backdrop;
  state.root.className = mergeClasses(overlayDrawerClassNames.root, baseClassNames, resetStyles, rootStyles[state.position], absoluteStyles, state.root.className);
  if (backdrop) {
    backdrop.className = mergeClasses(overlayDrawerClassNames.backdrop, absoluteStyles, backdrop.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/OverlayDrawer/OverlayDrawer.js
var OverlayDrawer = React489.forwardRef((props, ref) => {
  const state = useOverlayDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useOverlayDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerOverlayStyles_unstable")(state);
  useCustomStyleHook("useOverlayDrawerStyles_unstable")(state);
  return renderOverlayDrawer_unstable(state, contextValue);
});
OverlayDrawer.displayName = "OverlayDrawer";

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
var React491 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawer.js
var React490 = __toESM(require_react());
var STATIC_MOTION2 = {
  active: true,
  canRender: true,
  ref: React490.createRef(),
  type: "idle"
};
var useInlineDrawer_unstable = (props, ref) => {
  const { size: size3, position, open, unmountOnClose } = useDrawerDefaultProps(props);
  const { separator = false, surfaceMotion } = props;
  const { dir } = useFluent();
  const [animationDirection, setAnimationDirection] = React490.useState(open ? "enter" : "exit");
  return {
    components: {
      root: "div",
      // casting from internal type that has required properties
      // to external type that only has optional properties
      // converting to unknown first as both Function component signatures are not compatible
      surfaceMotion: InlineDrawerMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      ref,
      "aria-hidden": !unmountOnClose && !open ? true : void 0
    }), {
      elementType: "div"
    }),
    open,
    position,
    size: size3,
    separator,
    unmountOnClose,
    animationDirection,
    surfaceMotion: presenceMotionSlot(surfaceMotion, {
      elementType: InlineDrawerMotion,
      defaultProps: {
        position,
        size: size3,
        dir,
        visible: open,
        appear: unmountOnClose,
        unmountOnExit: unmountOnClose,
        onMotionFinish: (_, { direction }) => setAnimationDirection(direction),
        onMotionStart: (_, { direction }) => {
          if (direction === "enter") {
            setAnimationDirection("enter");
          }
        }
      }
    }),
    // Deprecated props
    motion: STATIC_MOTION2
  };
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/renderInlineDrawer.js
var renderInlineDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.surfaceMotion, {
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/useInlineDrawerStyles.styles.js
var inlineDrawerClassNames = {
  root: "fui-InlineDrawer"
};
var useDrawerResetStyles2 = __resetStyles("rkjj3x6", null, [".rkjj3x6{overflow:hidden;width:var(--fui-Drawer--size);max-width:100vw;height:auto;max-height:100vh;box-sizing:border-box;display:flex;flex-direction:column;align-items:flex-start;justify-content:flex-start;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);position:relative;}"]);
var borderValue = `1px solid ${tokens.colorNeutralBackground3}`;
var useDrawerRootStyles2 = __styles2({
  separatorStart: {
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    u1mtju: ["f1cxmi7i", "f1j970fk"]
  },
  separatorEnd: {
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    B4g9neb: ["f1j970fk", "f1cxmi7i"]
  },
  separatorBottom: {
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    i8vvqc: "f1n3kblk"
  },
  start: {},
  end: {},
  bottom: {
    a9b677: "fly5x3f",
    Bqenvij: "fub80nq"
  },
  animationExitStart: {
    a9b677: "f3tsq5r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh"
  },
  animationExitEnd: {
    a9b677: "f3tsq5r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh"
  },
  animationExitBottom: {
    Bqenvij: "fniina8",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh"
  }
}, {
  d: [[".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1j970fk{border-left:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1cxmi7i{border-right:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], [".f1n3kblk{border-top:1px solid var(--colorNeutralBackground3);}", {
    p: -1
  }], ".fly5x3f{width:100%;}", ".fub80nq{height:var(--fui-Drawer--size);}", ".f3tsq5r{width:0;}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".f3bhgqh{border:none;}", {
    p: -2
  }], ".fniina8{height:0;}", [".f3bhgqh{border:none;}", {
    p: -2
  }]]
});
function getSeparatorClass(state, classNames) {
  if (!state.separator) {
    return void 0;
  }
  switch (state.position) {
    case "start":
      return classNames.separatorStart;
    case "end":
      return classNames.separatorEnd;
    case "bottom":
      return classNames.separatorBottom;
    default:
      return void 0;
  }
}
function getAnimationExitClass(state, classNames) {
  switch (state.position) {
    case "start":
      return classNames.animationExitStart;
    case "end":
      return classNames.animationExitEnd;
    case "bottom":
      return classNames.animationExitBottom;
    default:
      return void 0;
  }
}
var useInlineDrawerStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useDrawerResetStyles2();
  const baseClassNames = useDrawerBaseClassNames(state);
  const rootStyles = useDrawerRootStyles2();
  state.root.className = mergeClasses(inlineDrawerClassNames.root, resetStyles, baseClassNames, getSeparatorClass(state, rootStyles), rootStyles[state.position], state.animationDirection === "exit" && getAnimationExitClass(state, rootStyles), state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/InlineDrawer/InlineDrawer.js
var InlineDrawer = React491.forwardRef((props, ref) => {
  const state = useInlineDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useInlineDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerInlineStyles_unstable")(state);
  useCustomStyleHook("useInlineDrawerStyles_unstable")(state);
  return renderInlineDrawer_unstable(state, contextValue);
});
InlineDrawer.displayName = "InlineDrawer";

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawer.js
var useDrawer_unstable = (props, ref) => {
  const elementType = props.type === "inline" ? InlineDrawer : OverlayDrawer;
  const root = slot_exports.always({
    ref,
    ...props
  }, {
    elementType
  });
  return {
    components: {
      root: elementType
    },
    root
  };
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/renderDrawer.js
var renderDrawer_unstable = (state, contextValue) => {
  assertSlots(state);
  return jsx(DrawerProvider, {
    value: contextValue,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/useDrawerStyles.styles.js
var drawerClassNames = {
  root: "fui-Drawer"
};
var useDrawerStyles_unstable = (state) => {
  "use no memo";
  state.root.className = mergeClasses(drawerClassNames.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/Drawer/Drawer.js
var Drawer = React493.forwardRef((props, ref) => {
  const state = useDrawer_unstable(props, ref);
  const contextValue = useDrawerContextValue();
  useDrawerStyles_unstable(state);
  useCustomStyleHook("useDrawerStyles_unstable")(state);
  return renderDrawer_unstable(state, contextValue);
});
Drawer.displayName = "Drawer";

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
var React495 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBody.js
var React494 = __toESM(require_react());
var getScrollState = ({ scrollTop, scrollHeight, clientHeight }) => {
  if (scrollHeight <= clientHeight) {
    return "none";
  }
  if (scrollTop === 0) {
    return "top";
  }
  if (scrollTop + clientHeight === scrollHeight) {
    return "bottom";
  }
  return "middle";
};
var useDrawerBody_unstable = (props, ref) => {
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const { setScrollState } = useDrawerContext_unstable();
  const scrollRef = React494.useRef(null);
  const mergedRef = useMergedRefs(ref, scrollRef);
  const [setScrollAnimationFrame, cancelScrollAnimationFrame] = useAnimationFrame();
  const [setResizeAnimationFrame, cancelResizeAnimationFrame] = useAnimationFrame();
  const updateScrollState = React494.useCallback(() => {
    if (!scrollRef.current) {
      return;
    }
    setScrollState(getScrollState(scrollRef.current));
  }, [
    setScrollState
  ]);
  const onScroll = React494.useCallback(() => {
    cancelScrollAnimationFrame();
    setScrollAnimationFrame(updateScrollState);
  }, [
    cancelScrollAnimationFrame,
    setScrollAnimationFrame,
    updateScrollState
  ]);
  useIsomorphicLayoutEffect(updateScrollState, [
    props.children,
    updateScrollState
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!scrollRef.current || !(win === null || win === void 0 ? void 0 : win.ResizeObserver)) {
      return;
    }
    const observer = new win.ResizeObserver(() => setResizeAnimationFrame(updateScrollState));
    observer.observe(scrollRef.current);
    return () => {
      observer.disconnect();
      cancelResizeAnimationFrame();
    };
  }, [
    setResizeAnimationFrame,
    cancelResizeAnimationFrame,
    updateScrollState,
    win
  ]);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: mergedRef,
      ...props,
      onScroll: mergeCallbacks(props.onScroll, onScroll)
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/renderDrawerBody.js
var renderDrawerBody_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/useDrawerBodyStyles.styles.js
var drawerBodyClassNames = {
  root: "fui-DrawerBody"
};
var useStyles55 = __resetStyles("ri6rvx7", null, [".ri6rvx7{padding:0 var(--spacingHorizontalXXL);flex:1;align-self:stretch;position:relative;z-index:1;overflow:auto;}", ".ri6rvx7:last-child{padding-bottom:calc(var(--spacingHorizontalXXL) + 1px);}", ".ri6rvx7:first-child{padding-top:calc(var(--spacingHorizontalXXL) + 1px);}"]);
var useDrawerBodyStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles55();
  state.root.className = mergeClasses(drawerBodyClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerBody/DrawerBody.js
var DrawerBody = React495.forwardRef((props, ref) => {
  const state = useDrawerBody_unstable(props, ref);
  useDrawerBodyStyles_unstable(state);
  useCustomStyleHook("useDrawerBodyStyles_unstable")(state);
  return renderDrawerBody_unstable(state);
});
DrawerBody.displayName = "DrawerBody";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
var React497 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeader.js
var React496 = __toESM(require_react());
var useDrawerHeader_unstable = (props, ref) => {
  const { scrollState } = useDrawerContext_unstable();
  return {
    components: {
      root: "header"
    },
    root: slot_exports.always(getIntrinsicElementProps("header", {
      ref,
      role: "none",
      ...props
    }), {
      elementType: "header"
    }),
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/renderDrawerHeader.js
var renderDrawerHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/shared/drawerSeparatorStyles.js
var drawerSeparatorStyles = {
  height: "1px",
  position: "absolute",
  right: 0,
  left: 0,
  opacity: 0,
  backgroundColor: tokens.colorNeutralStroke1,
  transitionDuration: tokens.durationNormal,
  transitionProperty: "opacity",
  transitionTimingFunction: tokens.curveEasyEase,
  content: '""'
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/useDrawerHeaderStyles.styles.js
var drawerHeaderClassNames = {
  root: "fui-DrawerHeader"
};
var useStyles56 = __resetStyles("r3ovn4i", null, [".r3ovn4i{width:100%;max-width:100%;padding:var(--spacingVerticalXXL) var(--spacingHorizontalXXL) var(--spacingVerticalS);gap:var(--spacingHorizontalS);align-self:stretch;display:flex;flex-direction:column;box-sizing:border-box;position:relative;z-index:2;}"]);
var useDrawerHeaderStyles = __styles2({
  separator: {
    Dlnsje: "fxnjyrl",
    E3zdtr: "f1mdlcz9",
    B1piin3: ["f15yvnhg", "f1n6gb5g"],
    Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
    Bp15pi3: "f1564nw5",
    Bjyk6c5: "fdlpgxj",
    F2fol1: "f15cmg8x",
    Ba2ppi3: "f3f8dgl",
    B1dyfl9: "fjvo4va",
    Bsft5z2: "f13zj6fq",
    By385i5: "fo72kxq"
  },
  separatorVisible: {
    Bp15pi3: "fjsqi2x"
  }
}, {
  d: [".fxnjyrl::after{height:1px;}", ".f1mdlcz9::after{position:absolute;}", ".f15yvnhg::after{right:0;}", ".f1n6gb5g::after{left:0;}", ".f1564nw5::after{opacity:0;}", ".fdlpgxj::after{background-color:var(--colorNeutralStroke1);}", ".f15cmg8x::after{transition-duration:var(--durationNormal);}", ".f3f8dgl::after{transition-property:opacity;}", ".fjvo4va::after{transition-timing-function:var(--curveEasyEase);}", '.f13zj6fq::after{content:"";}', ".fo72kxq::after{bottom:0;}", ".fjsqi2x::after{opacity:1;}"]
});
var useDrawerHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles56();
  const rootStyles = useDrawerHeaderStyles();
  state.root.className = mergeClasses(drawerHeaderClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "bottom"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeader/DrawerHeader.js
var DrawerHeader = React497.forwardRef((props, ref) => {
  const state = useDrawerHeader_unstable(props, ref);
  useDrawerHeaderStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderStyles_unstable")(state);
  return renderDrawerHeader_unstable(state);
});
DrawerHeader.displayName = "DrawerHeader";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
var React499 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitle.js
var React498 = __toESM(require_react());
var useDrawerHeaderTitle_unstable = (props, ref) => {
  const { children, heading } = props;
  const headingId = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
  return {
    components: {
      root: "div",
      heading: "h2",
      action: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    heading: slot_exports.optional(heading, {
      defaultProps: {
        id: headingId,
        children
      },
      renderByDefault: true,
      elementType: "h2"
    }),
    action: slot_exports.optional(props.action, {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/renderDrawerHeaderTitle.js
var renderDrawerHeaderTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.heading && jsx(state.heading, {}),
      state.action && jsx(state.action, {})
    ]
  });
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/useDrawerHeaderTitleStyles.styles.js
var drawerHeaderTitleClassNames = {
  root: "fui-DrawerHeaderTitle",
  heading: "fui-DrawerHeaderTitle__heading",
  action: "fui-DrawerHeaderTitle__action"
};
var useStyles57 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Brf1p80: "f1869bpl",
    Bt984gj: "f122n59",
    i8kkvl: "fsnqrgy"
  },
  action: {
    t21cq0: ["faqnl2i", "fd75udd"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1869bpl{justify-content:space-between;}", ".f122n59{align-items:center;}", ".fsnqrgy{column-gap:var(--spacingHorizontalS);}", ".faqnl2i{margin-right:calc(var(--spacingHorizontalS) * -1);}", ".fd75udd{margin-left:calc(var(--spacingHorizontalS) * -1);}"]
});
var useDrawerHeaderTitleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles57();
  const {
    heading: root = {},
    action,
    // We should not use components to pass along the base element type of a slot
    // but there's no way to retrieve the element type of a slot from the slot definition
    // right now without using SLOT_ELEMENT_TYPE_SYMBOL
    // TODO: create a method to retrieve the element type of a slot
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    components
  } = state;
  useDialogTitleStyles_unstable({
    components: {
      root: components.heading,
      action: components.action
    },
    root,
    action
  });
  state.root.className = mergeClasses(drawerHeaderTitleClassNames.root, styles.root, state.root.className);
  if (state.heading) {
    state.heading.className = mergeClasses(drawerHeaderTitleClassNames.heading, state.heading.className);
  }
  if (state.action) {
    state.action.className = mergeClasses(drawerHeaderTitleClassNames.action, styles.action, state.action.className);
  }
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderTitle/DrawerHeaderTitle.js
var DrawerHeaderTitle = React499.forwardRef((props, ref) => {
  const state = useDrawerHeaderTitle_unstable(props, ref);
  useDrawerHeaderTitleStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderTitleStyles_unstable")(state);
  return renderDrawerHeaderTitle_unstable(state);
});
DrawerHeaderTitle.displayName = "DrawerHeaderTitle";

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/DrawerHeaderNavigation.js
var React501 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigation.js
var React500 = __toESM(require_react());
var useDrawerHeaderNavigation_unstable = (props, ref) => {
  return {
    components: {
      root: "nav"
    },
    root: slot_exports.always(getIntrinsicElementProps("nav", {
      ref,
      ...props
    }), {
      elementType: "nav"
    })
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/renderDrawerHeaderNavigation.js
var renderDrawerHeaderNavigation_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/useDrawerHeaderNavigationStyles.styles.js
var drawerHeaderNavigationClassNames = {
  root: "fui-DrawerHeaderNavigation"
};
var useStyles58 = __resetStyles("r1ig4pwh", null, [".r1ig4pwh{margin:calc(var(--spacingVerticalS) * -1) calc(var(--spacingHorizontalL) * -1);}"]);
var useDrawerHeaderNavigationStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles58();
  state.root.className = mergeClasses(drawerHeaderNavigationClassNames.root, styles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerHeaderNavigation/DrawerHeaderNavigation.js
var DrawerHeaderNavigation = React501.forwardRef((props, ref) => {
  const state = useDrawerHeaderNavigation_unstable(props, ref);
  useDrawerHeaderNavigationStyles_unstable(state);
  useCustomStyleHook("useDrawerHeaderNavigationStyles_unstable")(state);
  return renderDrawerHeaderNavigation_unstable(state);
});
DrawerHeaderNavigation.displayName = "DrawerHeaderNavigation";

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/DrawerFooter.js
var React503 = __toESM(require_react());

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooter.js
var React502 = __toESM(require_react());
var useDrawerFooter_unstable = (props, ref) => {
  const { scrollState } = useDrawerContext_unstable();
  return {
    components: {
      root: "footer"
    },
    root: slot_exports.always(getIntrinsicElementProps("footer", {
      ref,
      role: "none",
      ...props
    }), {
      elementType: "footer"
    }),
    scrollState
  };
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/renderDrawerFooter.js
var renderDrawerFooter_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/useDrawerFooterStyles.styles.js
var drawerFooterClassNames = {
  root: "fui-DrawerFooter"
};
var useStyles59 = __resetStyles("r1snvl2j", null, [".r1snvl2j{width:100%;max-width:100%;padding:var(--spacingVerticalL) var(--spacingHorizontalXXL) var(--spacingVerticalXXL);display:flex;justify-content:flex-start;align-items:center;column-gap:var(--spacingHorizontalS);box-sizing:border-box;position:relative;z-index:2;}"]);
var useDrawerFooterStyles = __styles2({
  separator: {
    Baz25je: "f16b62f1",
    Brfgrao: "f1j7ml58",
    mdwyqc: ["f1f351id", "f1fzr1x6"],
    Fbdkly: ["f1fzr1x6", "f1f351id"],
    vz82u: "f1dhznln",
    cmx5o7: "f1p5zmk",
    h7gv66: "f1ljjo4k",
    B8bqphf: "ffd2d9j",
    wjn42g: "ffdt3s5",
    Ftih45: "f1wl9k8s",
    Bciustq: "ffi060y"
  },
  separatorVisible: {
    vz82u: "f1b3qyzu"
  }
}, {
  d: [".f16b62f1::before{height:1px;}", ".f1j7ml58::before{position:absolute;}", ".f1f351id::before{right:0;}", ".f1fzr1x6::before{left:0;}", ".f1dhznln::before{opacity:0;}", ".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}", ".f1ljjo4k::before{transition-duration:var(--durationNormal);}", ".ffd2d9j::before{transition-property:opacity;}", ".ffdt3s5::before{transition-timing-function:var(--curveEasyEase);}", '.f1wl9k8s::before{content:"";}', ".ffi060y::before{top:0;}", ".f1b3qyzu::before{opacity:1;}"]
});
var useDrawerFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles59();
  const rootStyles = useDrawerFooterStyles();
  state.root.className = mergeClasses(drawerFooterClassNames.root, styles, state.scrollState !== "none" && rootStyles.separator, ["middle", "top"].includes(state.scrollState) && rootStyles.separatorVisible, state.root.className);
  return state;
};

// node_modules/@fluentui/react-drawer/lib/components/DrawerFooter/DrawerFooter.js
var DrawerFooter = React503.forwardRef((props, ref) => {
  const state = useDrawerFooter_unstable(props, ref);
  useDrawerFooterStyles_unstable(state);
  useCustomStyleHook("useDrawerFooterStyles_unstable")(state);
  return renderDrawerFooter_unstable(state);
});
DrawerFooter.displayName = "DrawerFooter";

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/Breadcrumb.js
var React507 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumb.js
var React504 = __toESM(require_react());
var useBreadcrumb_unstable = (props, ref) => {
  const { focusMode = "tab", size: size3 = "medium", list, ...rest } = props;
  const focusAttributes = useArrowNavigationGroup({
    circular: true,
    axis: "horizontal",
    memorizeCurrent: true
  });
  var _props_arialabel;
  return {
    components: {
      root: "nav",
      list: "ol"
    },
    root: slot_exports.always(getIntrinsicElementProps("nav", {
      ref,
      "aria-label": (_props_arialabel = props["aria-label"]) !== null && _props_arialabel !== void 0 ? _props_arialabel : "breadcrumb",
      ...focusMode === "arrow" ? focusAttributes : {},
      ...rest
    }), {
      elementType: "nav"
    }),
    list: slot_exports.optional(list, {
      renderByDefault: true,
      defaultProps: {
        role: "list"
      },
      elementType: "ol"
    }),
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/BreadcrumbContext.js
var React505 = __toESM(require_react());
var BreadcrumbContext = React505.createContext(void 0);
var breadcrumbDefaultValue = {
  size: "medium"
};
var BreadcrumbProvider = BreadcrumbContext.Provider;
var useBreadcrumbContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React505.useContext(BreadcrumbContext)) !== null && _React_useContext !== void 0 ? _React_useContext : breadcrumbDefaultValue;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/renderBreadcrumb.js
var renderBreadcrumb_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(BreadcrumbProvider, {
      value: contextValues,
      children: state.list && jsx(state.list, {
        children: state.root.children
      })
    })
  });
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbStyles.styles.js
var breadcrumbClassNames = {
  root: "fui-Breadcrumb",
  list: "fui-Breadcrumb__list"
};
var useListClassName = __resetStyles("rc5rb6b", null, [".rc5rb6b{list-style-type:none;display:flex;align-items:center;margin:0;padding:0;}"]);
var useBreadcrumbStyles_unstable = (state) => {
  "use no memo";
  const listBaseClassName = useListClassName();
  state.root.className = mergeClasses(breadcrumbClassNames.root, state.root.className);
  if (state.list) {
    state.list.className = mergeClasses(listBaseClassName, breadcrumbClassNames.list, state.list.className);
  }
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/useBreadcrumbContextValue.js
var React506 = __toESM(require_react());
function useBreadcrumbContextValues_unstable(state) {
  const { size: size3 } = state;
  return React506.useMemo(() => ({
    size: size3
  }), [
    size3
  ]);
}

// node_modules/@fluentui/react-breadcrumb/lib/components/Breadcrumb/Breadcrumb.js
var Breadcrumb = React507.forwardRef((props, ref) => {
  const state = useBreadcrumb_unstable(props, ref);
  const contextValues = useBreadcrumbContextValues_unstable(state);
  useBreadcrumbStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbStyles_unstable")(state);
  return renderBreadcrumb_unstable(state, contextValues);
});
Breadcrumb.displayName = "Breadcrumb";

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/BreadcrumbDivider.js
var React509 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDivider.js
var React508 = __toESM(require_react());
var useBreadcrumbDivider_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  const { dir } = useFluent();
  const icon = getDividerIcon(dir);
  return {
    components: {
      root: "li"
    },
    root: slot_exports.always(getIntrinsicElementProps("li", {
      ref,
      "aria-hidden": true,
      children: icon,
      ...props
    }), {
      elementType: "li"
    }),
    size: size3
  };
};
function getDividerIcon(dir) {
  return dir === "rtl" ? React508.createElement(ChevronLeftRegular, null) : React508.createElement(ChevronRightRegular, null);
}

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/renderBreadcrumbDivider.js
var renderBreadcrumbDivider_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/useBreadcrumbDividerStyles.styles.js
var breadcrumbDividerClassNames = {
  root: "fui-BreadcrumbDivider"
};
var useStyles60 = __resetStyles("rk008qs", null, [".rk008qs{display:flex;}"]);
var useIconStyles9 = __styles2({
  small: {
    Be2twd7: "f1ugzwwg"
  },
  medium: {
    Be2twd7: "f4ybsrx"
  },
  large: {
    Be2twd7: "fe5j1ua"
  }
}, {
  d: [".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}"]
});
var useBreadcrumbDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles60();
  const iconStyles = useIconStyles9();
  const {
    size: size3 = "medium"
  } = state;
  state.root.className = mergeClasses(breadcrumbDividerClassNames.root, styles, iconStyles[size3], state.root.className);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbDivider/BreadcrumbDivider.js
var BreadcrumbDivider = React509.forwardRef((props, ref) => {
  const state = useBreadcrumbDivider_unstable(props, ref);
  useBreadcrumbDividerStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbDividerStyles_unstable")(state);
  return renderBreadcrumbDivider_unstable(state);
});
BreadcrumbDivider.displayName = "BreadcrumbDivider";

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/BreadcrumbItem.js
var React511 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItem.js
var React510 = __toESM(require_react());
var useBreadcrumbItem_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  return {
    components: {
      root: "li"
    },
    root: slot_exports.always(getIntrinsicElementProps("li", {
      ref,
      ...props
    }), {
      elementType: "li"
    }),
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/renderBreadcrumbItem.js
var renderBreadcrumbItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: state.root.children
  });
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/useBreadcrumbItemStyles.styles.js
var breadcrumbItemClassNames = {
  root: "fui-BreadcrumbItem"
};
var useBreadcrumbItemResetStyles = __resetStyles("r1tl60rs", null, [".r1tl60rs{display:flex;align-items:center;color:var(--colorNeutralForeground2);box-sizing:border-box;text-wrap:nowrap;}"]);
var useBreadcrumbItemStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useBreadcrumbItemResetStyles();
  state.root.className = mergeClasses(breadcrumbItemClassNames.root, resetStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbItem/BreadcrumbItem.js
var BreadcrumbItem = React511.forwardRef((props, ref) => {
  const state = useBreadcrumbItem_unstable(props, ref);
  useBreadcrumbItemStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbItemStyles_unstable")(state);
  return renderBreadcrumbItem_unstable(state);
});
BreadcrumbItem.displayName = "BreadcrumbItem";

// node_modules/@fluentui/react-breadcrumb/lib/utils/partitionBreadcrumbItems.js
var DEFAULT_OVERFLOW_INDEX = 1;
var DEFAULT_MAX_DISPLAYED_ITEMS = 6;
var partitionBreadcrumbItems = (options) => {
  let startDisplayedItems;
  let overflowItems;
  let endDisplayedItems;
  const { items = [] } = options;
  const itemsCount = items.length;
  const maxDisplayedItems = getMaxDisplayedItems(options.maxDisplayedItems);
  var _options_overflowIndex;
  let overflowIndex = (_options_overflowIndex = options.overflowIndex) !== null && _options_overflowIndex !== void 0 ? _options_overflowIndex : DEFAULT_OVERFLOW_INDEX;
  startDisplayedItems = items.slice(0, overflowIndex);
  const numberItemsToHide = itemsCount - maxDisplayedItems;
  if (numberItemsToHide > 0) {
    overflowIndex = overflowIndex >= maxDisplayedItems ? maxDisplayedItems - 1 : overflowIndex;
    const menuLastItemIdx = overflowIndex + numberItemsToHide;
    startDisplayedItems = startDisplayedItems.slice(0, overflowIndex);
    overflowItems = items.slice(overflowIndex, menuLastItemIdx);
    if (menuLastItemIdx < itemsCount) {
      endDisplayedItems = items.slice(menuLastItemIdx, itemsCount);
    }
  } else if (overflowIndex < itemsCount) {
    endDisplayedItems = items.slice(overflowIndex, itemsCount);
  }
  return {
    startDisplayedItems,
    overflowItems,
    endDisplayedItems
  };
};
function getMaxDisplayedItems(maxDisplayedItems) {
  return maxDisplayedItems && maxDisplayedItems >= 0 ? maxDisplayedItems : DEFAULT_MAX_DISPLAYED_ITEMS;
}

// node_modules/@fluentui/react-breadcrumb/lib/utils/truncateBreadcrumb.js
var MAX_NAME_LENGTH = 30;
var MAX_TOOLTIP_LENGTH = 80;
var truncateBreadcrumb = (content, maxLength) => {
  return isTruncatableBreadcrumbContent(content, maxLength) ? content.trim().slice(0, maxLength).concat("...") : content;
};
var isTruncatableBreadcrumbContent = (content, maxLength) => {
  return content.length > maxLength;
};
var truncateBreadcrumbLongName = (content, maxLength) => {
  const truncateLength = maxLength || MAX_NAME_LENGTH;
  return truncateBreadcrumb(content, truncateLength);
};
var truncateBreadcrumLongTooltip = (content, maxLength) => {
  const truncateLength = maxLength || MAX_TOOLTIP_LENGTH;
  return truncateBreadcrumb(content, truncateLength);
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/BreadcrumbButton.js
var React513 = __toESM(require_react());

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButton.js
var React512 = __toESM(require_react());
var useBreadcrumbButton_unstable = (props, ref) => {
  const { size: size3 } = useBreadcrumbContext_unstable();
  const { current = false, as, ...rest } = props;
  const controlType = (as !== null && as !== void 0 ? as : props.href) ? "a" : "button";
  var _props_ariacurrent, _props_ariadisabled;
  return {
    ...useButton_unstable({
      appearance: "subtle",
      role: void 0,
      type: void 0,
      as: controlType,
      iconPosition: "before",
      "aria-current": current ? (_props_ariacurrent = props["aria-current"]) !== null && _props_ariacurrent !== void 0 ? _props_ariacurrent : "page" : void 0,
      "aria-disabled": current ? (_props_ariadisabled = props["aria-disabled"]) !== null && _props_ariadisabled !== void 0 ? _props_ariadisabled : true : void 0,
      ...rest
    }, ref),
    current,
    size: size3
  };
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/renderBreadcrumbButton.js
var renderBreadcrumbButton_unstable = (state) => {
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/useBreadcrumbButtonStyles.styles.js
var breadcrumbButtonClassNames = {
  root: "fui-BreadcrumbButton",
  icon: "fui-BreadcrumbButton__icon"
};
var useIconStyles10 = __styles2({
  base: {
    Be2twd7: "fsj74e5",
    Bqenvij: "f1qfv4wv",
    Bg96gwp: "f15xapk4",
    a9b677: "f17j33op",
    t21cq0: ["fm0x6gh", "fbyavb5"]
  },
  small: {
    u3h8gg: "f1qfi7kw",
    Biu6dll: "f1876atl"
  },
  medium: {
    u3h8gg: "f1h9446d",
    Biu6dll: "f10xfswh"
  },
  large: {
    u3h8gg: "f5hcofs",
    Biu6dll: "f1a6v6zl"
  }
}, {
  d: [".fsj74e5{font-size:var(--fui-Breadcrumb--icon-size);}", ".f1qfv4wv{height:var(--fui-Breadcrumb--icon-size);}", ".f15xapk4{line-height:var(--fui-Breadcrumb--icon-line-height);}", ".f17j33op{width:var(--fui-Breadcrumb--icon-size);}", ".fm0x6gh{margin-right:var(--spacingHorizontalXS);}", ".fbyavb5{margin-left:var(--spacingHorizontalXS);}", ".f1qfi7kw{--fui-Breadcrumb--icon-size:12px;}", ".f1876atl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase200);}", ".f1h9446d{--fui-Breadcrumb--icon-size:16px;}", ".f10xfswh{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase400);}", ".f5hcofs{--fui-Breadcrumb--icon-size:20px;}", ".f1a6v6zl{--fui-Breadcrumb--icon-line-height:var(--lineHeightBase600);}"]
});
var defaultButtonStyles = {
  backgroundColor: tokens.colorTransparentBackground,
  color: tokens.colorNeutralForeground2,
  cursor: "auto"
};
var currentIconStyles = {
  ...defaultButtonStyles,
  [`& .${buttonClassNames.icon}`]: {
    color: "unset"
  },
  [`& .${iconFilledClassName}`]: {
    display: "none"
  },
  [`& .${iconRegularClassName}`]: {
    display: "inline"
  }
};
var useStyles61 = __styles2({
  root: {
    Bf4jedk: "f18p0k4z",
    j4b8c3: "fv6wr3j"
  },
  small: {
    Bqenvij: "frvgh55",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6"
  },
  medium: {
    Bqenvij: "f1d2rq10",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1r1wyb6"
  },
  large: {
    Bqenvij: "fbhnoac",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1bnz8pu"
  },
  current: {
    Jwef8y: "f9ql6rf",
    Bi91k9c: "f3p8bqa",
    eoavqd: "f14w7a5u",
    Bbdnnc7: "f1irjp3o",
    Bk3fhr4: "f19vpps7",
    Bmfj8id: "fv5swzo",
    iro3zm: "f3h1zc4",
    B2d53fq: "f1xkgyln",
    c3iz72: "f17wbbfx",
    x3br3k: "fofxw0a",
    em6i61: "f1ol4fw6",
    vm6p8p: "f1q1lw4e",
    Bszkowt: "ff24m",
    Dyrjrp: "ft5r8e9",
    ezr58z: "f1cbpfqp",
    nhk3du: "f1motppv",
    Bfrek18: "fi9vkhg",
    G209fr: "f1fg3nnv"
  },
  currentSmall: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  },
  currentMedium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  },
  currentLarge: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  }
}, {
  d: [".f18p0k4z{min-width:unset;}", ".fv6wr3j{text-wrap:nowrap;}", ".frvgh55{height:24px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".f1d2rq10{height:32px;}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f1r1wyb6{padding:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fbhnoac{height:40px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1bnz8pu{padding:var(--spacingHorizontalS);}", {
    p: -1
  }], ".ff24m:disabled{background-color:var(--colorTransparentBackground);}", ".ft5r8e9:disabled{color:var(--colorNeutralForeground2);}", ".f1cbpfqp:disabled{cursor:auto;}", ".f1motppv:disabled .fui-Button__icon{color:unset;}", ".fi9vkhg:disabled .fui-Icon-filled{display:none;}", ".f1fg3nnv:disabled .fui-Icon-regular{display:inline;}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"],
  h: [".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3p8bqa:hover{color:var(--colorNeutralForeground2);}", ".f14w7a5u:hover{cursor:auto;}", ".f1irjp3o:hover .fui-Button__icon{color:unset;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1xkgyln:hover:active{color:var(--colorNeutralForeground2);}", ".f17wbbfx:hover:active{cursor:auto;}", ".fofxw0a:hover:active .fui-Button__icon{color:unset;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}"]
});
var useBreadcrumbButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles61();
  const iconStyles = useIconStyles10();
  const currentSizeMap = {
    small: styles.currentSmall,
    medium: styles.currentMedium,
    large: styles.currentLarge
  };
  state.root.className = mergeClasses(breadcrumbButtonClassNames.root, styles[state.size], styles.root, state.current && currentSizeMap[state.size], state.current && styles.current, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(iconStyles.base, iconStyles[state.size], state.icon.className);
  }
  useButtonStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-breadcrumb/lib/components/BreadcrumbButton/BreadcrumbButton.js
var BreadcrumbButton = React513.forwardRef((props, ref) => {
  const state = useBreadcrumbButton_unstable(props, ref);
  useBreadcrumbButtonStyles_unstable(state);
  useCustomStyleHook("useBreadcrumbButtonStyles_unstable")(state);
  return renderBreadcrumbButton_unstable(state);
});
BreadcrumbButton.displayName = "BreadcrumbButton";

// node_modules/@fluentui/react-rating/lib/components/Rating/Rating.js
var React519 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/Rating/useRating.js
var React517 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingItem/RatingItem.js
var React516 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItem.js
var React515 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/contexts/RatingItemContext.js
var React514 = __toESM(require_react());
var RatingItemContext = React514.createContext(void 0);
var ratingItemContextDefaultValue = {
  color: "neutral",
  iconFilled: StarFilled,
  iconOutline: StarRegular,
  step: 1,
  size: "medium"
};
var RatingItemProvider = RatingItemContext.Provider;
var useRatingItemContextValue_unstable = () => React514.useContext(RatingItemContext) || ratingItemContextDefaultValue;

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItem.js
var defaultItemLabel = (num) => num + "";
var useRatingItem_unstable = (props, ref) => {
  const context = useRatingItemContextValue_unstable();
  const { value = 0 } = props;
  const { itemLabel = defaultItemLabel, iconFilled: IconFilled, iconOutline: IconOutline } = context;
  const ratingValue = Math.round((context.value || 0) * 2) / 2;
  var _context_hoveredValue;
  const displayedRatingValue = (_context_hoveredValue = context.hoveredValue) !== null && _context_hoveredValue !== void 0 ? _context_hoveredValue : ratingValue;
  const appearance = context.interactive ? "outline" : "filled";
  let iconFillWidth;
  if (context.compact || displayedRatingValue >= value) {
    iconFillWidth = 1;
  } else if (displayedRatingValue >= value - 0.5) {
    iconFillWidth = 0.5;
  } else {
    iconFillWidth = 0;
  }
  const root = slot_exports.always(getIntrinsicElementProps("span", {
    ref: useMergedRefs(useFocusWithin(), ref),
    ...props
  }), {
    elementType: "span"
  });
  let unselectedIcon;
  if (iconFillWidth < 1) {
    unselectedIcon = slot_exports.always(props.unselectedIcon, {
      defaultProps: {
        children: appearance === "filled" ? React515.createElement(IconFilled, null) : React515.createElement(IconOutline, null),
        "aria-hidden": true
      },
      elementType: "div"
    });
  }
  let selectedIcon;
  if (iconFillWidth > 0) {
    selectedIcon = slot_exports.always(props.selectedIcon, {
      defaultProps: {
        children: React515.createElement(IconFilled, null),
        "aria-hidden": true
      },
      elementType: "div"
    });
  }
  let halfValueInput;
  if (context.interactive && context.step === 0.5) {
    halfValueInput = slot_exports.always(props.halfValueInput, {
      defaultProps: {
        type: "radio",
        name: context.name,
        value: value - 0.5,
        checked: ratingValue === value - 0.5,
        "aria-label": itemLabel(value - 0.5),
        onChange: () => {
        }
      },
      elementType: "input"
    });
  }
  let fullValueInput;
  if (context.interactive) {
    fullValueInput = slot_exports.always(props.fullValueInput, {
      defaultProps: {
        type: "radio",
        name: context.name,
        value,
        checked: ratingValue === value,
        "aria-label": itemLabel(value),
        onChange: () => {
        }
      },
      elementType: "input"
    });
  }
  const state = {
    appearance,
    color: context.color,
    step: context.step,
    size: context.size,
    iconFillWidth,
    value,
    components: {
      root: "span",
      selectedIcon: "div",
      unselectedIcon: "div",
      halfValueInput: "input",
      fullValueInput: "input"
    },
    root,
    selectedIcon,
    unselectedIcon,
    halfValueInput,
    fullValueInput
  };
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/renderRatingItem.js
var renderRatingItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.halfValueInput && jsx(state.halfValueInput, {}),
      state.fullValueInput && jsx(state.fullValueInput, {}),
      state.unselectedIcon && jsx(state.unselectedIcon, {}),
      state.selectedIcon && jsx(state.selectedIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/useRatingItemStyles.styles.js
var ratingItemClassNames = {
  root: "fui-RatingItem",
  selectedIcon: "fui-RatingItem__selectedIcon",
  unselectedIcon: "fui-RatingItem__unselectedIcon",
  halfValueInput: "fui-RatingItem__halfValueInput",
  fullValueInput: "fui-RatingItem__fullValueInput"
};
var useStyles62 = __styles2({
  root: {
    qhf8xq: "f10pi13n",
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    h6p2u: "f1ufm4qn",
    I6qiy5: ["f1qnwcb4", "fgrk5zm"],
    yzno9d: "fi52z01",
    By0wis0: ["fgrk5zm", "f1qnwcb4"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "fmj8fco",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f1iwowo3",
    B2pnrqr: "f1spmvte",
    B29w5g4: ["fgp7k2s", "f13pb23"],
    Bhhzhcn: "f1ihbrwi",
    Bec0n69: ["f13pb23", "fgp7k2s"]
  },
  small: {
    Be2twd7: "f1ugzwwg",
    a9b677: "frx94fk",
    Bqenvij: "fvblgha"
  },
  medium: {
    Be2twd7: "f4ybsrx",
    a9b677: "fjw5fx7",
    Bqenvij: "fd461yt"
  },
  large: {
    Be2twd7: "fe5j1ua",
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  "extra-large": {
    Be2twd7: "f24l1pt",
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  }
}, {
  d: [".f10pi13n{position:relative;}", ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".fmj8fco[data-fui-focus-within]:focus-within::after{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1iwowo3[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1spmvte[data-fui-focus-within]:focus-within::after{top:calc(2px * -1);}", ".fgp7k2s[data-fui-focus-within]:focus-within::after{right:calc(2px * -1);}", ".f13pb23[data-fui-focus-within]:focus-within::after{left:calc(2px * -1);}", ".f1ihbrwi[data-fui-focus-within]:focus-within::after{bottom:calc(2px * -1);}", ".f1ugzwwg{font-size:12px;}", ".frx94fk{width:12px;}", ".fvblgha{height:12px;}", ".f4ybsrx{font-size:16px;}", ".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".fe5j1ua{font-size:20px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".f24l1pt{font-size:28px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputBaseClassName4 = __resetStyles("r1qfsv1p", "rh8pzaz", [".r1qfsv1p{position:absolute;left:0;top:0;right:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}", ".rh8pzaz{position:absolute;right:0;top:0;left:0;bottom:0;box-sizing:border-box;margin:0;opacity:0;cursor:pointer;height:100%;}"]);
var useInputStyles7 = __styles2({
  lowerHalf: {
    j35jbq: ["ffenbu1", "f1ktbn1t"]
  },
  upperHalf: {
    oyh7mz: ["f1ktbn1t", "ffenbu1"]
  }
}, {
  d: [".ffenbu1{right:50%;}", ".f1ktbn1t{left:50%;}"]
});
var useIndicatorBaseClassName4 = __resetStyles("r1420l2m", "r1yt29v5", [".r1420l2m{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;left:0;right:0;top:0;bottom:0;}", ".r1yt29v5{display:flex;overflow:hidden;color:var(--colorNeutralForeground1);fill:currentColor;pointer-events:none;position:absolute;right:0;left:0;top:0;bottom:0;}"]);
var useIndicatorStyles3 = __styles2({
  lowerHalf: {
    j35jbq: ["ffenbu1", "f1ktbn1t"],
    l5kjut: 0,
    uoufgc: 0,
    v39lw8: 0,
    Bbwb3tu: "f10jwh99"
  },
  upperHalf: {
    oyh7mz: ["f1ktbn1t", "ffenbu1"],
    Frg6f3: ["fbm7ezh", "f3ev47i"]
  },
  brand: {
    sj55zd: "f16muhyy"
  },
  marigold: {
    sj55zd: "f1whvut0"
  },
  filled: {
    sj55zd: "f1qaymga",
    ojy3ng: "f13qq9og",
    B7iucu3: "f1205bnn",
    Biw2w6l: "f1nocmko"
  },
  brandFilled: {
    sj55zd: "f1kdv6iu"
  },
  marigoldFilled: {
    sj55zd: "f1ymbmfq"
  }
}, {
  d: [".ffenbu1{right:50%;}", ".f1ktbn1t{left:50%;}", [".f10jwh99>svg{flex:0 0 auto;}", {
    p: -1
  }], ".fbm7ezh{margin-left:-50%;}", ".f3ev47i{margin-right:-50%;}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f1whvut0{color:var(--colorPaletteMarigoldBorderActive);}", ".f1qaymga{color:var(--colorNeutralBackground6);}", ".f13qq9og{stroke:var(--colorTransparentStroke);}", ".f1kdv6iu{color:var(--colorBrandBackground2);}", ".f1ymbmfq{color:var(--colorPaletteMarigoldBackground2);}"],
  m: [["@media (forced-colors: active){.f1205bnn{color:Canvas;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1nocmko{stroke:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useRatingItemStyles_unstable = (state) => {
  "use no memo";
  const {
    color: color2,
    size: size3,
    iconFillWidth,
    appearance
  } = state;
  const styles = useStyles62();
  const inputBaseClassName = useInputBaseClassName4();
  const inputStyles = useInputStyles7();
  const indicatorBaseClassName = useIndicatorBaseClassName4();
  const indicatorStyles = useIndicatorStyles3();
  state.root.className = mergeClasses(ratingItemClassNames.root, styles.root, styles[size3], state.root.className);
  if (state.halfValueInput) {
    state.halfValueInput.className = mergeClasses(ratingItemClassNames.halfValueInput, inputBaseClassName, inputStyles.lowerHalf, state.halfValueInput.className);
  }
  if (state.fullValueInput) {
    state.fullValueInput.className = mergeClasses(ratingItemClassNames.fullValueInput, inputBaseClassName, state.halfValueInput && inputStyles.upperHalf, state.fullValueInput.className);
  }
  if (state.unselectedIcon) {
    state.unselectedIcon.className = mergeClasses(ratingItemClassNames.unselectedIcon, indicatorBaseClassName, appearance === "filled" && indicatorStyles.filled, color2 === "brand" && (appearance === "filled" ? indicatorStyles.brandFilled : indicatorStyles.brand), color2 === "marigold" && (appearance === "filled" ? indicatorStyles.marigoldFilled : indicatorStyles.marigold), iconFillWidth === 0.5 && indicatorStyles.upperHalf, state.unselectedIcon.className);
  }
  if (state.selectedIcon) {
    state.selectedIcon.className = mergeClasses(ratingItemClassNames.selectedIcon, indicatorBaseClassName, color2 === "brand" && indicatorStyles.brand, color2 === "marigold" && indicatorStyles.marigold, iconFillWidth === 0.5 && indicatorStyles.lowerHalf, state.selectedIcon.className);
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingItem/RatingItem.js
var RatingItem = React516.forwardRef((props, ref) => {
  const state = useRatingItem_unstable(props, ref);
  useRatingItemStyles_unstable(state);
  useCustomStyleHook("useRatingItemStyles_unstable")(state);
  return renderRatingItem_unstable(state);
});
RatingItem.displayName = "RatingItem";

// node_modules/@fluentui/react-rating/lib/components/Rating/useRating.js
var useRating_unstable = (props, ref) => {
  const generatedName = useId2("rating-");
  const { color: color2 = "neutral", iconFilled = StarFilled, iconOutline = StarRegular, max: max2 = 5, name = generatedName, onChange, step = 1, size: size3 = "extra-large", itemLabel } = props;
  const [value, setValue] = useControllableState({
    state: props.value,
    defaultState: props.defaultValue,
    initialState: 0
  });
  const isRatingRadioItem = (target) => isHTMLElement(target, {
    constructorName: "HTMLInputElement"
  }) && target.type === "radio" && target.name === name;
  const [hoveredValue, setHoveredValue] = React517.useState(void 0);
  const rootChildren = React517.useMemo(() => {
    return Array.from(Array(max2), (_, i) => React517.createElement(RatingItem, {
      value: i + 1,
      key: i + 1
    }));
  }, [
    max2
  ]);
  const state = {
    color: color2,
    iconFilled,
    iconOutline,
    name,
    step,
    size: size3,
    itemLabel,
    value,
    hoveredValue,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      children: rootChildren,
      role: "radiogroup",
      ...props
    }, [
      "onChange"
    ]), {
      elementType: "div"
    })
  };
  state.root.onChange = (ev) => {
    if (isRatingRadioItem(ev.target)) {
      const newValue = parseFloat(ev.target.value);
      if (!isNaN(newValue)) {
        setValue(newValue);
        onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
          type: "change",
          event: ev,
          value: newValue
        });
      }
    }
  };
  state.root.onMouseOver = mergeCallbacks(props.onMouseOver, (ev) => {
    if (isRatingRadioItem(ev.target)) {
      const newValue = parseFloat(ev.target.value);
      if (!isNaN(newValue)) {
        setHoveredValue(newValue);
      }
    }
  });
  state.root.onMouseLeave = mergeCallbacks(props.onMouseLeave, (ev) => {
    setHoveredValue(void 0);
  });
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/Rating/renderRating.js
var renderRating_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RatingItemProvider, {
    value: contextValues.ratingItem,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-rating/lib/components/Rating/useRatingStyles.styles.js
var ratingClassNames = {
  root: "fui-Rating"
};
var useRootClassName7 = __resetStyles("r2imjyh", null, [".r2imjyh{display:flex;flex-wrap:wrap;}"]);
var useRatingStyles_unstable = (state) => {
  "use no memo";
  const rootClassName = useRootClassName7();
  state.root.className = mergeClasses(ratingClassNames.root, rootClassName, state.root.className);
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/Rating/useRatingContextValues.js
var React518 = __toESM(require_react());
var useRatingContextValues = (ratingState) => {
  const { color: color2, hoveredValue, iconFilled, iconOutline, itemLabel, name, step, size: size3, value } = ratingState;
  const ratingItem = React518.useMemo(() => ({
    color: color2,
    hoveredValue,
    iconFilled,
    iconOutline,
    interactive: true,
    itemLabel,
    name,
    step,
    size: size3,
    value
  }), [
    color2,
    hoveredValue,
    iconFilled,
    iconOutline,
    itemLabel,
    name,
    step,
    size3,
    value
  ]);
  return {
    ratingItem
  };
};

// node_modules/@fluentui/react-rating/lib/components/Rating/Rating.js
var Rating = React519.forwardRef((props, ref) => {
  const state = useRating_unstable(props, ref);
  const contextValues = useRatingContextValues(state);
  useRatingStyles_unstable(state);
  useCustomStyleHook("useRatingStyles_unstable")(state);
  return renderRating_unstable(state, contextValues);
});
Rating.displayName = "Rating";

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/RatingDisplay.js
var React522 = __toESM(require_react());

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplay.js
var React520 = __toESM(require_react());
var useRatingDisplay_unstable = (props, ref) => {
  const { color: color2 = "neutral", count, compact = false, icon = StarFilled, max: max2 = 5, size: size3 = "medium", value } = props;
  const valueTextId = useId2("rating-value-");
  const countTextId = useId2("rating-count-");
  const rootChildren = React520.useMemo(() => {
    return compact ? React520.createElement(RatingItem, {
      value: 1,
      key: 1,
      "aria-hidden": true
    }) : Array.from(Array(max2), (_, i) => React520.createElement(RatingItem, {
      value: i + 1,
      key: i + 1,
      "aria-hidden": true
    }));
  }, [
    compact,
    max2
  ]);
  const state = {
    color: color2,
    compact,
    icon,
    max: max2,
    size: size3,
    value,
    components: {
      root: "div",
      valueText: "span",
      countText: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      children: rootChildren,
      role: "img",
      ...props
    }), {
      elementType: "div"
    }),
    valueText: slot_exports.optional(props.valueText, {
      renderByDefault: value !== void 0,
      defaultProps: {
        children: value,
        id: valueTextId,
        "aria-hidden": true
      },
      elementType: "span"
    }),
    countText: slot_exports.optional(props.countText, {
      renderByDefault: count !== void 0,
      defaultProps: {
        children: count === null || count === void 0 ? void 0 : count.toLocaleString(),
        id: countTextId,
        "aria-hidden": true
      },
      elementType: "span"
    })
  };
  if (!state.root["aria-label"] && !state.root["aria-labelledby"]) {
    var _state_valueText, _state_countText;
    state.root["aria-labelledby"] = [
      (_state_valueText = state.valueText) === null || _state_valueText === void 0 ? void 0 : _state_valueText.id,
      (_state_countText = state.countText) === null || _state_countText === void 0 ? void 0 : _state_countText.id
    ].filter(Boolean).join(" ");
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/renderRatingDisplay.js
var renderRatingDisplay_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(RatingItemProvider, {
    value: contextValues.ratingItem,
    children: jsxs(state.root, {
      children: [
        state.root.children,
        state.valueText && jsx(state.valueText, {}),
        state.countText && jsx(state.countText, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayStyles.styles.js
var ratingDisplayClassNames = {
  root: "fui-RatingDisplay",
  valueText: "fui-RatingDisplay__valueText",
  countText: "fui-RatingDisplay__countText"
};
var useRootClassName8 = __resetStyles("rxxdqwu", null, [".rxxdqwu{display:flex;flex-wrap:wrap;align-items:center;}"]);
var useLabelClassName = __resetStyles("rkwnos5", "rwei36a", [".rkwnos5{color:var(--colorNeutralForeground1);margin-left:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}", ".rwei36a{color:var(--colorNeutralForeground1);margin-right:var(--spacingHorizontalXS);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useLabelStyles7 = __styles2({
  large: {
    Be2twd7: "fkhj508",
    Bg96gwp: "f1i3iumi",
    Frg6f3: ["f1t5qyk5", "f1ikr372"]
  },
  extraLarge: {
    Be2twd7: "fod5ikn",
    Bg96gwp: "faaz57k",
    Frg6f3: ["foyynoy", "f1vcna3q"]
  },
  strong: {
    Bhrd7zp: "fl43uef"
  },
  divider: {
    Ftih45: "f169p45e"
  }
}, {
  d: [".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".foyynoy{margin-left:var(--spacingHorizontalS);}", ".f1vcna3q{margin-right:var(--spacingHorizontalS);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", '.f169p45e::before{content:" ";}']
});
var useRatingDisplayStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const rootClassName = useRootClassName8();
  state.root.className = mergeClasses(ratingDisplayClassNames.root, rootClassName, state.root.className);
  const labelClassName = useLabelClassName();
  const labelStyles = useLabelStyles7();
  if (state.valueText) {
    state.valueText.className = mergeClasses(ratingDisplayClassNames.valueText, labelClassName, labelStyles.strong, size3 === "large" && labelStyles.large, size3 === "extra-large" && labelStyles.extraLarge, state.valueText.className);
  }
  if (state.countText) {
    state.countText.className = mergeClasses(ratingDisplayClassNames.countText, labelClassName, size3 === "large" && labelStyles.large, size3 === "extra-large" && labelStyles.extraLarge, state.valueText && labelStyles.divider, state.countText.className);
  }
  return state;
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/useRatingDisplayContextValues.js
var React521 = __toESM(require_react());
var useRatingDisplayContextValues = (state) => {
  const { color: color2, compact, icon, size: size3, value } = state;
  const ratingItem = React521.useMemo(() => ({
    color: color2,
    compact,
    iconFilled: icon,
    iconOutline: icon,
    interactive: false,
    step: 0.5,
    size: size3,
    value
  }), [
    color2,
    compact,
    icon,
    size3,
    value
  ]);
  return {
    ratingItem
  };
};

// node_modules/@fluentui/react-rating/lib/components/RatingDisplay/RatingDisplay.js
var RatingDisplay = React522.forwardRef((props, ref) => {
  const state = useRatingDisplay_unstable(props, ref);
  const contextValues = useRatingDisplayContextValues(state);
  useRatingDisplayStyles_unstable(state);
  useCustomStyleHook("useRatingDisplayStyles_unstable")(state);
  return renderRatingDisplay_unstable(state, contextValues);
});
RatingDisplay.displayName = "RatingDisplay";

// node_modules/@fluentui/react-search/lib/components/SearchBox/SearchBox.js
var React524 = __toESM(require_react());

// node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBox.js
var React523 = __toESM(require_react());
var useSearchBox_unstable = (props, ref) => {
  const { size: size3 = "medium", disabled = false, root, contentBefore, dismiss, contentAfter, value, defaultValue, ...inputProps } = props;
  const searchBoxRootRef = React523.useRef(null);
  const searchBoxRef = React523.useRef(null);
  const [internalValue, setInternalValue] = useControllableState({
    state: value,
    defaultState: defaultValue,
    initialState: ""
  });
  const [focused, setFocused] = React523.useState(false);
  const onFocus = React523.useCallback(() => {
    setFocused(true);
  }, [
    setFocused
  ]);
  const onBlur = React523.useCallback((ev) => {
    var _searchBoxRootRef_current;
    setFocused(!!((_searchBoxRootRef_current = searchBoxRootRef.current) === null || _searchBoxRootRef_current === void 0 ? void 0 : _searchBoxRootRef_current.contains(ev.relatedTarget)));
  }, [
    setFocused
  ]);
  const rootProps = slot_exports.resolveShorthand(root);
  const handleDismissClick = useEventCallback((event) => {
    var _props_onChange, _searchBoxRef_current;
    if (isResolvedShorthand(dismiss)) {
      var _dismiss_onClick;
      (_dismiss_onClick = dismiss.onClick) === null || _dismiss_onClick === void 0 ? void 0 : _dismiss_onClick.call(dismiss, event);
    }
    const newValue = "";
    setInternalValue(newValue);
    (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, event, {
      value: newValue
    });
    (_searchBoxRef_current = searchBoxRef.current) === null || _searchBoxRef_current === void 0 ? void 0 : _searchBoxRef_current.focus();
  });
  const inputState = useInput_unstable({
    type: "search",
    disabled,
    size: size3,
    value: internalValue,
    root: slot_exports.always({
      ...rootProps,
      ref: useMergedRefs(rootProps === null || rootProps === void 0 ? void 0 : rootProps.ref, searchBoxRootRef),
      onFocus: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onFocus, onFocus),
      onBlur: mergeCallbacks(rootProps === null || rootProps === void 0 ? void 0 : rootProps.onBlur, onBlur)
    }, {
      elementType: "span"
    }),
    contentBefore: slot_exports.optional(contentBefore, {
      renderByDefault: true,
      defaultProps: {
        children: React523.createElement(SearchRegular, null)
      },
      elementType: "span"
    }),
    contentAfter: slot_exports.optional(contentAfter, {
      renderByDefault: true,
      elementType: "span"
    }),
    ...inputProps,
    onChange: useEventCallback((ev) => {
      var _props_onChange;
      const newValue = ev.target.value;
      (_props_onChange = props.onChange) === null || _props_onChange === void 0 ? void 0 : _props_onChange.call(props, ev, {
        value: newValue
      });
      setInternalValue(newValue);
    })
  }, useMergedRefs(searchBoxRef, ref));
  const state = {
    ...inputState,
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...inputState.components,
      dismiss: "span"
    },
    dismiss: slot_exports.optional(dismiss, {
      defaultProps: {
        children: React523.createElement(DismissRegular, null),
        role: "button",
        "aria-label": "clear",
        tabIndex: -1
      },
      renderByDefault: true,
      elementType: "span"
    }),
    disabled,
    focused,
    size: size3
  };
  if (state.dismiss) {
    state.dismiss.onClick = handleDismissClick;
  }
  return state;
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/renderSearchBox.js
var renderSearchBox_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.contentBefore && jsx(state.contentBefore, {}),
      jsx(state.input, {}),
      state.contentAfter && jsxs(state.contentAfter, {
        children: [
          state.contentAfter.children,
          state.dismiss && jsx(state.dismiss, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/useSearchBoxStyles.styles.js
var searchBoxClassNames = {
  root: "fui-SearchBox",
  dismiss: "fui-SearchBox__dismiss",
  contentAfter: "fui-SearchBox__contentAfter",
  contentBefore: "fui-SearchBox__contentBefore",
  input: "fui-SearchBox__input"
};
var useRootStyles25 = __styles2({
  small: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["fk8j09s", "fdw0yi8"],
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  large: {
    i8kkvl: "fjuset5",
    B2u0y6b: "f1xzfw5u",
    uwmqm3: ["f1ng84yb", "f11gcy0p"],
    z189sj: ["f11gcy0p", "f1ng84yb"]
  },
  input: {
    uwmqm3: ["fk8j09s", "fdw0yi8"],
    z189sj: ["fhxju0i", "f1cnd47f"],
    Boqhc8c: "f18izjht",
    B8uat0v: "fcoa6sg"
  },
  unfocusedNoContentAfter: {
    z189sj: ["fhxju0i", "f1cnd47f"]
  }
}, {
  d: [".fjuset5{column-gap:0;}", ".f1xzfw5u{max-width:468px;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f18izjht::-webkit-search-decoration{display:none;}", ".fcoa6sg::-webkit-search-cancel-button{display:none;}"]
});
var useInputStyles8 = __styles2({
  small: {
    z189sj: ["fdw0yi8", "fk8j09s"]
  },
  medium: {
    z189sj: ["f1vdfbxk", "f1f5gg8d"]
  },
  large: {
    z189sj: ["f11gcy0p", "f1ng84yb"]
  }
}, {
  d: [".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f11gcy0p{padding-right:var(--spacingHorizontalMNudge);}", ".f1ng84yb{padding-left:var(--spacingHorizontalMNudge);}"]
});
var useContentAfterStyles = __styles2({
  contentAfter: {
    uwmqm3: ["f1uw59to", "fw5db7e"],
    i8kkvl: "f1ufnopg"
  },
  rest: {
    Bqenvij: "fniina8",
    a9b677: "f3tsq5r",
    uwmqm3: ["f1cnd47f", "fhxju0i"],
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  }
}, {
  d: [".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".fniina8{height:0;}", ".f3tsq5r{width:0;}", ".f1cnd47f{padding-left:0;}", ".fhxju0i{padding-right:0;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }]]
});
var useDismissClassName = __resetStyles("r1pvzcuu", null, [".r1pvzcuu{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;cursor:pointer;}", ".r1pvzcuu>svg{font-size:20px;}"]);
var useDismissStyles = __styles2({
  disabled: {
    sj55zd: "f1s2aq7o"
  },
  small: {
    Duoase: "f3qv9w"
  },
  medium: {},
  large: {
    Duoase: "f16u2scb"
  }
}, {
  d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3qv9w>svg{font-size:16px;}", ".f16u2scb>svg{font-size:24px;}"]
});
var useSearchBoxStyles_unstable = (state) => {
  "use no memo";
  const {
    disabled,
    focused,
    size: size3
  } = state;
  const rootStyles = useRootStyles25();
  const inputStyles = useInputStyles8();
  const contentAfterStyles = useContentAfterStyles();
  const dismissClassName = useDismissClassName();
  const dismissStyles = useDismissStyles();
  state.root.className = mergeClasses(searchBoxClassNames.root, rootStyles[size3], !focused && rootStyles.unfocusedNoContentAfter, state.root.className);
  state.input.className = mergeClasses(searchBoxClassNames.input, rootStyles.input, !focused && inputStyles[size3], state.input.className);
  if (state.dismiss) {
    state.dismiss.className = mergeClasses(searchBoxClassNames.dismiss, dismissClassName, disabled && dismissStyles.disabled, dismissStyles[size3], state.dismiss.className);
  }
  if (state.contentBefore) {
    state.contentBefore.className = mergeClasses(searchBoxClassNames.contentBefore, state.contentBefore.className);
  }
  if (state.contentAfter) {
    state.contentAfter.className = mergeClasses(searchBoxClassNames.contentAfter, contentAfterStyles.contentAfter, !focused && contentAfterStyles.rest, state.contentAfter.className);
  } else if (state.dismiss) {
    state.dismiss.className = mergeClasses(state.dismiss.className, contentAfterStyles.contentAfter);
  }
  useInputStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-search/lib/components/SearchBox/SearchBox.js
var SearchBox = React524.forwardRef((props, ref) => {
  const state = useSearchBox_unstable(props, ref);
  useSearchBoxStyles_unstable(state);
  useCustomStyleHook("useSearchBoxStyles_unstable")(state);
  return renderSearchBox_unstable(state);
});
SearchBox.displayName = "SearchBox";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/TeachingPopoverHeader.js
var React526 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeader.js
var React525 = __toESM(require_react());
var useTeachingPopoverHeader_unstable = (props, ref) => {
  const { dismissButton, icon } = props;
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const onDismissButtonClick = useEventCallback((ev) => {
    if (!ev.defaultPrevented) {
      setOpen(ev, false);
    }
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  });
  return {
    appearance,
    components: {
      root: "div",
      dismissButton: "button",
      icon: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      renderByDefault: true,
      defaultProps: {
        children: React525.createElement(Lightbulb16Regular, null),
        "aria-hidden": true
      },
      elementType: "div"
    }),
    dismissButton: slot_exports.optional(dismissButton, {
      renderByDefault: true,
      defaultProps: {
        children: React525.createElement(Dismiss12Regular, null),
        role: "button",
        "aria-label": "dismiss",
        onClick: onDismissButtonClick
      },
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/renderTeachingPopoverHeader.js
var renderTeachingPopoverHeader_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children,
      state.dismissButton && jsx(state.dismissButton, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/useTeachingPopoverHeaderStyles.styles.js
var teachingPopoverHeaderClassNames = {
  root: "fui-TeachingPopoverHeader",
  dismissButton: "fui-TeachingPopoverHeader__dismissButton",
  icon: "fui-TeachingPopoverHeader__icon"
};
var useStyles63 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    sj55zd: "f11d4kpn",
    Bhrd7zp: "fl43uef",
    Be2twd7: "fy9rknc",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: "f14wxoun",
    Bt984gj: "f122n59",
    B6of3ja: "f1jkagg5",
    jrapky: "fi2ljxd"
  },
  rootBrand: {
    sj55zd: "f1phragk"
  },
  dismissButton: {
    sj55zd: "fkfq4zb",
    qhf8xq: "f10pi13n",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: ["f1n71otn", "f1deefiw"],
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    De3pzq: "f1c21dwh",
    B7ck84d: "f1ewtqcl",
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    Jyy4pa: "f1lfeew",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16d74zd",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"]
  },
  dismissBrand: {
    sj55zd: "f1phragk"
  },
  icon: {
    Bqenvij: "fsv12xs",
    a9b677: "f19bqwv",
    Bg96gwp: "fwrc4pm",
    Be2twd7: "fy9rknc",
    Bt984gj: "f122n59",
    B7ck84d: "f1e4lqlz",
    mc9l5x: "ftuwxu6",
    Brf1p80: "f4d9j23",
    w71qe1: "f1iuv45f",
    ha4doy: "fmrv4ls",
    qhf8xq: "f10pi13n",
    De3pzq: "f1c21dwh",
    sj55zd: "fkfq4zb",
    Bokbzmb: "fpvr8q1"
  },
  iconBrand: {
    sj55zd: "f1phragk"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".f122n59{align-items:center;}", ".f1jkagg5{margin-top:var(--spacingHorizontalNone);}", ".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f10pi13n{position:relative;}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1ewtqcl{box-sizing:border-box;}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}", [".f16d74zd{padding:var(--spacingVerticalXS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".fsv12xs{height:var(--fontSizeBase200);}", ".f19bqwv{width:var(--fontSizeBase200);}", ".f1e4lqlz{box-sizing:content-box;}", ".ftuwxu6{display:inline-flex;}", ".f4d9j23{justify-content:center;}", ".f1iuv45f{text-decoration-line:none;}", ".fmrv4ls{vertical-align:middle;}", ".fpvr8q1{-webkit-margin-end:var(--spacingHorizontalXS);margin-inline-end:var(--spacingHorizontalXS);}"]
});
var useTeachingPopoverHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles63();
  const {
    appearance
  } = state;
  state.root.className = mergeClasses(teachingPopoverHeaderClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
  if (state.dismissButton) {
    state.dismissButton.className = mergeClasses(teachingPopoverHeaderClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(teachingPopoverHeaderClassNames.icon, styles.icon, appearance === "brand" ? styles.iconBrand : void 0, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverHeader/TeachingPopoverHeader.js
var TeachingPopoverHeader = React526.forwardRef((props, ref) => {
  const state = useTeachingPopoverHeader_unstable(props, ref);
  useTeachingPopoverHeaderStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverHeaderStyles_unstable")(state);
  return renderTeachingPopoverHeader_unstable(state);
});
TeachingPopoverHeader.displayName = "TeachingPopoverHeader";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/TeachingPopoverBody.js
var React528 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBody.js
var React527 = __toESM(require_react());
var useTeachingPopoverBody_unstable = (props, ref) => {
  const { mediaLength } = props;
  return {
    components: {
      root: "div",
      media: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    media: slot_exports.optional(props.media, {
      elementType: "span"
    }),
    mediaLength: mediaLength !== null && mediaLength !== void 0 ? mediaLength : "short"
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/renderTeachingPopoverBody.js
var renderTeachingPopoverBody_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(state.media, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/useTeachingPopoverBodyStyles.styles.js
var teachingPopoverBodyClassNames = {
  root: "fui-TeachingPopoverBody",
  media: "fui-TeachingPopoverBody__media"
};
var useMediaStyles2 = __styles2({
  base: {
    Bw0ie65: 0,
    Br312pm: 0,
    nk6f5a: 0,
    Ijaq50: 0,
    Bq1tomu: "fujjg13",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    a9b677: "f14z66ap",
    jrapky: "f1jlhsmd",
    ha4doy: "fmrv4ls",
    Brf1p80: "f4d9j23",
    mc9l5x: "f22iagw"
  },
  short: {
    Bubjx69: "f1taewuw",
    Bfd67p1: "f2f587x"
  },
  medium: {
    Bubjx69: "f7da563",
    Bfd67p1: "fmwcswg"
  },
  tall: {
    Bubjx69: "f9ikmtg",
    Bfd67p1: "f1gv48o"
  }
}, {
  d: [[".fujjg13{grid-area:media;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f14z66ap{width:auto;}", ".f1jlhsmd{margin-bottom:12px;}", ".fmrv4ls{vertical-align:middle;}", ".f4d9j23{justify-content:center;}", ".f22iagw{display:flex;}", ".f1taewuw{aspect-ratio:2.4615384615384617;}", ".f7da563{aspect-ratio:1.6363636363636365;}", ".f9ikmtg{aspect-ratio:1;}"],
  t: ["@supports not (aspect-ratio){.f2f587x{height:117px;}}", "@supports not (aspect-ratio){.fmwcswg{height:176px;}}", "@supports not (aspect-ratio){.f1gv48o{height:288px;}}"]
});
var useStyles64 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Byoj8tv: "fpe6lb7"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".fpe6lb7{padding-bottom:12px;}"]
});
var useTeachingPopoverBodyStyles_unstable = (state) => {
  "use no memo";
  const {
    mediaLength
  } = state;
  const styles = useStyles64();
  const mediaStyles = useMediaStyles2();
  state.root.className = mergeClasses(teachingPopoverBodyClassNames.root, styles.root, state.root.className);
  if (state.media) {
    state.media.className = mergeClasses(teachingPopoverBodyClassNames.media, mediaStyles.base, mediaStyles[mediaLength], state.media.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverBody/TeachingPopoverBody.js
var TeachingPopoverBody = React528.forwardRef((props, ref) => {
  const state = useTeachingPopoverBody_unstable(props, ref);
  useTeachingPopoverBodyStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverBodyStyles_unstable")(state);
  return renderTeachingPopoverBody_unstable(state);
});
TeachingPopoverBody.displayName = "TeachingPopoverBody";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/TeachingPopoverCarouselCard.js
var React533 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCard.js
var React532 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/Carouseltem.js
var React531 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/useCarouselItem.js
var React530 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselContext.js
var React529 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/createCarouselStore.js
var createCarouselStore = () => {
  let values = [];
  let listeners = [];
  const carouselStore = {
    clear() {
      values = [];
      emitChange();
    },
    addValue(value) {
      values = [
        ...values,
        value
      ];
      emitChange();
    },
    insertValue(value, prev) {
      if (!prev) {
        values = [
          value,
          ...values
        ];
      } else {
        const pos = values.indexOf(prev);
        values.splice(pos + 1, 0, value);
        values = [
          ...values
        ];
      }
      emitChange();
    },
    removeValue(value) {
      const pos = values.indexOf(value);
      values.splice(pos, 1);
      values = [
        ...values
      ];
      emitChange();
    },
    subscribe(listener) {
      listeners = [
        ...listeners,
        listener
      ];
      return () => {
        listeners = listeners.filter((l) => l !== listener);
      };
    },
    getSnapshot() {
      return values;
    }
  };
  function emitChange() {
    for (const listener of listeners) {
      listener();
    }
  }
  return carouselStore;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselContext.js
var carouselContextDefaultValue = {
  store: createCarouselStore(),
  value: null,
  selectPageByDirection: () => {
  },
  selectPageByValue: () => {
  }
};
var CarouselContext = createContext13(void 0);
var CarouselProvider = CarouselContext.Provider;
var useCarouselContext_unstable = (selector) => useContextSelector(CarouselContext, (ctx = carouselContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/constants.js
var CAROUSEL_ITEM = "data-carousel-item";
var CAROUSEL_ACTIVE_ITEM = "data-carousel-active-item";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/useCarouselItem.js
var useCarouselItem_unstable = (props, ref) => {
  const { value } = props;
  const visible = useCarouselContext_unstable((c) => c.value === value);
  const state = {
    value,
    visible,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      [CAROUSEL_ITEM]: value,
      [CAROUSEL_ACTIVE_ITEM]: visible,
      hidden: !visible,
      ...props
    }), {
      elementType: "div"
    })
  };
  if (!visible) {
    state.root.children = null;
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/renderCarouselItem.js
var renderCarouselItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/CarouselItem/Carouseltem.js
var CarouselItem = React531.forwardRef((props, ref) => {
  const state = useCarouselItem_unstable(props, ref);
  return renderCarouselItem_unstable(state);
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCard.js
var useTeachingPopoverCarouselCard_unstable = (props, ref) => {
  const { value } = props;
  return {
    value,
    components: {
      root: CarouselItem
    },
    root: slot_exports.always({
      ...getIntrinsicElementProps("div", {
        ref,
        ...props
      }),
      value
    }, {
      elementType: CarouselItem
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/renderTeachingPopoverCarouselCard.js
var renderTeachingPopoverCarouselCard_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/useTeachingPopoverCarouselCardStyles.styles.js
var teachingPopoverCarouselCardClassNames = {
  root: "fui-TeachingPopoverCarouselCard"
};
var useStyles65 = __styles2({
  root: {}
}, {});
var useTeachingPopoverCarouselCardStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles65();
  state.root.className = mergeClasses(teachingPopoverCarouselCardClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselCard/TeachingPopoverCarouselCard.js
var TeachingPopoverCarouselCard = React533.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselCard_unstable(props, ref);
  useTeachingPopoverCarouselCardStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselCardStyles_unstable")(state);
  return renderTeachingPopoverCarouselCard_unstable(state);
});
TeachingPopoverCarouselCard.displayName = "TeachingPopoverCarouselCard";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/TeachingPopoverCarousel.js
var React537 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarousel.js
var React536 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/Carousel.js
var React535 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselWalker.js
var React534 = __toESM(require_react());
var useCarouselWalker_unstable = () => {
  const { targetDocument } = useFluent();
  const treeWalkerRef = React534.useRef(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.createTreeWalker(targetDocument.body));
  const htmlRef = React534.useRef(null);
  const ref = React534.useCallback((el) => {
    if (!targetDocument) {
      return;
    }
    if (!el) {
      return;
    }
    htmlRef.current = el;
    treeWalkerRef.current = targetDocument.createTreeWalker(el, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (!isHTMLElement(node)) {
          return NodeFilter.FILTER_SKIP;
        }
        return node.hasAttribute(CAROUSEL_ITEM) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
  }, [
    targetDocument
  ]);
  return {
    ref,
    walker: React534.useMemo(() => ({
      active() {
        if (!htmlRef.current) {
          return null;
        }
        const activeEl = htmlRef.current.querySelector(`[${CAROUSEL_ACTIVE_ITEM}="true"]`);
        if (isHTMLElement(activeEl)) {
          return {
            el: activeEl,
            value: activeEl.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      },
      find(value) {
        var _treeWalkerRef_current;
        if (!((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode) || !htmlRef.current) {
          return null;
        }
        treeWalkerRef.current.currentNode = htmlRef.current;
        let nextNode = null;
        while (nextNode = treeWalkerRef.current.nextNode()) {
          if (!isHTMLElement(nextNode)) {
            continue;
          }
          if (nextNode.getAttribute(CAROUSEL_ITEM) === value) {
            return {
              el: nextNode,
              value: nextNode.getAttribute(CAROUSEL_ITEM)
            };
          }
        }
        return null;
      },
      nextPage(value) {
        var _treeWalkerRef_current;
        const res = this.find(value);
        if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) {
          return null;
        }
        treeWalkerRef.current.currentNode = res.el;
        const next = treeWalkerRef.current.nextNode();
        if (isHTMLElement(next)) {
          return {
            el: next,
            value: next.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      },
      prevPage(value) {
        var _treeWalkerRef_current;
        const res = this.find(value);
        if (!res || !((_treeWalkerRef_current = treeWalkerRef.current) === null || _treeWalkerRef_current === void 0 ? void 0 : _treeWalkerRef_current.currentNode)) {
          return null;
        }
        treeWalkerRef.current.currentNode = res.el;
        const next = treeWalkerRef.current.previousNode();
        if (isHTMLElement(next)) {
          return {
            el: next,
            value: next.getAttribute(CAROUSEL_ITEM)
          };
        }
        return null;
      }
    }), [])
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/Carousel.js
function useCarousel_unstable(options) {
  "use no memo";
  const { announcement, onValueChange, onFinish } = options;
  const { targetDocument } = useFluent();
  const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
  const { ref: carouselRef, walker: carouselWalker } = useCarouselWalker_unstable();
  const [store] = React535.useState(() => createCarouselStore());
  const [value, setValue] = useControllableState({
    defaultState: options.defaultValue,
    state: options.value,
    initialState: null
  });
  const rootRef = React535.useRef(null);
  const { announce } = useAnnounce();
  if (true) {
    React535.useEffect(() => {
      if (value === null) {
        console.error("useCarousel: Carousel needs to have a `defaultValue` or `value` prop set. If you want to control the value, use the `value` prop.");
      }
    }, [
      value
    ]);
  }
  React535.useEffect(() => {
    var _rootRef_current;
    const allItems = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.querySelectorAll(`[${CAROUSEL_ITEM}]`);
    for (let i = 0; i < allItems.length; i++) {
      store.addValue(allItems.item(i).getAttribute(CAROUSEL_ITEM));
    }
    return () => {
      store.clear();
    };
  }, [
    store
  ]);
  React535.useEffect(() => {
    if (!win) {
      return;
    }
    const config = {
      attributes: true,
      attributeFilter: [
        CAROUSEL_ITEM
      ],
      childList: true,
      subtree: true
    };
    const callback = (mutationList) => {
      for (const mutation of mutationList) {
        for (const addedNode of Array.from(mutation.addedNodes)) {
          if (isHTMLElement(addedNode) && addedNode.hasAttribute(CAROUSEL_ITEM)) {
            const newValue = addedNode.getAttribute(CAROUSEL_ITEM);
            const newNode = carouselWalker.find(newValue);
            if (!(newNode === null || newNode === void 0 ? void 0 : newNode.value)) {
              return;
            }
            const previousNode = carouselWalker.prevPage(newNode === null || newNode === void 0 ? void 0 : newNode.value);
            var _previousNode_value;
            store.insertValue(newValue, (_previousNode_value = previousNode === null || previousNode === void 0 ? void 0 : previousNode.value) !== null && _previousNode_value !== void 0 ? _previousNode_value : null);
          }
        }
        for (const removedNode of Array.from(mutation.removedNodes)) {
          if (isHTMLElement(removedNode) && (removedNode === null || removedNode === void 0 ? void 0 : removedNode.hasAttribute(CAROUSEL_ITEM))) {
            const removedValue = removedNode.getAttribute(CAROUSEL_ITEM);
            store.removeValue(removedValue);
          }
        }
      }
    };
    const observer = new win.MutationObserver(callback);
    observer.observe(rootRef.current, config);
    return () => {
      observer.disconnect();
    };
  }, [
    carouselWalker,
    store,
    win
  ]);
  const updateSlide = useEventCallback((event, newValue) => {
    setValue(newValue);
    onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange(event, {
      event,
      type: "click",
      value: newValue
    });
    const announceText = announcement === null || announcement === void 0 ? void 0 : announcement(newValue);
    if (announceText) {
      announce(announceText, {
        polite: true
      });
    }
  });
  const selectPageByDirection = useEventCallback((event, direction) => {
    const active = carouselWalker.active();
    if (!(active === null || active === void 0 ? void 0 : active.value)) {
      return;
    }
    const newPage = direction === "prev" ? carouselWalker.prevPage(active.value) : carouselWalker.nextPage(active.value);
    if (newPage) {
      updateSlide(event, newPage === null || newPage === void 0 ? void 0 : newPage.value);
    } else {
      onFinish === null || onFinish === void 0 ? void 0 : onFinish(event, {
        event,
        type: "click",
        value: active === null || active === void 0 ? void 0 : active.value
      });
    }
  });
  return {
    carouselRef: useMergedRefs(rootRef, carouselRef),
    carousel: {
      store,
      value,
      selectPageByDirection,
      selectPageByValue: updateSlide
    }
  };
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarousel.js
var useTeachingPopoverCarousel_unstable = (props, ref) => {
  const toggleOpen = usePopoverContext_unstable((c) => c.toggleOpen);
  const handleFinish = useEventCallback((event, data) => {
    var _props_onFinish;
    (_props_onFinish = props.onFinish) === null || _props_onFinish === void 0 ? void 0 : _props_onFinish.call(props, event, data);
    toggleOpen(event);
  });
  const { carousel, carouselRef } = useCarousel_unstable({
    announcement: props.announcement,
    defaultValue: props.defaultValue,
    value: props.value,
    onValueChange: props.onValueChange,
    onFinish: handleFinish
  });
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  return {
    appearance,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, carouselRef),
      ...props
    }), {
      elementType: "div"
    }),
    ...carousel
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/renderTeachingPopoverCarousel.js
var renderTeachingPopoverCarousel_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselProvider, {
    value: contextValues.carousel,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselStyles.styles.js
var teachingPopoverCarouselClassNames = {
  root: "fui-TeachingPopoverCarousel"
};
var useStyles66 = __styles2({
  root: {}
}, {});
var useTeachingPopoverCarouselStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles66();
  state.root.className = mergeClasses(teachingPopoverCarouselClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/useTeachingPopoverCarouselContextValues.js
function useTeachingPopoverCarouselContextValues_unstable(state) {
  const { store, value, selectPageByValue, selectPageByDirection } = state;
  const carousel = {
    store,
    value,
    selectPageByDirection,
    selectPageByValue
  };
  return {
    carousel
  };
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/TeachingPopoverCarousel.js
var TeachingPopoverCarousel = React537.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarousel_unstable(props, ref);
  useTeachingPopoverCarouselStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselStyles_unstable")(state);
  const contextValues = useTeachingPopoverCarouselContextValues_unstable(state);
  return renderTeachingPopoverCarousel_unstable(state, contextValues);
});
TeachingPopoverCarousel.displayName = "TeachingPopoverCarousel";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/TeachingPopoverCarouselFooter.js
var React541 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooter.js
var React540 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/TeachingPopoverCarouselFooterButton.js
var React539 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButton.js
var React538 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarousel/Carousel/useCarouselValues.js
var import_shim2 = __toESM(require_shim());
function useCarouselValues_unstable(getSnapshot) {
  const store = useCarouselContext_unstable((c) => c.store);
  return (0, import_shim2.useSyncExternalStore)(store.subscribe, () => getSnapshot(store.getSnapshot()));
}

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButton.js
var useTeachingPopoverCarouselFooterButton_unstable = (props, ref) => {
  const { navType, altText } = props;
  const popoverAppearance = usePopoverContext_unstable((context) => context.appearance);
  const selectPageByDirection = useCarouselContext_unstable((c) => c.selectPageByDirection);
  const values = useCarouselValues_unstable((snapshot) => snapshot);
  const activeValue = useCarouselContext_unstable((c) => c.value);
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    selectPageByDirection(event, navType);
  };
  const handleButtonClick = useEventCallback(mergeCallbacks(handleClick, props.onClick));
  const isTrailing = React538.useMemo(() => {
    if (!activeValue) {
      return false;
    }
    if (navType === "prev") {
      return values.indexOf(activeValue) === 0;
    }
    return values.indexOf(activeValue) === values.length - 1;
  }, [
    navType,
    activeValue,
    values
  ]);
  let buttonAppearanceType;
  if (navType === "next") {
    buttonAppearanceType = popoverAppearance === "brand" ? void 0 : "primary";
  } else {
    buttonAppearanceType = popoverAppearance === "brand" ? "outline" : void 0;
  }
  let buttonChild = props.children;
  if (isTrailing) {
    buttonChild = altText;
  }
  return {
    ...useButton_unstable({
      appearance: buttonAppearanceType,
      ...props
    }, ref),
    navType,
    popoverAppearance,
    altText,
    // Override useButton root slot
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      appearance: buttonAppearanceType,
      ...props,
      onClick: handleButtonClick,
      children: buttonChild
    }), {
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/renderTeachingPopoverCarouselFooterButton.js
var renderTeachingPopoverCarouselFooterButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/useTeachingPopoverCarouselFooterButtonStyles.styles.js
var teachingPopoverCarouselFooterButtonClassNames = {
  root: "fui-TeachingPopoverCarouselFooterButton"
};
var useStyles67 = __styles2({
  root: {
    Bf4jedk: "f14es27b"
  },
  brandNext: {
    sj55zd: "f16muhyy",
    De3pzq: "f10s6wn9",
    g2u3we: "f1iimpp0",
    h3c5rm: ["f19uhqvu", "f1nx14hx"],
    B9xav0g: "fnqa90p",
    zhjwy3: ["f1nx14hx", "f19uhqvu"],
    Bi91k9c: "f3ymbdj",
    Jwef8y: "f1rgtb95",
    B2d53fq: "f1pu27ff",
    iro3zm: "f1d5c7in"
  },
  brandPrevious: {
    sj55zd: "f1phragk",
    De3pzq: "ffp7eso",
    g2u3we: "fm1ebug",
    h3c5rm: ["f28omuz", "f1uhflii"],
    B9xav0g: "f1ixw5o4",
    zhjwy3: ["f1uhflii", "f28omuz"],
    Bi91k9c: "f1rq72xc",
    Bgoe8wy: "f1bg5g8r",
    Bwzppfd: ["f1h9bnsk", "f12x9t0k"],
    oetu4i: "f19ervry",
    gg5e9n: ["f12x9t0k", "f1h9bnsk"],
    Jwef8y: "f15wkkf3",
    B2d53fq: "f1d6v5y2",
    b661bw: "f1565b9n",
    Bk6r4ia: ["fm07gvo", "fwlsg72"],
    B9zn80p: "fzw6fmy",
    Bpld233: ["fwlsg72", "fm07gvo"],
    iro3zm: "fnp9lpt"
  }
}, {
  d: [".f14es27b{min-width:96px;}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1iimpp0{border-top-color:var(--colorTransparentBackground);}", ".f19uhqvu{border-right-color:var(--colorTransparentBackground);}", ".f1nx14hx{border-left-color:var(--colorTransparentBackground);}", ".fnqa90p{border-bottom-color:var(--colorTransparentBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}"],
  h: [".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".f1bg5g8r:hover{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f1h9bnsk:hover{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f12x9t0k:hover{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f19ervry:hover{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1565b9n:hover:active{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".fm07gvo:hover:active{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".fwlsg72:hover:active{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".fzw6fmy:hover:active{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}"]
});
var useTeachingPopoverCarouselFooterButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles67();
  const {
    navType,
    popoverAppearance
  } = state;
  state = {
    ...state,
    ...useButtonStyles_unstable(state)
  };
  state.root.className = mergeClasses(teachingPopoverCarouselFooterButtonClassNames.root, styles.root, navType === "prev" && popoverAppearance === "brand" && styles.brandPrevious, navType === "next" && popoverAppearance === "brand" && styles.brandNext, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooterButton/TeachingPopoverCarouselFooterButton.js
var TeachingPopoverCarouselFooterButton = React539.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselFooterButton_unstable(props, ref);
  useTeachingPopoverCarouselFooterButtonStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselFooterButtonStyles_unstable")(state);
  return renderTeachingPopoverCarouselFooterButton_unstable(state);
});
TeachingPopoverCarouselFooterButton.displayName = "TeachingPopoverCarouselFooterButton";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooter.js
var useTeachingPopoverCarouselFooter_unstable = (props, ref) => {
  const { layout = "centered", initialStepText, finalStepText } = props;
  const previous = slot_exports.optional(props.previous, {
    defaultProps: {
      navType: "prev",
      altText: initialStepText
    },
    renderByDefault: true,
    elementType: TeachingPopoverCarouselFooterButton
  });
  const next = slot_exports.always(props.next, {
    defaultProps: {
      navType: "next",
      altText: finalStepText
    },
    elementType: TeachingPopoverCarouselFooterButton
  });
  return {
    layout,
    components: {
      root: "div",
      next: TeachingPopoverCarouselFooterButton,
      previous: TeachingPopoverCarouselFooterButton
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    previous,
    next
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/renderTeachingPopoverCarouselFooter.js
var renderTeachingPopoverCarouselFooter_unstable = (state) => {
  assertSlots(state);
  const { layout } = state;
  return jsxs(state.root, {
    children: [
      layout === "centered" && state.previous && jsx(state.previous, {}),
      state.root.children,
      layout === "offset" && state.previous && jsx(state.previous, {}),
      jsx(state.next, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/useTeachingPopoverCarouselFooterStyles.styles.js
var teachingPopoverCarouselFooterClassNames = {
  root: "fui-TeachingPopoverCarouselFooter",
  previous: "fui-TeachingPopoverCarouselFooter__previous",
  next: "fui-TeachingPopoverCarouselFooter__next"
};
var useStyles68 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq"
  },
  rootCentered: {
    Brf1p80: "f1869bpl",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4"
  },
  rootRightAligned: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4",
    Bp34fd5: "f1y65ohq"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1869bpl{justify-content:space-between;}", [".f19gb1f4{gap:8px;}", {
    p: -1
  }], [".f19gb1f4{gap:8px;}", {
    p: -1
  }], ".f1y65ohq :first-child{-webkit-margin-end:auto;margin-inline-end:auto;}"]
});
var useTeachingPopoverCarouselFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles68();
  const {
    layout
  } = state;
  state.root.className = mergeClasses(teachingPopoverCarouselFooterClassNames.root, styles.root, layout === "centered" ? styles.rootCentered : styles.rootRightAligned, state.root.className);
  if (state.previous) {
    state.previous.className = mergeClasses(teachingPopoverCarouselFooterClassNames.previous, state.previous.className);
  }
  state.next.className = mergeClasses(teachingPopoverCarouselFooterClassNames.next, state.next.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselFooter/TeachingPopoverCarouselFooter.js
var TeachingPopoverCarouselFooter = React541.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselFooter_unstable(props, ref);
  useTeachingPopoverCarouselFooterStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselFooterStyles_unstable")(state);
  return renderTeachingPopoverCarouselFooter_unstable(state);
});
TeachingPopoverCarouselFooter.displayName = "TeachingPopoverCarouselFooter";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/TeachingPopoverCarouselNav.js
var React544 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNav.js
var React542 = __toESM(require_react());
var useTeachingPopoverCarouselNav_unstable = (props, ref) => {
  const focusableGroupAttr = useArrowNavigationGroup({
    circular: false,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const values = useCarouselValues_unstable((snapshot) => snapshot);
  return {
    values,
    renderNavButton: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "tablist",
      tabIndex: 0,
      ...props,
      ...focusableGroupAttr,
      children: null
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/valueIdContext.js
var React543 = __toESM(require_react());
var valueIdContext = React543.createContext(void 0);
var valueIdContextDefaultValue = "";
var useValueIdContext = () => {
  var _React_useContext;
  return (_React_useContext = React543.useContext(valueIdContext)) !== null && _React_useContext !== void 0 ? _React_useContext : valueIdContextDefaultValue;
};
var ValueIdContextProvider = valueIdContext.Provider;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/renderTeachingPopoverCarouselNav.js
var renderTeachingPopoverCarouselNav_unstable = (state) => {
  assertSlots(state);
  const { values, renderNavButton } = state;
  return jsx(state.root, {
    children: values.map((value) => jsx(ValueIdContextProvider, {
      value,
      children: renderNavButton(value)
    }, value))
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/useTeachingPopoverCarouselNavStyles.styles.js
var teachingPopoverCarouselNavClassNames = {
  root: "fui-TeachingPopoverCarouselNav"
};
var useStyles69 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    i8kkvl: "f1ufnopg",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"]
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1ufnopg{column-gap:var(--spacingHorizontalXS);}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}"]
});
var useTeachingPopoverCarouselNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles69();
  state.root.className = mergeClasses(teachingPopoverCarouselNavClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNav/TeachingPopoverCarouselNav.js
var TeachingPopoverCarouselNav = React544.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselNav_unstable(props, ref);
  useTeachingPopoverCarouselNavStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselNavStyles_unstable")(state);
  return renderTeachingPopoverCarouselNav_unstable(state);
});
TeachingPopoverCarouselNav.displayName = "TeachingPopoverCarouselNav";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/TeachingPopoverCarouselNavButton.js
var React546 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButton.js
var React545 = __toESM(require_react());
var useTeachingPopoverCarouselNavButton_unstable = (props, ref) => {
  const { onClick, as = "a" } = props;
  const value = useValueIdContext();
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const selectPageByValue = useCarouselContext_unstable((c) => c.selectPageByValue);
  const isSelected = useCarouselContext_unstable((c) => c.value === value);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByValue(event, value);
    }
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: isSelected
    }
  });
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref,
      role: "tab",
      type: "button",
      "aria-selected": `${!!isSelected}`,
      ...defaultTabProps
    }
  });
  _carouselButton.onClick = handleClick;
  const state = {
    isSelected,
    appearance,
    components: {
      root: "button"
    },
    root: _carouselButton
  };
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/renderTeachingPopoverCarouselNavButton.js
var renderTeachingPopoverCarouselNavButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/useTeachingPopoverCarouselNavButtonStyles.styles.js
var teachingPopoverCarouselNavButtonClassNames = {
  root: "fui-TeachingPopoverCarouselNavButton"
};
var useStyles70 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bceei9c: "f1k6fduh",
    B7ck84d: "f1ewtqcl",
    Bqenvij: "f1x82gua",
    a9b677: "f1o3cbw4",
    De3pzq: "ffp7eso"
  },
  rootUnselected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f5q2cvs",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    De3pzq: "frgiif3",
    o2ey54: "fawpdd5",
    C3llkk: "feyhbel"
  },
  rootSelected: {
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    a9b677: "fjw5fx7",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    By8wz76: "f1wgxgin"
  },
  rootBrand: {
    De3pzq: "f10s6wn9"
  },
  rootBrandUnselected: {
    De3pzq: "frxe7el",
    o2ey54: "fawpdd5",
    C3llkk: "feyhbel"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1k6fduh{cursor:pointer;}", ".f1ewtqcl{box-sizing:border-box;}", ".f1x82gua{height:8px;}", ".f1o3cbw4{width:8px;}", ".ffp7eso{background-color:var(--colorBrandBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".f5q2cvs{border-radius:50%;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".frgiif3{background-color:color-mix(in srgb, var(--colorBrandBackground) 30%, transparent);}", [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], ".fjw5fx7{width:16px;}", [".f3bhgqh{border:none;}", {
    p: -2
  }], [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}", ".frxe7el{background-color:color-mix(in srgb, var(--colorNeutralForegroundOnBrand) 30%, transparent);}"],
  t: ["@supports not (color: color-mix(in lch, white, black)){.fawpdd5{opacity:0.3;}}", "@supports not (color: color-mix(in lch, white, black)){.feyhbel{background-color:var(--colorBrandBackground);}}"],
  m: [["@media (forced-colors: active){.f1wgxgin{background-color:CanvasText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTeachingPopoverCarouselNavButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles70();
  const {
    appearance,
    isSelected
  } = state;
  const brandStyles = isSelected ? styles.rootBrand : styles.rootBrandUnselected;
  state.root.className = mergeClasses(teachingPopoverCarouselNavButtonClassNames.root, styles.root, isSelected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && brandStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselNavButton/TeachingPopoverCarouselNavButton.js
var TeachingPopoverCarouselNavButton = React546.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselNavButton_unstable(props, ref);
  useTeachingPopoverCarouselNavButtonStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselNavButtonStyles_unstable")(state);
  return renderTeachingPopoverCarouselNavButton_unstable(state);
});
TeachingPopoverCarouselNavButton.displayName = "TeachingPopoverCarouselNavButton";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/TeachingPopoverSurface.js
var React548 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurface.js
var React547 = __toESM(require_react());
var useTeachingPopoverSurface_unstable = (props, ref) => {
  const state = usePopoverSurface_unstable(props, ref);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/useTeachingPopoverSurfaceStyles.styles.js
var teachingPopoverSurfaceClassNames = {
  root: "fui-TeachingPopoverSurface"
};
var useStyles71 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f23zza1",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    Bf4jedk: "f14hp5dx",
    B7ck84d: "f1ewtqcl"
  }
}, {
  d: [[".f23zza1{padding:var(--spacingVerticalL) var(--spacingVerticalL);}", {
    p: -1
  }], [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".f14hp5dx{min-width:320px;}", ".f1ewtqcl{box-sizing:border-box;}"]
});
var useTeachingPopoverSurfaceStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles71();
  state.root.className = mergeClasses(teachingPopoverSurfaceClassNames.root, styles.root, state.root.className);
  const updatedState = usePopoverSurfaceStyles_unstable(state);
  return updatedState;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/renderTeachingPopoverSurface.js
var renderTeachingPopoverSurface_unstable = (state) => {
  assertSlots(state);
  return renderPopoverSurface_unstable(state);
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverSurface/TeachingPopoverSurface.js
var TeachingPopoverSurface = React548.forwardRef((props, ref) => {
  const state = useTeachingPopoverSurface_unstable(props, ref);
  useTeachingPopoverSurfaceStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverSurfaceStyles_unstable")(state);
  return renderTeachingPopoverSurface_unstable(state);
});
TeachingPopoverSurface.displayName = "TeachingPopoverSurface";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/TeachingPopoverTitle.js
var React550 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitle.js
var React549 = __toESM(require_react());
var DismissIcon = bundleIcon(DismissFilled, DismissRegular);
var useTeachingPopoverTitle_unstable = (props, ref) => {
  const { dismissButton } = props;
  const setOpen = usePopoverContext_unstable((context) => context.setOpen);
  const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const onDismissButtonClick = useEventCallback((ev) => {
    if (!ev.defaultPrevented) {
      setOpen(ev, false);
    }
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  });
  return {
    appearance,
    components: {
      root: "h2",
      dismissButton: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("h2", {
      ref,
      ...props
    }), {
      elementType: "h2"
    }),
    dismissButton: slot_exports.optional(dismissButton, {
      renderByDefault: false,
      defaultProps: {
        children: React549.createElement(DismissIcon, null),
        onClick: onDismissButtonClick,
        "aria-label": "dismiss",
        "aria-hidden": true
      },
      elementType: "button"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/renderTeachingPopoverTitle.js
var renderTeachingPopoverTitle_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.dismissButton && jsx(state.dismissButton, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/useTeachingPopoverTitleStyles.styles.js
var teachingPopoverTitleClassNames = {
  root: "fui-TeachingPopoverTitle",
  dismissButton: "fui-TeachingPopoverTitle__dismissButton"
};
var useStyles72 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Brf1p80: "f1869bpl",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    sj55zd: "f19n0e5",
    Bg96gwp: "faaz57k",
    Byoj8tv: "f5b47ha",
    B6of3ja: "f1jkagg5",
    jrapky: "fi2ljxd"
  },
  rootBrand: {
    sj55zd: "f1phragk"
  },
  dismissButton: {
    qhf8xq: "f10pi13n",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: ["f1n71otn", "f1deefiw"],
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w",
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    De3pzq: "f1c21dwh",
    B7ck84d: "f1ewtqcl",
    B7oj6ja: ["f3fg2lr", "f13av6d4"],
    Bbmb7ep: ["fzi6hpg", "fyowgf4"],
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Jyy4pa: "f1lfeew"
  },
  dismissBrand: {
    sj55zd: "f1phragk"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1869bpl{justify-content:space-between;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".f1jkagg5{margin-top:var(--spacingHorizontalNone);}", ".fi2ljxd{margin-bottom:var(--spacingHorizontalNone);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f10pi13n{position:relative;}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f122n59{align-items:center;}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1ewtqcl{box-sizing:border-box;}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", ".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}"]
});
var useTeachingPopoverTitleStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles72();
  const {
    appearance
  } = state;
  state.root.className = mergeClasses(teachingPopoverTitleClassNames.root, styles.root, appearance === "brand" && styles.rootBrand, state.root.className);
  if (state.dismissButton) {
    state.dismissButton.className = mergeClasses(teachingPopoverTitleClassNames.dismissButton, styles.dismissButton, appearance === "brand" ? styles.dismissBrand : void 0, state.dismissButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTitle/TeachingPopoverTitle.js
var TeachingPopoverTitle = React550.forwardRef((props, ref) => {
  const state = useTeachingPopoverTitle_unstable(props, ref);
  useTeachingPopoverTitleStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverTitleStyles_unstable")(state);
  return renderTeachingPopoverTitle_unstable(state);
});
TeachingPopoverTitle.displayName = "TeachingPopoverTitle";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/TeachingPopoverTrigger.js
var React551 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/renderTeachingPopoverTrigger.js
var renderTeachingPopoverTrigger_unstable = (state) => {
  return state.children;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/useTeachingPopoverTrigger.js
var useTeachingPopoverTrigger_unstable = (props) => {
  const state = usePopoverTrigger_unstable(props);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverTrigger/TeachingPopoverTrigger.js
var TeachingPopoverTrigger = (props) => {
  const state = useTeachingPopoverTrigger_unstable(props);
  return renderTeachingPopoverTrigger_unstable(state);
};
TeachingPopoverTrigger.displayName = "TeachingPopoverTrigger";
TeachingPopoverTrigger.isFluentTriggerComponent = true;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/TeachingPopover.js
var React552 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/useTeachingPopover.js
var useTeachingPopover_unstable = (props) => {
  const popoverState = usePopover_unstable(props);
  var _props_withArrow, _props_trapFocus;
  return {
    ...popoverState,
    withArrow: (_props_withArrow = props.withArrow) !== null && _props_withArrow !== void 0 ? _props_withArrow : true,
    // We trap focus because the default TeachingPopover view has buttons/carousel.
    trapFocus: (_props_trapFocus = props.trapFocus) !== null && _props_trapFocus !== void 0 ? _props_trapFocus : true
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/renderTeachingPopover.js
var renderTeachingPopover_unstable = renderPopover_unstable;

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopover/TeachingPopover.js
var TeachingPopover = (props) => {
  const state = useTeachingPopover_unstable(props);
  return renderTeachingPopover_unstable(state);
};
TeachingPopover.displayName = "TeachingPopover";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/TeachingPopoverFooter.js
var React554 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooter.js
var React553 = __toESM(require_react());
var useTeachingPopoverFooter_unstable = (props, ref) => {
  const appearance = usePopoverContext_unstable((context) => context.appearance);
  const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
  const handleButtonClick = useEventCallback((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    toggleOpen(event);
  });
  const secondary = slot_exports.optional(props.secondary, {
    defaultProps: {
      appearance: appearance === "brand" ? "primary" : void 0
    },
    renderByDefault: props.secondary !== void 0,
    elementType: Button
  });
  if (secondary) {
    secondary.onClick = mergeCallbacks(handleButtonClick, secondary === null || secondary === void 0 ? void 0 : secondary.onClick);
  }
  const primary = slot_exports.always(props.primary, {
    defaultProps: {
      appearance: appearance === "brand" ? void 0 : "primary"
    },
    elementType: Button
  });
  if (!secondary) {
    primary.onClick = mergeCallbacks(handleButtonClick, primary === null || primary === void 0 ? void 0 : primary.onClick);
  }
  var _props_footerLayout;
  return {
    footerLayout: (_props_footerLayout = props.footerLayout) !== null && _props_footerLayout !== void 0 ? _props_footerLayout : "horizontal",
    appearance,
    components: {
      root: "div",
      primary: Button,
      secondary: Button
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    secondary,
    primary
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/renderTeachingPopoverFooter.js
var renderTeachingPopoverFooter_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.primary, {}),
      state.secondary && jsx(state.secondary, {})
    ]
  });
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/useTeachingPopoverFooterStyles.styles.js
var teachingPopoverFooterClassNames = {
  root: "fui-TeachingPopoverFooter",
  primary: "fui-TeachingPopoverFooter__primary",
  secondary: "fui-TeachingPopoverFooter__secondary"
};
var useStyles73 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f19gb1f4",
    z8tnut: "f1kcqot9"
  },
  rootVertical: {
    Beiy3e4: "f1vx9l62"
  },
  rootHorizontal: {
    Beiy3e4: "f1063pyq",
    Brf1p80: "f9c4gz4"
  },
  buttonRootVertical: {
    a9b677: "f14z66ap",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  },
  buttonRootHorizontal: {
    Bf4jedk: "f14es27b",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ff3glw6"
  },
  brandSecondary: {
    g2u3we: "fm1ebug",
    h3c5rm: ["f28omuz", "f1uhflii"],
    B9xav0g: "f1ixw5o4",
    zhjwy3: ["f1uhflii", "f28omuz"]
  },
  brandPrimary: {
    sj55zd: "f16muhyy",
    De3pzq: "f10s6wn9",
    Bi91k9c: "f3ymbdj",
    Jwef8y: "f1rgtb95",
    B2d53fq: "f1pu27ff",
    iro3zm: "f1d5c7in"
  }
}, {
  d: [".f22iagw{display:flex;}", [".f19gb1f4{gap:8px;}", {
    p: -1
  }], ".f1kcqot9{padding-top:12px;}", ".f1vx9l62{flex-direction:column;}", ".f1063pyq{flex-direction:row;}", ".f9c4gz4{justify-content:flex-end;}", ".f14z66ap{width:auto;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], ".f14es27b{min-width:96px;}", [".ff3glw6{border-radius:4px;}", {
    p: -1
  }], ".fm1ebug{border-top-color:var(--colorNeutralForegroundOnBrand);}", ".f28omuz{border-right-color:var(--colorNeutralForegroundOnBrand);}", ".f1uhflii{border-left-color:var(--colorNeutralForegroundOnBrand);}", ".f1ixw5o4{border-bottom-color:var(--colorNeutralForegroundOnBrand);}", ".f16muhyy{color:var(--colorBrandForeground1);}", ".f10s6wn9{background-color:var(--colorNeutralForegroundOnBrand);}"],
  h: [".f3ymbdj:hover{color:var(--colorCompoundBrandForeground1Hover);}", ".f1rgtb95:hover{background-color:var(--colorNeutralForegroundOnBrand);}", ".f1pu27ff:hover:active{color:var(--colorCompoundBrandForeground1Pressed);}", ".f1d5c7in:hover:active{background-color:var(--colorNeutralForegroundOnBrand);}"]
});
var useTeachingPopoverFooterStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles73();
  const {
    appearance,
    footerLayout
  } = state;
  state.root.className = mergeClasses(teachingPopoverFooterClassNames.root, styles.root, footerLayout === "horizontal" ? styles.rootHorizontal : styles.rootVertical, state.root.className);
  if (state.secondary) {
    state.secondary.className = mergeClasses(teachingPopoverFooterClassNames.secondary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandSecondary : void 0, state.secondary.className);
  }
  state.primary.className = mergeClasses(teachingPopoverFooterClassNames.primary, footerLayout === "horizontal" ? styles.buttonRootHorizontal : styles.buttonRootVertical, appearance === "brand" ? styles.brandPrimary : void 0, state.primary.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverFooter/TeachingPopoverFooter.js
var TeachingPopoverFooter = React554.forwardRef((props, ref) => {
  const state = useTeachingPopoverFooter_unstable(props, ref);
  useTeachingPopoverFooterStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverFooterStyles_unstable")(state);
  return renderTeachingPopoverFooter_unstable(state);
});
TeachingPopoverFooter.displayName = "TeachingPopoverFooter";

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/TeachingPopoverCarouselPageCount.js
var React556 = __toESM(require_react());

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCount.js
var React555 = __toESM(require_react());
var useTeachingPopoverCarouselPageCount_unstable = (props, ref) => {
  const values = useCarouselValues_unstable((snapshot) => snapshot);
  var _useCarouselContext_unstable;
  const selectedValue = (_useCarouselContext_unstable = useCarouselContext_unstable((c) => c.value)) !== null && _useCarouselContext_unstable !== void 0 ? _useCarouselContext_unstable : values[0];
  const currentIndex = values.indexOf(selectedValue);
  const totalPages = values.length;
  return {
    currentIndex,
    totalPages,
    renderPageCount: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      children: props.children(currentIndex + 1, totalPages)
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/renderTeachingPopoverCarouselPageCount.js
var renderTeachingPopoverCarouselPageCount_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/useTeachingPopoverCarouselPageCountStyles.styles.js
var teachingPopoverCarouselPageCountClassNames = {
  root: "fui-TeachingPopoverCarouselPageCount"
};
var useStyles74 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}"]
});
var useTeachingPopoverCarouselPageCountStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles74();
  state.root.className = mergeClasses(teachingPopoverCarouselPageCountClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-teaching-popover/lib/components/TeachingPopoverCarouselPageCount/TeachingPopoverCarouselPageCount.js
var TeachingPopoverCarouselPageCount = React556.forwardRef((props, ref) => {
  const state = useTeachingPopoverCarouselPageCount_unstable(props, ref);
  useTeachingPopoverCarouselPageCountStyles_unstable(state);
  useCustomStyleHook("useTeachingPopoverCarouselPageCountStyles_unstable")(state);
  return renderTeachingPopoverCarouselPageCount_unstable(state);
});
TeachingPopoverCarouselPageCount.displayName = "TeachingPopoverCarouselPageCount";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/TagPicker.js
var React561 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPicker.js
var React557 = __toESM(require_react());
var fallbackPositions = [
  "above",
  "after",
  "after-top",
  "before",
  "before-top"
];
var useTagPicker_unstable = (props) => {
  const popoverId = useId2("picker-listbox");
  const triggerInnerRef = React557.useRef(null);
  const secondaryActionRef = React557.useRef(null);
  const tagPickerGroupRef = React557.useRef(null);
  const { positioning, size: size3 = "medium", inline: inline2 = false, noPopover = false } = props;
  const { targetRef, containerRef } = usePositioning({
    position: "below",
    align: "start",
    offset: {
      crossAxis: 0,
      mainAxis: 2
    },
    fallbackPositions,
    matchTargetSize: "width",
    ...resolvePositioningShorthand(positioning)
  });
  const { controller: activeDescendantController, activeParentRef, listboxRef } = useActiveDescendant({
    matchOption: (el) => el.classList.contains(optionClassNames.root)
  });
  const comboboxState = useComboboxBaseState({
    ...props,
    onOptionSelect: useEventCallback((event, data) => {
      var _props_onOptionSelect;
      return (_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 ? void 0 : _props_onOptionSelect.call(props, event, {
        selectedOptions: data.selectedOptions,
        value: data.optionValue,
        type: event.type,
        event
      });
    }),
    onOpenChange: useEventCallback((event, data) => {
      var _props_onOpenChange;
      return (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 ? void 0 : _props_onOpenChange.call(props, event, {
        ...data,
        type: event.type,
        event
      });
    }),
    activeDescendantController,
    editable: true,
    multiselect: true,
    size: "medium"
  });
  const { trigger, popover } = childrenToTriggerAndPopover(props.children, noPopover);
  return {
    activeDescendantController,
    components: {},
    trigger,
    popover: comboboxState.open || comboboxState.hasFocus ? popover : void 0,
    popoverId,
    noPopover,
    disabled: comboboxState.disabled,
    triggerRef: useMergedRefs(triggerInnerRef, activeParentRef),
    popoverRef: useMergedRefs(listboxRef, containerRef),
    secondaryActionRef,
    tagPickerGroupRef,
    targetRef,
    size: size3,
    inline: inline2,
    open: comboboxState.open,
    mountNode: comboboxState.mountNode,
    onOptionClick: useEventCallback((event) => {
      comboboxState.onOptionClick(event);
      comboboxState.setOpen(event, false);
    }),
    appearance: comboboxState.appearance,
    clearSelection: comboboxState.clearSelection,
    getOptionById: comboboxState.getOptionById,
    getOptionsMatchingValue: comboboxState.getOptionsMatchingValue,
    registerOption: comboboxState.registerOption,
    selectedOptions: comboboxState.selectedOptions,
    selectOption: useEventCallback((event, data) => {
      if (comboboxState.selectedOptions.includes(data.value) && !elementContains(tagPickerGroupRef.current, event.target)) {
        var _props_onOptionSelect;
        (_props_onOptionSelect = props.onOptionSelect) === null || _props_onOptionSelect === void 0 ? void 0 : _props_onOptionSelect.call(props, event, {
          selectedOptions: comboboxState.selectedOptions,
          value: data.value,
          type: event.type,
          event
        });
        return;
      }
      comboboxState.selectOption(event, data);
    }),
    setHasFocus: comboboxState.setHasFocus,
    setOpen: comboboxState.setOpen,
    setValue: comboboxState.setValue,
    value: comboboxState.value
  };
};
var childrenToTriggerAndPopover = (children, noPopover) => {
  const childrenArray = React557.Children.toArray(children);
  if (true) {
    if (childrenArray.length === 0) {
      console.warn("TagPicker must contain at least one child");
    }
    if (childrenArray.length > 2) {
      console.warn("TagPicker must contain at most two children");
    }
  }
  if (noPopover) {
    return {
      trigger: childrenArray[0]
    };
  }
  let trigger = void 0;
  let popover = void 0;
  if (childrenArray.length === 2) {
    trigger = childrenArray[0];
    popover = childrenArray[1];
  } else if (childrenArray.length === 1) {
    popover = childrenArray[0];
  }
  return {
    trigger,
    popover
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/renderTagPicker.js
var React559 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/contexts/TagPickerContext.js
var React558 = __toESM(require_react());
var tagPickerContextDefaultValue = {
  triggerRef: React558.createRef(),
  popoverRef: React558.createRef(),
  targetRef: React558.createRef(),
  tagPickerGroupRef: React558.createRef(),
  secondaryActionRef: React558.createRef(),
  open: false,
  clearSelection: () => null,
  getOptionById: () => void 0,
  selectedOptions: [],
  selectOption: () => null,
  setHasFocus: () => null,
  setOpen: () => null,
  setValue: () => null,
  value: void 0,
  popoverId: "",
  size: "medium",
  appearance: "outline",
  disabled: false
};
var TagPickerContext = createContext13(void 0);
var TagPickerContextProvider = TagPickerContext.Provider;
var useTagPickerContext_unstable = (selector) => useContextSelector(TagPickerContext, (ctx = tagPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/renderTagPicker.js
var renderTagPicker_unstable = (state, contexts) => {
  assertSlots(state);
  return React559.createElement(TagPickerContextProvider, {
    value: contexts.picker
  }, React559.createElement(ActiveDescendantContextProvider, {
    value: contexts.activeDescendant
  }, React559.createElement(ListboxProvider, {
    value: contexts.listbox
  }, state.trigger, state.popover && (state.inline ? state.popover : React559.createElement(Portal, {
    mountNode: state.mountNode
  }, state.popover)))));
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/useTagPickerContextValues.js
var React560 = __toESM(require_react());
function useTagPickerContextValues(state) {
  const { onOptionClick, registerOption, selectedOptions, selectOption, value, triggerRef, secondaryActionRef, tagPickerGroupRef, targetRef, size: size3, setValue, setOpen, setHasFocus, popoverRef, appearance, clearSelection, getOptionById, getOptionsMatchingValue, open, popoverId, disabled, noPopover } = state;
  return {
    activeDescendant: React560.useMemo(() => ({
      controller: state.activeDescendantController
    }), [
      state.activeDescendantController
    ]),
    listbox: {
      onOptionClick,
      registerOption,
      getOptionById,
      getOptionsMatchingValue,
      selectedOptions,
      selectOption,
      focusVisible: false,
      setActiveOption: noop12
    },
    picker: {
      value,
      triggerRef,
      targetRef,
      secondaryActionRef,
      tagPickerGroupRef,
      size: size3,
      setValue,
      setOpen,
      setHasFocus,
      selectOption,
      popoverRef,
      selectedOptions,
      appearance,
      clearSelection,
      getOptionById,
      open,
      popoverId,
      disabled,
      noPopover
    }
  };
}
var noop12 = () => {
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPicker/TagPicker.js
var TagPicker = React561.memo((props) => {
  const state = useTagPicker_unstable(props);
  const contextValues = useTagPickerContextValues(state);
  return renderTagPicker_unstable(state, contextValues);
});
TagPicker.displayName = "TagPicker";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/TagPickerInput.js
var React563 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInput.js
var React562 = __toESM(require_react());
var ReactDOM4 = __toESM(require_react_dom());

// node_modules/@fluentui/react-tag-picker/lib/utils/tokens.js
var tagPickerInputCSSRules = {
  width: "--fluent-TagPickerInput__width"
};
var tagPickerInputTokens = {
  width: `var(${tagPickerInputCSSRules.width}, 0)`
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInput.js
var useTagPickerInput_unstable = (propsArg, ref) => {
  const props = useFieldControlProps_unstable(propsArg, {
    supportsLabelFor: true,
    supportsRequired: true,
    supportsSize: true
  });
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const contextDisabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const selectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions);
  const setValue = useTagPickerContext_unstable((ctx) => ctx.setValue);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
  const clearSelection = useTagPickerContext_unstable((ctx) => ctx.clearSelection);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.noPopover ? void 0 : ctx.popoverId);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
  const contextValue = useTagPickerContext_unstable((ctx) => ctx.value);
  useIsomorphicLayoutEffect(() => {
    if (!triggerRef.current) {
      return;
    }
    setTagPickerInputStretchStyle(triggerRef.current);
  }, [
    selectedOptions,
    triggerRef
  ]);
  useIsomorphicLayoutEffect(() => {
    if (triggerRef.current) {
      const input = triggerRef.current;
      const cb = () => setTagPickerInputStretchStyle(input);
      input.addEventListener("input", cb);
      return () => {
        input.removeEventListener("input", cb);
      };
    }
  }, [
    triggerRef
  ]);
  const { value = contextValue, disabled = contextDisabled } = props;
  const { findLastFocusable } = useFocusFinders();
  const isTypingRef = React562.useRef(false);
  const root = useInputTriggerSlot({
    type: "text",
    value: value !== null && value !== void 0 ? value : "",
    "aria-controls": open ? popoverId : void 0,
    disabled,
    ...getIntrinsicElementProps("input", props),
    onKeyDown: useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if ((event.key === ArrowLeft || event.key === Backspace) && event.currentTarget.selectionStart === 0 && event.currentTarget.selectionEnd === 0 && tagPickerGroupRef.current) {
        var _findLastFocusable;
        (_findLastFocusable = findLastFocusable(tagPickerGroupRef.current)) === null || _findLastFocusable === void 0 ? void 0 : _findLastFocusable.focus();
      } else if (event.key === Space) {
        if (open && !isTypingRef.current) {
          setOpen(event, false);
        }
      } else if (event.key === Enter) {
        if (open) {
          ReactDOM4.unstable_batchedUpdates(() => {
            setValue(void 0);
            setOpen(event, false);
          });
        } else {
          setOpen(event, true);
        }
      }
      isTypingRef.current = event.key.length === 1 && event.code !== Space && !event.altKey && !event.ctrlKey && !event.metaKey;
    })
  }, useMergedRefs(triggerRef, ref), {
    activeDescendantController,
    freeform: false,
    state: {
      clearSelection,
      getOptionById,
      open,
      selectedOptions,
      selectOption,
      setHasFocus,
      setOpen,
      setValue,
      multiselect: true,
      value: props.value
    }
  });
  const state = {
    components: {
      root: "input"
    },
    root,
    disabled,
    size: size3
  };
  return state;
};
var setTagPickerInputStretchStyle = (input) => {
  input.style.removeProperty(tagPickerInputCSSRules.width);
  if (input.scrollWidth > input.offsetWidth + 1) {
    input.style.setProperty(tagPickerInputCSSRules.width, "100%");
  } else {
    input.style.removeProperty(tagPickerInputCSSRules.width);
  }
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/renderTagPickerInput.js
var renderTagPickerInput_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/useTagPickerInputStyles.styles.js
var tagPickerInputClassNames = {
  root: "fui-TagPickerInput"
};
var useBaseStyle = __resetStyles("r1hdk6fw", null, [".r1hdk6fw{background-color:var(--colorTransparentBackground);color:var(--colorNeutralForeground1);font-family:var(--fontFamilyBase);box-sizing:border-box;border:none;min-width:24px;max-width:100%;width:var(--fluent-TagPickerInput__width, 0);flex-grow:1;}", ".r1hdk6fw:focus{outline-style:none;}", ".r1hdk6fw::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".r1hdk6fw::after{visibility:hidden;white-space:pre-wrap;}"]);
var useStyles75 = __styles2({
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fa2pw7h"
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "ft37c3"
  },
  "extra-large": {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f3abo53"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    De3pzq: "f1c21dwh",
    Bceei9c: "fdrzuqr",
    yvdlaj: "fahhnxm"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", {
    p: -1
  }], [".ft37c3{padding:var(--spacingVerticalMNudge) 0 var(--spacingVerticalMNudge) 0;}", {
    p: -1
  }], [".f3abo53{padding:var(--spacingVerticalM) 0 var(--spacingVerticalM) 0;}", {
    p: -1
  }], ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
});
var useTagPickerInputStyles_unstable = (state) => {
  "use no memo";
  const baseStyle = useBaseStyle();
  const styles = useStyles75();
  state.root.className = mergeClasses(tagPickerInputClassNames.root, baseStyle, styles[state.size], state.disabled && styles.disabled, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerInput/TagPickerInput.js
var TagPickerInput = React563.forwardRef((props, ref) => {
  const state = useTagPickerInput_unstable(props, ref);
  useTagPickerInputStyles_unstable(state);
  useCustomStyleHook("useTagPickerInputStyles_unstable")(state);
  return renderTagPickerInput_unstable(state);
});
TagPickerInput.displayName = "TagPickerInput";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/TagPickerList.js
var React565 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerList.js
var React564 = __toESM(require_react());
var useTagPickerList_unstable = (props, ref) => {
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const popoverRef = useTagPickerContext_unstable((ctx) => ctx.popoverRef);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  return {
    open,
    components: {
      root: Listbox
    },
    root: slot_exports.always({
      ...useListboxSlot(props, useMergedRefs(popoverRef, ref), {
        state: {
          multiselect: true
        },
        triggerRef,
        defaultProps: {
          id: popoverId
        }
      }),
      role: "listbox"
    }, {
      elementType: Listbox
    })
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/renderTagPickerList.js
var renderTagPickerList_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/useTagPickerListStyles.styles.js
var tagPickerListClassNames = {
  root: "fui-TagPickerList"
};
var useStyles76 = __styles2({
  root: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  collapsed: {
    mc9l5x: "fjseox"
  }
}, {
  d: [".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".f1ewtqcl{box-sizing:border-box;}", ".fjseox{display:none;}"]
});
var useTagPickerListStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles76();
  state.root.className = mergeClasses(tagPickerListClassNames.root, styles.root, !state.open && styles.collapsed, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerList/TagPickerList.js
var TagPickerList = React565.forwardRef((props, ref) => {
  const state = useTagPickerList_unstable(props, ref);
  useTagPickerListStyles_unstable(state);
  useCustomStyleHook("useTagPickerListStyles_unstable")(state);
  return renderTagPickerList_unstable(state);
});
TagPickerList.displayName = "TagPickerList";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/TagPickerButton.js
var React567 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButton.js
var React566 = __toESM(require_react());
var useTagPickerButton_unstable = (props, ref) => {
  const { controller: activeDescendantController } = useActiveDescendantContext();
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const value = useTagPickerContext_unstable((ctx) => ctx.value);
  const hasSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const getOptionById = useTagPickerContext_unstable((ctx) => ctx.getOptionById);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const setHasFocus = useTagPickerContext_unstable((ctx) => ctx.setHasFocus);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const root = useButtonTriggerSlot(props, triggerRef, {
    activeDescendantController,
    defaultProps: {
      type: "button",
      tabIndex: 0,
      children: value || // @ts-expect-error - FIXME: TS2339: Property 'placeholder' does not exist on type 'TagPickerButtonProps'
      props.placeholder,
      "aria-controls": open ? popoverId : void 0,
      ref
    },
    state: {
      getOptionById,
      open,
      selectOption,
      setHasFocus,
      setOpen,
      multiselect: true
    }
  });
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const state = {
    components: {
      root: "button"
    },
    root,
    size: size3,
    hasSelectedOption
  };
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/renderTagPickerButton.js
var renderTagPickerButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/useTagPickerButtonStyles.styles.js
var tagPickerButtonClassNames = {
  root: "fui-TagPickerButton"
};
var useStyles77 = __styles2({
  button: {
    Bt984gj: "f122n59",
    sshi5w: "f1nxs5xn",
    De3pzq: "f1c21dwh",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    B7ck84d: "f1ewtqcl",
    sj55zd: "f19n0e5",
    i8kkvl: "f14mj54c",
    Bceei9c: "f1k6fduh",
    Bahqtrf: "fk6fouc",
    fsow6f: ["f1o700av", "fes3tcz"],
    Bh6795r: "fqerorx",
    Brovlpu: "ftqa4ok"
  },
  placeholder: {
    sj55zd: "fxc4j92"
  },
  medium: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "figsok6",
    Bg96gwp: "fwrc4pm",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fye6m5k", "f3cq2dl"]
  },
  large: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "figsok6",
    Bg96gwp: "f1i3iumi",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f14ev680", "f58uxzw"]
  },
  "extra-large": {
    i8kkvl: "f1rjii52",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "figsok6",
    Bg96gwp: "faaz57k",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f139mn7i", "f1v3q0m"]
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "flmw63s",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "fqhmt4z",
    B50zh58: ["f4ruux4", "f1assf6x"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fs2rfia"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  },
  disabledText: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  },
  hidden: {
    mc9l5x: "fjseox"
  },
  visuallyHidden: {
    Bh84pgu: "f1ekcaio",
    Bqenvij: "f1mpe4l3",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1jlpb2r",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    a9b677: "frkrog8",
    qhf8xq: "f1euv43f"
  }
}, {
  d: [".f122n59{align-items:center;}", ".f1nxs5xn{min-height:32px;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f3bhgqh{border:none;}", {
    p: -2
  }], ".f1ewtqcl{box-sizing:border-box;}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1k6fduh{cursor:pointer;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fqerorx{flex-grow:1;}", ".fxc4j92{color:var(--colorNeutralForeground4);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", [".fye6m5k{padding:3px var(--spacingHorizontalSNudge) 3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f3cq2dl{padding:3px calc(var(--spacingHorizontalSNudge) + var(--spacingHorizontalXXS)) 3px var(--spacingHorizontalSNudge);}", {
    p: -1
  }], ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", [".f14ev680{padding:5px var(--spacingHorizontalMNudge) 5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS));}", {
    p: -1
  }], [".f58uxzw{padding:5px calc(var(--spacingHorizontalMNudge) + var(--spacingHorizontalXXS)) 5px var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f139mn7i{padding:7px var(--spacingHorizontalM) 7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge));}", {
    p: -1
  }], [".f1v3q0m{padding:7px calc(var(--spacingHorizontalM) + var(--spacingHorizontalSNudge)) 7px var(--spacingHorizontalM);}", {
    p: -1
  }], ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".fs2rfia{border:var(--strokeWidthThin) solid transparent;}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fjseox{display:none;}", ".f1ekcaio{clip:rect(0px, 0px, 0px, 0px);}", ".f1mpe4l3{height:1px;}", [".f1jlpb2r{margin:-1px;}", {
    p: -1
  }], [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], ".frkrog8{width:1px;}", ".f1euv43f{position:absolute;}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".flmw63s:hover{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".fqhmt4z:active{border-bottom-color:var(--colorNeutralStrokeAccessible);}"],
  m: [["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useTagPickerButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles77();
  state.root.className = mergeClasses(tagPickerButtonClassNames.root, styles.button, styles[state.size], state.hasSelectedOption && styles.visuallyHidden, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerButton/TagPickerButton.js
var TagPickerButton = React567.forwardRef((props, ref) => {
  const state = useTagPickerButton_unstable(props, ref);
  useTagPickerButtonStyles_unstable(state);
  useCustomStyleHook("useTagPickerButtonStyles_unstable")(state);
  return renderTagPickerButton_unstable(state);
});
TagPickerButton.displayName = "TagPickerButton";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/TagPickerControl.js
var React571 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControl.js
var React570 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/utils/useResizeObserverRef.js
var React568 = __toESM(require_react());
var useResizeObserverRef = (callback) => {
  const { targetDocument } = useFluent();
  const [observer] = React568.useState(() => {
    var _targetDocument_defaultView;
    const ResizeObserverConstructor = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.ResizeObserver;
    if (ResizeObserverConstructor) {
      return new ResizeObserverConstructor(callback);
    }
  });
  const ref = React568.useCallback((element) => {
    if (element) {
      observer === null || observer === void 0 ? void 0 : observer.observe(element);
    } else {
      observer === null || observer === void 0 ? void 0 : observer.disconnect();
    }
  }, [
    observer
  ]);
  return ref;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControlStyles.styles.js
var tagPickerControlClassNames = {
  root: "fui-TagPickerControl",
  expandIcon: "fui-TagPickerControl__expandIcon",
  secondaryAction: "fui-TagPickerControl__secondaryAction",
  aside: "fui-TagPickerControl__aside"
};
var tagPickerControlAsideWidthToken = "--fui-TagPickerControl-aside-width";
var useStyles78 = __styles2({
  root: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    z189sj: ["f1d8q41i", "f8lqu5g"],
    uwmqm3: ["f1uw59to", "fw5db7e"],
    Bt984gj: "f122n59",
    i8kkvl: "f14mj54c",
    B7ck84d: "f1ewtqcl",
    mc9l5x: "f22iagw",
    Bf4jedk: "f1exfvgq",
    qhf8xq: "f10pi13n",
    Eh141a: "fni485r",
    Bbr2w1p: "f14a1fxs",
    Bduesf4: "f3e99gv",
    Bpq79vn: "fhljsf7",
    li1rpt: "f1gw3sf2",
    Bsft5z2: "f13zj6fq",
    E3zdtr: "f1mdlcz9",
    Eqx8gd: ["f1a7op3", "f1cjjd47"],
    By385i5: "f1gboi2j",
    B1piin3: ["f1cjjd47", "f1a7op3"],
    Dlnsje: "f145g4dw",
    d9w3h3: ["f1kp91vd", "f1ibwz09"],
    B3778ie: ["f1ibwz09", "f1kp91vd"],
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Bjuhk93: "f1mnjydx",
    Gjdm7m: "f13evtba",
    b1kco5: "f1yk9hq",
    Ba2ppi3: "fhwpy7i",
    F2fol1: "f14ee0xe",
    lck23g: "f1xhbsuh",
    wi16st: "fsrmcvb",
    ywj3b2: "f1t3k7v9",
    umuwi5: "fjw5xc1",
    Blcqepd: "f1xdyd5c",
    nplu4u: "fatpbeo",
    Bioka5o: "fb7uyps",
    Bnupc0a: "fx04xgm",
    bing71: "f1c7in40",
    Bercvud: "f1ibeo51"
  },
  listbox: {
    E5pizo: "f1hg901r",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bxyxcbc: "fmmk62d",
    B7ck84d: "f1ewtqcl"
  },
  listboxCollapsed: {
    mc9l5x: "fjseox"
  },
  medium: {
    sshi5w: "f1nxs5xn"
  },
  large: {
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    sshi5w: "f5pgtk9"
  },
  outline: {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: "f1c1zstj",
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fhz96rm"
  },
  outlineInteractive: {
    Bgoe8wy: "fvcxoqz",
    Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
    oetu4i: "f1l4zc64",
    gg5e9n: ["f1m52nbi", "f1ub3y4t"],
    B6oc9vd: "fvs00aa",
    ak43y8: ["f1assf6x", "f4ruux4"],
    wmxk5l: "f1z0osm6",
    B50zh58: ["f4ruux4", "f1assf6x"],
    Bvq3b66: "f1b473iu",
    Brahy3i: ["f381qr8", "ft4skwv"],
    zoxjo1: "f1qzcrsd",
    an54nd: ["ft4skwv", "f381qr8"]
  },
  underline: {
    De3pzq: "f1c21dwh",
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    Bgfg5da: "f9ez7ne",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fokr779"
  },
  "filled-lighter": {
    De3pzq: "fxugw4r",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  "filled-darker": {
    De3pzq: "f16xq7d1",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f88035w"
  },
  invalid: {
    tvckwq: "fs4k3qj",
    gk2u95: ["fcee079", "fmyw78r"],
    hhx65j: "f1fgmyf4",
    Bxowmz0: ["fmyw78r", "fcee079"]
  },
  invalidUnderline: {
    hhx65j: "f1fgmyf4"
  },
  disabled: {
    Bceei9c: "fdrzuqr",
    De3pzq: "f1c21dwh",
    g2u3we: "f1jj8ep1",
    h3c5rm: ["f15xbau", "fy0fskl"],
    B9xav0g: "f4ikngz",
    zhjwy3: ["fy0fskl", "f15xbau"],
    Bcq6wej: "f9dbb4x",
    Jcjdmf: ["f3qs60o", "f5u9ap2"],
    sc4o1m: "fwd1oij",
    Bosien3: ["f5u9ap2", "f3qs60o"]
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1d8q41i{padding-right:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}", ".f8lqu5g{padding-left:calc(var(--spacingHorizontalM) + var(--fui-TagPickerControl-aside-width, 0px));}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".f122n59{align-items:center;}", ".f14mj54c{column-gap:var(--spacingHorizontalXXS);}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1exfvgq{min-width:250px;}", ".f10pi13n{position:relative;}", ".fni485r{flex-wrap:wrap;}", ".f1gw3sf2::after{box-sizing:border-box;}", '.f13zj6fq::after{content:"";}', ".f1mdlcz9::after{position:absolute;}", ".f1a7op3::after{left:-1px;}", ".f1cjjd47::after{right:-1px;}", ".f1gboi2j::after{bottom:-1px;}", ".f145g4dw::after{height:max(2px, var(--borderRadiusMedium));}", ".f1kp91vd::after{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1ibwz09::after{border-bottom-right-radius:var(--borderRadiusMedium);}", [".f1mnjydx::after{border-bottom:var(--strokeWidthThick) solid var(--colorCompoundBrandStroke);}", {
    p: -1
  }], ".f13evtba::after{clip-path:inset(calc(100% - 2px) 0 0 0);}", ".f1yk9hq::after{transform:scaleX(0);}", ".fhwpy7i::after{transition-property:transform;}", ".f14ee0xe::after{transition-duration:var(--durationUltraFast);}", ".f1xhbsuh::after{transition-delay:var(--curveAccelerateMid);}", ".f1hg901r{box-shadow:var(--shadow16);}", [".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".fmmk62d{max-height:80vh;}", ".fjseox{display:none;}", ".f1nxs5xn{min-height:32px;}", ".f1w5jphr{min-height:40px;}", ".f5pgtk9{min-height:44px;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", [".fhz96rm{border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);}", {
    p: -2
  }], ".f1c1zstj{border-bottom-color:var(--colorNeutralStrokeAccessible);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", [".f9ez7ne{border-bottom:var(--strokeWidthThin) solid var(--colorNeutralStrokeAccessible);}", {
    p: -1
  }], [".fokr779{border-radius:0;}", {
    p: -1
  }], [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", [".f88035w{border:var(--strokeWidthThin) solid var(--colorTransparentStroke);}", {
    p: -2
  }], ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}"],
  w: [".f14a1fxs:focus-within{outline-width:2px;}", ".f3e99gv:focus-within{outline-style:solid;}", ".fhljsf7:focus-within{outline-color:transparent;}", ".fjw5xc1:focus-within::after{transform:scaleX(1);}", ".f1xdyd5c:focus-within::after{transition-property:transform;}", ".fatpbeo:focus-within::after{transition-duration:var(--durationNormal);}", ".fb7uyps:focus-within::after{transition-delay:var(--curveDecelerateMid);}", ".f1ibeo51:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".f1b473iu:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f381qr8:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".ft4skwv:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1qzcrsd:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
  m: [["@media screen and (prefers-reduced-motion: reduce){.fsrmcvb::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1t3k7v9::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.fx04xgm:focus-within::after{transition-duration:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media screen and (prefers-reduced-motion: reduce){.f1c7in40:focus-within::after{transition-delay:0.01ms;}}", {
    m: "screen and (prefers-reduced-motion: reduce)"
  }], ["@media (forced-colors: active){.f9dbb4x{border-top-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f3qs60o{border-right-color:GrayText;}.f5u9ap2{border-left-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fwd1oij{border-bottom-color:GrayText;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}"],
  a: [".fvs00aa:active{border-top-color:var(--colorNeutralStroke1Pressed);}", ".f1assf6x:active{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f4ruux4:active{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1z0osm6:active{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"]
});
var useAsideStyles = __styles2({
  root: {
    mc9l5x: "f22iagw",
    qhf8xq: "f1euv43f",
    Bhzewxz: "f15twtuk",
    j35jbq: ["f8b87gs", "fedtrts"],
    Bqenvij: "f1l02sjl",
    Bceei9c: "f113hnb5"
  },
  medium: {
    sshi5w: "f1nxs5xn"
  },
  large: {
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    sshi5w: "f5pgtk9"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".f1l02sjl{height:100%;}", ".f113hnb5{cursor:text;}", ".f1nxs5xn{min-height:32px;}", ".f1w5jphr{min-height:40px;}", ".f5pgtk9{min-height:44px;}"]
});
var useIconStyles11 = __styles2({
  icon: {
    B7ck84d: "f1ewtqcl",
    sj55zd: "fxkbij4",
    Bceei9c: "f1k6fduh",
    mc9l5x: "f22iagw",
    Brf1p80: "f4d9j23",
    Bt984gj: "f122n59",
    qb2dma: "fjgzulp",
    Be2twd7: "f1pp30po",
    Bo70h7d: "fvc9v3g"
  },
  medium: {
    Be2twd7: "f4ybsrx",
    Frg6f3: ["f1h9en5y", "f1xk557c"],
    sshi5w: "f1nxs5xn"
  },
  large: {
    Be2twd7: "fe5j1ua",
    Frg6f3: ["f1h9en5y", "f1xk557c"],
    sshi5w: "f1w5jphr"
  },
  "extra-large": {
    Be2twd7: "f1rt2boy",
    Frg6f3: ["f1t5qyk5", "f1ikr372"],
    sshi5w: "f5pgtk9"
  },
  disabled: {
    sj55zd: "f1s2aq7o",
    Bceei9c: "fdrzuqr"
  }
}, {
  d: [".f1ewtqcl{box-sizing:border-box;}", ".fxkbij4{color:var(--colorNeutralStrokeAccessible);}", ".f1k6fduh{cursor:pointer;}", ".f22iagw{display:flex;}", ".f4d9j23{justify-content:center;}", ".f122n59{align-items:center;}", ".fjgzulp{align-self:flex-start;}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".fvc9v3g svg{display:block;}", ".f4ybsrx{font-size:16px;}", ".f1h9en5y{margin-left:var(--spacingHorizontalXXS);}", ".f1xk557c{margin-right:var(--spacingHorizontalXXS);}", ".f1nxs5xn{min-height:32px;}", ".fe5j1ua{font-size:20px;}", ".f1w5jphr{min-height:40px;}", ".f1rt2boy{font-size:24px;}", ".f1t5qyk5{margin-left:var(--spacingHorizontalSNudge);}", ".f1ikr372{margin-right:var(--spacingHorizontalSNudge);}", ".f5pgtk9{min-height:44px;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}"]
});
var useSecondaryActionStyles = __styles2({
  root: {
    mc9l5x: "f22iagw"
  }
}, {
  d: [".f22iagw{display:flex;}"]
});
var useTagPickerControlStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles78();
  const iconStyles = useIconStyles11();
  const asideStyles = useAsideStyles();
  const secondaryActionStyles = useSecondaryActionStyles();
  state.root.className = mergeClasses(tagPickerControlClassNames.root, styles.root, styles[state.size], styles[state.appearance], !state.disabled && state.appearance === "outline" && styles.outlineInteractive, state.invalid && state.appearance !== "underline" && styles.invalid, state.invalid && state.appearance === "underline" && styles.invalidUnderline, state.disabled && styles.disabled, state.root.className);
  if (state.aside) {
    state.aside.className = mergeClasses(tagPickerControlClassNames.aside, asideStyles.root, asideStyles[state.size], state.aside.className);
  }
  if (state.expandIcon) {
    state.expandIcon.className = mergeClasses(tagPickerControlClassNames.expandIcon, iconStyles.icon, iconStyles[state.size], state.disabled && iconStyles.disabled, state.expandIcon.className);
  }
  if (state.secondaryAction) {
    state.secondaryAction.className = mergeClasses(tagPickerControlClassNames.secondaryAction, secondaryActionStyles.root, state.secondaryAction.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/utils/useExpandLabel.js
var React569 = __toESM(require_react());
function useExpandLabel(options) {
  const { tagPickerId, state } = options;
  const { targetDocument } = useFluent();
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const expandIconRef = React569.useRef(null);
  const hasExpandIcon = !!state.expandIcon;
  const { "aria-label": expandIconAriaLabel, "aria-labelledby": expandIconAriaLabelledby, id: expandIconId } = state.expandIcon || {};
  const getExpandLabel = React569.useCallback((ariaLabel, ariaLabelledBy) => {
    let expandAriaLabel = void 0;
    let expandAriaLabelledBy = void 0;
    let expandId = void 0;
    if (hasExpandIcon) {
      const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
      const defaultOpenString = "Open";
      if (!hasExpandLabel) {
        if (ariaLabelledBy) {
          expandAriaLabel = defaultOpenString;
          expandId = expandIconId !== null && expandIconId !== void 0 ? expandIconId : `${tagPickerId}-chevron`;
          expandAriaLabelledBy = `${expandId} ${ariaLabelledBy}`;
        } else if (ariaLabel) {
          expandAriaLabel = `${defaultOpenString} ${ariaLabel}`;
        } else {
          expandAriaLabel = defaultOpenString;
        }
      }
    }
    return {
      expandAriaLabel,
      expandAriaLabelledBy,
      expandId
    };
  }, [
    expandIconAriaLabel,
    expandIconAriaLabelledby,
    expandIconId,
    hasExpandIcon,
    tagPickerId
  ]);
  const setExpandLabel = React569.useCallback(() => {
    var _triggerRef_current, _triggerRef_current1;
    const inputAriaLabel = (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.getAttribute("aria-label");
    const inputAriaLabelledBy = (_triggerRef_current1 = triggerRef.current) === null || _triggerRef_current1 === void 0 ? void 0 : _triggerRef_current1.getAttribute("aria-labelledby");
    const { expandAriaLabel, expandAriaLabelledBy, expandId } = getExpandLabel(inputAriaLabel, inputAriaLabelledBy);
    if (expandAriaLabelledBy) {
      var _expandIconRef_current;
      (_expandIconRef_current = expandIconRef.current) === null || _expandIconRef_current === void 0 ? void 0 : _expandIconRef_current.setAttribute("aria-labelledby", expandAriaLabelledBy);
    }
    if (expandAriaLabel) {
      var _expandIconRef_current1;
      (_expandIconRef_current1 = expandIconRef.current) === null || _expandIconRef_current1 === void 0 ? void 0 : _expandIconRef_current1.setAttribute("aria-label", expandAriaLabel);
    }
    if (expandId) {
      var _expandIconRef_current2;
      (_expandIconRef_current2 = expandIconRef.current) === null || _expandIconRef_current2 === void 0 ? void 0 : _expandIconRef_current2.setAttribute("id", expandId);
    }
  }, [
    getExpandLabel,
    triggerRef
  ]);
  React569.useEffect(() => {
    const hasExpandLabel = expandIconAriaLabel || expandIconAriaLabelledby;
    if (!(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || !triggerRef.current || !hasExpandIcon || hasExpandLabel) {
      return;
    }
    const win = targetDocument.defaultView;
    setExpandLabel();
    const observer = new win.MutationObserver(setExpandLabel);
    observer.observe(triggerRef.current, {
      attributes: true,
      attributeFilter: [
        "aria-label",
        "aria-labelledby"
      ]
    });
    return () => observer.disconnect();
  }, [
    getExpandLabel,
    setExpandLabel,
    expandIconAriaLabel,
    expandIconAriaLabelledby,
    hasExpandIcon,
    tagPickerId,
    triggerRef,
    targetDocument
  ]);
  return expandIconRef;
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/useTagPickerControl.js
var useTagPickerControl_unstable = (props, ref) => {
  var _useFieldContext_unstable;
  const targetRef = useTagPickerContext_unstable((ctx) => ctx.targetRef);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const open = useTagPickerContext_unstable((ctx) => ctx.open);
  const popoverId = useTagPickerContext_unstable((ctx) => ctx.popoverId);
  const setOpen = useTagPickerContext_unstable((ctx) => ctx.setOpen);
  const secondaryInnerActionRef = useTagPickerContext_unstable((ctx) => ctx.secondaryActionRef);
  const size3 = useTagPickerContext_unstable((ctx) => ctx.size);
  const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
  const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const invalid = ((_useFieldContext_unstable = useFieldContext_unstable()) === null || _useFieldContext_unstable === void 0 ? void 0 : _useFieldContext_unstable.validationState) === "error";
  const noPopover = useTagPickerContext_unstable((ctx) => {
    var _ctx_noPopover;
    return (_ctx_noPopover = ctx.noPopover) !== null && _ctx_noPopover !== void 0 ? _ctx_noPopover : false;
  });
  const { targetDocument } = useFluent();
  const tagPickerId = useId2("tagPicker-");
  const rafIdRef = React570.useRef(null);
  const innerRef = React570.useRef(null);
  const expandIconRef = React570.useRef(null);
  const asideRef = React570.useRef(null);
  const secondaryAction = slot_exports.optional(props.secondaryAction, {
    elementType: "span"
  });
  const secondaryActionRef = useMergedRefs(secondaryInnerActionRef, secondaryAction === null || secondaryAction === void 0 ? void 0 : secondaryAction.ref);
  if (secondaryAction) {
    secondaryAction.ref = secondaryActionRef;
  }
  const expandIcon = slot_exports.optional(props.expandIcon, {
    renderByDefault: !noPopover,
    defaultProps: {
      "aria-expanded": open,
      "aria-disabled": disabled ? "true" : void 0,
      children: React570.createElement(ChevronDownRegular, null),
      role: "button"
    },
    elementType: "span"
  });
  const expandIconMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);
  if (expandIcon) {
    expandIcon.ref = expandIconMergeRef;
  }
  const observerRef = useResizeObserverRef(([entry]) => {
    const targetWindow = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
    if (targetWindow) {
      rafIdRef.current = targetWindow.requestAnimationFrame(() => {
        var _innerRef_current;
        (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.style.setProperty(tagPickerControlAsideWidthToken, `${entry.contentRect.width}px`);
      });
    }
  });
  const aside = slot_exports.optional(void 0, {
    elementType: "span",
    renderByDefault: Boolean(secondaryAction || expandIcon),
    defaultProps: {
      ref: observerRef
    }
  });
  const mergedAsideRefs = useMergedRefs(asideRef, aside === null || aside === void 0 ? void 0 : aside.ref);
  if (aside) {
    aside.ref = mergedAsideRefs;
  }
  const handleMouseDown = useEventCallback((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (elementContains(expandIconRef.current, event.target) || event.target === innerRef.current || event.target === tagPickerGroupRef.current || event.target === asideRef.current) {
      var _triggerRef_current;
      event.preventDefault();
      setOpen(event, !open);
      (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
    }
  });
  const state = {
    components: {
      root: "div",
      expandIcon: "span",
      secondaryAction: "span",
      aside: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, targetRef, innerRef),
      "aria-owns": open && !noPopover ? popoverId : void 0,
      ...props,
      onMouseDown: handleMouseDown
    }), {
      elementType: "div"
    }),
    aside,
    expandIcon,
    secondaryAction,
    size: size3,
    appearance,
    disabled,
    invalid
  };
  const expandIconLabelRef = useExpandLabel({
    tagPickerId,
    state
  });
  const expandIconLabelMergeRef = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconLabelRef);
  if (state.expandIcon) {
    state.expandIcon.ref = expandIconLabelMergeRef;
  }
  React570.useEffect(() => {
    if (rafIdRef.current && (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
      targetDocument.defaultView.cancelAnimationFrame(rafIdRef.current);
    }
  }, [
    targetDocument
  ]);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/renderTagPickerControl.js
var renderTagPickerControl_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.aside && jsxs(state.aside, {
        children: [
          state.secondaryAction && jsx(state.secondaryAction, {}),
          state.expandIcon && jsx(state.expandIcon, {})
        ]
      })
    ]
  });
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerControl/TagPickerControl.js
var TagPickerControl = React571.forwardRef((props, ref) => {
  const state = useTagPickerControl_unstable(props, ref);
  useTagPickerControlStyles_unstable(state);
  useCustomStyleHook("useTagPickerControlStyles_unstable")(state);
  return renderTagPickerControl_unstable(state);
});
TagPickerControl.displayName = "TagPickerControl";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/TagPickerOption.js
var React573 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOption.js
var React572 = __toESM(require_react());
var useTagPickerOption_unstable = (props, ref) => {
  const optionState = useOption_unstable(props, ref);
  const state = {
    components: {
      // eslint-disable-next-line @typescript-eslint/no-deprecated
      ...optionState.components,
      media: "div",
      secondaryContent: "span"
    },
    media: slot_exports.optional(props.media, {
      elementType: "div"
    }),
    secondaryContent: slot_exports.optional(props.secondaryContent, {
      elementType: "span"
    }),
    root: slot_exports.always({
      ...optionState.root,
      role: "option",
      "aria-checked": props["aria-checked"]
    }, {
      elementType: "div"
    })
  };
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/renderTagPickerOption.js
var renderTagPickerOption_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.media && jsx(state.media, {}),
      state.root.children,
      state.secondaryContent && jsx(state.secondaryContent, {})
    ]
  });
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/useTagPickerOptionStyles.styles.js
var tagPickerOptionClassNames = {
  root: "fui-TagPickerOption",
  media: "fui-TagPickerOption__media",
  secondaryContent: "fui-TagPickerOption__secondaryContent"
};
var useRootBaseStyle2 = __resetStyles("r70qvj9", null, [".r70qvj9{display:flex;align-items:center;}"]);
var useRootStyles26 = __styles2({
  secondaryContent: {
    mc9l5x: "f13qh94s",
    Budl1dq: "fjxzuw"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".fjxzuw{grid-template-columns:auto 1fr;}"]
});
var useSecondaryContentBaseStyle = __resetStyles("r131qrbm", null, [".r131qrbm{grid-column-start:2;grid-row-start:2;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
var useMediaBaseStyle = __resetStyles("rrip69g", null, [".rrip69g{grid-row-start:span 2;}"]);
var useTagPickerOptionStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyle = useRootBaseStyle2();
  const rootStyles = useRootStyles26();
  const secondaryContentBaseStyle = useSecondaryContentBaseStyle();
  const mediaBaseStyle = useMediaBaseStyle();
  state.root.className = mergeClasses(tagPickerOptionClassNames.root, rootBaseStyle, state.secondaryContent && rootStyles.secondaryContent, state.root.className);
  useOptionStyles_unstable({
    ...state,
    active: false,
    disabled: false,
    focusVisible: false,
    checkIcon: void 0,
    selected: false
  });
  if (state.media) {
    state.media.className = mergeClasses(tagPickerOptionClassNames.media, mediaBaseStyle, state.media.className);
  }
  if (state.secondaryContent) {
    state.secondaryContent.className = mergeClasses(tagPickerOptionClassNames.secondaryContent, secondaryContentBaseStyle, state.secondaryContent.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOption/TagPickerOption.js
var TagPickerOption = React573.forwardRef((props, ref) => {
  const state = useTagPickerOption_unstable(props, ref);
  useTagPickerOptionStyles_unstable(state);
  useCustomStyleHook("useTagPickerOptionStyles_unstable")(state);
  return renderTagPickerOption_unstable(state);
});
TagPickerOption.displayName = "TagPickerOption";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/TagPickerGroup.js
var React575 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroup.js
var React574 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/utils/tagPicker2Tag.js
function tagPickerSizeToTagSize(size3) {
  switch (size3) {
    case "medium":
      return "extra-small";
    case "large":
      return "small";
    case "extra-large":
      return "medium";
    default:
      return "extra-small";
  }
}
function tagSizeToTagPickerSize(size3) {
  switch (size3) {
    case "extra-small":
      return "medium";
    case "small":
      return "large";
    case "medium":
      return "extra-large";
    default:
      return "medium";
  }
}
function tagPickerAppearanceToTagAppearance(appearance) {
  switch (appearance) {
    case "filled-darker":
      return "outline";
    default:
      return "filled";
  }
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroup.js
var useTagPickerGroup_unstable = (props, ref) => {
  const hasSelectedOptions = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length > 0);
  const hasOneSelectedOption = useTagPickerContext_unstable((ctx) => ctx.selectedOptions.length === 1);
  const triggerRef = useTagPickerContext_unstable((ctx) => ctx.triggerRef);
  const tagPickerGroupRef = useTagPickerContext_unstable((ctx) => ctx.tagPickerGroupRef);
  const selectOption = useTagPickerContext_unstable((ctx) => ctx.selectOption);
  const size3 = useTagPickerContext_unstable((ctx) => tagPickerSizeToTagSize(ctx.size));
  const appearance = useTagPickerContext_unstable((ctx) => ctx.appearance);
  const disabled = useTagPickerContext_unstable((ctx) => ctx.disabled);
  const arrowNavigationProps = useArrowNavigationGroup({
    circular: false,
    axis: "both",
    memorizeCurrent: true
  });
  const state = useTagGroup_unstable({
    role: "listbox",
    disabled,
    ...props,
    ...arrowNavigationProps,
    size: size3,
    appearance: tagPickerAppearanceToTagAppearance(appearance),
    dismissible: true,
    onKeyDown: useEventCallback((event) => {
      var _props_onKeyDown;
      (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
      if (isHTMLElement(event.target) && event.key === ArrowRight) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    }),
    onDismiss: useEventCallback((event, data) => {
      selectOption(event, {
        value: data.value,
        // These values no longer exist because the option has unregistered itself
        // for the purposes of selection - these values aren't actually used
        id: "ERROR_DO_NOT_USE",
        text: "ERROR_DO_NOT_USE"
      });
      if (hasOneSelectedOption && !event.isDefaultPrevented()) {
        var _triggerRef_current;
        (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
      }
    })
  }, useMergedRefs(ref, tagPickerGroupRef));
  return {
    ...state,
    hasSelectedOptions
  };
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/renderTagPickerGroup.js
function renderTagPickerGroup_unstable(state, contexts) {
  if (!state.hasSelectedOptions) {
    return null;
  }
  return renderTagGroup_unstable(state, contexts);
}

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/useTagPickerGroupStyles.styles.js
var tagPickerGroupClassNames = {
  root: "fui-TagPickerGroup"
};
var useStyles79 = __styles2({
  root: {
    Eh141a: "fni485r",
    B7ck84d: "f1ewtqcl",
    Bceei9c: "f113hnb5"
  },
  medium: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fa2pw7h",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fkln5zr"
  },
  large: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fc0zr7g",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  },
  "extra-large": {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fc0zr7g",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1eyhf9v"
  }
}, {
  d: [".fni485r{flex-wrap:wrap;}", ".f1ewtqcl{box-sizing:border-box;}", ".f113hnb5{cursor:text;}", [".fa2pw7h{padding:var(--spacingVerticalSNudge) 0 var(--spacingVerticalSNudge) 0;}", {
    p: -1
  }], [".fkln5zr{gap:var(--spacingHorizontalXS);}", {
    p: -1
  }], [".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", {
    p: -1
  }], [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }], [".fc0zr7g{padding:var(--spacingVerticalS) 0 var(--spacingVerticalS) 0;}", {
    p: -1
  }], [".f1eyhf9v{gap:var(--spacingHorizontalSNudge);}", {
    p: -1
  }]]
});
var useTagPickerGroupStyles_unstable = (state) => {
  "use no memo";
  useTagGroupStyles_unstable(state);
  const styles = useStyles79();
  state.root.className = mergeClasses(tagPickerGroupClassNames.root, styles[tagSizeToTagPickerSize(state.size)], styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerGroup/TagPickerGroup.js
var TagPickerGroup = React575.forwardRef((props, ref) => {
  const state = useTagPickerGroup_unstable(props, ref);
  useTagPickerGroupStyles_unstable(state);
  useCustomStyleHook("useTagPickerGroupStyles_unstable")(state);
  return renderTagPickerGroup_unstable(state, useTagGroupContextValues_unstable(state));
});
TagPickerGroup.displayName = "TagPickerGroup";

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/TagPickerOptionGroup.js
var React577 = __toESM(require_react());

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroup.js
var React576 = __toESM(require_react());
var useTagPickerOptionGroup = useOptionGroup_unstable;

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/renderTagPickerOptionGroup.js
var renderTagPickerOptionGroup = renderOptionGroup_unstable;

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/useTagPickerOptionGroupStyles.styles.js
var tagPickerOptionGroupClassNames = {
  root: "fui-TagPickerOptionGroup",
  label: "fui-TagPickerOptionGroup__label"
};
var useTagPickerOptionGroupStyles = (state) => {
  "use no memo";
  useOptionGroupStyles_unstable(state);
  state.root.className = mergeClasses(tagPickerOptionGroupClassNames.root, state.root.className);
  if (state.label) {
    state.label.className = mergeClasses(tagPickerOptionGroupClassNames.label, state.label.className);
  }
  return state;
};

// node_modules/@fluentui/react-tag-picker/lib/components/TagPickerOptionGroup/TagPickerOptionGroup.js
var TagPickerOptionGroup = React577.forwardRef((props, ref) => {
  const state = useTagPickerOptionGroup(props, ref);
  useTagPickerOptionGroupStyles(state);
  useCustomStyleHook("useTagPickerOptionGroupStyles_unstable")(state);
  return renderTagPickerOptionGroup(state);
});
TagPickerOptionGroup.displayName = "TagPickerOptionGroup";

// node_modules/@fluentui/react-tag-picker/lib/utils/useTagPickerFilter.js
var React578 = __toESM(require_react());
function defaultRenderOption(option) {
  return React578.createElement(TagPickerOption, {
    value: option,
    key: option
  }, option);
}
function useTagPickerFilter({ filter: filterOverride, noOptionsElement, renderOption = defaultRenderOption, query, options }) {
  const defaultFilter2 = React578.useCallback((option) => {
    const trimmedQuery = query.trim();
    if (trimmedQuery === "") {
      return true;
    }
    return option.toLowerCase().includes(trimmedQuery.toLowerCase());
  }, [
    query
  ]);
  const filter = filterOverride !== null && filterOverride !== void 0 ? filterOverride : defaultFilter2;
  const filteredOptions = React578.useMemo(() => options.reduce((accumulator, option, index) => {
    if (filter(option, index)) {
      accumulator.push(renderOption(option));
    }
    return accumulator;
  }, []), [
    options,
    renderOption,
    filter
  ]);
  return filteredOptions.length === 0 ? [
    noOptionsElement.key ? noOptionsElement : React578.cloneElement(noOptionsElement, {
      key: "no-options"
    })
  ] : filteredOptions;
}

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/SwatchPicker.js
var React581 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPicker.js
var React579 = __toESM(require_react());
var useSwatchPicker_unstable = (props, ref) => {
  props = useFieldControlProps_unstable(props);
  const { layout, onSelectionChange, size: size3 = "medium", shape, spacing = "medium", style, ...rest } = props;
  const isGrid = layout === "grid";
  const focusAttributes = useArrowNavigationGroup({
    circular: true,
    axis: isGrid ? "grid-linear" : "both",
    memorizeCurrent: true
  });
  const role = isGrid ? "grid" : "radiogroup";
  const [selectedValue, setSelectedValue] = useControllableState({
    state: props.selectedValue,
    defaultState: props.defaultSelectedValue,
    initialState: ""
  });
  const requestSelectionChange = useEventCallback((event, data) => {
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(event, {
      type: "click",
      event,
      selectedValue: data.selectedValue,
      selectedSwatch: data.selectedSwatch
    });
    setSelectedValue(data.selectedValue);
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role,
      ...focusAttributes,
      ...rest
    }), {
      elementType: "div"
    }),
    isGrid,
    requestSelectionChange,
    selectedValue,
    size: size3,
    shape,
    spacing
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/contexts/swatchPicker.js
var React580 = __toESM(require_react());
var useSwatchPickerContextValues = (state) => {
  const { isGrid, size: size3, shape, spacing, requestSelectionChange, selectedValue } = state;
  const swatchPicker = {
    isGrid,
    size: size3,
    shape,
    spacing,
    selectedValue,
    requestSelectionChange
  };
  return {
    swatchPicker
  };
};
var swatchPickerContextDefaultValue = {
  requestSelectionChange: () => {
  },
  isGrid: false,
  size: "medium",
  shape: "square",
  spacing: "medium",
  selectedValue: void 0
};
var SwatchPickerContext = createContext13(void 0);
var SwatchPickerProvider = SwatchPickerContext.Provider;
var useSwatchPickerContextValue_unstable = (selector) => useContextSelector(SwatchPickerContext, (ctx = swatchPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/renderSwatchPicker.js
var renderSwatchPicker_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(SwatchPickerProvider, {
    value: contextValues.swatchPicker,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/useSwatchPickerStyles.styles.js
var swatchPickerClassNames = {
  root: "fui-SwatchPicker"
};
var useStyles80 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f14ufcw5",
    mc9l5x: "f22iagw"
  },
  row: {
    Beiy3e4: "f1063pyq"
  },
  grid: {
    Beiy3e4: "f1vx9l62"
  },
  spacingSmall: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1t6b6ee"
  },
  spacingMedium: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f4xv25i"
  }
}, {
  d: [[".f14ufcw5{padding:var(--spacingHorizontalNone) var(--spacingVerticalNone);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f1vx9l62{flex-direction:column;}", [".f1t6b6ee{gap:2px;}", {
    p: -1
  }], [".f4xv25i{gap:4px;}", {
    p: -1
  }]]
});
var useSwatchPickerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles80();
  const layoutStyle = state.isGrid ? styles.grid : styles.row;
  const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
  state.root.className = mergeClasses(swatchPickerClassNames.root, styles.root, layoutStyle, spacingStyle, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPicker/SwatchPicker.js
var SwatchPicker = React581.forwardRef((props, ref) => {
  const state = useSwatchPicker_unstable(props, ref);
  const contextValues = useSwatchPickerContextValues(state);
  useSwatchPickerStyles_unstable(state);
  useCustomStyleHook("useSwatchPickerStyles_unstable")(state);
  return renderSwatchPicker_unstable(state, contextValues);
});
SwatchPicker.displayName = "SwatchPicker";

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/ColorSwatch.js
var React583 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatch.js
var React582 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatchStyles.styles.js
var colorSwatchClassNames = {
  root: "fui-ColorSwatch",
  icon: "fui-ColorSwatch__icon",
  disabledIcon: "fui-ColorSwatch__disabledIcon"
};
var swatchCSSVars = {
  color: `--fui-SwatchPicker--color`,
  borderColor: `--fui-SwatchPicker--borderColor`
};
var {
  color,
  borderColor
} = swatchCSSVars;
var useResetStyles4 = __resetStyles("ryw27oi", null, {
  r: [".ryw27oi{display:inline-flex;flex-shrink:0;align-items:center;justify-content:center;box-sizing:border-box;border:1px solid var(--fui-SwatchPicker--borderColor);background:var(--fui-SwatchPicker--color);overflow:hidden;padding:0;}", ".ryw27oi:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".ryw27oi:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}", ".ryw27oi:focus{outline:none;}", ".ryw27oi:focus-visible{outline:none;}", ".ryw27oi[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"],
  s: ["@media (forced-colors: active){.ryw27oi{forced-color-adjust:none;}.ryw27oi:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.ryw27oi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
});
var useStyles81 = __styles2({
  disabled: {
    eoavqd: "fphbwmw",
    Bvxd0ez: "f1q3txrk",
    Be968up: "f10pb1y8"
  },
  selected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    E5pizo: "f8ps3yo",
    Bvxd0ez: "f106r15f",
    vajtyg: "ft0nc49",
    j6ew2k: "f16jq8vy",
    Bv9i2bc: "f1wdoq7e"
  },
  selectedSmall: {
    E5pizo: "fxflcoq",
    Bvxd0ez: "fha7ylp",
    vajtyg: "fb3iqi"
  }
}, {
  h: [".fphbwmw:hover{cursor:not-allowed;}", ".f1q3txrk:hover{box-shadow:none;}", ".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}", ".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}", ".fha7ylp:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokeHover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".fb3iqi:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}"],
  m: [["@media (forced-colors: active){.f10pb1y8:hover{box-shadow:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1wdoq7e{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", {
    m: "(forced-colors: active)"
  }]],
  d: [[".f3bhgqh{border:none;}", {
    p: -2
  }], ".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".fxflcoq{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"]
});
var useSizeStyles3 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b",
    Bvxd0ez: "fnzblak",
    Bfsrqk8: 0,
    B9zn80p: 0,
    libdba: 0,
    qi15n7: 0,
    G6mxvm: 0,
    Bpld233: 0,
    B2v0cj4: 0,
    qv9p00: 0,
    Bg6oviu: 0,
    Bk6r4ia: 0,
    Bckajt6: 0,
    Bone85h: 0,
    hkxzgu: 0,
    b661bw: 0,
    kpb45w: 0,
    uiygdg: 0,
    rljib7: "f18wa7jm",
    vajtyg: "faswyoo"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55",
    Bfsrqk8: 0,
    B9zn80p: 0,
    libdba: 0,
    qi15n7: 0,
    G6mxvm: 0,
    Bpld233: 0,
    B2v0cj4: 0,
    qv9p00: 0,
    Bg6oviu: 0,
    Bk6r4ia: 0,
    Bckajt6: 0,
    Bone85h: 0,
    hkxzgu: 0,
    b661bw: 0,
    kpb45w: 0,
    uiygdg: 0,
    rljib7: "f18wa7jm",
    vajtyg: "faswyoo"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"],
  h: [".fnzblak:hover{box-shadow:inset 0 0 0 var(--strokeWidthThin) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus1);}", [".f18wa7jm:hover:active{border:none;}", {
    p: -2
  }], ".faswyoo:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", [".f18wa7jm:hover:active{border:none;}", {
    p: -2
  }]]
});
var useShapeStyles = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useIconStyles12 = __styles2({
  disabledIcon: {
    sj55zd: "fqpbvvt",
    Bhu2qc9: "f14y0k3d"
  },
  icon: {
    qhf8xq: "f1euv43f",
    mc9l5x: "f22iagw",
    qb2dma: "f7nlbp4"
  },
  "extra-small": {
    Be2twd7: "f4ybsrx"
  },
  small: {
    Be2twd7: "f4ybsrx"
  },
  medium: {
    Be2twd7: "fe5j1ua"
  },
  large: {
    Be2twd7: "f1rt2boy"
  }
}, {
  d: [".fqpbvvt{color:var(--colorNeutralForegroundInverted);}", ".f14y0k3d{filter:drop-shadow(0 1px 1px rgb(0 0 0 / 1));}", ".f1euv43f{position:absolute;}", ".f22iagw{display:flex;}", ".f7nlbp4{align-self:center;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}"]
});
var useColorSwatchStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3 = "medium",
    shape = "square"
  } = state;
  const resetStyles = useResetStyles4();
  const styles = useStyles81();
  const sizeStyles = useSizeStyles3();
  const shapeStyles = useShapeStyles();
  const iconStyles = useIconStyles12();
  const smallerSelectedStyles = size3 === "small" || size3 === "extra-small" ? styles.selectedSmall : "";
  state.root.className = mergeClasses(colorSwatchClassNames.root, resetStyles, sizeStyles[size3], shapeStyles[shape], state.selected && styles.selected, state.selected && smallerSelectedStyles, state.disabled && styles.disabled, state.root.className);
  if (state.disabled && state.disabledIcon) {
    state.disabledIcon.className = mergeClasses(iconStyles.icon, iconStyles[size3], iconStyles.disabledIcon, state.disabledIcon.className);
  }
  if (state.icon) {
    state.icon.className = mergeClasses(iconStyles.icon, iconStyles[size3], state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/useColorSwatch.js
var useColorSwatch_unstable = (props, ref) => {
  const { borderColor: borderColor2, color: color2, disabled, disabledIcon, icon, value, onClick, size: size3, shape, style, ...rest } = props;
  const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
  const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
  const onColorSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
    selectedValue: value,
    selectedSwatch: color2
  })));
  const rootVariables = {
    [swatchCSSVars.color]: color2,
    [swatchCSSVars.borderColor]: borderColor2 !== null && borderColor2 !== void 0 ? borderColor2 : tokens.colorTransparentStroke
  };
  const role = isGrid ? "gridcell" : "radio";
  const ariaSelected = isGrid ? {
    "aria-selected": selected
  } : {
    "aria-checked": selected
  };
  const iconShorthand = slot_exports.optional(icon, {
    elementType: "span"
  });
  const disabledIconShorthand = slot_exports.optional(disabledIcon, {
    defaultProps: {
      children: React582.createElement(ProhibitedFilled, null)
    },
    renderByDefault: true,
    elementType: "span"
  });
  return {
    components: {
      root: "button",
      icon: "span",
      disabledIcon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...ariaSelected,
      onClick: onColorSwatchClick,
      type: "button",
      disabled,
      ...rest,
      style: {
        ...rootVariables,
        ...style
      }
    }), {
      elementType: "button"
    }),
    icon: iconShorthand,
    disabledIcon: disabledIconShorthand,
    disabled,
    size: size3 !== null && size3 !== void 0 ? size3 : _size,
    shape: shape !== null && shape !== void 0 ? shape : _shape,
    selected,
    color: color2,
    value
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/renderColorSwatch.js
var renderColorSwatch_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.root.children,
      state.icon && jsx(state.icon, {}),
      state.disabled && state.disabledIcon && jsx(state.disabledIcon, {})
    ]
  });
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ColorSwatch/ColorSwatch.js
var ColorSwatch = React583.forwardRef((props, ref) => {
  const state = useColorSwatch_unstable(props, ref);
  useColorSwatchStyles_unstable(state);
  useCustomStyleHook("useColorSwatchStyles_unstable")(state);
  return renderColorSwatch_unstable(state);
});
ColorSwatch.displayName = "ColorSwatch";

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/ImageSwatch.js
var React585 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatch.js
var React584 = __toESM(require_react());
var useImageSwatch_unstable = (props, ref) => {
  const { src, value, onClick, style, ...rest } = props;
  const size3 = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const requestSelectionChange = useSwatchPickerContextValue_unstable((ctx) => ctx.requestSelectionChange);
  const selected = useSwatchPickerContextValue_unstable((ctx) => ctx.selectedValue === value);
  const role = isGrid ? "gridcell" : "radio";
  const ariaSelected = isGrid ? {
    "aria-selected": selected
  } : {
    "aria-checked": selected
  };
  const onImageSwatchClick = useEventCallback(mergeCallbacks(onClick, (event) => requestSelectionChange(event, {
    selectedValue: value,
    selectedSwatch: src
  })));
  return {
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...ariaSelected,
      onClick: onImageSwatchClick,
      ...rest,
      style: {
        backgroundImage: `url(${src})`,
        ...style
      }
    }), {
      elementType: "button"
    }),
    value,
    selected,
    size: size3,
    shape
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/renderImageSwatch.js
var renderImageSwatch_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/useImageSwatchStyles.styles.js
var imageSwatchClassNames = {
  root: "fui-ImageSwatch"
};
var useStyles82 = __resetStyles("r18b5q7m", null, {
  r: [".r18b5q7m{display:inline-flex;box-sizing:border-box;border:1px solid var(--colorTransparentStroke);background-size:cover;background-repeat:no-repeat;padding:0;}", ".r18b5q7m:hover{cursor:pointer;border:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke1),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}", ".r18b5q7m:hover:active{border:none;box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorCompoundBrandStrokePressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}", ".r18b5q7m:focus{outline:none;}", ".r18b5q7m:focus-visible{outline:none;}", ".r18b5q7m[data-fui-focus-visible]{border:none;outline:none;box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorStrokeFocus2),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}"],
  s: ["@media (forced-colors: active){.r18b5q7m{forced-color-adjust:none;}.r18b5q7m:hover{box-shadow:inset 0 0 0 var(--strokeWidthThick) var(--colorBrandStroke2Hover),inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus1);}.r18b5q7m:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 var(--strokeWidthThickest) var(--colorStrokeFocus1);}}"]
});
var useStylesSelected = __styles2({
  selected: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    E5pizo: "f8ps3yo",
    Bvxd0ez: "f106r15f",
    vajtyg: "ft0nc49",
    j6ew2k: "f16jq8vy",
    Bv9i2bc: "f1wdoq7e"
  }
}, {
  d: [[".f3bhgqh{border:none;}", {
    p: -2
  }], ".f8ps3yo{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke1),inset 0 0 0 5px var(--colorStrokeFocus1);}", ".f16jq8vy[data-fui-focus-visible]{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorStrokeFocus2),inset 0 0 0 5px var(--colorStrokeFocus1);}"],
  h: [".f106r15f:hover{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokeHover),inset 0 0 0 6px var(--colorStrokeFocus1);}", ".ft0nc49:hover:active{box-shadow:inset 0 0 0 var(--strokeWidthThickest) var(--colorCompoundBrandStrokePressed),inset 0 0 0 7px var(--colorStrokeFocus1);}"],
  m: [["@media (forced-colors: active){.f1wdoq7e{box-shadow:inset 0 0 0 var(--strokeWidthThicker) var(--colorBrandStroke2Pressed),inset 0 0 0 5px var(--colorStrokeFocus1);}}", {
    m: "(forced-colors: active)"
  }]]
});
var useSizeStyles4 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useShapeStyles2 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useImageSwatchStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles82();
  const selectedStyles = useStylesSelected();
  const sizeStyles = useSizeStyles4();
  const shapeStyles = useShapeStyles2();
  const {
    size: size3 = "medium",
    shape = "square"
  } = state;
  state.root.className = mergeClasses(imageSwatchClassNames.root, styles, sizeStyles[size3], shapeStyles[shape], state.selected && selectedStyles.selected, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/ImageSwatch/ImageSwatch.js
var ImageSwatch = React585.forwardRef((props, ref) => {
  const state = useImageSwatch_unstable(props, ref);
  useImageSwatchStyles_unstable(state);
  useCustomStyleHook("useImageSwatchStyles_unstable")(state);
  return renderImageSwatch_unstable(state);
});
ImageSwatch.displayName = "ImageSwatch";

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/SwatchPickerRow.js
var React587 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRow.js
var React586 = __toESM(require_react());
var useSwatchPickerRow_unstable = (props, ref) => {
  const { style, ...rest } = props;
  const spacing = useSwatchPickerContextValue_unstable((ctx) => ctx.spacing);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "row",
      ...rest
    }), {
      elementType: "div"
    }),
    spacing
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/renderSwatchPickerRow.js
var renderSwatchPickerRow_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/useSwatchPickerRowStyles.styles.js
var swatchPickerRowClassNames = {
  root: "fui-SwatchPickerRow"
};
var useResetStyles5 = __resetStyles("r1xhj18k", null, [".r1xhj18k{display:flex;flex-direction:row;}"]);
var useStyles83 = __styles2({
  spacingSmall: {
    i8kkvl: "f16mnhsx"
  },
  spacingMedium: {
    i8kkvl: "f1q8lukm"
  }
}, {
  d: [".f16mnhsx{column-gap:2px;}", ".f1q8lukm{column-gap:4px;}"]
});
var useSwatchPickerRowStyles_unstable = (state) => {
  "use no memo";
  const resetStyles = useResetStyles5();
  const styles = useStyles83();
  const spacingStyle = state.spacing === "small" ? styles.spacingSmall : styles.spacingMedium;
  state.root.className = mergeClasses(swatchPickerRowClassNames.root, resetStyles, spacingStyle, state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/SwatchPickerRow/SwatchPickerRow.js
var SwatchPickerRow = React587.forwardRef((props, ref) => {
  const state = useSwatchPickerRow_unstable(props, ref);
  useSwatchPickerRowStyles_unstable(state);
  useCustomStyleHook("useSwatchPickerRowStyles_unstable")(state);
  return renderSwatchPickerRow_unstable(state);
});
SwatchPickerRow.displayName = "SwatchPickerRow";

// node_modules/@fluentui/react-swatch-picker/lib/utils/renderUtils.js
var React588 = __toESM(require_react());
var renderSwatchPickerGrid = (props) => {
  const { items, columnCount, renderRow, renderSwatch } = props;
  const _renderRow = renderRow || (({ children, rowId }) => React588.createElement(SwatchPickerRow, {
    key: rowId
  }, children));
  const _renderSwatch = renderSwatch || ((item) => {
    var _item_src;
    return item.src ? React588.createElement(ImageSwatch, {
      key: item.value,
      src: (_item_src = item.src) !== null && _item_src !== void 0 ? _item_src : "",
      ...item
    }) : React588.createElement(ColorSwatch, {
      key: item.value,
      color: item.color || "",
      ...item
    });
  });
  const rowCount = Math.ceil(items.length / columnCount);
  const rows = Array.from({
    length: rowCount
  }, (_, i) => {
    const start = i * columnCount;
    const end = start + columnCount;
    return items.slice(start, end);
  });
  return rows.map((row, index) => _renderRow({
    children: row.map(_renderSwatch),
    rowId: index
  }));
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/EmptySwatch.js
var React590 = __toESM(require_react());

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatch.js
var React589 = __toESM(require_react());
var useEmptySwatch_unstable = (props, ref) => {
  const { size: size3, shape, ...rest } = props;
  const _size = useSwatchPickerContextValue_unstable((ctx) => ctx.size);
  const _shape = useSwatchPickerContextValue_unstable((ctx) => ctx.shape);
  const isGrid = useSwatchPickerContextValue_unstable((ctx) => ctx.isGrid);
  const role = isGrid ? "gridcell" : "radio";
  const a11yProps = isGrid ? {} : {
    "aria-checked": false
  };
  return {
    components: {
      root: "button"
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      role,
      ...a11yProps,
      ...rest
    }), {
      elementType: "button"
    }),
    size: size3 !== null && size3 !== void 0 ? size3 : _size,
    shape: shape !== null && shape !== void 0 ? shape : _shape
  };
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/renderEmptySwatch.js
var renderEmptySwatch_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/useEmptySwatchStyles.styles.js
var emptySwatchClassNames = {
  root: "fui-EmptySwatch"
};
var useStyles84 = __resetStyles("r1top892", null, [".r1top892{background-color:var(--colorTransparentBackground);border:1px dashed var(--colorNeutralForeground4);}"]);
var useSizeStyles5 = __styles2({
  "extra-small": {
    a9b677: "f64fuq3",
    Bqenvij: "fjamq6b"
  },
  small: {
    a9b677: "fq4mcun",
    Bqenvij: "frvgh55"
  },
  medium: {
    a9b677: "f1w9dchk",
    Bqenvij: "fxldao9"
  },
  large: {
    a9b677: "f1szoe96",
    Bqenvij: "f1d2rq10"
  }
}, {
  d: [".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}"]
});
var useShapeStyles3 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w"
  },
  circular: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f1062rbf"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "fj0ryk1"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1062rbf[data-fui-focus-visible]{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }], [".fj0ryk1[data-fui-focus-visible]{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useEmptySwatchStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles84();
  const sizeStyles = useSizeStyles5();
  const shapeStyles = useShapeStyles3();
  var _state_size;
  const size3 = (_state_size = state.size) !== null && _state_size !== void 0 ? _state_size : "medium";
  var _state_shape;
  state.root.className = mergeClasses(emptySwatchClassNames.root, styles, sizeStyles[size3], shapeStyles[(_state_shape = state.shape) !== null && _state_shape !== void 0 ? _state_shape : "square"], state.root.className);
  return state;
};

// node_modules/@fluentui/react-swatch-picker/lib/components/EmptySwatch/EmptySwatch.js
var EmptySwatch = React590.forwardRef((props, ref) => {
  const state = useEmptySwatch_unstable(props, ref);
  useEmptySwatchStyles_unstable(state);
  useCustomStyleHook("useEmptySwatchStyles_unstable")(state);
  return renderEmptySwatch_unstable(state);
});
EmptySwatch.displayName = "EmptySwatch";

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/CarouselButton.js
var React592 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButton.js
var React591 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselContext.js
var carouselContextDefaultValue2 = {
  activeIndex: 0,
  appearance: "flat",
  selectPageByElement: () => {
    return 0;
  },
  selectPageByDirection: () => {
    return 0;
  },
  selectPageByIndex: () => {
  },
  subscribeForValues: () => () => {
  },
  enableAutoplay: () => {
  },
  resetAutoplay: () => {
  },
  circular: false,
  containerRef: void 0,
  viewportRef: void 0
};
var CarouselContext2 = createContext13(void 0);
var CarouselProvider2 = CarouselContext2.Provider;
var useCarouselContext_unstable2 = (selector) => useContextSelector(CarouselContext2, (ctx = carouselContextDefaultValue2) => selector(ctx));

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButtonStyles.styles.js
var carouselButtonClassNames = {
  root: "fui-CarouselButton",
  icon: "fui-CarouselButton__icon"
};
var useStyles85 = __styles2({
  root: {
    B6of3ja: "fgr6219",
    jrapky: "f10jk5vf",
    sj55zd: "fkfq4zb",
    De3pzq: "fkfdr9r",
    Bkecrkj: "fc5wo7j",
    eoavqd: "f8491dx"
  }
}, {
  d: [".fgr6219{margin-top:auto;}", ".f10jk5vf{margin-bottom:auto;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}", ".fc5wo7j{pointer-events:all;}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles85();
  state = {
    ...state,
    ...useButtonStyles_unstable(state)
  };
  state.root.className = mergeClasses(carouselButtonClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(carouselButtonClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/useCarouselButton.js
var useCarouselButton_unstable = (props, ref) => {
  const { navType = "next" } = props;
  const [totalSlides, setTotalSlides] = React591.useState(0);
  const { dir } = useFluent();
  const buttonRef = React591.useRef(void 0);
  const circular = useCarouselContext_unstable2((ctx) => ctx.circular);
  const [canLoop, setCanLoop] = React591.useState(circular);
  const containerRef = useCarouselContext_unstable2((ctx) => ctx.containerRef);
  const selectPageByDirection = useCarouselContext_unstable2((ctx) => ctx.selectPageByDirection);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const resetAutoplay = useCarouselContext_unstable2((ctx) => ctx.resetAutoplay);
  const isTrailing = useCarouselContext_unstable2((ctx) => {
    if (circular && canLoop) {
      return false;
    }
    if (navType === "prev") {
      return ctx.activeIndex === 0;
    }
    return ctx.activeIndex === totalSlides - 1;
  });
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    const nextIndex = selectPageByDirection(event, navType);
    let _trailing = false;
    if (navType === "prev") {
      _trailing = nextIndex === 0;
    } else {
      _trailing = nextIndex === totalSlides - 1;
    }
    if (!circular && _trailing && (containerRef === null || containerRef === void 0 ? void 0 : containerRef.current)) {
      const buttonRefs = containerRef.current.querySelectorAll(`.${carouselButtonClassNames.root}`);
      buttonRefs.forEach((_buttonRef) => {
        if (_buttonRef !== buttonRef.current) {
          _buttonRef.focus();
        }
      });
    }
    resetAutoplay();
  };
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      if (data.canLoop !== void 0) {
        setCanLoop(data.canLoop);
      }
      setTotalSlides(data.navItemsCount);
    });
  }, [
    subscribeForValues
  ]);
  const nextArrowIcon = dir === "ltr" ? React591.createElement(ChevronRightRegular, null) : React591.createElement(ChevronLeftRegular, null);
  const prevArrowIcon = dir === "ltr" ? React591.createElement(ChevronLeftRegular, null) : React591.createElement(ChevronRightRegular, null);
  return {
    navType,
    // We lean on react-button class to handle styling and icon enhancements
    ...useButton_unstable({
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: navType === "next" ? nextArrowIcon : prevArrowIcon
        },
        renderByDefault: true,
        elementType: "span"
      }),
      disabled: isTrailing,
      tabIndex: isTrailing ? -1 : 0,
      "aria-disabled": isTrailing,
      appearance: "subtle",
      ...props,
      onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
    }, useMergedRefs(ref, buttonRef))
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/renderCarouselButton.js
var renderCarouselButton_unstable = (state) => {
  assertSlots(state);
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselButton/CarouselButton.js
var CarouselButton = React592.forwardRef((props, ref) => {
  const state = useCarouselButton_unstable(props, ref);
  useCarouselButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselButtonStyles_unstable")(state);
  return renderCarouselButton_unstable(state);
});
CarouselButton.displayName = "CarouselButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNav.js
var React596 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavContext.js
var React593 = __toESM(require_react());
var carouselNavContext = React593.createContext(void 0);
var carouselNavContextDefaultValue = {
  appearance: void 0
};
var useCarouselNavContext = () => {
  var _React_useContext;
  return (_React_useContext = React593.useContext(carouselNavContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavContextDefaultValue;
};
var CarouselNavContextProvider = carouselNavContext.Provider;
function useCarouselNavContextValues_unstable(state) {
  const { appearance } = state;
  const carouselNav = React593.useMemo(() => ({
    appearance
  }), [
    appearance
  ]);
  return {
    carouselNav
  };
}

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNavIndexContext.js
var React594 = __toESM(require_react());
var carouselNavIndexContext = React594.createContext(void 0);
var carouselNavIndexContextDefaultValue = 0;
var useCarouselNavIndexContext = () => {
  var _React_useContext;
  return (_React_useContext = React594.useContext(carouselNavIndexContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselNavIndexContextDefaultValue;
};
var CarouselNavIndexContextProvider = carouselNavIndexContext.Provider;

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/renderCarouselNav.js
var renderCarouselNav_unstable = (state, contextValues) => {
  assertSlots(state);
  const { totalSlides, renderNavButton } = state;
  return jsx(state.root, {
    children: jsx(CarouselNavContextProvider, {
      value: contextValues.carouselNav,
      children: new Array(totalSlides).fill(null).map((_, index) => jsx(CarouselNavIndexContextProvider, {
        value: index,
        children: renderNavButton(index)
      }, index))
    })
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNav.js
var React595 = __toESM(require_react());
var useCarouselNav_unstable = (props, ref) => {
  const { appearance } = props;
  const focusableGroupAttr = useArrowNavigationGroup({
    circular: false,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const [totalSlides, setTotalSlides] = useControllableState({
    state: props.totalSlides,
    initialState: 0
  });
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      setTotalSlides(data.navItemsCount);
    });
  }, [
    subscribeForValues,
    setTotalSlides
  ]);
  return {
    totalSlides,
    appearance,
    renderNavButton: props.children,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "tablist",
      ...props,
      ...focusableGroupAttr,
      children: null
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/useCarouselNavStyles.styles.js
var carouselNavClassNames = {
  root: "fui-CarouselNav"
};
var useStyles86 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Bt984gj: "f122n59",
    Brf1p80: "f4d9j23",
    Bkecrkj: "fc5wo7j",
    Bfpq7zp: 0,
    g9k6zt: 0,
    Bn4voq9: 0,
    giviqs: "f89hs3r",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    B8q5s1w: "f8hki3x",
    Bci5o5g: ["f1d2448m", "ffh67wi"],
    n8qw10: "f1bjia2o",
    Bdrgwmp: ["ffh67wi", "f1d2448m"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "fkb7v5e",
    De3pzq: "fkfdr9r"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fc5wo7j{pointer-events:all;}", [".f89hs3r[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f8hki3x[data-fui-focus-visible]{border-top-color:transparent;}", ".f1d2448m[data-fui-focus-visible]{border-right-color:transparent;}", ".ffh67wi[data-fui-focus-visible]{border-left-color:transparent;}", ".f1bjia2o[data-fui-focus-visible]{border-bottom-color:transparent;}", [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], [".fkb7v5e{margin:auto var(--spacingHorizontalS);}", {
    p: -1
  }], ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"]
});
var useCarouselNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles86();
  state.root.className = mergeClasses(carouselNavClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNav/CarouselNav.js
var CarouselNav = React596.forwardRef((props, ref) => {
  const state = useCarouselNav_unstable(props, ref);
  const contextValues = useCarouselNavContextValues_unstable(state);
  useCarouselNavStyles_unstable(state);
  useCustomStyleHook("useCarouselNavStyles_unstable")(state);
  return renderCarouselNav_unstable(state, contextValues);
});
CarouselNav.displayName = "CarouselNav";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/CarouselNavButton.js
var React598 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButton.js
var React597 = __toESM(require_react());
var useCarouselNavButton_unstable = (props, ref) => {
  const { onClick, as = "button" } = props;
  const { appearance } = useCarouselNavContext();
  const index = useCarouselNavIndexContext();
  const selectPageByIndex = useCarouselContext_unstable2((ctx) => ctx.selectPageByIndex);
  const selected = useCarouselContext_unstable2((ctx) => ctx.activeIndex === index);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const resetAutoplay = useCarouselContext_unstable2((ctx) => ctx.resetAutoplay);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByIndex(event, index);
    }
    resetAutoplay();
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
  const buttonRef = React597.useRef(void 0);
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref: useMergedRefs(ref, buttonRef),
      role: "tab",
      type: "button",
      "aria-selected": selected,
      ...defaultTabProps
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      var _data_groupIndexList;
      var _data_groupIndexList_index;
      const controlList = (_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : [];
      const _controlledSlideIds = controlList.map((slideIndex) => {
        return data.slideNodes[slideIndex].id;
      }).join(" ");
      if (buttonRef.current) {
        buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
      }
    });
  }, [
    index,
    subscribeForValues
  ]);
  _carouselButton.onClick = handleClick;
  const state = {
    selected,
    appearance,
    components: {
      root: "button"
    },
    root: _carouselButton
  };
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/renderCarouselNavButton.js
var renderCarouselNavButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/useCarouselNavButtonStyles.styles.js
var carouselNavButtonClassNames = {
  root: "fui-CarouselNavButton"
};
var useStyles87 = __styles2({
  root: {
    Bceei9c: "f1k6fduh",
    Bkecrkj: "fc5wo7j",
    a9b677: "f1van5z7",
    Bqenvij: "f1fkmctz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1f5q0n8",
    B7ck84d: "f1e4lqlz",
    De3pzq: "f1c21dwh",
    B4j52fo: "fre7gi1",
    Bekrc4i: ["f1358rze", "f1rvrf73"],
    Bn0qgzm: "fqdk4by",
    ibv6hh: ["f1rvrf73", "f1358rze"],
    Bsft5z2: "f13zj6fq",
    ap17g6: "f2gz7yw",
    li1rpt: "f1gw3sf2",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f1x820d0",
    Bjuhk93: 0,
    B1q35kw: 0,
    Bw17bha: 0,
    Bcgy8vk: 0,
    Du69r6: 0,
    Gp14am: 0,
    vfts7: 0,
    Bhxzhr1: 0,
    G63luc: 0,
    s924m2: 0,
    Barhvk9: 0,
    Ihftqj: 0,
    wywymt: 0,
    B0n5ga8: 0,
    Bm2nyyq: 0,
    xrcqlc: 0,
    e1d83w: "fnwf5yv",
    Dlnsje: "foue38v",
    a2br6o: "fi4ui2s",
    Bjyk6c5: "f1w4p7kh",
    go7t6h: "fo5b2b9",
    xdqbwx: "f16vizm6",
    Hwb57: "fqolsir",
    umgawz: "fim7wbh"
  },
  rootUnselected: {
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    Bj9ihqo: 0,
    Bl51kww: 0,
    B3bvztg: 0,
    Btyt4dx: 0,
    Brhw1f9: "f1tdm9ui",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    Bp15pi3: "f7x02et",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1e9f9ku"
  },
  rootSelected: {
    a9b677: "f1eh74fx",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "fwku66v",
    Bw0xxkn: 0,
    oeaueh: 0,
    Bpd4iqm: 0,
    Befb4lg: "f71xx7",
    Byu6kyc: 0,
    n8qw10: 0,
    Bbjhlyh: 0,
    i2cumq: 0,
    Bunx835: 0,
    Bdrgwmp: 0,
    mqozju: 0,
    lbo84a: 0,
    Bksnhdo: 0,
    Bci5o5g: 0,
    u5e7qz: 0,
    Bn40d3w: 0,
    B7b6zxw: 0,
    B8q5s1w: 0,
    B5gfjzb: 0,
    Bbcte9g: 0,
    Bqz3imu: "f1j9b7x8",
    Bj9ihqo: 0,
    Bl51kww: 0,
    B3bvztg: 0,
    Btyt4dx: 0,
    Brhw1f9: "f1tdm9ui",
    Bw81rd7: 0,
    kdpuga: 0,
    dm238s: 0,
    B6xbmo0: 0,
    B3whbx2: "f2krc9w",
    a2br6o: "f1v6lwa2",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "fgm6wgx",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1gxfet"
  },
  brand: {
    Bjyk6c5: "fnrv5e1",
    Bp15pi3: "fjsqi2x",
    Glksuk: "frrwqtn",
    Bay5ve9: "f9atwx8",
    Blzl0y7: "fmmpig5",
    Bni0232: "f1e9f9ku"
  },
  unselectedBrand: {
    Bp15pi3: "f7x02et",
    Bjyk6c5: "f1w4p7kh",
    Bay5ve9: "f1ry2q4s",
    Bni0232: "f1e9f9ku"
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fc5wo7j{pointer-events:all;}", ".f1van5z7{width:var(--spacingHorizontalS);}", ".f1fkmctz{height:var(--spacingVerticalS);}", [".f1f5q0n8{padding:var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".f1e4lqlz{box-sizing:content-box;}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fre7gi1{border-top-width:0;}", ".f1358rze{border-right-width:0;}", ".f1rvrf73{border-left-width:0;}", ".fqdk4by{border-bottom-width:0;}", '.f13zj6fq::after{content:"";}', ".f2gz7yw::after{display:block;}", ".f1gw3sf2::after{box-sizing:border-box;}", [".f1x820d0::after{border-radius:50%;}", {
    p: -1
  }], [".fnwf5yv::after{border:none;}", {
    p: -2
  }], ".foue38v::after{height:var(--spacingVerticalS);}", ".fi4ui2s::after{width:var(--spacingHorizontalS);}", ".f1w4p7kh::after{background-color:var(--colorNeutralForeground1);}", ".fo5b2b9::after{color:var(--colorNeutralForeground1);}", [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f7x02et::after{opacity:0.6;}", ".f1eh74fx{width:var(--spacingHorizontalL);}", [".fwku66v{padding:var(--spacingVerticalS) var(--spacingHorizontalXS);}", {
    p: -1
  }], [".f71xx7{outline:var(--strokeWidthThin) solid transparent;}", {
    p: -1
  }], [".f1j9b7x8[data-fui-focus-visible]{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f1tdm9ui[data-fui-focus-visible]{margin:calc(-1 * var(--strokeWidthThick));}", {
    p: -1
  }], [".f2krc9w[data-fui-focus-visible]{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], ".f1v6lwa2::after{width:var(--spacingHorizontalL);}", [".fgm6wgx::after{border-radius:4px;}", {
    p: -1
  }], ".fnrv5e1::after{background-color:var(--colorCompoundBrandBackground);}", ".fjsqi2x::after{opacity:1;}"],
  m: [["@media (forced-colors: active){.f16vizm6::after{forced-color-adjust:none;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fqolsir::after{background-color:white;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fim7wbh::after{mix-blend-mode:difference;}}", {
    m: "(forced-colors: active)"
  }]],
  h: [".f1ry2q4s:hover::after{opacity:0.75;}", ".frrwqtn:hover::after{background-color:var(--colorCompoundBrandBackgroundHover);}", ".f9atwx8:hover::after{opacity:1;}"],
  a: [".f1e9f9ku:active::after{opacity:1;}", ".f1gxfet:active::after{opacity:0.65;}", ".fmmpig5:active::after{background-color:var(--colorCompoundBrandBackgroundPressed);}"]
});
var useCarouselNavButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles87();
  const {
    selected,
    appearance
  } = state;
  state.root.className = mergeClasses(carouselNavButtonClassNames.root, styles.root, selected ? styles.rootSelected : styles.rootUnselected, appearance === "brand" && styles.brand, !selected && appearance === "brand" && styles.unselectedBrand, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavButton/CarouselNavButton.js
var CarouselNavButton = React598.forwardRef((props, ref) => {
  const state = useCarouselNavButton_unstable(props, ref);
  useCarouselNavButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselNavButtonStyles_unstable")(state);
  return renderCarouselNavButton_unstable(state);
});
CarouselNavButton.displayName = "CarouselNavButton";

// node_modules/@fluentui/react-carousel/lib/components/Carousel/Carousel.js
var React602 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarousel.js
var React600 = __toESM(require_react());

// node_modules/embla-carousel/esm/embla-carousel.esm.js
function isNumber(subject) {
  return typeof subject === "number";
}
function isString(subject) {
  return typeof subject === "string";
}
function isBoolean(subject) {
  return typeof subject === "boolean";
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === "[object Object]";
}
function mathAbs(n) {
  return Math.abs(n);
}
function mathSign(n) {
  return Math.sign(n);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index) {
  return index === arrayLastIndex(array);
}
function arrayFromNumber(n, startAt = 0) {
  return Array.from(Array(n), (_, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach((key) => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject(valueA) && isObject(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent2(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== "undefined" && evt instanceof ownerWindow.MouseEvent;
}
function Alignment(align, viewSize) {
  const predefined = {
    start,
    center,
    end
  };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return viewSize - n;
  }
  function measure(n, index) {
    if (isString(align)) return predefined[align](n);
    return align(viewSize, n, index);
  }
  const self = {
    measure
  };
  return self;
}
function EventStore() {
  let listeners = [];
  function add(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ("addEventListener" in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners.push(removeListener);
    return self;
  }
  function clear() {
    listeners = listeners.filter((remove) => remove());
  }
  const self = {
    add,
    clear
  };
  return self;
}
function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1e3 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, "visibilitychange", () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) {
      lastTimeStamp = timeStamp;
      update();
      update();
    }
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self = {
    init,
    destroy,
    start,
    stop,
    update,
    render
  };
  return self;
}
function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === "rtl";
  const isVertical = axis === "y";
  const scroll = isVertical ? "y" : "x";
  const cross = isVertical ? "x" : "y";
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return "top";
    return isRightToLeft ? "right" : "left";
  }
  function getEndEdge() {
    if (isVertical) return "bottom";
    return isRightToLeft ? "left" : "right";
  }
  function direction(n) {
    return n * sign;
  }
  const self = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self;
}
function Limit(min2 = 0, max2 = 0) {
  const length = mathAbs(min2 - max2);
  function reachedMin(n) {
    return n < min2;
  }
  function reachedMax(n) {
    return n > max2;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n)) return n;
    return reachedMin(n) ? min2 : max2;
  }
  function removeOffset(n) {
    if (!length) return n;
    return n - length * Math.ceil((n - max2) / length);
  }
  const self = {
    length,
    max: max2,
    min: min2,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self;
}
function Counter(max2, start, loop) {
  const {
    constrain
  } = Limit(0, max2);
  const loopEnd = max2 + 1;
  let counter4 = withinLimit(start);
  function withinLimit(n) {
    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
  }
  function get() {
    return counter4;
  }
  function set(n) {
    counter4 = withinLimit(n);
    return self;
  }
  function add(n) {
    return clone().set(get() + n);
  }
  function clone() {
    return Counter(max2, get(), loop);
  }
  const self = {
    get,
    set,
    add,
    clone
  };
  return self;
}
function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ["INPUT", "SELECT", "TEXTAREA"];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, "dragstart", (evt) => evt.preventDefault(), nonPassiveEvent).add(node, "touchmove", () => void 0, nonPassiveEvent).add(node, "touchend", () => void 0).add(node, "touchstart", downIfAllowed).add(node, "mousedown", downIfAllowed).add(node, "touchcancel", up).add(node, "contextmenu", up).add(node, "click", click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, "touchmove", move, nonPassiveEvent).add(node, "touchend", up).add(node, "mousemove", move, nonPassiveEvent).add(node, "mouseup", up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || "";
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? "mouse" : "touch";
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent2(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit("pointerDown");
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent2(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit("pointerUp");
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self = {
    init,
    destroy,
    pointerDown
  };
  return self;
}
function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === "x" ? "X" : "Y"}`;
    return (isMouseEvent2(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self;
}
function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset4 = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset4;
  }
  const self = {
    measure
  };
  return self;
}
function PercentOfView(viewSize) {
  function measure(n) {
    return viewSize * (n / 100);
  }
  const self = {
    measure
  };
  return self;
}
function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit("resize");
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver((entries) => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach((node) => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 1e-3;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n) {
    scrollDuration = n;
    return self;
  }
  function useFriction(n) {
    scrollFriction = n;
    return self;
  }
  const self = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self;
}
function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target.get())) return false;
    if (!limit.reachedAny(location.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location.get()) ? "min" : "max";
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self;
}
function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min2 = snapsBounded.lastIndexOf(startSnap);
    const max2 = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min2, max2);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index) => {
      const {
        min: min2,
        max: max2
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index;
      const isLast = arrayIsLastIndex(snapsAligned, index);
      if (isFirst) return max2;
      if (isLast) return min2;
      if (usePixelTolerance(min2, snap)) return min2;
      if (usePixelTolerance(max2, snap)) return max2;
      return snap;
    }).map((scrollBound) => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === "keepSnaps") return snapsBounded;
    const {
      min: min2,
      max: max2
    } = scrollContainLimit;
    return snapsBounded.slice(min2, max2);
  }
  const self = {
    snapsContained,
    scrollContainLimit
  };
  return self;
}
function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max2 = scrollSnaps[0];
  const min2 = loop ? max2 - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min2, max2);
  const self = {
    limit
  };
  return self;
}
function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min2 = limit.min + jointSafety;
  const max2 = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min2, max2);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location.get());
    if (direction === -1) return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach((v) => v.add(loopDistance));
  }
  const self = {
    loop
  };
  return self;
}
function ScrollProgress(limit) {
  const {
    max: max2,
    length
  } = limit;
  function get(n) {
    const currentLocation = n - max2;
    return length ? currentLocation / -length : 0;
  }
  const self = {
    get
  };
  return self;
}
function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments2 = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map((rect) => containerRect[startEdge] - rect[startEdge]).map((snap) => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map((g) => g[0]).map((snap, index) => snap + alignments2[index]);
  }
  const self = {
    snaps,
    snapsAligned
  };
  return self;
}
function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min: min2,
    max: max2
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === "keepSnaps";
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min2, max2).map((group, index, groups) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(groups, index);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self = {
    slideRegistry
  };
  return self;
}
function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index2) => ({
      diff: shortcut(snap - distance, 0),
      index: index2
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index
    } = ascDiffsToSnaps[0];
    return {
      index,
      distance
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop) return target;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter((t) => mathSign(t) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index, direction) {
    const diffToSnap = scrollSnaps[index] - targetVector.get();
    const distance = shortcut(diffToSnap, direction);
    return {
      index,
      distance
    };
  }
  function byDistance(distance, snap) {
    const target = targetVector.get() + distance;
    const {
      index,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound) return {
      index,
      distance
    };
    const diffToSnap = scrollSnaps[index] - targetSnapDistance;
    const snapDistance = distance + shortcut(diffToSnap, 0);
    return {
      index,
      distance: snapDistance
    };
  }
  const self = {
    byDistance,
    byIndex,
    shortcut
  };
  return self;
}
function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit("select");
    }
  }
  function distance(n, snap) {
    const target = scrollTarget.byDistance(n, snap);
    scrollTo(target);
  }
  function index(n, direction) {
    const targetIndex = indexCurrent.clone().set(n);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self = {
    distance,
    index
  };
  return self;
}
function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index) {
      const nowTime = (/* @__PURE__ */ new Date()).getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit("slideFocusStart");
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex((group2) => group2.includes(index));
      if (!isNumber(group)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit("slideFocus");
    }
    eventStore.add(document, "keydown", registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, "focus", (evt) => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === "Tab") lastTabPressTime = (/* @__PURE__ */ new Date()).getTime();
  }
  const self = {
    init
  };
  return self;
}
function Vector1D(initialValue) {
  let value = initialValue;
  function get() {
    return value;
  }
  function set(n) {
    value = normalizeInput(n);
  }
  function add(n) {
    value += normalizeInput(n);
  }
  function subtract(n) {
    value -= normalizeInput(n);
  }
  function normalizeInput(n) {
    return isNumber(n) ? n : n.get();
  }
  const self = {
    get,
    set,
    add,
    subtract
  };
  return self;
}
function Translate(axis, container) {
  const translate = axis.scroll === "x" ? x : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x(n) {
    return `translate3d(${n}px,0px,0px)`;
  }
  function y(n) {
    return `translate3d(0px,${n}px,0px)`;
  }
  function to(target) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = "";
    if (!container.getAttribute("style")) container.removeAttribute("style");
  }
  const self = {
    clear,
    to,
    toggleActive
  };
  return self;
}
function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset4) {
    return snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + roundingSafety + offset4,
      end: snap + viewSize - roundingSafety + offset4
    }));
  }
  function findLoopPoints(indexes, offset4, isEndEdge) {
    const slideBounds = findSlideBounds(offset4);
    return indexes.map((index) => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? "end" : "start";
      const loopPoint = slideBounds[index][boundEdge];
      return {
        index,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index
    }) => {
      const otherIndexes = ascItems.filter((i) => i !== index);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach((loopPoint) => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get()) return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach((loopPoint) => loopPoint.translate.clear());
  }
  const self = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self;
}
function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === "childList") {
          emblaApi.reInit();
          eventHandler.emit("slidesChanged");
          break;
        }
      }
    }
    mutationObserver = new MutationObserver((mutations) => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function SlidesInView(container, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver((entries) => {
      if (destroyed) return;
      entries.forEach((entry) => {
        const index = slides.indexOf(entry.target);
        intersectionEntryMap[index] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit("slidesInView");
    }, {
      root: container.parentElement,
      threshold
    });
    slides.forEach((slide) => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index);
      return list;
    }, []);
  }
  function get(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self = {
    init,
    destroy,
    get
  };
  return self;
}
function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(rects, index);
      if (isFirst) return slideSizes[index] + startGap;
      if (isLast) return slideSizes[index] + endGap;
      return rects[index + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self;
}
function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index, groups) => {
      const previousSize = Math.max(groups[index - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self = {
    groupSlides
  };
  return self;
}
function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index.clone();
  const slideIndexes = arrayKeys(slides);
  const update = ({
    dragHandler,
    scrollBody: scrollBody2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }) => {
    if (!loop2) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody2.seek();
  };
  const render = ({
    scrollBody: scrollBody2,
    translate,
    location: location2,
    offsetLocation: offsetLocation2,
    previousLocation: previousLocation2,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation: animation2,
    eventHandler: eventHandler2,
    scrollBounds,
    options: {
      loop: loop2
    }
  }, alpha) => {
    const shouldSettle = scrollBody2.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop2 ? shouldSettle : shouldSettle && withinBounds;
    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
    if (hasSettledAndIdle) animation2.stop();
    const interpolatedLocation = location2.get() * alpha + previousLocation2.get() * (1 - alpha);
    offsetLocation2.set(interpolatedLocation);
    if (loop2) {
      scrollLooper.loop(scrollBody2.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation2.get());
    if (hasSettledAndIdle) eventHandler2.emit("settle");
    if (!hasSettled) eventHandler2.emit("scroll");
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), (alpha) => render(engine, alpha));
  const friction = 0.68;
  const startLocation = scrollSnaps[index.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container)
  };
  return engine;
}
function EventHandler() {
  let listeners = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach((e) => e(api, evt));
    return self;
  }
  function on(evt, cb) {
    listeners[evt] = getListeners(evt).concat([cb]);
    return self;
  }
  function off(evt, cb) {
    listeners[evt] = getListeners(evt).filter((e) => e !== cb);
    return self;
  }
  function clear() {
    listeners = {};
  }
  const self = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self;
}
var defaultOptions2 = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};
function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia2 = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia2).filter((media) => ownerWindow.matchMedia(media).matches).map((media) => optionsAtMedia2[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map((options) => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self;
}
function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter((plugin) => plugin.destroy());
  }
  const self = {
    init,
    destroy
  };
  return self;
}
function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions2, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options2) {
    const engine2 = Engine(root, container, slides, ownerDocument, ownerWindow, options2, eventHandler);
    if (options2.loop && !engine2.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options2, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine2;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options: options2
    }) => options2)]).forEach((query) => mediaHandlers.add(query, "change", reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self);
    engine.eventHandler.init(self);
    engine.resizeHandler.init(self);
    engine.slidesHandler.init(self);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container.offsetParent && slides.length) engine.dragHandler.init(self);
    pluginApis = pluginsHandler.init(self, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit("reInit");
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit("destroy");
    eventHandler.clear();
  }
  function scrollTo(index, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit("init"), 0);
  return self;
}
EmblaCarousel.globalOptions = void 0;

// node_modules/@fluentui/react-carousel/lib/components/useEmblaCarousel.js
var React599 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCardStyles.styles.js
var carouselCardClassNames = {
  root: "fui-CarouselCard"
};
var useStyles88 = __styles2({
  root: {
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "fg68ejw",
    B2u0y6b: "f6dzj5z"
  },
  autoSize: {
    xawz: 0,
    Bh6795r: 0,
    Bnnss6s: 0,
    fkmc3a: "fd9q35j",
    Bf4jedk: "fy77jfu",
    a9b677: "f14z66ap",
    B2u0y6b: "f6dzj5z"
  },
  elevated: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1kijzfu",
    E5pizo: "f1hg901r",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  }
}, {
  d: [[".fg68ejw{flex:0 0 100%;}", {
    p: -1
  }], ".f6dzj5z{max-width:100%;}", [".fd9q35j{flex:0 0 auto;}", {
    p: -1
  }], ".fy77jfu{min-width:0;}", ".f14z66ap{width:auto;}", [".f1kijzfu{border-radius:var(--borderRadiusXLarge);}", {
    p: -1
  }], ".f1hg901r{box-shadow:var(--shadow16);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }]]
});
var useCarouselCardStyles_unstable = (state) => {
  "use no memo";
  const {
    autoSize
  } = state;
  const appearance = useCarouselContext_unstable2((context) => context.appearance);
  const styles = useStyles88();
  state.root.className = mergeClasses(carouselCardClassNames.root, styles.root, appearance === "elevated" && styles.elevated, autoSize && styles.autoSize, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSliderStyles.styles.js
var carouselSliderClassNames = {
  root: "fui-CarouselSlider"
};
var useStyles89 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Eiaeu8: "f1115ve7"
  },
  elevated: {
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1vkj2z1"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1115ve7{overflow-anchor:none;}", [".f1vkj2z1{gap:var(--spacingHorizontalXXL);}", {
    p: -1
  }]]
});
var useCarouselSliderStyles_unstable = (state) => {
  "use no memo";
  const appearance = useCarouselContext_unstable2((context) => context.appearance);
  const styles = useStyles89();
  state.root.className = mergeClasses(carouselSliderClassNames.root, styles.root, appearance === "elevated" && styles.elevated, state.root.className);
  return state;
};

// node_modules/embla-carousel-autoplay/esm/embla-carousel-autoplay.esm.js
var defaultOptions3 = {
  active: true,
  breakpoints: {},
  delay: 4e3,
  jump: false,
  playOnInit: true,
  stopOnFocusIn: true,
  stopOnInteraction: true,
  stopOnMouseEnter: false,
  stopOnLastSnap: false,
  rootNode: null
};
function normalizeDelay(emblaApi, delay) {
  const scrollSnaps = emblaApi.scrollSnapList();
  if (typeof delay === "number") {
    return scrollSnaps.map(() => delay);
  }
  return delay(scrollSnaps, emblaApi);
}
function getAutoplayRootNode(emblaApi, rootNode) {
  const emblaRootNode = emblaApi.rootNode();
  return rootNode && rootNode(emblaRootNode) || emblaRootNode;
}
function Autoplay(userOptions = {}) {
  let options;
  let emblaApi;
  let destroyed;
  let delay;
  let timerStartTime = null;
  let timerId = 0;
  let autoplayActive = false;
  let mouseIsOver = false;
  let playOnDocumentVisible = false;
  let jump = false;
  function init(emblaApiInstance, optionsHandler) {
    emblaApi = emblaApiInstance;
    const {
      mergeOptions,
      optionsAtMedia
    } = optionsHandler;
    const optionsBase = mergeOptions(defaultOptions3, Autoplay.globalOptions);
    const allOptions = mergeOptions(optionsBase, userOptions);
    options = optionsAtMedia(allOptions);
    if (emblaApi.scrollSnapList().length <= 1) return;
    jump = options.jump;
    destroyed = false;
    delay = normalizeDelay(emblaApi, options.delay);
    const {
      eventStore,
      ownerDocument
    } = emblaApi.internalEngine();
    const isDraggable = !!emblaApi.internalEngine().options.watchDrag;
    const root = getAutoplayRootNode(emblaApi, options.rootNode);
    eventStore.add(ownerDocument, "visibilitychange", visibilityChange);
    if (isDraggable) {
      emblaApi.on("pointerDown", pointerDown);
    }
    if (isDraggable && !options.stopOnInteraction) {
      emblaApi.on("pointerUp", pointerUp);
    }
    if (options.stopOnMouseEnter) {
      eventStore.add(root, "mouseenter", mouseEnter);
    }
    if (options.stopOnMouseEnter && !options.stopOnInteraction) {
      eventStore.add(root, "mouseleave", mouseLeave);
    }
    if (options.stopOnFocusIn) {
      emblaApi.on("slideFocusStart", stopAutoplay);
    }
    if (options.stopOnFocusIn && !options.stopOnInteraction) {
      eventStore.add(emblaApi.containerNode(), "focusout", startAutoplay);
    }
    if (options.playOnInit) startAutoplay();
  }
  function destroy() {
    emblaApi.off("pointerDown", pointerDown).off("pointerUp", pointerUp).off("slideFocusStart", stopAutoplay);
    stopAutoplay();
    destroyed = true;
    autoplayActive = false;
  }
  function setTimer() {
    const {
      ownerWindow
    } = emblaApi.internalEngine();
    ownerWindow.clearTimeout(timerId);
    timerId = ownerWindow.setTimeout(next, delay[emblaApi.selectedScrollSnap()]);
    timerStartTime = (/* @__PURE__ */ new Date()).getTime();
    emblaApi.emit("autoplay:timerset");
  }
  function clearTimer() {
    const {
      ownerWindow
    } = emblaApi.internalEngine();
    ownerWindow.clearTimeout(timerId);
    timerId = 0;
    timerStartTime = null;
    emblaApi.emit("autoplay:timerstopped");
  }
  function startAutoplay() {
    if (destroyed) return;
    if (documentIsHidden()) {
      playOnDocumentVisible = true;
      return;
    }
    if (!autoplayActive) emblaApi.emit("autoplay:play");
    setTimer();
    autoplayActive = true;
  }
  function stopAutoplay() {
    if (destroyed) return;
    if (autoplayActive) emblaApi.emit("autoplay:stop");
    clearTimer();
    autoplayActive = false;
  }
  function visibilityChange() {
    if (documentIsHidden()) {
      playOnDocumentVisible = autoplayActive;
      return stopAutoplay();
    }
    if (playOnDocumentVisible) startAutoplay();
  }
  function documentIsHidden() {
    const {
      ownerDocument
    } = emblaApi.internalEngine();
    return ownerDocument.visibilityState === "hidden";
  }
  function pointerDown() {
    if (!mouseIsOver) stopAutoplay();
  }
  function pointerUp() {
    if (!mouseIsOver) startAutoplay();
  }
  function mouseEnter() {
    mouseIsOver = true;
    stopAutoplay();
  }
  function mouseLeave() {
    mouseIsOver = false;
    startAutoplay();
  }
  function play(jumpOverride) {
    if (typeof jumpOverride !== "undefined") jump = jumpOverride;
    startAutoplay();
  }
  function stop() {
    if (autoplayActive) stopAutoplay();
  }
  function reset() {
    if (autoplayActive) startAutoplay();
  }
  function isPlaying() {
    return autoplayActive;
  }
  function next() {
    const {
      index
    } = emblaApi.internalEngine();
    const nextIndex = index.clone().add(1).get();
    const lastIndex = emblaApi.scrollSnapList().length - 1;
    const kill = options.stopOnLastSnap && nextIndex === lastIndex;
    if (emblaApi.canScrollNext()) {
      emblaApi.scrollNext(jump);
    } else {
      emblaApi.scrollTo(0, jump);
    }
    emblaApi.emit("autoplay:select");
    if (kill) return stopAutoplay();
    startAutoplay();
  }
  function timeUntilNext() {
    if (!timerStartTime) return null;
    const currentDelay = delay[emblaApi.selectedScrollSnap()];
    const timePastSinceStart = (/* @__PURE__ */ new Date()).getTime() - timerStartTime;
    return currentDelay - timePastSinceStart;
  }
  const self = {
    name: "autoplay",
    options: userOptions,
    init,
    destroy,
    play,
    stop,
    reset,
    isPlaying,
    timeUntilNext
  };
  return self;
}
Autoplay.globalOptions = void 0;

// node_modules/embla-carousel-fade/esm/embla-carousel-fade.esm.js
function clampNumber(number, min2, max2) {
  return Math.min(Math.max(number, min2), max2);
}
function isNumber2(value) {
  return typeof value === "number" && !isNaN(value);
}
function Fade2(userOptions = {}) {
  const fullOpacity = 1;
  const noOpacity = 0;
  const fadeFriction = 0.68;
  let emblaApi;
  let opacities = [];
  let fadeToNextDistance;
  let distanceFromPointerDown = 0;
  let fadeVelocity = 0;
  let progress = 0;
  let shouldFadePair = false;
  let defaultSettledBehaviour;
  let defaultProgressBehaviour;
  function init(emblaApiInstance) {
    emblaApi = emblaApiInstance;
    const selectedSnap = emblaApi.selectedScrollSnap();
    const {
      scrollBody,
      containerRect,
      axis
    } = emblaApi.internalEngine();
    const containerSize = axis.measureSize(containerRect);
    fadeToNextDistance = clampNumber(containerSize * 0.75, 200, 500);
    shouldFadePair = false;
    opacities = emblaApi.scrollSnapList().map((_, index) => index === selectedSnap ? fullOpacity : noOpacity);
    defaultSettledBehaviour = scrollBody.settled;
    defaultProgressBehaviour = emblaApi.scrollProgress;
    scrollBody.settled = settled;
    emblaApi.scrollProgress = scrollProgress;
    emblaApi.on("select", select).on("slideFocus", fadeToSelectedSnapInstantly).on("pointerDown", pointerDown).on("pointerUp", pointerUp);
    disableScroll();
    fadeToSelectedSnapInstantly();
  }
  function destroy() {
    const {
      scrollBody
    } = emblaApi.internalEngine();
    scrollBody.settled = defaultSettledBehaviour;
    emblaApi.scrollProgress = defaultProgressBehaviour;
    emblaApi.off("select", select).off("slideFocus", fadeToSelectedSnapInstantly).off("pointerDown", pointerDown).off("pointerUp", pointerUp);
    emblaApi.slideNodes().forEach((slideNode) => {
      const slideStyle = slideNode.style;
      slideStyle.opacity = "";
      slideStyle.transform = "";
      slideStyle.pointerEvents = "";
      if (!slideNode.getAttribute("style")) slideNode.removeAttribute("style");
    });
  }
  function fadeToSelectedSnapInstantly() {
    const selectedSnap = emblaApi.selectedScrollSnap();
    setOpacities(selectedSnap, fullOpacity);
  }
  function pointerUp() {
    shouldFadePair = false;
  }
  function pointerDown() {
    shouldFadePair = false;
    distanceFromPointerDown = 0;
    fadeVelocity = 0;
  }
  function select() {
    const duration = emblaApi.internalEngine().scrollBody.duration();
    fadeVelocity = duration ? 0 : fullOpacity;
    shouldFadePair = true;
    if (!duration) fadeToSelectedSnapInstantly();
  }
  function getSlideTransform(position) {
    const {
      axis
    } = emblaApi.internalEngine();
    const translateAxis = axis.scroll.toUpperCase();
    return `translate${translateAxis}(${axis.direction(position)}px)`;
  }
  function disableScroll() {
    const {
      translate,
      slideLooper
    } = emblaApi.internalEngine();
    translate.clear();
    translate.toggleActive(false);
    slideLooper.loopPoints.forEach(({
      translate: translate2
    }) => {
      translate2.clear();
      translate2.toggleActive(false);
    });
  }
  function lockExcessiveScroll(fadeIndex) {
    const {
      scrollSnaps,
      location,
      target
    } = emblaApi.internalEngine();
    if (!isNumber2(fadeIndex) || opacities[fadeIndex] < 0.5) return;
    location.set(scrollSnaps[fadeIndex]);
    target.set(location);
  }
  function setOpacities(fadeIndex, velocity) {
    const scrollSnaps = emblaApi.scrollSnapList();
    scrollSnaps.forEach((_, indexA) => {
      const absVelocity = Math.abs(velocity);
      const currentOpacity = opacities[indexA];
      const isFadeIndex = indexA === fadeIndex;
      const nextOpacity = isFadeIndex ? currentOpacity + absVelocity : currentOpacity - absVelocity;
      const clampedOpacity = clampNumber(nextOpacity, noOpacity, fullOpacity);
      opacities[indexA] = clampedOpacity;
      const fadePair = isFadeIndex && shouldFadePair;
      const indexB = emblaApi.previousScrollSnap();
      if (fadePair) opacities[indexB] = 1 - clampedOpacity;
      if (isFadeIndex) setProgress(fadeIndex, clampedOpacity);
      setOpacity(indexA);
    });
  }
  function setOpacity(index) {
    const slidesInSnap = emblaApi.internalEngine().slideRegistry[index];
    const {
      scrollSnaps,
      containerRect
    } = emblaApi.internalEngine();
    const opacity = opacities[index];
    slidesInSnap.forEach((slideIndex) => {
      const slideStyle = emblaApi.slideNodes()[slideIndex].style;
      const roundedOpacity = parseFloat(opacity.toFixed(2));
      const hasOpacity = roundedOpacity > noOpacity;
      const position = hasOpacity ? scrollSnaps[index] : containerRect.width + 2;
      const transform = getSlideTransform(position);
      if (hasOpacity) slideStyle.transform = transform;
      slideStyle.opacity = roundedOpacity.toString();
      slideStyle.pointerEvents = opacity > 0.5 ? "auto" : "none";
      if (!hasOpacity) slideStyle.transform = transform;
    });
  }
  function setProgress(fadeIndex, opacity) {
    const {
      index,
      dragHandler,
      scrollSnaps
    } = emblaApi.internalEngine();
    const pointerDown2 = dragHandler.pointerDown();
    const snapFraction = 1 / (scrollSnaps.length - 1);
    let indexA = fadeIndex;
    let indexB = pointerDown2 ? emblaApi.selectedScrollSnap() : emblaApi.previousScrollSnap();
    if (pointerDown2 && indexA === indexB) {
      const reverseSign = Math.sign(distanceFromPointerDown) * -1;
      indexA = indexB;
      indexB = index.clone().set(indexB).add(reverseSign).get();
    }
    const currentPosition = indexB * snapFraction;
    const diffPosition = (indexA - indexB) * snapFraction;
    progress = currentPosition + diffPosition * opacity;
  }
  function getFadeIndex() {
    const {
      dragHandler,
      index,
      scrollBody
    } = emblaApi.internalEngine();
    const selectedSnap = emblaApi.selectedScrollSnap();
    if (!dragHandler.pointerDown()) return selectedSnap;
    const directionSign = Math.sign(scrollBody.velocity());
    const distanceSign = Math.sign(distanceFromPointerDown);
    const nextSnap = index.clone().set(selectedSnap).add(directionSign * -1).get();
    if (!directionSign || !distanceSign) return null;
    return distanceSign === directionSign ? nextSnap : selectedSnap;
  }
  function fade(emblaApi2) {
    const {
      dragHandler,
      scrollBody
    } = emblaApi2.internalEngine();
    const pointerDown2 = dragHandler.pointerDown();
    const velocity = scrollBody.velocity();
    const duration = scrollBody.duration();
    const fadeIndex = getFadeIndex();
    const noFadeIndex = !isNumber2(fadeIndex);
    if (pointerDown2) {
      if (!velocity) return;
      distanceFromPointerDown += velocity;
      fadeVelocity = Math.abs(velocity / fadeToNextDistance);
      lockExcessiveScroll(fadeIndex);
    }
    if (!pointerDown2) {
      if (!duration || noFadeIndex) return;
      fadeVelocity += (fullOpacity - opacities[fadeIndex]) / duration;
      fadeVelocity *= fadeFriction;
    }
    if (noFadeIndex) return;
    setOpacities(fadeIndex, fadeVelocity);
  }
  function settled() {
    const {
      target,
      location
    } = emblaApi.internalEngine();
    const diffToTarget = target.get() - location.get();
    const notReachedTarget = Math.abs(diffToTarget) >= 1;
    const fadeIndex = getFadeIndex();
    const noFadeIndex = !isNumber2(fadeIndex);
    fade(emblaApi);
    if (noFadeIndex || notReachedTarget) return false;
    return opacities[fadeIndex] > 0.999;
  }
  function scrollProgress() {
    return progress;
  }
  const self = {
    name: "fade",
    options: userOptions,
    init,
    destroy
  };
  return self;
}
Fade2.globalOptions = void 0;

// node_modules/@fluentui/react-carousel/lib/components/pointerEvents.js
function pointerEventPlugin(options) {
  let emblaApi;
  let pointerEvent;
  let carouselListenerTarget;
  function documentDownListener(event) {
    if (event.target) {
      const targetNode = event.target;
      if (targetNode.classList.contains(carouselClassNames.root) || (carouselListenerTarget === null || carouselListenerTarget === void 0 ? void 0 : carouselListenerTarget.contains(targetNode))) {
        pointerEvent = event;
      }
    }
    if (carouselListenerTarget) {
      carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
      carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
    }
  }
  function pointerUpListener() {
    if (carouselListenerTarget) {
      carouselListenerTarget.addEventListener("mousedown", documentDownListener);
      carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
    }
  }
  function clearPointerEvent() {
    pointerEvent = void 0;
    pointerUpListener();
  }
  function selectListener() {
    if (pointerEvent) {
      var _emblaApi_selectedScrollSnap;
      const newIndex = (_emblaApi_selectedScrollSnap = emblaApi.selectedScrollSnap()) !== null && _emblaApi_selectedScrollSnap !== void 0 ? _emblaApi_selectedScrollSnap : 0;
      options.onSelectViaDrag(pointerEvent, newIndex);
    }
  }
  function init(emblaApiInstance, optionsHandler) {
    emblaApi = emblaApiInstance;
    carouselListenerTarget = emblaApi.containerNode();
    carouselListenerTarget.addEventListener("mousedown", documentDownListener);
    carouselListenerTarget.addEventListener("pointerdown", documentDownListener);
    emblaApi.on("pointerUp", pointerUpListener);
    emblaApi.on("select", selectListener);
    emblaApi.on("settle", clearPointerEvent);
  }
  function destroy() {
    if (carouselListenerTarget) {
      carouselListenerTarget.removeEventListener("mousedown", documentDownListener);
      carouselListenerTarget.removeEventListener("pointerdown", documentDownListener);
    }
    carouselListenerTarget = void 0;
    emblaApi.off("pointerUp", pointerUpListener);
    emblaApi.off("select", selectListener);
    emblaApi.off("settle", clearPointerEvent);
  }
  return {
    name: "pointerEvent",
    options,
    init,
    destroy
  };
}

// node_modules/@fluentui/react-carousel/lib/components/useEmblaCarousel.js
var sliderClassname = `.${carouselSliderClassNames.root}`;
var DEFAULT_EMBLA_OPTIONS = {
  containScroll: "trimSnaps",
  inViewThreshold: 0.99,
  watchDrag: false,
  skipSnaps: true,
  container: sliderClassname,
  slides: `.${carouselCardClassNames.root}`
};
var EMBLA_VISIBILITY_EVENT = "embla:visibilitychange";
function setTabsterDefault(element, isDefault) {
  const tabsterAttr = element.getAttribute("data-tabster");
  if (tabsterAttr) {
    const tabsterAttributes = JSON.parse(tabsterAttr);
    if (tabsterAttributes.focusable) {
      tabsterAttributes.focusable.isDefault = isDefault;
      element.setAttribute("data-tabster", JSON.stringify(tabsterAttributes));
    }
  }
}
function useEmblaCarousel(options) {
  const { align, autoplayInterval, direction, loop, slidesToScroll, watchDrag, containScroll, motion, onDragIndexChange, onAutoplayIndexChange } = options;
  var _motion_kind;
  const motionType = typeof motion === "string" ? motion : (_motion_kind = motion === null || motion === void 0 ? void 0 : motion.kind) !== null && _motion_kind !== void 0 ? _motion_kind : "slide";
  var _motion_duration;
  const motionDuration = typeof motion === "string" ? 25 : (_motion_duration = motion === null || motion === void 0 ? void 0 : motion.duration) !== null && _motion_duration !== void 0 ? _motion_duration : 25;
  const [activeIndex, setActiveIndex] = useControllableState({
    defaultState: options.defaultActiveIndex,
    state: options.activeIndex,
    initialState: 0
  });
  const onDragEvent = useEventCallback((event, index) => {
    onDragIndexChange === null || onDragIndexChange === void 0 ? void 0 : onDragIndexChange(event, {
      event,
      type: "drag",
      index
    });
  });
  const emblaOptions = React599.useRef({
    align,
    direction,
    loop,
    slidesToScroll,
    startIndex: activeIndex,
    watchDrag,
    containScroll,
    duration: motionDuration
  });
  const emblaApi = React599.useRef(null);
  const autoplayRef = React599.useRef(false);
  const resetAutoplay = React599.useCallback(() => {
    var _emblaApi_current_plugins_autoplay, _emblaApi_current;
    (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.reset();
  }, []);
  const getPlugins = React599.useCallback(() => {
    const plugins = [];
    plugins.push(Autoplay({
      playOnInit: autoplayRef.current,
      delay: autoplayInterval,
      /* stopOnInteraction: false causes autoplay to restart on interaction end*/
      /* we'll handle this logic to ensure autoplay state is respected */
      stopOnInteraction: true,
      stopOnFocusIn: false,
      stopOnMouseEnter: false
    }));
    if (motionType === "fade") {
      plugins.push(Fade2());
    }
    if (watchDrag) {
      plugins.push(pointerEventPlugin({
        onSelectViaDrag: onDragEvent
      }));
    }
    return plugins;
  }, [
    motionType,
    onDragEvent,
    watchDrag,
    autoplayInterval
  ]);
  const enableAutoplay = React599.useCallback((autoplay, temporary) => {
    if (!temporary) {
      autoplayRef.current = autoplay;
    }
    if (autoplay && autoplayRef.current) {
      var _emblaApi_current_plugins_autoplay, _emblaApi_current;
      (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.play();
      resetAutoplay();
    } else if (!autoplay) {
      var _emblaApi_current_plugins_autoplay1, _emblaApi_current1;
      (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay1 = _emblaApi_current1.plugins().autoplay) === null || _emblaApi_current_plugins_autoplay1 === void 0 ? void 0 : _emblaApi_current_plugins_autoplay1.stop();
    }
  }, [
    resetAutoplay
  ]);
  const listeners = React599.useRef(/* @__PURE__ */ new Set());
  const subscribeForValues = React599.useCallback((listener) => {
    listeners.current.add(listener);
    return () => {
      listeners.current.delete(listener);
    };
  }, []);
  const updateIndex = () => {
    var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _slideRegistry_newIndex;
    var _emblaApi_current_selectedScrollSnap;
    const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    const slides = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slideNodes();
    const slideRegistry = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideRegistry;
    var _slideRegistry_newIndex_;
    const actualIndex = (_slideRegistry_newIndex_ = slideRegistry === null || slideRegistry === void 0 ? void 0 : (_slideRegistry_newIndex = slideRegistry[newIndex]) === null || _slideRegistry_newIndex === void 0 ? void 0 : _slideRegistry_newIndex[0]) !== null && _slideRegistry_newIndex_ !== void 0 ? _slideRegistry_newIndex_ : 0;
    slides === null || slides === void 0 ? void 0 : slides.forEach((slide, slideIndex) => {
      setTabsterDefault(slide, slideIndex === actualIndex);
    });
    setActiveIndex(newIndex);
  };
  const handleReinit = useEventCallback(() => {
    var _emblaApi_current, _emblaApi_current1, _emblaApi_current2, _emblaApi_current3, _emblaApi_current4;
    var _emblaApi_current_slideNodes;
    const nodes = (_emblaApi_current_slideNodes = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes()) !== null && _emblaApi_current_slideNodes !== void 0 ? _emblaApi_current_slideNodes : [];
    var _emblaApi_current_internalEngine_slideRegistry;
    const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
    const navItemsCount = groupIndexList.length > 0 ? groupIndexList.length : nodes.length;
    const canLoop = (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.internalEngine().slideLooper.canLoop();
    var _emblaApi_current_selectedScrollSnap;
    const data = {
      navItemsCount,
      activeIndex: (_emblaApi_current_selectedScrollSnap = (_emblaApi_current3 = emblaApi.current) === null || _emblaApi_current3 === void 0 ? void 0 : _emblaApi_current3.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0,
      groupIndexList,
      slideNodes: nodes,
      canLoop
    };
    updateIndex();
    (_emblaApi_current4 = emblaApi.current) === null || _emblaApi_current4 === void 0 ? void 0 : _emblaApi_current4.scrollTo(activeIndex, false);
    for (const listener of listeners.current) {
      listener(data);
    }
  });
  const handleIndexChange = useEventCallback((_, eventType) => {
    var _emblaApi_current;
    var _emblaApi_current_selectedScrollSnap;
    const newIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    updateIndex();
    if (eventType === "autoplay:select") {
      const noopEvent = new Event("autoplay");
      onAutoplayIndexChange === null || onAutoplayIndexChange === void 0 ? void 0 : onAutoplayIndexChange(noopEvent, {
        event: noopEvent,
        type: "autoplay",
        index: newIndex
      });
    }
  });
  const viewportRef = React599.useRef(null);
  const containerRef = React599.useMemo(() => {
    const handleVisibilityChange = () => {
      var _emblaApi_current, _emblaApi_current1;
      const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
      var _emblaApi_current_slidesInView;
      const visibleIndexes = (_emblaApi_current_slidesInView = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.slidesInView()) !== null && _emblaApi_current_slidesInView !== void 0 ? _emblaApi_current_slidesInView : [];
      cardElements === null || cardElements === void 0 ? void 0 : cardElements.forEach((cardElement, index) => {
        cardElement.dispatchEvent(new CustomEvent(EMBLA_VISIBILITY_EVENT, {
          bubbles: false,
          detail: {
            isVisible: visibleIndexes.includes(index)
          }
        }));
      });
    };
    const plugins = getPlugins();
    return {
      set current(newElement) {
        if (emblaApi.current) {
          var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current;
          (_emblaApi_current_plugins = (_emblaApi_current = emblaApi.current).plugins) === null || _emblaApi_current_plugins === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.stop();
          emblaApi.current.off("slidesInView", handleVisibilityChange);
          emblaApi.current.off("select", handleIndexChange);
          emblaApi.current.off("reInit", handleReinit);
          emblaApi.current.off("autoplay:select", handleIndexChange);
          emblaApi.current.destroy();
          emblaApi.current = null;
        }
        if (newElement) {
          var _viewportRef_current;
          const newEmblaApi = EmblaCarousel((_viewportRef_current = viewportRef.current) !== null && _viewportRef_current !== void 0 ? _viewportRef_current : newElement, {
            ...DEFAULT_EMBLA_OPTIONS,
            ...emblaOptions.current
          }, plugins);
          newEmblaApi.on("reInit", handleReinit);
          newEmblaApi.on("slidesInView", handleVisibilityChange);
          newEmblaApi.on("select", handleIndexChange);
          newEmblaApi.on("autoplay:select", handleIndexChange);
          emblaApi.current = newEmblaApi;
        }
      }
    };
  }, [
    getPlugins,
    handleIndexChange,
    handleReinit
  ]);
  const carouselApi = React599.useMemo(() => ({
    scrollToElement: (element, jump) => {
      var _emblaApi_current, _emblaApi_current1, _emblaApi_current2;
      const cardElements = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.slideNodes();
      var _emblaApi_current_internalEngine_slideRegistry;
      const groupIndexList = (_emblaApi_current_internalEngine_slideRegistry = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.internalEngine().slideRegistry) !== null && _emblaApi_current_internalEngine_slideRegistry !== void 0 ? _emblaApi_current_internalEngine_slideRegistry : [];
      var _cardElements_indexOf;
      const cardIndex = (_cardElements_indexOf = cardElements === null || cardElements === void 0 ? void 0 : cardElements.indexOf(element)) !== null && _cardElements_indexOf !== void 0 ? _cardElements_indexOf : 0;
      const groupIndex = groupIndexList.findIndex((group) => {
        return group.includes(cardIndex);
      });
      const indexFocus = groupIndex !== null && groupIndex !== void 0 ? groupIndex : cardIndex;
      (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollTo(indexFocus, jump);
      return indexFocus;
    },
    scrollToIndex: (index, jump) => {
      var _emblaApi_current;
      (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.scrollTo(index, jump);
    },
    scrollInDirection: (dir) => {
      var _emblaApi_current;
      if (dir === "prev") {
        var _emblaApi_current1;
        (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.scrollPrev();
      } else {
        var _emblaApi_current2;
        (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollNext();
      }
      var _emblaApi_current_selectedScrollSnap;
      return (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    }
  }), []);
  React599.useEffect(() => {
    var _emblaApi_current_plugins_autoplay, _emblaApi_current_plugins, _emblaApi_current, _emblaApi_current1;
    const plugins = getPlugins();
    emblaOptions.current = {
      startIndex: emblaOptions.current.startIndex,
      align,
      direction,
      loop,
      slidesToScroll,
      watchDrag,
      containScroll,
      duration: motionDuration
    };
    (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : (_emblaApi_current_plugins = _emblaApi_current.plugins) === null || _emblaApi_current_plugins === void 0 ? void 0 : (_emblaApi_current_plugins_autoplay = _emblaApi_current_plugins.call(_emblaApi_current).autoplay) === null || _emblaApi_current_plugins_autoplay === void 0 ? void 0 : _emblaApi_current_plugins_autoplay.stop();
    (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : _emblaApi_current1.reInit({
      ...DEFAULT_EMBLA_OPTIONS,
      ...emblaOptions.current
    }, plugins);
  }, [
    align,
    containScroll,
    direction,
    getPlugins,
    loop,
    slidesToScroll,
    watchDrag,
    motionDuration
  ]);
  React599.useEffect(() => {
    var _emblaApi_current, _emblaApi_current_slideNodes, _emblaApi_current1;
    var _emblaApi_current_selectedScrollSnap;
    const currentActiveIndex = (_emblaApi_current_selectedScrollSnap = (_emblaApi_current = emblaApi.current) === null || _emblaApi_current === void 0 ? void 0 : _emblaApi_current.selectedScrollSnap()) !== null && _emblaApi_current_selectedScrollSnap !== void 0 ? _emblaApi_current_selectedScrollSnap : 0;
    var _emblaApi_current_slideNodes_length;
    const slideLength = (_emblaApi_current_slideNodes_length = (_emblaApi_current1 = emblaApi.current) === null || _emblaApi_current1 === void 0 ? void 0 : (_emblaApi_current_slideNodes = _emblaApi_current1.slideNodes()) === null || _emblaApi_current_slideNodes === void 0 ? void 0 : _emblaApi_current_slideNodes.length) !== null && _emblaApi_current_slideNodes_length !== void 0 ? _emblaApi_current_slideNodes_length : 0;
    emblaOptions.current.startIndex = activeIndex;
    if (activeIndex < slideLength && activeIndex !== currentActiveIndex) {
      var _emblaApi_current2;
      (_emblaApi_current2 = emblaApi.current) === null || _emblaApi_current2 === void 0 ? void 0 : _emblaApi_current2.scrollTo(activeIndex);
    }
  }, [
    activeIndex
  ]);
  return {
    activeIndex,
    carouselApi,
    viewportRef,
    containerRef,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarousel.js
function useCarousel_unstable2(props, ref) {
  "use no memo";
  const { align = "center", circular = false, onActiveIndexChange, groupSize = "auto", draggable = false, whitespace = false, announcement, motion = "slide", autoplayInterval = 4e3, appearance = "flat" } = props;
  const { dir } = useFluent();
  const { activeIndex, carouselApi, containerRef, viewportRef, subscribeForValues, enableAutoplay, resetAutoplay } = useEmblaCarousel({
    align,
    direction: dir,
    loop: circular,
    slidesToScroll: groupSize,
    defaultActiveIndex: props.defaultActiveIndex,
    activeIndex: props.activeIndex,
    watchDrag: draggable,
    containScroll: whitespace ? false : "keepSnaps",
    motion,
    onDragIndexChange: onActiveIndexChange,
    onAutoplayIndexChange: onActiveIndexChange,
    autoplayInterval
  });
  const selectPageByElement = useEventCallback((event, element, jump) => {
    const foundIndex = carouselApi.scrollToElement(element, jump);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "focus",
      index: foundIndex
    });
    return foundIndex;
  });
  const selectPageByIndex = useEventCallback((event, index, jump) => {
    carouselApi.scrollToIndex(index, jump);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "click",
      index
    });
  });
  const selectPageByDirection = useEventCallback((event, direction) => {
    const nextPageIndex = carouselApi.scrollInDirection(direction);
    onActiveIndexChange === null || onActiveIndexChange === void 0 ? void 0 : onActiveIndexChange(event, {
      event,
      type: "click",
      index: nextPageIndex
    });
    return nextPageIndex;
  });
  const mergedContainerRef = useMergedRefs(ref, containerRef);
  const announcementTextRef = React600.useRef("");
  const totalNavLength = React600.useRef(0);
  const navGroupRef = React600.useRef([]);
  const { announce } = useAnnounce();
  const updateAnnouncement = useEventCallback(() => {
    if (totalNavLength.current <= 0 || !announcement) {
      return;
    }
    const announcementText = announcement(activeIndex, totalNavLength.current, navGroupRef.current);
    if (announcementText !== announcementTextRef.current) {
      announcementTextRef.current = announcementText;
      announce(announcementText, {
        polite: true
      });
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      if (totalNavLength.current <= 0 && data.navItemsCount > 0 && announcement) {
        const announcementText = announcement(data.activeIndex, data.navItemsCount, data.groupIndexList);
        announcementTextRef.current = announcementText;
      }
      totalNavLength.current = data.navItemsCount;
      navGroupRef.current = data.groupIndexList;
      updateAnnouncement();
    });
  }, [
    subscribeForValues,
    updateAnnouncement,
    announcement
  ]);
  useIsomorphicLayoutEffect(() => {
    updateAnnouncement();
  }, [
    activeIndex,
    updateAnnouncement
  ]);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: mergedContainerRef,
      role: "region",
      ...props
    }), {
      elementType: "div"
    }),
    activeIndex,
    appearance,
    circular,
    containerRef: mergedContainerRef,
    viewportRef,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/renderCarousel.js
var renderCarousel_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselProvider2, {
    value: contextValues.carousel,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselStyles.styles.js
var carouselClassNames = {
  root: "fui-Carousel"
};
var useStyles90 = __styles2({
  root: {
    B68tc82: "f1p9o1ba",
    Eiaeu8: "f1115ve7",
    qhf8xq: "f10pi13n"
  },
  elevated: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "flfurxc",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f16dxoy8"
  }
}, {
  d: [".f1p9o1ba{overflow-x:hidden;}", ".f1115ve7{overflow-anchor:none;}", ".f10pi13n{position:relative;}", [".flfurxc{margin:var(--spacingVerticalL);}", {
    p: -1
  }], [".f16dxoy8{padding:var(--spacingVerticalL);}", {
    p: -1
  }]]
});
var useCarouselStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles90();
  const {
    appearance
  } = state;
  state.root.className = mergeClasses(carouselClassNames.root, styles.root, appearance === "elevated" && styles.elevated, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/Carousel/useCarouselContextValues.js
var React601 = __toESM(require_react());
function useCarouselContextValues_unstable(state) {
  const { activeIndex, appearance, selectPageByElement, selectPageByDirection, selectPageByIndex, subscribeForValues, enableAutoplay, resetAutoplay, circular, containerRef, viewportRef } = state;
  const carousel = React601.useMemo(() => ({
    activeIndex,
    appearance,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay,
    circular,
    containerRef,
    viewportRef
  }), [
    activeIndex,
    appearance,
    selectPageByElement,
    selectPageByDirection,
    selectPageByIndex,
    subscribeForValues,
    enableAutoplay,
    resetAutoplay,
    circular,
    containerRef,
    viewportRef
  ]);
  return {
    carousel
  };
}

// node_modules/@fluentui/react-carousel/lib/components/Carousel/Carousel.js
var Carousel = React602.forwardRef((props, ref) => {
  const state = useCarousel_unstable2(props, ref);
  useCarouselStyles_unstable(state);
  useCustomStyleHook("useCarouselStyles_unstable")(state);
  const contextValues = useCarouselContextValues_unstable(state);
  return renderCarousel_unstable(state, contextValues);
});
Carousel.displayName = "Carousel";

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/CarouselCard.js
var React605 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCard.js
var React604 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSliderContext.js
var React603 = __toESM(require_react());
var carouselSliderContext = React603.createContext(void 0);
var carouselSliderContextDefaultValue = {
  cardFocus: false
};
var useCarouselSliderContext = () => {
  var _React_useContext;
  return (_React_useContext = React603.useContext(carouselSliderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : carouselSliderContextDefaultValue;
};
var CarouselSliderContextProvider = carouselSliderContext.Provider;
function useCarouselSliderContextValues_unstable(state) {
  const { cardFocus } = state;
  const carouselSlider = React603.useMemo(() => ({
    cardFocus
  }), [
    cardFocus
  ]);
  return {
    carouselSlider
  };
}

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/useCarouselCard.js
var useCarouselCard_unstable = (props, ref) => {
  const { autoSize } = props;
  const elementRef = React604.useRef(null);
  const isMouseEvent3 = React604.useRef(false);
  const selectPageByElement = useCarouselContext_unstable2((ctx) => ctx.selectPageByElement);
  const containerRef = useCarouselContext_unstable2((ctx) => ctx.containerRef);
  const { cardFocus } = useCarouselSliderContext();
  const focusAttr = useFocusableGroup({
    tabBehavior: "limited"
  });
  const focusAttrProps = cardFocus ? {
    ...focusAttr,
    tabIndex: 0
  } : {};
  const id = useId2(carouselCardClassNames.root, props.id);
  React604.useEffect(() => {
    const element = elementRef.current;
    if (element) {
      const listener = (_e) => {
        const event = _e;
        if (!cardFocus) {
          const hidden = !event.detail.isVisible;
          element.ariaHidden = hidden.toString();
          element.inert = hidden;
        }
      };
      element.addEventListener(EMBLA_VISIBILITY_EVENT, listener);
      return () => {
        element.removeEventListener(EMBLA_VISIBILITY_EVENT, listener);
      };
    }
  }, [
    cardFocus
  ]);
  const handleFocus = React604.useCallback((e) => {
    if (!e.defaultPrevented && isHTMLElement(e.currentTarget) && !isMouseEvent3.current) {
      var _containerRef_current;
      containerRef === null || containerRef === void 0 ? void 0 : (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.scrollTo(0, 0);
      selectPageByElement(e, e.currentTarget, false);
    }
    isMouseEvent3.current = false;
  }, [
    selectPageByElement,
    containerRef
  ]);
  const handlePointerDown = (e) => {
    if (!e.defaultPrevented) {
      isMouseEvent3.current = true;
    }
  };
  const handlePointerUp = (e) => {
    if (!e.defaultPrevented) {
      isMouseEvent3.current = false;
    }
  };
  const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocus);
  const onPointerUp = mergeCallbacks(props.onPointerUp, handlePointerUp);
  const onPointerDown = mergeCallbacks(props.onPointerDown, handlePointerDown);
  const state = {
    autoSize,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(elementRef, ref),
      role: "tabpanel",
      tabIndex: cardFocus ? 0 : void 0,
      ...props,
      id,
      onFocusCapture,
      onPointerUp,
      onPointerDown,
      ...focusAttrProps
    }), {
      elementType: "div"
    })
  };
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/renderCarouselCard.js
var renderCarouselCard_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselCard/CarouselCard.js
var CarouselCard = React605.forwardRef((props, ref) => {
  const state = useCarouselCard_unstable(props, ref);
  useCarouselCardStyles_unstable(state);
  useCustomStyleHook("useCarouselCardStyles_unstable")(state);
  return renderCarouselCard_unstable(state);
});
CarouselCard.displayName = "CarouselCard";

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/CarouselAutoplayButton.js
var React607 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButton.js
var React606 = __toESM(require_react());
var useCarouselAutoplayButton_unstable = (props, ref) => {
  const { onCheckedChange, checked, defaultChecked } = props;
  const [autoplay, setAutoplay] = useControllableState({
    state: checked,
    defaultState: defaultChecked,
    initialState: false
  });
  const enableAutoplay = useCarouselContext_unstable2((ctx) => ctx.enableAutoplay);
  React606.useEffect(() => {
    enableAutoplay(autoplay);
    return () => {
      enableAutoplay(false);
    };
  }, [
    autoplay,
    enableAutoplay
  ]);
  const handleClick = (event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    const newValue = !autoplay;
    setAutoplay(newValue);
    onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(event, {
      event,
      type: "click",
      checked: newValue
    });
  };
  return {
    // We lean on react-button class to handle styling and icon enhancements
    ...useToggleButton_unstable({
      icon: slot_exports.optional(props.icon, {
        defaultProps: {
          children: autoplay ? React606.createElement(PauseCircleRegular, null) : React606.createElement(PlayCircleRegular, null)
        },
        renderByDefault: true,
        elementType: "span"
      }),
      ...props,
      checked: autoplay,
      onClick: useEventCallback(mergeCallbacks(handleClick, props.onClick))
    }, ref)
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/renderCarouselAutoplayButton.js
var renderCarouselAutoplayButton_unstable = (state) => {
  assertSlots(state);
  return renderButton_unstable(state);
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/useCarouselAutoplayButtonStyles.styles.js
var carouselAutoplayButtonClassNames = {
  root: "fui-CarouselAutoplayButton",
  icon: "fui-CarouselAutoplayButton__icon"
};
var useStyles91 = __styles2({
  root: {
    Bkecrkj: "fc5wo7j",
    B6of3ja: "fgr6219",
    jrapky: "f10jk5vf",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    sj55zd: "fkfq4zb",
    De3pzq: "fkfdr9r",
    eoavqd: "f8491dx"
  }
}, {
  d: [".fc5wo7j{pointer-events:all;}", ".fgr6219{margin-top:auto;}", ".f10jk5vf{margin-bottom:auto;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".fkfdr9r{background-color:var(--colorNeutralBackgroundAlpha);}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselAutoplayButtonStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles91();
  useToggleButtonStyles_unstable(state);
  state.root.className = mergeClasses(carouselAutoplayButtonClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(carouselAutoplayButtonClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselAutoplayButton/CarouselAutoplayButton.js
var CarouselAutoplayButton = React607.forwardRef((props, ref) => {
  const state = useCarouselAutoplayButton_unstable(props, ref);
  useCarouselAutoplayButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselAutoplayButtonStyles_unstable")(state);
  return renderCarouselAutoplayButton_unstable(state);
});
CarouselAutoplayButton.displayName = "CarouselAutoplayButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/CarouselNavImageButton.js
var React609 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButton.js
var React608 = __toESM(require_react());
var useCarouselNavImageButton_unstable = (props, ref) => {
  const { onClick, as = "button" } = props;
  const index = useCarouselNavIndexContext();
  const selectPageByIndex = useCarouselContext_unstable2((ctx) => ctx.selectPageByIndex);
  const selected = useCarouselContext_unstable2((ctx) => ctx.activeIndex === index);
  const subscribeForValues = useCarouselContext_unstable2((ctx) => ctx.subscribeForValues);
  const handleClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      selectPageByIndex(event, index);
    }
  });
  const defaultTabProps = useTabsterAttributes({
    focusable: {
      isDefault: selected
    }
  });
  const buttonRef = React608.useRef(void 0);
  const _carouselButton = slot_exports.always(getIntrinsicElementProps(as, useARIAButtonProps(props.as, props)), {
    elementType: "button",
    defaultProps: {
      ref: useMergedRefs(ref, buttonRef),
      role: "tab",
      type: "button",
      "aria-selected": selected,
      ...defaultTabProps
    }
  });
  useIsomorphicLayoutEffect(() => {
    return subscribeForValues((data) => {
      var _data_groupIndexList;
      var _data_groupIndexList_index;
      const controlList = (_data_groupIndexList_index = (_data_groupIndexList = data.groupIndexList) === null || _data_groupIndexList === void 0 ? void 0 : _data_groupIndexList[index]) !== null && _data_groupIndexList_index !== void 0 ? _data_groupIndexList_index : [];
      const _controlledSlideIds = controlList.map((slideIndex) => {
        return data.slideNodes[slideIndex].id;
      }).join(" ");
      if (buttonRef.current) {
        buttonRef.current.setAttribute("aria-controls", _controlledSlideIds);
      }
    });
  }, [
    subscribeForValues,
    index
  ]);
  _carouselButton.onClick = handleClick;
  const image = slot_exports.always(getIntrinsicElementProps("img", {
    "aria-hidden": true,
    alt: "",
    role: "presentation",
    ...props.image
  }), {
    elementType: "img"
  });
  return {
    components: {
      root: "button",
      image: "img"
    },
    root: _carouselButton,
    image,
    selected
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/renderCarouselNavImageButton.js
var renderCarouselNavImageButton_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsx(state.image, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/useCarouselNavImageButtonStyles.styles.js
var carouselNavImageButtonClassNames = {
  root: "fui-CarouselNavImageButton",
  image: "fui-CarouselNavImageButton__image"
};
var useStyles92 = __styles2({
  root: {
    B7ck84d: "f1e4lqlz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1c5fvqg",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f186qr3g",
    g2u3we: "fghlq4f",
    h3c5rm: ["f1gn591s", "fjscplz"],
    B9xav0g: "fb073pr",
    zhjwy3: ["fjscplz", "f1gn591s"],
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91",
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    eoavqd: "f8491dx"
  },
  image: {
    a9b677: "feqmc2u",
    Bqenvij: "fbhnoac",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "fq9zq91"
  },
  selected: {
    a9b677: "f124akge",
    Bqenvij: "ff2sm71"
  }
}, {
  d: [".f1e4lqlz{box-sizing:content-box;}", [".f1c5fvqg{padding:0px;}", {
    p: -1
  }], [".f186qr3g{margin:0 var(--spacingHorizontalXS);}", {
    p: -1
  }], ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".fq9zq91{border-radius:var(--borderRadiusSmall);}", {
    p: -1
  }], ".f124akge{width:48px;}", ".ff2sm71{height:48px;}"],
  h: [".f8491dx:hover{cursor:pointer;}"]
});
var useCarouselNavImageButtonStyles_unstable = (state) => {
  "use no memo";
  const {
    selected
  } = state;
  const styles = useStyles92();
  state.root.className = mergeClasses(carouselNavImageButtonClassNames.root, styles.root, selected && styles.selected, state.root.className);
  if (state.image) {
    var _state_image;
    state.image.className = mergeClasses(carouselNavImageButtonClassNames.image, styles.image, selected && styles.selected, (_state_image = state.image) === null || _state_image === void 0 ? void 0 : _state_image.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavImageButton/CarouselNavImageButton.js
var CarouselNavImageButton = React609.forwardRef((props, ref) => {
  const state = useCarouselNavImageButton_unstable(props, ref);
  useCarouselNavImageButtonStyles_unstable(state);
  useCustomStyleHook("useCarouselNavImageButtonStyles_unstable")(state);
  return renderCarouselNavImageButton_unstable(state);
});
CarouselNavImageButton.displayName = "CarouselNavImageButton";

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSlider.js
var React611 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/useCarouselSlider.js
var React610 = __toESM(require_react());
var useCarouselSlider_unstable = (props, ref) => {
  const { cardFocus = false } = props;
  const circular = useCarouselContext_unstable2((ctx) => ctx.circular);
  const focusableGroupAttr = useArrowNavigationGroup({
    circular,
    axis: "horizontal",
    memorizeCurrent: false,
    // eslint-disable-next-line @typescript-eslint/naming-convention
    unstable_hasDefault: true
  });
  const focusProps = cardFocus ? focusableGroupAttr : {};
  return {
    cardFocus,
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      role: "group",
      ...props,
      ...focusProps
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/renderCarouselSlider.js
var renderCarouselSlider_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselSliderContextProvider, {
    value: contextValues.carouselSlider,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselSlider/CarouselSlider.js
var CarouselSlider = React611.forwardRef((props, ref) => {
  const state = useCarouselSlider_unstable(props, ref);
  useCarouselSliderStyles_unstable(state);
  useCustomStyleHook("useCarouselSliderStyles_unstable")(state);
  const context = useCarouselSliderContextValues_unstable(state);
  return renderCarouselSlider_unstable(state, context);
});
CarouselSlider.displayName = "CarouselSlider";

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/CarouselNavContainer.js
var React613 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainer.js
var React612 = __toESM(require_react());
var useCarouselNavContainer_unstable = (props, ref) => {
  const { layout } = props;
  const next = slot_exports.optional(props.next, {
    defaultProps: {
      navType: "next"
    },
    elementType: CarouselButton,
    renderByDefault: true
  });
  const prev = slot_exports.optional(props.prev, {
    defaultProps: {
      navType: "prev"
    },
    elementType: CarouselButton,
    renderByDefault: true
  });
  const autoplay = slot_exports.optional(props.autoplay, {
    elementType: CarouselAutoplayButton,
    renderByDefault: !!props.autoplay || !!props.autoplayTooltip
  });
  const nextTooltip = slot_exports.optional(props.nextTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  const prevTooltip = slot_exports.optional(props.prevTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  const autoplayTooltip = slot_exports.optional(props.autoplayTooltip, {
    defaultProps: {},
    elementType: Tooltip,
    renderByDefault: false
  });
  return {
    layout,
    components: {
      root: "div",
      next: CarouselButton,
      prev: CarouselButton,
      autoplay: CarouselAutoplayButton,
      nextTooltip: Tooltip,
      prevTooltip: Tooltip,
      autoplayTooltip: Tooltip
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    next,
    prev,
    autoplay,
    nextTooltip,
    prevTooltip,
    autoplayTooltip
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/renderCarouselNavContainer.js
var renderCarouselNavContainer_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      !state.autoplayTooltip && state.autoplay && jsx(state.autoplay, {}),
      state.autoplayTooltip && state.autoplay && jsx(state.autoplayTooltip, {
        children: jsx(state.autoplay, {})
      }),
      !state.prevTooltip && state.prev && jsx(state.prev, {}),
      state.prevTooltip && state.prev && jsx(state.prevTooltip, {
        children: jsx(state.prev, {})
      }),
      state.root.children,
      !state.nextTooltip && state.next && jsx(state.next, {}),
      state.nextTooltip && state.next && jsx(state.nextTooltip, {
        children: jsx(state.next, {})
      })
    ]
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/useCarouselNavContainerStyles.styles.js
var carouselNavContainerClassNames = {
  root: "fui-CarouselNavContainer",
  next: "fui-CarouselNavContainer__next",
  prev: "fui-CarouselNavContainer__prev",
  autoplay: "fui-CarouselNavContainer__autoplay",
  /* Tooltip classNames are listed for type compatibility only (cannot assign root className to portal)
  * Use 'content' slot to style Tooltip content instead
  */
  nextTooltip: "fui-CarouselNavContainer__nextTooltip",
  prevTooltip: "fui-CarouselNavContainer__prevTooltip",
  autoplayTooltip: "fui-CarouselNavContainer__autoplayTooltip"
};
var useStyles93 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1063pyq",
    Brf1p80: "f4d9j23",
    a9b677: "fly5x3f",
    Bkecrkj: "f1aehjj5"
  },
  next: {},
  prev: {},
  autoplay: {},
  inline: {
    B6of3ja: "f1mevb6"
  },
  overlay: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f1bu4tuc",
    B7ck84d: "f1ewtqcl"
  },
  overlayWide: {
    B5kzvoi: "f1bu4tuc"
  },
  nextWide: {
    Frg6f3: ["fcgxt0o", "f1ujusj6"]
  },
  prevWide: {
    t21cq0: ["f1ujusj6", "fcgxt0o"]
  },
  nextOverlayWide: {
    t21cq0: ["fkujibs", "f199hnxi"]
  },
  prevOverlayWide: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  },
  autoplayOverlayWide: {
    Frg6f3: ["f199hnxi", "fkujibs"]
  },
  expanded: {
    a9b677: "fly5x3f",
    Bqenvij: "f1l02sjl",
    Bt984gj: "fgs5rwf",
    Brf1p80: "f4d9j23",
    B5kzvoi: "f1yab3r1",
    c7y7m3: "f1ok8cdc",
    yx0ijg: "fcq6x80",
    v4amzz: "f1gy9d85"
  },
  nextOverlayExpanded: {
    qhf8xq: "f1euv43f",
    j35jbq: ["f8b87gs", "fedtrts"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x"
  },
  prevOverlayExpanded: {
    qhf8xq: "f1euv43f",
    oyh7mz: ["fedtrts", "f8b87gs"],
    Bhzewxz: "f1i1t8d1",
    Bz10aip: "f188r07x"
  },
  autoplayExpanded: {
    qhf8xq: "f1euv43f",
    B5kzvoi: "f49tsn4",
    oyh7mz: ["fedtrts", "f8b87gs"],
    jrapky: "f18zxyen"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".f4d9j23{justify-content:center;}", ".fly5x3f{width:100%;}", ".f1aehjj5{pointer-events:none;}", ".f1mevb6{margin-top:var(--spacingVerticalM);}", ".f1euv43f{position:absolute;}", ".f1bu4tuc{bottom:var(--spacingVerticalM);}", ".f1ewtqcl{box-sizing:border-box;}", ".fcgxt0o{margin-left:auto;}", ".f1ujusj6{margin-right:auto;}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f1l02sjl{height:100%;}", ".fgs5rwf{align-items:flex-end;}", ".f1yab3r1{bottom:0;}", ".f1ok8cdc>div{position:relative;}", ".fcq6x80>div{bottom:var(--spacingVerticalL);}", ".f1gy9d85>div{margin-bottom:0;}", ".f8b87gs{right:var(--spacingHorizontalM);}", ".fedtrts{left:var(--spacingHorizontalM);}", ".f1i1t8d1{top:50%;}", ".f188r07x{transform:translateY(-50%);}", ".f49tsn4{bottom:-var(--spacingHorizontalXS);}", ".f18zxyen{margin-bottom:var(--spacingVerticalM);}"]
});
var useCarouselNavContainerStyles_unstable = (state) => {
  "use no memo";
  const {
    layout
  } = state;
  const isOverlay = layout === "overlay" || layout === "overlay-wide" || layout === "overlay-expanded";
  const isWide = layout === "inline-wide" || layout === "overlay-wide";
  const styles = useStyles93();
  state.root.className = mergeClasses(carouselNavContainerClassNames.root, styles.root, isOverlay ? styles.overlay : styles.inline, isOverlay && isWide && styles.overlayWide, layout === "overlay-expanded" && styles.expanded, state.root.className);
  if (state.next) {
    state.next.className = mergeClasses(carouselNavContainerClassNames.next, styles.next, isWide && styles.nextWide, isWide && isOverlay && styles.nextOverlayWide, layout === "overlay-expanded" && styles.nextOverlayExpanded, state.next.className);
  }
  if (state.prev) {
    state.prev.className = mergeClasses(carouselNavContainerClassNames.prev, styles.prev, isWide && styles.prevWide, !state.autoplay && isWide && isOverlay && styles.prevOverlayWide, layout === "overlay-expanded" && styles.prevOverlayExpanded, state.prev.className);
  }
  if (state.autoplay) {
    state.autoplay.className = mergeClasses(carouselNavContainerClassNames.autoplay, styles.autoplay, layout === "overlay-expanded" && styles.autoplayExpanded, isWide && isOverlay && styles.autoplayOverlayWide, state.autoplay.className);
  }
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselNavContainer/CarouselNavContainer.js
var CarouselNavContainer = React613.forwardRef((props, ref) => {
  const state = useCarouselNavContainer_unstable(props, ref);
  useCarouselNavContainerStyles_unstable(state);
  useCustomStyleHook("useCarouselNavContainerStyles_unstable")(state);
  return renderCarouselNavContainer_unstable(state);
});
CarouselNavContainer.displayName = "CarouselNavContainer";

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/CarouselViewport.js
var React615 = __toESM(require_react());

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewport.js
var React614 = __toESM(require_react());
var useCarouselViewport_unstable = (props, ref) => {
  const hasFocus = React614.useRef(false);
  const hasMouse = React614.useRef(false);
  const viewportRef = useCarouselContext_unstable2((ctx) => ctx.viewportRef);
  const enableAutoplay = useCarouselContext_unstable2((ctx) => ctx.enableAutoplay);
  const handleFocusCapture = React614.useCallback(() => {
    hasFocus.current = true;
    enableAutoplay(false, true);
  }, [
    enableAutoplay
  ]);
  const handleBlurCapture = React614.useCallback((e) => {
    if (!e.currentTarget.contains(e.relatedTarget)) {
      hasFocus.current = false;
      if (!hasMouse.current) {
        enableAutoplay(true, true);
      }
    }
  }, [
    enableAutoplay
  ]);
  const handleMouseEnter = React614.useCallback(() => {
    hasMouse.current = true;
    enableAutoplay(false, true);
  }, [
    enableAutoplay
  ]);
  const handleMouseLeave = React614.useCallback(() => {
    hasMouse.current = false;
    if (!hasFocus.current) {
      enableAutoplay(true, true);
    }
  }, [
    enableAutoplay
  ]);
  const onFocusCapture = mergeCallbacks(props.onFocusCapture, handleFocusCapture);
  const onBlurCapture = mergeCallbacks(props.onBlurCapture, handleBlurCapture);
  const onMouseEnter = mergeCallbacks(props.onMouseEnter, handleMouseEnter);
  const onMouseLeave = mergeCallbacks(props.onMouseLeave, handleMouseLeave);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, viewportRef),
      role: "presentation",
      // Draggable ensures dragging is supported (even if not enabled)
      draggable: true,
      ...props,
      onFocusCapture,
      onBlurCapture,
      onMouseEnter,
      onMouseLeave
    }), {
      elementType: "div"
    })
  };
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/renderCarouselViewport.js
var renderCarouselViewport_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(CarouselSliderContextProvider, {
    value: contextValues.carouselSlider,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/useCarouselViewportStyles.styles.js
var carouselViewportClassNames = {
  root: "fui-CarouselViewport"
};
var useStyles94 = __styles2({
  root: {
    B2u0y6b: "f6dzj5z",
    a9b677: "f14z66ap"
  }
}, {
  d: [".f6dzj5z{max-width:100%;}", ".f14z66ap{width:auto;}"]
});
var useCarouselViewportStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles94();
  state.root.className = mergeClasses(carouselViewportClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-carousel/lib/components/CarouselViewport/CarouselViewport.js
var CarouselViewport = React615.forwardRef((props, ref) => {
  const state = useCarouselViewport_unstable(props, ref);
  useCarouselViewportStyles_unstable(state);
  useCustomStyleHook("useCarouselViewportStyles_unstable")(state);
  const context = useCarouselSliderContextValues_unstable(state);
  return renderCarouselViewport_unstable(state, context);
});
CarouselViewport.displayName = "CarouselViewport";

// node_modules/@fluentui/react-list/lib/components/List/List.js
var React620 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/components/List/useList.js
var React617 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/hooks/useListSelection.js
var React616 = __toESM(require_react());
function useListSelection(options = {
  selectionMode: "multiselect"
}) {
  const { selectionMode, defaultSelectedItems, onSelectionChange } = options;
  const [selectedItems, setSelectedItems] = useControllableState({
    state: options.selectedItems,
    defaultState: defaultSelectedItems,
    initialState: []
  });
  const [selected, selectionMethods] = useSelection({
    selectionMode,
    defaultSelectedItems,
    selectedItems,
    onSelectionChange: (e, data) => {
      setSelectedItems(data.selectedItems);
      onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, data);
    }
  });
  const toggleItem = useEventCallback((e, itemId) => selectionMethods.toggleItem(e, itemId));
  const toggleAllItems = useEventCallback((e, itemIds) => {
    selectionMethods.toggleAllItems(e, itemIds);
  });
  const deselectItem = useEventCallback((e, itemId) => selectionMethods.deselectItem(e, itemId));
  const selectItem = useEventCallback((e, itemId) => selectionMethods.selectItem(e, itemId));
  const clearSelection = useEventCallback((e) => selectionMethods.clearItems(e));
  const selectedArray = React616.useMemo(() => Array.from(selected), [
    selected
  ]);
  return {
    selectedItems: selectedArray,
    toggleItem,
    toggleAllItems,
    deselectItem,
    selectItem,
    setSelectedItems,
    isSelected: (id) => selectionMethods.isSelected(id),
    clearSelection
  };
}

// node_modules/@fluentui/react-list/lib/utils/calculateListRole.js
var calculateListRole = (navigationMode, selectable) => {
  if (navigationMode === "composite") {
    return "grid";
  } else if (selectable) {
    return "listbox";
  } else {
    return "list";
  }
};

// node_modules/@fluentui/react-list/lib/utils/validateProperElementTypes.js
function validateProperElementTypes(listRenderedAs, listItemRenderedAs) {
  if (listItemRenderedAs === "div" && listRenderedAs !== "div") {
    throw new Error("ListItem cannot be rendered as a div when its parent is not a div.");
  }
  if (listItemRenderedAs === "li" && listRenderedAs === "div") {
    throw new Error("ListItem cannot be rendered as a li when its parent is a div.");
  }
}

// node_modules/@fluentui/react-list/lib/utils/validateProperRolesAreUsed.js
var validateProperRolesAreUsed = (role, listItemRole, hasSelection, hasFocusableChildren) => {
  if (role === "list" && listItemRole !== "listitem") {
    throw new Error('When the List role is "list", ListItem role must be "listitem".');
  }
  if (role === "listbox" && listItemRole !== "option") {
    throw new Error('When the List role is "listbox", ListItem role must be "option".');
  }
  if (role === "grid" && listItemRole !== "row") {
    throw new Error('When the List role is "grid", ListItem role must be "row".');
  }
  const expectedRole = (() => {
    if (hasFocusableChildren) {
      return "grid";
    } else {
      if (hasSelection) {
        return "listbox";
      } else {
        return "list";
      }
    }
  })();
  if (role !== expectedRole) {
    console.warn(`@fluentui/react-list [useList]:
The role "${role}" does not match the expected role "${expectedRole}".
Please use the "navigationMode" property for automatic role assignment and keyboard navigation.
If you are using this role intentionally, make sure to verify screen reader support.
    `);
  }
};

// node_modules/@fluentui/react-list/lib/utils/calculateListItemRoleForListRole.js
var calculateListItemRoleForListRole = (listRole) => {
  switch (listRole) {
    case "list":
      return "listitem";
    case "listbox":
      return "option";
    case "grid":
      return "row";
    default:
      return "listitem";
  }
};

// node_modules/@fluentui/react-list/lib/utils/validateGridCellsArePresent.js
var validateGridCellsArePresent = (listRole, listItemEl) => {
  if (listRole !== "grid") {
    return;
  }
  const gridCells = listItemEl.querySelectorAll(':scope > [role="gridcell"]');
  if (gridCells.length === 0) {
    console.warn(`@fluentui/react-list [useList]:
List items in List with "grid" role (which is automatically assigned when navigationMode is set to "composite") must contain at least one "gridcell" as direct child of <ListItem /> for proper screen reader support.`, `Ideally, each focus target should be in it's own "gridcell", which is a direct child of <ListItem />.
`);
  }
};

// node_modules/@fluentui/react-list/lib/components/List/useList.js
var DEFAULT_ROOT_EL_TYPE = "ul";
var useList_unstable = (props, ref) => {
  const { navigationMode, selectionMode, selectedItems, defaultSelectedItems, onSelectionChange } = props;
  const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE;
  const arrowNavigationAttributes = useArrowNavigationGroup({
    axis: "vertical",
    memorizeCurrent: true
  });
  const [selectionState, setSelectionState] = useControllableState({
    state: selectedItems,
    defaultState: defaultSelectedItems,
    initialState: []
  });
  const onChange = useEventCallback((e, data) => {
    const selectedItemsAsArray = Array.from(data.selectedItems);
    setSelectionState(selectedItemsAsArray);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(e, {
      event: e,
      type: "change",
      selectedItems: selectedItemsAsArray
    });
  });
  const selection = useListSelection({
    onSelectionChange: onChange,
    selectionMode: selectionMode || "multiselect",
    selectedItems: selectionState
  });
  const listRole = props.role || calculateListRole(navigationMode, !!selectionMode);
  const listItemRole = calculateListItemRoleForListRole(listRole);
  const { findAllFocusable } = useFocusFinders();
  const validateListItem = useEventCallback((listItemEl) => {
    if (false) {
      return;
    }
    const itemRole = listItemEl.getAttribute("role") || "";
    const focusable = findAllFocusable(listItemEl);
    validateProperElementTypes(as, listItemEl.tagName.toLocaleLowerCase());
    validateProperRolesAreUsed(listRole, itemRole, !!selectionMode, focusable.length > 0);
    validateGridCellsArePresent(listRole, listItemEl);
  });
  return {
    components: {
      root: as
    },
    root: slot_exports.always(getIntrinsicElementProps(as, {
      ref,
      role: listRole,
      ...selectionMode && {
        "aria-multiselectable": selectionMode === "multiselect" ? true : void 0
      },
      ...arrowNavigationAttributes,
      ...props
    }), {
      elementType: as
    }),
    listItemRole,
    validateListItem,
    navigationMode,
    // only pass down selection state if its handled internally, otherwise just report the events
    selection: selectionMode ? selection : void 0
  };
};

// node_modules/@fluentui/react-list/lib/components/List/listContext.js
var React618 = __toESM(require_react());
var listContextDefaultValue = {
  selection: void 0,
  validateListItem: () => {
  }
};
var listContext = createContext13(void 0);
var ListContextProvider = listContext.Provider;
var useListContext_unstable = (selector) => useContextSelector(listContext, (ctx = listContextDefaultValue) => selector(ctx));
var ListSynchronousContext = React618.createContext(void 0);
var ListSynchronousContextProvider = ListSynchronousContext.Provider;
var useListSynchronousContext = () => React618.useContext(ListSynchronousContext) || {
  navigationMode: void 0,
  listItemRole: "listitem"
};

// node_modules/@fluentui/react-list/lib/components/List/renderList.js
var renderList_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ListContextProvider, {
    value: contextValues.listContext,
    children: jsx(ListSynchronousContextProvider, {
      value: contextValues.synchronousContext,
      children: jsx(state.root, {})
    })
  });
};

// node_modules/@fluentui/react-list/lib/components/List/useListStyles.styles.js
var listClassNames = {
  root: "fui-List"
};
var useRootBaseStyles8 = __resetStyles("r1m6yby2", null, [".r1m6yby2{padding:0;margin:0;text-indent:0;list-style-type:none;}"]);
var useListStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootBaseStyles8();
  state.root.className = mergeClasses(listClassNames.root, rootStyles, state.root.className);
  return state;
};

// node_modules/@fluentui/react-list/lib/components/List/useListContextValues.js
var React619 = __toESM(require_react());
function useListContextValues_unstable(state) {
  const { selection, navigationMode, listItemRole, validateListItem } = state;
  const listContext2 = {
    selection,
    navigationMode,
    validateListItem
  };
  const synchronousContext = React619.useMemo(() => ({
    listItemRole,
    navigationMode
  }), [
    listItemRole,
    navigationMode
  ]);
  return {
    listContext: listContext2,
    synchronousContext
  };
}

// node_modules/@fluentui/react-list/lib/components/List/List.js
var List = React620.forwardRef((props, ref) => {
  const state = useList_unstable(props, ref);
  const contextValues = useListContextValues_unstable(state);
  useListStyles_unstable(state);
  useCustomStyleHook("useListStyles_unstable")(state);
  return renderList_unstable(state, contextValues);
});
List.displayName = "List";

// node_modules/@fluentui/react-list/lib/components/ListItem/ListItem.js
var React623 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItem.js
var React622 = __toESM(require_react());

// node_modules/@fluentui/react-list/lib/events/ListItemActionEvent.js
var React621 = __toESM(require_react());
var ListItemActionEventName = "ListItemAction";
var createListItemActionEvent = (originalEvent) => new CustomEvent(ListItemActionEventName, {
  cancelable: true,
  bubbles: true,
  detail: {
    originalEvent
  }
});

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItem.js
var DEFAULT_ROOT_EL_TYPE2 = "li";
var useListItem_unstable = (props, ref) => {
  const id = useId2("listItem");
  const { value = id, onKeyDown, onClick, tabIndex, role, onAction, disabledSelection } = props;
  const toggleItem = useListContext_unstable((ctx) => {
    var _ctx_selection;
    return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.toggleItem;
  });
  const { navigationMode, listItemRole } = useListSynchronousContext();
  const isSelectionModeEnabled = useListContext_unstable((ctx) => !!ctx.selection);
  var _useListContext_unstable;
  const isSelected = (_useListContext_unstable = useListContext_unstable((ctx) => {
    var _ctx_selection;
    return (_ctx_selection = ctx.selection) === null || _ctx_selection === void 0 ? void 0 : _ctx_selection.isSelected(value);
  })) !== null && _useListContext_unstable !== void 0 ? _useListContext_unstable : false;
  const validateListItem = useListContext_unstable((ctx) => ctx.validateListItem);
  const as = props.as || navigationMode === "composite" ? "div" : DEFAULT_ROOT_EL_TYPE2;
  const finalListItemRole = role || listItemRole;
  const focusableItems = Boolean(isSelectionModeEnabled || navigationMode || tabIndex === 0);
  const rootRef = React622.useRef(null);
  const checkmarkRef = React622.useRef(null);
  const handleAction = useEventCallback((event) => {
    onAction === null || onAction === void 0 ? void 0 : onAction(event, {
      event,
      value,
      type: ListItemActionEventName
    });
    if (event.defaultPrevented) {
      return;
    }
    if (isSelectionModeEnabled && !disabledSelection) {
      toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(event.detail.originalEvent, value);
    }
  });
  React622.useEffect(() => {
    if (rootRef.current) {
      validateListItem(rootRef.current);
    }
  }, [
    validateListItem
  ]);
  const triggerAction = (e) => {
    const actionEvent = createListItemActionEvent(e);
    handleAction(actionEvent);
    e.target.dispatchEvent(actionEvent);
  };
  const focusableGroupAttrs = useFocusableGroup({
    ignoreDefaultKeydown: {
      Enter: true
    },
    tabBehavior: "limited-trap-focus"
  });
  const handleClick = useEventCallback((e) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
    if (e.defaultPrevented) {
      return;
    }
    const isFromCheckbox = elementContains(checkmarkRef.current, e.target);
    if (isFromCheckbox) {
      return;
    }
    triggerAction(e);
  });
  const handleKeyDown = useEventCallback((e) => {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    if (e.defaultPrevented) {
      return;
    }
    if (e.target !== e.currentTarget) {
      if (focusableItems) {
        switch (e.key) {
          case ArrowLeft:
            e.target.dispatchEvent(new GroupperMoveFocusEvent({
              action: GroupperMoveFocusActions.Escape
            }));
            break;
          case ArrowDown:
          case ArrowUp:
            e.preventDefault();
            e.target.dispatchEvent(new GroupperMoveFocusEvent({
              action: GroupperMoveFocusActions.Escape
            }));
            e.currentTarget.dispatchEvent(new MoverMoveFocusEvent({
              key: MoverKeys[e.key]
            }));
        }
        return;
      }
      return;
    }
    switch (e.key) {
      case Space:
        e.preventDefault();
        if (isSelectionModeEnabled) {
          if (!disabledSelection) {
            toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(e, value);
          }
        } else {
          triggerAction(e);
        }
        break;
      case Enter:
        triggerAction(e);
        break;
      case ArrowRight:
        if (navigationMode === "composite") {
          e.target.dispatchEvent(new GroupperMoveFocusEvent({
            action: GroupperMoveFocusActions.Enter
          }));
        }
        break;
    }
  });
  const onCheckboxChange = useEventCallback((e, data) => {
    if (!isSelectionModeEnabled || e.defaultPrevented) {
      return;
    }
    toggleItem === null || toggleItem === void 0 ? void 0 : toggleItem(e, value);
  });
  const arrowNavigationAttributes = useArrowNavigationGroup({
    axis: "horizontal"
  });
  const tabsterAttributes = useMergedTabsterAttributes_unstable(focusableItems ? arrowNavigationAttributes : {}, focusableGroupAttrs, props);
  const root = slot_exports.always(getIntrinsicElementProps(as, {
    ref: useMergedRefs(rootRef, ref),
    tabIndex: focusableItems ? 0 : void 0,
    role: finalListItemRole,
    id: String(value),
    ...isSelectionModeEnabled && {
      "aria-selected": isSelected,
      "aria-disabled": disabledSelection && !onAction || void 0
    },
    ...props,
    ...tabsterAttributes,
    onKeyDown: handleKeyDown,
    onClick: isSelectionModeEnabled || onClick || onAction ? handleClick : void 0
  }), {
    elementType: as
  });
  const checkmark = slot_exports.optional(props.checkmark, {
    defaultProps: {
      checked: isSelected,
      tabIndex: -1,
      disabled: disabledSelection
    },
    renderByDefault: isSelectionModeEnabled,
    elementType: Checkbox
  });
  const mergedCheckmarkRef = useMergedRefs(checkmark === null || checkmark === void 0 ? void 0 : checkmark.ref, checkmarkRef);
  if (checkmark) {
    checkmark.onChange = mergeCallbacks(checkmark.onChange, onCheckboxChange);
    checkmark.ref = mergedCheckmarkRef;
  }
  const state = {
    components: {
      root: as,
      checkmark: Checkbox
    },
    root,
    checkmark,
    disabled: disabledSelection && !onAction,
    selectable: isSelectionModeEnabled,
    navigable: focusableItems
  };
  return state;
};

// node_modules/@fluentui/react-list/lib/components/ListItem/renderListItem.js
var renderListItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.checkmark && jsx(state.checkmark, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-list/lib/components/ListItem/useListItemStyles.styles.js
var listItemClassNames = {
  root: "fui-ListItem",
  checkmark: "fui-ListItem__checkmark"
};
var useRootBaseStyles9 = __resetStyles("rikgcmv", null, [".rikgcmv{padding:0;margin:0;text-indent:0;list-style-type:none;}", ".rikgcmv[data-fui-focus-visible]{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);}"]);
var useCheckmarkBaseStyles = __styles2({
  root: {
    qb2dma: "f7nlbp4",
    Bpb5tq4: 0,
    Biccaaf: 0,
    Gaeyjg: 0,
    ldoezw: 0,
    B6gmeee: "f1bgo3o3"
  }
}, {
  d: [".f7nlbp4{align-self:center;}", [".f1bgo3o3 .fui-Checkbox__indicator{margin:4px;}", {
    p: -1
  }]]
});
var useStyles95 = __styles2({
  rootClickableOrSelectable: {
    mc9l5x: "f22iagw",
    Bceei9c: "f1k6fduh"
  },
  disabled: {
    Bceei9c: "f158kwzp"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1k6fduh{cursor:pointer;}", ".f158kwzp{cursor:default;}"]
});
var useListItemStyles_unstable = (state) => {
  "use no memo";
  const rootBaseStyles = useRootBaseStyles9();
  const checkmarkBaseStyles = useCheckmarkBaseStyles();
  const styles = useStyles95();
  state.root.className = mergeClasses(listItemClassNames.root, rootBaseStyles, (state.selectable || state.navigable) && styles.rootClickableOrSelectable, state.disabled && styles.disabled, state.root.className);
  if (state.checkmark) {
    state.checkmark.className = mergeClasses(listItemClassNames.checkmark, checkmarkBaseStyles.root, state.checkmark.className);
  }
  return state;
};

// node_modules/@fluentui/react-list/lib/components/ListItem/ListItem.js
var ListItem = React623.forwardRef((props, ref) => {
  const state = useListItem_unstable(props, ref);
  useListItemStyles_unstable(state);
  useCustomStyleHook("useListItemStyles_unstable")(state);
  return renderListItem_unstable(state);
});
ListItem.displayName = "ListItem";

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/ColorSlider.js
var React626 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSlider.js
var React625 = __toESM(require_react());

// node_modules/@ctrl/tinycolor/dist/module/util.js
function bound01(n, max2) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max2 === 360 ? n : Math.min(max2, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max2), 10) / 100;
  }
  if (Math.abs(n - max2) < 1e-6) {
    return 1;
  }
  if (max2 === 360) {
    n = (n < 0 ? n % max2 + max2 : n % max2) / parseFloat(String(max2));
  } else {
    n = n % max2 / parseFloat(String(max2));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}

// node_modules/@ctrl/tinycolor/dist/module/conversion.js
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r, g, b);
  var min2 = Math.min(r, g, b);
  var h = 0;
  var s = 0;
  var l = (max2 + min2) / 2;
  if (max2 === min2) {
    s = 0;
    h = 0;
  } else {
    var d = max2 - min2;
    s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * (6 * t);
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max2 = Math.max(r, g, b);
  var min2 = Math.min(r, g, b);
  var h = 0;
  var v = max2;
  var d = max2 - min2;
  var s = max2 === 0 ? 0 : d / max2;
  if (max2 === min2) {
    h = 0;
  } else {
    switch (max2) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        break;
    }
    h /= 6;
  }
  return { h, s, v };
}
function hsvToRgb(h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h);
  var f = h - i;
  var p = v * (1 - s);
  var q = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q, p, p, t, v][mod];
  var g = [t, v, v, q, p, p][mod];
  var b = [p, p, t, v, v, q][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}

// node_modules/@ctrl/tinycolor/dist/module/css-color-names.js
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};

// node_modules/@ctrl/tinycolor/dist/module/format-input.js
function inputToRGB(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok = true;
      format = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s = convertToPercentage(color2.s);
      v = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s = convertToPercentage(color2.s);
      l = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color2.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color2);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color2);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color2);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}

// node_modules/@ctrl/tinycolor/dist/module/index.js
var TinyColor = (
  /** @class */
  function() {
    function TinyColor2(color2, opts) {
      if (color2 === void 0) {
        color2 = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a;
      if (color2 instanceof TinyColor2) {
        return color2;
      }
      if (typeof color2 === "number") {
        color2 = numberInputToObject(color2);
      }
      this.originalInput = color2;
      var rgb = inputToRGB(color2);
      this.originalInput = color2;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R;
      var G;
      var B;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s = this.toHsl().s;
      return s === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h = Math.round(hsv.h * 360);
      var s = Math.round(hsv.s * 100);
      var v = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h = Math.round(hsl.h * 360);
      var s = Math.round(hsl.s * 100);
      var l = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x) {
        return "".concat(Math.round(bound01(x, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x) {
        return Math.round(bound01(x, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        if (hex === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format) {
      var formatSet = Boolean(format);
      format = format !== null && format !== void 0 ? format : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
      if (needsAlphaFormat) {
        if (format === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format === "hex" || format === "hex6") {
        formattedString = this.toHexString();
      }
      if (format === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format === "name") {
        formattedString = this.toName();
      }
      if (format === "hsl") {
        formattedString = this.toHslString();
      }
      if (format === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color2, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color2).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h = hsv.h;
      var s = hsv.s;
      var v = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h, s, v }));
        v = (v + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
        a: alpha
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n) {
      var hsl = this.toHsl();
      var h = hsl.h;
      var result = [this];
      var increment = 360 / n;
      for (var i = 1; i < n; i++) {
        result.push(new TinyColor2({ h: (h + i * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color2) {
      return this.toRgbString() === new TinyColor2(color2).toRgbString();
    };
    return TinyColor2;
  }()
);
function tinycolor(color2, opts) {
  if (color2 === void 0) {
    color2 = "";
  }
  if (opts === void 0) {
    opts = {};
  }
  return new TinyColor(color2, opts);
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSliderStyles.styles.js
var colorSliderClassNames = {
  root: "fui-ColorSlider",
  rail: "fui-ColorSlider__rail",
  thumb: "fui-ColorSlider__thumb",
  input: "fui-ColorSlider__input"
};
var colorSliderCSSVars = {
  sliderDirectionVar: `--fui-Slider--direction`,
  sliderProgressVar: `--fui-Slider--progress`,
  thumbColorVar: `--fui-Slider__thumb--color`,
  railColorVar: `--fui-Slider__rail--color`,
  thumbSizeVar: `--fui-Slider__thumb--size`,
  railSizeVar: `--fui-Slider__rail--size`
};
var hueBackground = `linear-gradient(${[`var(${colorSliderCSSVars.sliderDirectionVar})`, "red", "fuchsia", "blue", "aqua", "lime", "yellow", "red"].join(",")})`;
var useRootStyles27 = __resetStyles("r1j9hj9j", null, [".r1j9hj9j{position:relative;display:inline-grid;touch-action:none;align-items:center;justify-items:center;--fui-Slider__thumb--size:20px;--fui-Slider__rail--size:20px;min-height:32px;}"]);
var useStyles96 = __styles2({
  horizontal: {
    Bf4jedk: "f93ek0f",
    wkccdc: "fgfd48t",
    Budl1dq: "f11e9psi"
  },
  vertical: {
    sshi5w: "fwwq4i4",
    wkccdc: "fqcvrs3",
    Budl1dq: "fiadc6h"
  }
}, {
  d: [".f93ek0f{min-width:200px;}", ".fgfd48t{grid-template-rows:1fr var(--fui-Slider__thumb--size) 1fr;}", ".f11e9psi{grid-template-columns:1fr 100% 1fr;}", ".fwwq4i4{min-height:280px;}", ".fqcvrs3{grid-template-rows:1fr 100% 1fr;}", ".fiadc6h{grid-template-columns:1fr var(--fui-Slider__thumb--size) 1fr;}"]
});
var useChannelStyles = __styles2({
  hue: {
    Bcmaq0h: "f1curpo1"
  },
  saturation: {
    Bcmaq0h: ["fdhcg5e", "f1onqon0"]
  },
  value: {
    Bcmaq0h: ["f1r1ueul", "fbtriqu"]
  }
}, {
  d: [".f1curpo1{background-image:linear-gradient(var(--fui-Slider--direction),red,fuchsia,blue,aqua,lime,yellow,red);}", ".fdhcg5e{background-image:linear-gradient(to right, #808080, var(--fui-Slider__rail--color));}", ".f1onqon0{background-image:linear-gradient(to left, #808080, var(--fui-Slider__rail--color));}", ".f1r1ueul{background-image:linear-gradient(to right, #000, var(--fui-Slider__rail--color));}", ".fbtriqu{background-image:linear-gradient(to left, #000, var(--fui-Slider__rail--color));}"]
});
var useRailStyles2 = __styles2({
  rail: {
    Bkecrkj: "f1aehjj5",
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f10pi13n",
    Bvjb7m6: "fdgv6k0",
    Bpd4iqm: "fpvhumw",
    oeaueh: "f1yog68k",
    Bw0xxkn: "f13sgyd8",
    Ftih45: "fzhtfnv",
    Brfgrao: "f1j7ml58"
  },
  horizontal: {
    a9b677: "fly5x3f",
    Bqenvij: "f1cy86ho",
    Fbdkly: ["f1heqfse", "fkh49vu"],
    mdwyqc: ["fkh49vu", "f1heqfse"],
    Baz25je: "f16tdq4e"
  },
  vertical: {
    a9b677: "fqxfnkd",
    Bqenvij: "f1l02sjl",
    Ccq8qp: "f1rik0od",
    Bciustq: "f14xwovp",
    lawp4y: "febq2dz"
  }
}, {
  d: [".f1aehjj5{pointer-events:none;}", ".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f10pi13n{position:relative;}", ".fdgv6k0{forced-color-adjust:none;}", ".fpvhumw{outline-width:1px;}", ".f1yog68k{outline-style:solid;}", ".f13sgyd8{outline-color:var(--colorTransparentStroke);}", ".fzhtfnv::before{content:'';}", ".f1j7ml58::before{position:absolute;}", ".fly5x3f{width:100%;}", ".f1cy86ho{height:var(--fui-Slider__rail--size);}", ".f1heqfse::before{left:-1px;}", ".fkh49vu::before{right:-1px;}", ".f16tdq4e::before{height:var(--fui-Slider__rail--size);}", ".fqxfnkd{width:var(--fui-Slider__rail--size);}", ".f1l02sjl{height:100%;}", ".f1rik0od::before{width:var(--fui-Slider__rail--size);}", ".f14xwovp::before{top:-1px;}", ".febq2dz::before{bottom:1px;}"]
});
var useThumbStyles2 = __styles2({
  thumb: {
    Ijaq50: "faunodf",
    nk6f5a: "f88nxoq",
    Br312pm: "fd46tj4",
    Bw0ie65: "f1e2fz10",
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1lvq45z",
    E5pizo: "f1whvlc6",
    De3pzq: "foksa45",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f1abv9ik",
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f3i7wkk"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["f1fj3zth", "fcf9u6w"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "feeniun"
  }
}, {
  d: [".faunodf{grid-row-start:2;}", ".f88nxoq{grid-row-end:2;}", ".fd46tj4{grid-column-start:2;}", ".f1e2fz10{grid-column-end:2;}", ".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", {
    p: -2
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".foksa45{background-color:var(--fui-Slider__thumb--color);}", ".f1j7ml58::before{position:absolute;}", [".f1abv9ik::before{inset:0px;}", {
    p: -1
  }], [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", {
    p: -2
  }], ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".f1fj3zth{left:var(--fui-Slider--progress);}", ".fcf9u6w{right:var(--fui-Slider--progress);}", ".f5cv5a3{transform:translateY(50%);}", ".feeniun{bottom:var(--fui-Slider--progress);}"]
});
var useShapeStyles4 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useInputStyles9 = __styles2({
  input: {
    Bceei9c: "f1k6fduh",
    abs64n: "fk73vx1",
    Ijaq50: "f16hsg94",
    nk6f5a: "f1nzqi2z",
    Br312pm: "fwpfdsa",
    Bw0ie65: "fuur7zz",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    jo39rj: 0,
    C5zqim: 0,
    Bdlbwnu: 0,
    B8rk77i: 0,
    Bbzx7hc: 0,
    Hwkvcz: 0,
    B0nnt1c: 0,
    Brwsv5j: 0,
    B2b7vog: 0,
    B4hmq5e: 0,
    B8jxwem: 0,
    B18nadz: 0,
    Ddg5ig: 0,
    Byj09el: 0,
    Dac2s3: 0,
    Dd2y6r: 0,
    Bk0t58e: "f1nq8t98",
    Ewenww: 0,
    Brqi8qb: 0,
    zz3kca: 0,
    low6xx: "fjt56wq",
    d0s10n: 0,
    wea7l5: 0,
    olu5tv: 0,
    g5nsvh: 0,
    Bqvnfwh: "f1n9m442"
  },
  horizontal: {
    Bqenvij: "f1yfdkfd",
    a9b677: "fly5x3f"
  },
  vertical: {
    Bqenvij: "f1l02sjl",
    a9b677: "f174ca62",
    Biqzhck: "f1r7j8g6",
    kgocjf: ["f1va4sj6", "f1r2v9sp"]
  }
}, {
  d: [".f1k6fduh{cursor:pointer;}", ".fk73vx1{opacity:0;}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}", ".fwpfdsa{grid-column-start:1;}", ".fuur7zz{grid-column-end:-1;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1r7j8g6{writing-mode:vertical-lr;}", ".f1va4sj6{direction:rtl;}", ".f1r2v9sp{direction:ltr;}"],
  i: [[".f1nq8t98:focus-visible~.fui-ColorSlider__thumb{border:2px solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".fjt56wq:focus-visible~.fui-ColorSlider__thumb{outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);}", {
    p: -1
  }], [".f1n9m442:focus-visible~.fui-ColorSlider__thumb{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }]]
});
var useColorSliderStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles27();
  const styles = useStyles96();
  const railStyles = useRailStyles2();
  const thumbStyles = useThumbStyles2();
  const inputStyles = useInputStyles9();
  const shapeStyles = useShapeStyles4();
  const channelStyles = useChannelStyles();
  const isVertical = state.vertical;
  state.root.className = mergeClasses(colorSliderClassNames.root, rootStyles, isVertical ? styles.vertical : styles.horizontal, state.root.className);
  state.rail.className = mergeClasses(colorSliderClassNames.rail, railStyles.rail, channelStyles[state.channel || "hue"], shapeStyles[state.shape || "rounded"], isVertical ? railStyles.vertical : railStyles.horizontal, state.rail.className);
  state.thumb.className = mergeClasses(colorSliderClassNames.thumb, thumbStyles.thumb, isVertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  state.input.className = mergeClasses(colorSliderClassNames.input, inputStyles.input, isVertical ? inputStyles.vertical : inputStyles.horizontal, state.input.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/contexts/colorPicker.js
var React624 = __toESM(require_react());
var useColorPickerContextValues = (state) => {
  const { color: color2, shape, requestChange } = state;
  const colorPicker = {
    requestChange,
    color: color2,
    shape
  };
  return {
    colorPicker
  };
};
var colorPickerContextDefaultValue = {
  requestChange: () => {
  },
  color: void 0,
  shape: "rounded"
};
var colorPickerContext = createContext13(void 0);
var ColorPickerProvider = colorPickerContext.Provider;
var useColorPickerContextValue_unstable = (selector) => useContextSelector(colorPickerContext, (ctx = colorPickerContextDefaultValue) => selector(ctx));

// node_modules/@fluentui/react-color-picker/lib/utils/constants.js
var MIN = 0;
var MAX = 100;
var HUE_MAX = 360;
var INITIAL_COLOR = "#FFF";
var INITIAL_COLOR_HSV = tinycolor(INITIAL_COLOR).toHsv();

// node_modules/@fluentui/react-color-picker/lib/utils/getPercent.js
var getPercent2 = (value, min2, max2) => {
  return max2 === min2 ? 0 : (value - min2) / (max2 - min2) * 100;
};

// node_modules/@fluentui/react-color-picker/lib/utils/createHsvColor.js
function createHsvColor({ h = 0, s = 0, v = 0, a = 1 }) {
  return {
    h,
    s,
    v,
    a
  };
}

// node_modules/@fluentui/react-color-picker/lib/utils/adjustChannel.js
function clampValue2(value, channel = "hue") {
  const MAX2 = channel === "hue" ? HUE_MAX : MAX;
  return clamp(value, MIN, MAX2);
}
function adjustChannel(channel, actions) {
  return actions[channel] || actions.hue;
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/useColorSlider.js
var useColorSlider_unstable = (props, ref) => {
  "use no memo";
  const { dir } = useFluent();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "color"
    ]
  });
  const {
    color: color2,
    channel = "hue",
    onChange = onChangeFromContext,
    shape = shapeFromContext,
    vertical,
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const hsvColor = color2 || colorFromContext;
  const hslColor = tinycolor(hsvColor).toHsl();
  const [currentColor, setCurrentColor] = useControllableState({
    defaultState: props.defaultColor,
    state: hsvColor,
    initialState: INITIAL_COLOR_HSV
  });
  const MAX2 = channel === "hue" ? HUE_MAX : MAX;
  const valueChannelActions = {
    hue: clampValue2(currentColor.h),
    saturation: clampValue2(currentColor.s * 100),
    value: clampValue2(currentColor.v * 100)
  };
  const clampedValue = adjustChannel(channel, valueChannelActions);
  const valuePercent = getPercent2(clampedValue, MIN, MAX2);
  const inputOnChange = input === null || input === void 0 ? void 0 : input.onChange;
  const _onChange = useEventCallback((event) => {
    const newValue = Number(event.target.value);
    const colorActions = {
      hue: () => createHsvColor({
        ...hsvColor,
        h: newValue
      }),
      saturation: () => createHsvColor({
        ...hsvColor,
        s: newValue / 100
      }),
      value: () => createHsvColor({
        ...hsvColor,
        v: newValue / 100
      })
    };
    const newColor = adjustChannel(channel, colorActions)();
    setCurrentColor(newColor);
    inputOnChange === null || inputOnChange === void 0 ? void 0 : inputOnChange(event);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const rootVariables = {
    [colorSliderCSSVars.sliderDirectionVar]: vertical ? "180deg" : dir === "ltr" ? "-90deg" : "90deg",
    [colorSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
    [colorSliderCSSVars.thumbColorVar]: channel === "hue" ? `hsl(${clampedValue}, 100%, 50%)` : tinycolor(hsvColor).toRgbString(),
    [colorSliderCSSVars.railColorVar]: channel === "hue" ? `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)` : `hsl(${hslColor.h} 100%, 50%)`
  };
  const state = {
    shape,
    vertical,
    channel,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: {
        role: "group",
        ...nativeProps.root
      },
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        min: MIN,
        max: MAX2,
        tabIndex: 0,
        ["aria-orientation"]: vertical ? "vertical" : "horizontal",
        ...nativeProps.primary,
        type: "range"
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = _onChange;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/renderColorSlider.js
var renderColorSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorSlider/ColorSlider.js
var ColorSlider = React626.forwardRef((props, ref) => {
  const state = useColorSlider_unstable(props, ref);
  useColorSliderStyles_unstable(state);
  useCustomStyleHook("useColorSliderStyles_unstable")(state);
  return renderColorSlider_unstable(state);
});
ColorSlider.displayName = "ColorSlider";

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/ColorPicker.js
var React628 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPicker.js
var React627 = __toESM(require_react());
var useColorPicker_unstable = (props, ref) => {
  const { color: color2, onColorChange, shape, ...rest } = props;
  const requestChange = useEventCallback((event, data) => {
    onColorChange === null || onColorChange === void 0 ? void 0 : onColorChange(event, {
      type: "change",
      event,
      color: data.color
    });
  });
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...rest
    }), {
      elementType: "div"
    }),
    color: color2,
    requestChange,
    shape
  };
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/renderColorPicker.js
var renderColorPicker_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(ColorPickerProvider, {
    value: contextValues.colorPicker,
    children: jsx(state.root, {
      children: state.root.children
    })
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/useColorPickerStyles.styles.js
var colorPickerClassNames = {
  root: "fui-ColorPicker"
};
var useStyles97 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f7e3wsx"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", [".f7e3wsx{gap:var(--spacingVerticalXS);}", {
    p: -1
  }]]
});
var useColorPickerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles97();
  state.root.className = mergeClasses(colorPickerClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorPicker/ColorPicker.js
var ColorPicker = React628.forwardRef((props, ref) => {
  const state = useColorPicker_unstable(props, ref);
  const contextValues = useColorPickerContextValues(state);
  useColorPickerStyles_unstable(state);
  useCustomStyleHook("useColorPickerStyles_unstable")(state);
  return renderColorPicker_unstable(state, contextValues);
});
ColorPicker.displayName = "ColorPicker";

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/ColorArea.js
var React630 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorArea.js
var React629 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorAreaStyles.styles.js
var colorAreaClassNames = {
  root: "fui-ColorArea",
  thumb: "fui-ColorArea__thumb",
  inputX: "fui-ColorArea__inputX",
  inputY: "fui-ColorArea__inputY"
};
var colorAreaCSSVars = {
  areaXProgressVar: `--fui-AreaX--progress`,
  areaYProgressVar: `--fui-AreaY--progress`,
  thumbColorVar: `--fui-Area__thumb--color`,
  mainColorVar: `--fui-Area--main-color`
};
var useRootStyles28 = __resetStyles("r77w3t7", "r9og4es", [".r77w3t7{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to right, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}", ".r9og4es{position:relative;border:1px solid var(--colorNeutralStroke1);background:linear-gradient(to bottom, transparent, #000),linear-gradient(to left, #fff, transparent),var(--fui-Area--main-color);forced-color-adjust:none;display:inline-grid;touch-action:none;align-items:start;justify-items:start;--fui-Slider__thumb--size:20px;min-width:300px;min-height:300px;box-sizing:border-box;margin-bottom:var(--spacingVerticalSNudge);}"]);
var useThumbStyles3 = __styles2({
  thumb: {
    qhf8xq: "f1euv43f",
    a9b677: "f174ca62",
    Bqenvij: "f1yfdkfd",
    Bkecrkj: "f1aehjj5",
    oeaueh: "f1s6fcnf",
    Bvjb7m6: "fdgv6k0",
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f44lkw9",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f1lvq45z",
    E5pizo: "f1whvlc6",
    De3pzq: "fqogvx2",
    Bz10aip: ["f1g1iug4", "f11okln6"],
    oyh7mz: ["f1r4bsg1", "fwsk87b"],
    B5kzvoi: "f1rtkqdg",
    Brfgrao: "f1j7ml58",
    lawp4y: 0,
    Fbdkly: 0,
    mdwyqc: 0,
    Bciustq: 0,
    gc50h5: "f1abv9ik",
    r59vdv: 0,
    Budzafs: 0,
    ck0cow: 0,
    n07z76: 0,
    Gng75u: "fielpny",
    Bcvre1j: "fyl8oag",
    Ftih45: "fzhtfnv",
    Bcgcnre: 0,
    Bqjgrrk: 0,
    qa3bma: 0,
    y0oebl: 0,
    Biqmznv: 0,
    Bm6vgfq: 0,
    Bbv0w2i: 0,
    uvfttm: 0,
    eqrjj: 0,
    Bk5zm6e: 0,
    m598lv: 0,
    B4f6apu: 0,
    ydt019: 0,
    Bq4z7u6: 0,
    Bdkvgpv: 0,
    B0qfbqy: 0,
    kj8mxx: "f3i7wkk"
  },
  focusIndicator: {
    Brovlpu: "ftqa4ok",
    B486eqv: "f2hkw1w",
    Bssx7fj: "f1b1k54r",
    uh7if5: ["f4ne723", "fqqcjud"],
    clntm0: "fh7aioi",
    Dlk2r6: ["fqqcjud", "f4ne723"],
    h6p2u: "f1ufm4qn",
    I6qiy5: ["f1qnwcb4", "fgrk5zm"],
    yzno9d: "fi52z01",
    By0wis0: ["fgrk5zm", "f1qnwcb4"],
    B2j2mmj: "ffht0p2",
    wigs8: "f1p0ul1q",
    pbfy6t: "f1c901ms",
    B0v4ure: "f1alokd7",
    Byrf0fs: 0,
    Bsiemmq: 0,
    Bwckmig: 0,
    skfxo0: 0,
    Iidy0u: 0,
    B98u21t: 0,
    Bvwlmkc: 0,
    jo1ztg: 0,
    Ba1iezr: 0,
    Blmvk6g: 0,
    B24cy0v: 0,
    Bil7v7r: 0,
    Br3gin4: 0,
    nr063g: 0,
    ghq09: 0,
    Bbgo44z: 0,
    Bseh09z: "f1i978nd",
    az1dzo: 0,
    Ba3ybja: 0,
    B6352mv: 0,
    vppk2z: 0,
    Biaj6j7: "f16hcqkr",
    B2pnrqr: "f1tye2sp",
    B29w5g4: ["flw7qy0", "f1t01kh7"],
    Bhhzhcn: "frujvlw",
    Bec0n69: ["f1t01kh7", "flw7qy0"]
  }
}, {
  d: [".f1euv43f{position:absolute;}", ".f174ca62{width:var(--fui-Slider__thumb--size);}", ".f1yfdkfd{height:var(--fui-Slider__thumb--size);}", ".f1aehjj5{pointer-events:none;}", ".f1s6fcnf{outline-style:none;}", ".fdgv6k0{forced-color-adjust:none;}", [".f44lkw9{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], [".f1lvq45z{border:var(--strokeWidthThin) solid var(--colorNeutralForeground4);}", {
    p: -2
  }], ".f1whvlc6{box-shadow:var(--shadow4);}", ".fqogvx2{background-color:var(--fui-Area__thumb--color);}", ".f1g1iug4{transform:translate(-50%, 50%);}", ".f11okln6{transform:translate(50%, 50%);}", ".f1r4bsg1{left:var(--fui-AreaX--progress);}", ".fwsk87b{right:var(--fui-AreaX--progress);}", ".f1rtkqdg{bottom:var(--fui-AreaY--progress);}", ".f1j7ml58::before{position:absolute;}", [".f1abv9ik::before{inset:0px;}", {
    p: -1
  }], [".fielpny::before{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".fyl8oag::before{box-sizing:border-box;}", ".fzhtfnv::before{content:'';}", [".f3i7wkk::before{border:var(--strokeWidthThick) solid var(--colorNeutralBackground1);}", {
    p: -2
  }], ".f1b1k54r[data-fui-focus-within]:focus-within{border-top-color:transparent;}", ".f4ne723[data-fui-focus-within]:focus-within{border-right-color:transparent;}", ".fqqcjud[data-fui-focus-within]:focus-within{border-left-color:transparent;}", ".fh7aioi[data-fui-focus-within]:focus-within{border-bottom-color:transparent;}", '.ffht0p2[data-fui-focus-within]:focus-within::after{content:"";}', ".f1p0ul1q[data-fui-focus-within]:focus-within::after{position:absolute;}", ".f1c901ms[data-fui-focus-within]:focus-within::after{pointer-events:none;}", ".f1alokd7[data-fui-focus-within]:focus-within::after{z-index:1;}", [".f1i978nd[data-fui-focus-within]:focus-within::after{border:var(--strokeWidthThick) solid var(--colorStrokeFocus2);}", {
    p: -2
  }], [".f16hcqkr[data-fui-focus-within]:focus-within::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], ".f1tye2sp[data-fui-focus-within]:focus-within::after{top:calc(var(--strokeWidthThick) * -1);}", ".flw7qy0[data-fui-focus-within]:focus-within::after{right:calc(var(--strokeWidthThick) * -1);}", ".f1t01kh7[data-fui-focus-within]:focus-within::after{left:calc(var(--strokeWidthThick) * -1);}", ".frujvlw[data-fui-focus-within]:focus-within::after{bottom:calc(var(--strokeWidthThick) * -1);}"],
  f: [".ftqa4ok:focus{outline-style:none;}"],
  i: [".f2hkw1w:focus-visible{outline-style:none;}"],
  m: [["@media (forced-colors: active){.f1ufm4qn[data-fui-focus-within]:focus-within::after{border-top-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.f1qnwcb4[data-fui-focus-within]:focus-within::after{border-right-color:Highlight;}.fgrk5zm[data-fui-focus-within]:focus-within::after{border-left-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fi52z01[data-fui-focus-within]:focus-within::after{border-bottom-color:Highlight;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useInputStyles10 = __styles2({
  input: {
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    qhf8xq: "f1euv43f",
    Bkecrkj: "f1aehjj5",
    Bhzewxz: "f15twtuk",
    oyh7mz: ["f1vgc2s3", "f1e31b4d"],
    abs64n: "fk73vx1",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1mk8lai",
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1s184ao",
    a9b677: "fly5x3f",
    Bqenvij: "f1l02sjl"
  }
}, {
  d: [[".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], ".f1euv43f{position:absolute;}", ".f1aehjj5{pointer-events:none;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".fk73vx1{opacity:0;}", [".f1mk8lai{padding:0;}", {
    p: -1
  }], [".f1s184ao{margin:0;}", {
    p: -1
  }], ".fly5x3f{width:100%;}", ".f1l02sjl{height:100%;}"]
});
var useShapeStyles5 = __styles2({
  rounded: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "ft85np5"
  },
  square: {
    Beyfa6y: 0,
    Bbmb7ep: 0,
    Btl43ni: 0,
    B7oj6ja: 0,
    Dimara: "f1fabniw"
  }
}, {
  d: [[".ft85np5{border-radius:var(--borderRadiusMedium);}", {
    p: -1
  }], [".f1fabniw{border-radius:var(--borderRadiusNone);}", {
    p: -1
  }]]
});
var useColorAreaStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles28();
  const thumbStyles = useThumbStyles3();
  const inputStyles = useInputStyles10();
  const shapeStyles = useShapeStyles5();
  state.root.className = mergeClasses(colorAreaClassNames.root, rootStyles, shapeStyles[state.shape || "rounded"], state.root.className);
  state.thumb.className = mergeClasses(colorAreaClassNames.thumb, thumbStyles.thumb, thumbStyles.focusIndicator, state.thumb.className);
  state.inputX.className = mergeClasses(colorAreaClassNames.inputX, inputStyles.input, state.inputX.className);
  state.inputY.className = mergeClasses(colorAreaClassNames.inputY, inputStyles.input, state.inputY.className);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/utils/getCoordinates.js
function getCoordinates(element, event) {
  const rect = element.getBoundingClientRect();
  const newX = roundTwoDecimal((event.clientX - rect.left) / rect.width);
  const newY = roundTwoDecimal(1 - (event.clientY - rect.top) / rect.height);
  return {
    x: clamp(newX, 0, 1),
    y: clamp(newY, 0, 1)
  };
}
function roundTwoDecimal(num) {
  return Math.round(num * 100) / 100;
}

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/useColorArea.js
var useColorArea_unstable = (props, ref) => {
  const { targetDocument } = useFluent();
  const rootRef = React629.useRef(null);
  const xRef = React629.useRef(null);
  const yRef = React629.useRef(null);
  const focusWithinRef = useFocusWithin();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const {
    onChange = onChangeFromContext,
    shape = shapeFromContext,
    // Slots
    inputX,
    inputY,
    thumb,
    color: color2,
    ...rest
  } = props;
  const [hsvColor, setColor] = useControllableState({
    defaultState: props.defaultColor,
    state: color2 || colorFromContext,
    initialState: INITIAL_COLOR_HSV
  });
  const saturation = Math.round(hsvColor.s * 100);
  const value = Math.round(hsvColor.v * 100);
  const [activeAxis, setActiveAxis] = React629.useState(null);
  const requestColorChange = useEventCallback((event) => {
    if (!rootRef.current) {
      return;
    }
    const coordinates = getCoordinates(rootRef.current, event);
    const newColor = {
      ...hsvColor,
      s: coordinates.x,
      v: coordinates.y
    };
    setColor(newColor);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const handleDocumentPointerMove = React629.useCallback((event) => {
    requestColorChange(event);
  }, [
    requestColorChange
  ]);
  const handleDocumentPointerUp = useEventCallback(() => {
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("pointermove", handleDocumentPointerMove);
  });
  const handleRootOnPointerDown = useEventCallback((event) => {
    event.stopPropagation();
    event.preventDefault();
    requestColorChange(event.nativeEvent);
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("pointermove", handleDocumentPointerMove);
    targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("pointerup", handleDocumentPointerUp, {
      once: true
    });
  });
  const handleInputOnChange = useEventCallback((event) => {
    const targetValue = Number(event.target.value) / 100;
    const newColor = {
      ...hsvColor,
      ...event.target === xRef.current && {
        s: targetValue
      },
      ...event.target === yRef.current && {
        v: targetValue
      }
    };
    setColor(newColor);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const handleRootOnKeyDown = useEventCallback((event) => {
    let deltaX = 0;
    let deltaY = 0;
    let axis = "x";
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        axis = "y";
        deltaY = 1;
        break;
      case "ArrowDown":
        event.preventDefault();
        axis = "y";
        deltaY = -1;
        break;
      case "ArrowLeft":
        event.preventDefault();
        axis = "x";
        deltaX = -1;
        break;
      case "ArrowRight":
        event.preventDefault();
        axis = "x";
        deltaX = 1;
        break;
    }
    if (deltaX === 0 && deltaY === 0) {
      return;
    }
    const newColor = {
      ...hsvColor,
      s: Math.min(Math.max(hsvColor.s + deltaX / 100, 0), 1),
      v: Math.min(Math.max(hsvColor.v + deltaY / 100, 0), 1)
    };
    setColor(newColor);
    setActiveAxis(axis);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const rootVariables = {
    [colorAreaCSSVars.areaXProgressVar]: `${saturation}%`,
    [colorAreaCSSVars.areaYProgressVar]: `${value}%`,
    [colorAreaCSSVars.thumbColorVar]: tinycolor(hsvColor).toRgbString(),
    [colorAreaCSSVars.mainColorVar]: `hsl(${hsvColor.h}, 100%, 50%)`
  };
  const state = {
    shape,
    components: {
      inputX: "input",
      inputY: "input",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...rest
    }), {
      elementType: "div"
    }),
    inputX: slot_exports.always(inputX, {
      defaultProps: {
        id: useId2("sliderX-"),
        type: "range",
        ...activeAxis && {
          tabIndex: activeAxis === "x" ? 0 : -1
        }
      },
      elementType: "input"
    }),
    inputY: slot_exports.always(inputY, {
      defaultProps: {
        id: useId2("sliderY-"),
        type: "range",
        tabIndex: activeAxis && activeAxis === "y" ? 0 : -1
      },
      elementType: "input"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  state.root.ref = useMergedRefs(state.root.ref, rootRef);
  state.thumb.ref = useMergedRefs(state.thumb.ref, focusWithinRef);
  state.inputX.ref = useMergedRefs(state.inputX.ref, xRef);
  state.inputY.ref = useMergedRefs(state.inputY.ref, yRef);
  state.root.style = {
    ...state.root.style,
    ...rootVariables
  };
  state.root.onPointerDown = useEventCallback(mergeCallbacks(state.root.onPointerDown, handleRootOnPointerDown));
  state.root.onKeyDown = useEventCallback(mergeCallbacks(state.root.onKeyDown, handleRootOnKeyDown));
  state.inputX.onChange = useEventCallback(mergeCallbacks(state.inputX.onChange, handleInputOnChange));
  state.inputY.onChange = useEventCallback(mergeCallbacks(state.inputY.onChange, handleInputOnChange));
  state.inputX.value = saturation;
  state.inputY.value = value;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/renderColorArea.js
var renderColorArea_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {
    children: jsxs(state.thumb, {
      children: [
        jsx(state.inputX, {}),
        jsx(state.inputY, {})
      ]
    })
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/ColorArea/ColorArea.js
var ColorArea = React630.forwardRef((props, ref) => {
  const state = useColorArea_unstable(props, ref);
  useColorAreaStyles_unstable(state);
  useCustomStyleHook("useColorAreaStyles_unstable")(state);
  return renderColorArea_unstable(state);
});
ColorArea.displayName = "ColorArea";

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/AlphaSlider.js
var React633 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSlider.js
var React632 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderState.js
var React631 = __toESM(require_react());

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderStyles.styles.js
var alphaSliderClassNames = {
  root: "fui-AlphaSlider",
  rail: "fui-AlphaSlider__rail",
  thumb: "fui-AlphaSlider__thumb",
  input: "fui-AlphaSlider__input"
};
var alphaSliderCSSVars = {
  sliderDirectionVar: `--fui-AlphaSlider--direction`,
  sliderProgressVar: `--fui-AlphaSlider--progress`,
  thumbColorVar: `--fui-AlphaSlider__thumb--color`,
  railColorVar: `--fui-AlphaSlider__rail--color`
};
var useStyles98 = __styles2({
  rail: {
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "fm9niy",
    Bcmaq0h: "f183gti0"
  }
}, {
  d: [[".fm9niy{border:1px solid var(--colorNeutralStroke1);}", {
    p: -2
  }], `.f183gti0{background-image:linear-gradient(var(--fui-AlphaSlider--direction), transparent, var(--fui-AlphaSlider__rail--color)),url(https://fabricweb.azureedge.net/fabric-website/assets/images/transparent-pattern.png);}`]
});
var useThumbStyles4 = __styles2({
  thumb: {
    De3pzq: "fxugw4r",
    cmx5o7: "f5vbyc6"
  },
  horizontal: {
    Bz10aip: ["f13gfj74", "f1nfknbn"],
    oyh7mz: ["fsmxtey", "fh8h8tc"]
  },
  vertical: {
    Bz10aip: "f5cv5a3",
    B5kzvoi: "falo4kr"
  }
}, {
  d: [".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f5vbyc6::before{background-color:var(--fui-AlphaSlider__thumb--color);}", ".f13gfj74{transform:translateX(-50%);}", ".f1nfknbn{transform:translateX(50%);}", ".fsmxtey{left:var(--fui-AlphaSlider--progress);}", ".fh8h8tc{right:var(--fui-AlphaSlider--progress);}", ".f5cv5a3{transform:translateY(50%);}", ".falo4kr{bottom:var(--fui-AlphaSlider--progress);}"]
});
var useAlphaSliderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles98();
  const thumbStyles = useThumbStyles4();
  state.root.className = mergeClasses(alphaSliderClassNames.root, state.root.className);
  state.input.className = mergeClasses(alphaSliderClassNames.input, state.input.className);
  state.rail.className = mergeClasses(alphaSliderClassNames.rail, styles.rail, state.rail.className);
  state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  state.thumb.className = mergeClasses(alphaSliderClassNames.thumb, thumbStyles.thumb, state.vertical ? thumbStyles.vertical : thumbStyles.horizontal, state.thumb.className);
  useColorSliderStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/alphaSliderUtils.js
function adjustToTransparency(value, transparency) {
  return transparency ? 100 - value : value;
}
function calculateTransparencyValue(transparency, value) {
  return value !== void 0 ? adjustToTransparency(value * 100, transparency) : void 0;
}
function getSliderDirection(dir, vertical, transparency) {
  if (vertical) {
    return transparency ? "180deg" : "0deg";
  }
  return dir === "ltr" && !transparency ? "90deg" : "-90deg";
}

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSliderState.js
var useAlphaSliderState_unstable = (state, props) => {
  "use no memo";
  var _props_defaultColor;
  const { dir } = useFluent();
  const onChangeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.requestChange);
  const colorFromContext = useColorPickerContextValue_unstable((ctx) => ctx.color);
  const { color: color2, onChange = onChangeFromContext, transparency = false, vertical = false } = props;
  const hsvColor = color2 || colorFromContext;
  const hslColor = tinycolor(hsvColor).toHsl();
  const [currentValue, setCurrentValue] = useControllableState({
    defaultState: calculateTransparencyValue(transparency, (_props_defaultColor = props.defaultColor) === null || _props_defaultColor === void 0 ? void 0 : _props_defaultColor.a),
    state: calculateTransparencyValue(transparency, hsvColor === null || hsvColor === void 0 ? void 0 : hsvColor.a),
    initialState: adjustToTransparency(100, transparency)
  });
  const clampedValue = clamp(currentValue, MIN, MAX);
  const valuePercent = getPercent2(clampedValue, MIN, MAX);
  const inputOnChange = state.input.onChange;
  const _onChange = useEventCallback((event) => {
    const newValue = adjustToTransparency(Number(event.target.value), transparency);
    const newColor = createHsvColor({
      ...hsvColor,
      a: newValue / 100
    });
    setCurrentValue(newValue);
    inputOnChange === null || inputOnChange === void 0 ? void 0 : inputOnChange(event);
    onChange === null || onChange === void 0 ? void 0 : onChange(event, {
      type: "change",
      event,
      color: newColor
    });
  });
  const sliderDirection = getSliderDirection(dir, vertical, transparency);
  const rootVariables = {
    [alphaSliderCSSVars.sliderDirectionVar]: sliderDirection,
    [alphaSliderCSSVars.sliderProgressVar]: `${valuePercent}%`,
    [alphaSliderCSSVars.thumbColorVar]: `hsla(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%, ${hslColor.a})`,
    [alphaSliderCSSVars.railColorVar]: `hsl(${hslColor.h} ${hslColor.s * 100}%, ${hslColor.l * 100}%)`
  };
  state.root.style = {
    ...rootVariables,
    ...state.root.style
  };
  state.input.value = clampedValue;
  state.input.onChange = _onChange;
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/useAlphaSlider.js
var useAlphaSlider_unstable = (props, ref) => {
  const shapeFromContext = useColorPickerContextValue_unstable((ctx) => ctx.shape);
  const nativeProps = getPartitionedNativeProps({
    props,
    primarySlotTagName: "input",
    excludedPropNames: [
      "onChange",
      "color"
    ]
  });
  const {
    shape = shapeFromContext,
    vertical,
    // Slots
    root,
    input,
    rail,
    thumb
  } = props;
  const state = {
    shape,
    vertical,
    components: {
      input: "input",
      rail: "div",
      root: "div",
      thumb: "div"
    },
    root: slot_exports.always(root, {
      defaultProps: nativeProps.root,
      elementType: "div"
    }),
    input: slot_exports.always(input, {
      defaultProps: {
        id: useId2("slider-", props.id),
        ref,
        ...nativeProps.primary,
        type: "range"
      },
      elementType: "input"
    }),
    rail: slot_exports.always(rail, {
      elementType: "div"
    }),
    thumb: slot_exports.always(thumb, {
      elementType: "div"
    })
  };
  useAlphaSliderState_unstable(state, props);
  return state;
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/renderAlphaSlider.js
var renderAlphaSlider_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      jsx(state.input, {}),
      jsx(state.rail, {}),
      jsx(state.thumb, {})
    ]
  });
};

// node_modules/@fluentui/react-color-picker/lib/components/AlphaSlider/AlphaSlider.js
var AlphaSlider = React633.forwardRef((props, ref) => {
  const state = useAlphaSlider_unstable(props, ref);
  useAlphaSliderStyles_unstable(state);
  useCustomStyleHook("useAlphaSliderStyles_unstable")(state);
  return renderAlphaSlider_unstable(state);
});
AlphaSlider.displayName = "AlphaSlider";

// node_modules/@fluentui/react-nav/lib/components/Nav/Nav.js
var React637 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/Nav/useNav.js
var React634 = __toESM(require_react());
function initializeUncontrolledOpenCategories({ defaultOpenCategories, multiple }) {
  if (defaultOpenCategories !== void 0) {
    if (Array.isArray(defaultOpenCategories)) {
      return multiple ? defaultOpenCategories : [
        defaultOpenCategories[0]
      ];
    }
    return [
      defaultOpenCategories
    ];
  }
  return void 0;
}
var updateOpenCategories = (value, previousOpenItems, multiple) => {
  if (multiple) {
    if (previousOpenItems.includes(value)) {
      return previousOpenItems.filter((i) => i !== value);
    } else {
      return [
        ...previousOpenItems,
        value
      ];
    }
  }
  return previousOpenItems[0] === value ? [] : [
    value
  ];
};
var useNav_unstable = (props, ref) => {
  const { onNavItemSelect, onNavCategoryItemToggle, multiple = true, density = "medium", openCategories: controlledOpenCategoryItems, selectedCategoryValue: controlledSelectedCategoryValue, selectedValue: controlledSelectedValue, defaultOpenCategories, defaultSelectedValue, defaultSelectedCategoryValue } = props;
  const innerRef = React634.useRef(null);
  const [openCategories, setOpenCategories] = useControllableState({
    state: controlledOpenCategoryItems,
    defaultState: initializeUncontrolledOpenCategories({
      defaultOpenCategories,
      multiple
    }),
    initialState: []
  });
  const [selectedCategoryValue, setSelectedCategoryValue] = useControllableState({
    state: controlledSelectedCategoryValue,
    defaultState: defaultSelectedCategoryValue,
    initialState: void 0
  });
  const [selectedValue, setSelectedValue] = useControllableState({
    state: controlledSelectedValue,
    defaultState: defaultSelectedValue,
    initialState: void 0
  });
  const currentSelectedValue = React634.useRef(void 0);
  const previousSelectedValue = React634.useRef(void 0);
  const currentSelectedCategoryValue = React634.useRef(void 0);
  const previousSelectedCategoryValue = React634.useRef(void 0);
  if (currentSelectedValue.current !== selectedValue) {
    previousSelectedValue.current = currentSelectedValue.current;
    currentSelectedValue.current = selectedValue;
  }
  if (currentSelectedCategoryValue.current !== selectedCategoryValue) {
    previousSelectedCategoryValue.current = currentSelectedCategoryValue.current;
    currentSelectedCategoryValue.current = selectedCategoryValue;
  }
  const onSelect = useEventCallback((event, data) => {
    setSelectedValue(data.value);
    setSelectedCategoryValue(data.categoryValue ? data.categoryValue : "");
    onNavItemSelect === null || onNavItemSelect === void 0 ? void 0 : onNavItemSelect(event, data);
  });
  const onRequestNavCategoryItemToggle = useEventCallback((event, data) => {
    if (data.categoryValue !== void 0) {
      const nextOpenCategories = updateOpenCategories(data.categoryValue, openCategories !== null && openCategories !== void 0 ? openCategories : [], multiple);
      onNavCategoryItemToggle === null || onNavCategoryItemToggle === void 0 ? void 0 : onNavCategoryItemToggle(event, data);
      setOpenCategories(nextOpenCategories);
    }
  });
  const registeredNavItems = React634.useRef({});
  const onRegister = React634.useCallback((data) => {
    registeredNavItems.current[JSON.stringify(data.value)] = data;
  }, []);
  const onUnregister = React634.useCallback((data) => {
    delete registeredNavItems.current[JSON.stringify(data.value)];
  }, []);
  const getRegisteredNavItems = React634.useCallback(() => {
    return {
      selectedValue: currentSelectedValue.current,
      previousSelectedValue: previousSelectedValue.current,
      selectedCategoryValue: currentSelectedCategoryValue.current,
      previousSelectedCategoryValue: previousSelectedCategoryValue.current,
      registeredNavItems: registeredNavItems.current
    };
  }, []);
  return {
    components: {
      root: "div"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref: useMergedRefs(ref, innerRef),
      ...props
    }), {
      elementType: "div"
    }),
    openCategories,
    selectedValue,
    selectedCategoryValue,
    onRegister,
    onUnregister,
    onSelect,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    multiple,
    density,
    tabbable: false
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavContext.js
var React635 = __toESM(require_react());
var navContextDefaultValue = {
  selectedValue: void 0,
  selectedCategoryValue: void 0,
  onRegister: () => {
  },
  onUnregister: () => {
  },
  onSelect: () => {
  },
  getRegisteredNavItems: () => {
    return {
      registeredNavItems: {}
    };
  },
  onRequestNavCategoryItemToggle() {
  },
  /**
  * The list of opened panels by index
  */
  openCategories: [],
  /**
  * Indicates if Nav supports multiple open Categories at the same time.
  */
  multiple: true,
  /**
  * Indicates the vertical density and density of the Nav.
  */
  density: "medium",
  /**
  * By default, the Nav is a single tab stop with only arrow key navigation
  */
  tabbable: false
};
var NavContext = React635.createContext(void 0);
var NavProvider = NavContext.Provider;
var useNavContext_unstable = () => React635.useContext(NavContext) || navContextDefaultValue;

// node_modules/@fluentui/react-nav/lib/components/Nav/renderNav.js
var renderNav_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavProvider, {
    value: contextValues.nav,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-nav/lib/components/Nav/useNavStyles.styles.js
var navClassNames = {
  root: "fui-Nav"
};
var useStyles99 = __styles2({
  root: {
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62"
  }
}, {
  d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}"]
});
var useNavStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles99();
  state.root.className = mergeClasses(navClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/useNavContextValues.js
var React636 = __toESM(require_react());
function useNavContextValues_unstable(state) {
  const { selectedValue, selectedCategoryValue, onRegister, onUnregister, onSelect, getRegisteredNavItems, onRequestNavCategoryItemToggle, openCategories, multiple, density, onNavItemSelect, tabbable } = state;
  const navContext = React636.useMemo(() => ({
    selectedValue,
    selectedCategoryValue,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    openCategories,
    multiple,
    density,
    onNavItemSelect,
    tabbable
  }), [
    selectedValue,
    selectedCategoryValue,
    onSelect,
    onRegister,
    onUnregister,
    getRegisteredNavItems,
    onRequestNavCategoryItemToggle,
    openCategories,
    multiple,
    density,
    onNavItemSelect,
    tabbable
  ]);
  return {
    nav: navContext
  };
}

// node_modules/@fluentui/react-nav/lib/components/Nav/Nav.js
var Nav = React637.forwardRef((props, ref) => {
  const state = useNav_unstable(props, ref);
  const contextValues = useNavContextValues_unstable(state);
  useNavStyles_unstable(state);
  useCustomStyleHook("useHamburgerStyles_unstable")(state);
  return renderNav_unstable(state, contextValues);
});
Nav.displayName = "Nav";

// node_modules/@fluentui/react-nav/lib/components/NavCategory/NavCategory.js
var React642 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategory/useNavCategory.js
var React638 = __toESM(require_react());
var useNavCategory_unstable = (props, ref) => {
  const { value, children } = props;
  const { openCategories } = useNavContext_unstable();
  const open = openCategories === null || openCategories === void 0 ? void 0 : openCategories.includes(value);
  return {
    open,
    value,
    children: children !== null && children !== void 0 ? children : null
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavCategory/renderNavCategory.js
var React640 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategoryContext.js
var React639 = __toESM(require_react());
var NavCategoryContext = React639.createContext(void 0);
var navCategoryContextDefaultValue = {
  open: false,
  value: ""
};
var { Provider: NavCategoryProvider } = NavCategoryContext;
var useNavCategoryContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React639.useContext(NavCategoryContext)) !== null && _React_useContext !== void 0 ? _React_useContext : navCategoryContextDefaultValue;
};

// node_modules/@fluentui/react-nav/lib/components/NavCategory/renderNavCategory.js
var renderNavCategory_unstable = (state, contextValues) => {
  return React640.createElement(NavCategoryProvider, {
    value: contextValues.categoryValue
  }, state.children);
};

// node_modules/@fluentui/react-nav/lib/components/useNavCategoryContextValues_unstable.js
var React641 = __toESM(require_react());
function useNavCategoryContextValues_unstable(state) {
  const { open, value } = state;
  const navCategory = React641.useMemo(() => ({
    open,
    value
  }), [
    open,
    value
  ]);
  return {
    categoryValue: navCategory
  };
}

// node_modules/@fluentui/react-nav/lib/components/NavCategory/NavCategory.js
var NavCategory = React642.forwardRef((props, ref) => {
  const state = useNavCategory_unstable(props, ref);
  const contextValues = useNavCategoryContextValues_unstable(state);
  return renderNavCategory_unstable(state, contextValues);
});
NavCategory.displayName = "NavCategory";

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/NavCategoryItem.js
var React646 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.js
var React643 = __toESM(require_react());
var ExpandIconMotion = createPresenceComponentVariant(Rotate, {
  duration: motionTokens.durationFast,
  easing: motionTokens.curveEasyEase,
  animateOpacity: false,
  outAngle: 0,
  inAngle: 180
});
var useNavCategoryItem_unstable = (props, ref) => {
  const { onClick, expandIcon, icon } = props;
  const { open, value } = useNavCategoryContext_unstable();
  const { onRequestNavCategoryItemToggle, selectedCategoryValue, density = "medium" } = useNavContext_unstable();
  const onNavCategoryItemClick = useEventCallback(mergeCallbacks(onClick, (event) => onRequestNavCategoryItemToggle(event, {
    type: "click",
    event,
    value: "",
    categoryValue: value
  })));
  const selected = selectedCategoryValue === value && !open;
  const validAriaCurrent = selected && !open ? "page" : "false";
  return {
    open,
    value,
    selected,
    components: {
      root: "button",
      icon: "span",
      expandIcon: "span",
      expandIconMotion: ExpandIconMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("button", {
      ref,
      "aria-current": validAriaCurrent,
      "aria-expanded": open,
      ...props,
      onClick: onNavCategoryItemClick
    }), {
      elementType: "button"
    }),
    expandIcon: slot_exports.always(expandIcon, {
      defaultProps: {
        children: React643.createElement(ChevronDown20Regular, null),
        "aria-hidden": true
      },
      elementType: "span"
    }),
    expandIconMotion: presenceMotionSlot(props.expandIconMotion, {
      elementType: ExpandIconMotion,
      defaultProps: {
        visible: open
      }
    }),
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItemContext.js
var React644 = __toESM(require_react());
var NavCategoryItemContext = React644.createContext(void 0);
var NavCategoryItemContextDefaultValues = {
  open: false
};
var { Provider: NavCategoryItemProvider } = NavCategoryItemContext;
var useNavCategoryItemContext_unstable = () => {
  var _React_useContext;
  return (_React_useContext = React644.useContext(NavCategoryItemContext)) !== null && _React_useContext !== void 0 ? _React_useContext : NavCategoryItemContextDefaultValues;
};

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/renderNavCategoryItem.js
var getExpandIcon = (state) => {
  assertSlots(state);
  if (!state.expandIcon) {
    return null;
  }
  if (!state.expandIconMotion) {
    return jsx(state.expandIcon, {});
  }
  return jsx(state.expandIconMotion, {
    children: jsx(state.expandIcon, {})
  });
};
var renderNavCategoryItem_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavCategoryItemProvider, {
    value: contextValues.navCategoryItem,
    children: jsxs(state.root, {
      children: [
        state.icon && jsx(state.icon, {}),
        state.root.children,
        getExpandIcon(state)
      ]
    })
  });
};

// node_modules/@fluentui/react-nav/lib/components/sharedNavStyles.styles.js
var navItemTokens = {
  defaultDrawerWidth: 260,
  indicatorOffset: 16,
  indicatorWidth: 4,
  indicatorHeight: 20,
  backgroundColor: tokens.colorNeutralBackground4,
  backgroundColorHover: tokens.colorNeutralBackground4Hover,
  backgroundColorPressed: tokens.colorNeutralBackground4Pressed,
  animationTokens: {
    animationDuration: tokens.durationFaster,
    animationFillMode: "both",
    animationTimingFunction: tokens.curveLinear
  },
  transitionTokens: {
    transitionDuration: tokens.durationFaster,
    transitionTimingFunction: tokens.curveLinear,
    transitionProperty: "background"
  }
};
var useRootDefaultClassName = __resetStyles("rdi7s9k", "r94071", [".rdi7s9k{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:left;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalS) var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}", ".rdi7s9k:hover{background-color:var(--colorNeutralBackground4Hover);}", ".rdi7s9k:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}", ".r94071{display:flex;text-transform:none;position:relative;justify-content:start;align-items:flex-start;text-align:right;gap:var(--spacingVerticalL);padding:var(--spacingVerticalMNudge) var(--spacingHorizontalMNudge) var(--spacingVerticalMNudge) var(--spacingHorizontalS);background-color:var(--colorNeutralBackground4);border-radius:var(--borderRadiusMedium);color:var(--colorNeutralForeground2);text-decoration-line:none;border:none;box-sizing:border-box;cursor:pointer;transition-duration:var(--durationFaster);transition-timing-function:var(--curveLinear);transition-property:background;width:100%;font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);}", ".r94071:hover{background-color:var(--colorNeutralBackground4Hover);}", ".r94071:focus-visible{outline:var(--strokeWidthThick) solid var(--colorStrokeFocus2);outline-offset:calc(var(--strokeWidthThick) * -1);}"]);
var useSmallStyles = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1434i56", "f1jkyjtc"]
  }
}, {
  d: [[".f1434i56{padding:var(--spacingVerticalXS) var(--spacingHorizontalS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1jkyjtc{padding:var(--spacingVerticalXS) var(--spacingHorizontalMNudge) var(--spacingVerticalXS) var(--spacingHorizontalS);}", {
    p: -1
  }]]
});
var useContentStyles4 = __styles2({
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useIndicatorStyles4 = __styles2({
  base: {
    E3zdtr: "f1mdlcz9",
    xr36ep: "fpil94b",
    B67388b: "f90z1up",
    Bitv4sc: "f2ic3ny",
    Br128sd: "f1xz7mvd",
    rjyhj6: "f3i5gj0",
    Bjyk6c5: "fi4v1pz",
    Dlnsje: "f1tvrmnx",
    a2br6o: "f1p1ggug",
    d9w3h3: 0,
    B3778ie: 0,
    B4j8arr: 0,
    Bl18szs: 0,
    Blrzh8d: "f3b9emi",
    Bsft5z2: "f13zj6fq",
    vikyaa: 0,
    Brlscjf: 0,
    vvp1qr: 0,
    t65l24: "f1ak99p5",
    rc3c53: "fmnu42u"
  }
}, {
  d: [".f1mdlcz9::after{position:absolute;}", ".fpil94b::after{animation-duration:var(--durationFaster);}", ".f90z1up::after{animation-fill-mode:both;}", ".f2ic3ny::after{animation-timing-function:var(--curveLinear);}", ".f1xz7mvd::after{animation-name:f1ayorr4;}", ".f3i5gj0::after{-webkit-margin-start:-16px;margin-inline-start:-16px;}", ".fi4v1pz::after{background-color:var(--colorCompoundBrandForeground1);}", ".f1tvrmnx::after{height:20px;}", ".f1p1ggug::after{width:4px;}", [".f3b9emi::after{border-radius:var(--borderRadiusCircular);}", {
    p: -1
  }], '.f13zj6fq::after{content:"";}'],
  k: ["@keyframes f1ayorr4{0%{background:transparent;}100%{background:var(--colorCompoundBrandForeground1);}}"],
  m: [["@media (forced-colors: active){.f1ak99p5::after{outline:solid 2px var(--colorTransparentStroke);}}", {
    p: -1,
    m: "(forced-colors: active)"
  }], ["@media (forced-colors: active){.fmnu42u::after{outline-offset:-2px;}}", {
    m: "(forced-colors: active)"
  }]]
});
var useIconStyles13 = __styles2({
  base: {
    mc9l5x: "f13qh94s",
    zoa1oz: "fngvled",
    sshi5w: "f16gbxbe",
    Bf4jedk: "f11u7vat",
    Bt984gj: "f1w4ww9t",
    Brf1p80: "f4d9j23",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp",
    B9gejnh: 0,
    yr4pdu: 0,
    Bvkmzld: 0,
    mqdk8l: 0,
    Gbjhqp: "f1uiug86",
    obb2bi: "fwrh02z",
    D0sxk3: "f16u1re",
    Esdz9e: 0,
    Bqil8sh: 0,
    Bbom3er: 0,
    djjtid: 0,
    mz70lj: "f1jsjwoh",
    t6yez3: "f8bsbmo"
  },
  selected: {
    C9vb3z: "f5rs5gh",
    ux3ctl: "f1ioc1t6",
    Ba906uv: "fey0lwf",
    D0sxk3: "fxoiby5",
    hndn0g: "fnh0dvc",
    cw2nnk: "fp7jrvw",
    Bkztwl0: "fdt4y6x",
    H8nmoi: "fvl64og",
    ipgedg: "ffh1t26"
  }
}, {
  d: [".f13qh94s{display:grid;}", ".fngvled{grid-template-areas:overlay-area;}", ".f16gbxbe{min-height:20px;}", ".f11u7vat{min-width:20px;}", ".f1w4ww9t{align-items:top;}", ".f4d9j23{justify-content:center;}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }], [".f1uiug86 .fui-Icon-filled{grid-area:overlay-area;}", {
    p: -1
  }], ".fwrh02z .fui-Icon-filled{color:transparent;}", ".f16u1re .fui-Icon-filled{display:none;}", [".f1jsjwoh .fui-Icon-regular{grid-area:overlay-area;}", {
    p: -1
  }], ".f8bsbmo .fui-Icon-regular{display:inline;}", ".f5rs5gh .fui-Icon-filled{animation-duration:var(--durationFaster);}", ".f1ioc1t6 .fui-Icon-filled{animation-fill-mode:both;}", ".fey0lwf .fui-Icon-filled{animation-timing-function:var(--curveLinear);}", ".fxoiby5 .fui-Icon-filled{display:inline;}", ".fnh0dvc .fui-Icon-filled{animation-name:f9t3kp0;}", ".fp7jrvw .fui-Icon-regular{animation-duration:var(--durationFaster);}", ".fdt4y6x .fui-Icon-regular{animation-fill-mode:both;}", ".fvl64og .fui-Icon-regular{animation-timing-function:var(--curveLinear);}", ".ffh1t26 .fui-Icon-regular{animation-name:fvunsy5;}"],
  k: ["@keyframes f9t3kp0{0%{opacity:0;color:transparent;}100%{opacity:1;color:var(--colorNeutralForeground2BrandSelected);}}", "@keyframes fvunsy5{0%{opacity:1;color:var(--colorNeutralForeground2);}100%{opacity:0;color:transparent;}}"]
});

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/useNavCategoryItem.styles.js
var navCategoryItemClassNames = {
  root: "fui-NavCategoryItem",
  icon: "fui-NavCategoryItem__icon",
  expandIcon: "fui-NavCategoryItem__expandIcon",
  expandIconMotion: "fui-NavCategoryItem__expandIconMotion"
};
var useExpandIconStyles = __styles2({
  base: {
    Jyy4pa: "f1lfeew",
    Bqenvij: "fjamq6b"
  },
  selected: {
    Bahqtrf: "fk6fouc",
    Be2twd7: "fkhj508",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "f1i3iumi"
  }
}, {
  d: [".f1lfeew{-webkit-margin-start:auto;margin-inline-start:auto;}", ".fjamq6b{height:20px;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
});
var useRootStyles29 = __styles2({
  base: {
    a9b677: "fly5x3f"
  }
}, {
  d: [".fly5x3f{width:100%;}"]
});
var useNavCategoryItemStyles_unstable = (state) => {
  "use no memo";
  const rootStyles = useRootStyles29();
  const smallStyles = useSmallStyles();
  const defaultRootClassName = useRootDefaultClassName();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const iconStyles = useIconStyles13();
  const expandIconStyles = useExpandIconStyles();
  const {
    selected,
    open,
    density
  } = state;
  state.root.className = mergeClasses(navCategoryItemClassNames.root, defaultRootClassName, rootStyles.base, density === "small" && smallStyles.root, selected && open === false && indicatorStyles.base, selected && open === false && contentStyles.selected, state.root.className);
  state.expandIcon.className = mergeClasses(navCategoryItemClassNames.expandIcon, expandIconStyles.base, state.expandIcon.className);
  if (state.icon) {
    state.icon.className = mergeClasses(navCategoryItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/useNavCategoryItemContextValues_unstable.js
var React645 = __toESM(require_react());
function useNavCategoryItemContextValues_unstable(state) {
  const { open, value } = state;
  const navCategoryItem = React645.useMemo(() => ({
    open,
    value
  }), [
    open,
    value
  ]);
  return {
    navCategoryItem
  };
}

// node_modules/@fluentui/react-nav/lib/components/NavCategoryItem/NavCategoryItem.js
var NavCategoryItem = React646.forwardRef((props, ref) => {
  const state = useNavCategoryItem_unstable(props, ref);
  const contextValues = useNavCategoryItemContextValues_unstable(state);
  useNavCategoryItemStyles_unstable(state);
  useCustomStyleHook("useNavCategoryItemStyles")(state);
  return renderNavCategoryItem_unstable(state, contextValues);
});
NavCategoryItem.displayName = "NavCategoryItem";

// node_modules/@fluentui/react-nav/lib/components/NavItem/NavItem.js
var React648 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItem.js
var React647 = __toESM(require_react());
var useNavItem_unstable = (props, ref) => {
  const { onClick, value, icon, as, href } = props;
  const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
  const rootElementType = as || (href ? "a" : "button");
  const selected = selectedValue === value;
  const innerRef = React647.useRef(null);
  const onNavItemClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      onSelect(event, {
        type: "click",
        event,
        value
      });
    }
  });
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    "aria-current": selected ? "page" : "false",
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  root.onClick = onNavItemClick;
  React647.useEffect(() => {
    onRegister({
      value,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    value
  ]);
  return {
    components: {
      root: rootElementType,
      icon: "span"
    },
    root,
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    selected,
    value,
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/renderNavItem.js
var renderNavItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/useNavItemStyles.styles.js
var navItemClassNames = {
  root: "fui-NavItem",
  icon: "fui-NavItem__icon"
};
var useNavItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const smallStyles = useSmallStyles();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const iconStyles = useIconStyles13();
  const {
    selected,
    density
  } = state;
  state.root.className = mergeClasses(navItemClassNames.root, rootDefaultClassName, density === "small" && smallStyles.root, selected && indicatorStyles.base, selected && contentStyles.selected, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(navItemClassNames.icon, iconStyles.base, selected && iconStyles.selected, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavItem/NavItem.js
var NavItem = React648.forwardRef((props, ref) => {
  const state = useNavItem_unstable(props, ref);
  useNavItemStyles_unstable(state);
  useCustomStyleHook("useNavItemStyles_unstable")(state);
  return renderNavItem_unstable(state);
});
NavItem.displayName = "NavItem";

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/NavSubItem.js
var React650 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItem.js
var React649 = __toESM(require_react());
var useNavSubItem_unstable = (props, ref) => {
  const { onClick, value: subItemValue, as, href } = props;
  const { selectedValue, onRegister, onUnregister, onSelect, density = "medium" } = useNavContext_unstable();
  const { value: parentCategoryValue } = useNavCategoryContext_unstable();
  const rootElementType = as || (href ? "a" : "button");
  const selected = selectedValue === subItemValue;
  const innerRef = React649.useRef(null);
  const onNavSubItemClick = useEventCallback((event) => {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    if (!event.defaultPrevented && isHTMLElement(event.target)) {
      onSelect(event, {
        type: "click",
        event,
        value: subItemValue,
        categoryValue: parentCategoryValue
      });
    }
  });
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    "aria-current": selected ? "page" : "false",
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  root.onClick = onNavSubItemClick;
  React649.useEffect(() => {
    onRegister({
      value: subItemValue,
      ref: innerRef
    });
    return () => {
      onUnregister({
        value: subItemValue,
        ref: innerRef
      });
    };
  }, [
    onRegister,
    onUnregister,
    innerRef,
    subItemValue
  ]);
  return {
    components: {
      root: rootElementType
    },
    root,
    selected,
    value: subItemValue,
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/renderNavSubItem.js
var renderNavSubItem_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/useNavSubItemStyles.styles.js
var navSubItemClassNames = {
  root: "fui-NavSubItem"
};
var useNavSubItemSpecificStyles = __styles2({
  base: {
    B1hrpyx: "fqo71ku"
  },
  smallBase: {
    B1hrpyx: "f17f9sv1"
  },
  selectedIndicator: {
    rjyhj6: "f1f74g36"
  }
}, {
  d: [".fqo71ku{-webkit-padding-start:46px;padding-inline-start:46px;}", ".f17f9sv1{-webkit-padding-start:40px;padding-inline-start:40px;}", ".f1f74g36::after{-webkit-margin-start:-52px;margin-inline-start:-52px;}"]
});
var useNavSubItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const smallStyles = useSmallStyles();
  const contentStyles = useContentStyles4();
  const indicatorStyles = useIndicatorStyles4();
  const navSubItemSpecificStyles = useNavSubItemSpecificStyles();
  const {
    selected,
    density
  } = state;
  const isSmallDensity = density === "small";
  state.root.className = mergeClasses(navSubItemClassNames.root, rootDefaultClassName, isSmallDensity && smallStyles.root, isSmallDensity && navSubItemSpecificStyles.smallBase, navSubItemSpecificStyles.base, selected && indicatorStyles.base, selected && contentStyles.selected, selected && navSubItemSpecificStyles.selectedIndicator, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItem/NavSubItem.js
var NavSubItem = React650.forwardRef((props, ref) => {
  const state = useNavSubItem_unstable(props, ref);
  useNavSubItemStyles_unstable(state);
  useCustomStyleHook("useNavSubItemStyles_unstable")(state);
  return renderNavSubItem_unstable(state);
});
NavSubItem.displayName = "NavSubItem";

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/NavSubItemGroup.js
var React652 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroup.js
var React651 = __toESM(require_react());
var smallSize = 28;
var largeSize = 40;
var NavGroupMotion = createPresenceComponent(({ items, density }) => {
  const isSmallDensity = density === "small";
  const height = items ? isSmallDensity ? items * smallSize : items * largeSize : 0;
  const durationPerItem = isSmallDensity ? 15 : 25;
  const keyframes = [
    {
      opacity: 0,
      minHeight: 0,
      height: 0
    },
    {
      opacity: 1,
      minHeight: `${height}px`,
      height: `${height}px`
    }
  ];
  const baseDuration = motionTokens.durationFast + (items || 0) * durationPerItem;
  const maxDuration = motionTokens.durationUltraSlow;
  const duration = baseDuration > maxDuration ? maxDuration : baseDuration;
  return {
    enter: {
      keyframes,
      duration,
      easing: motionTokens.curveDecelerateMid
    },
    exit: {
      keyframes: [
        ...keyframes
      ].reverse(),
      duration,
      easing: motionTokens.curveAccelerateMin
    }
  };
});
var useNavSubItemGroup_unstable = (props, ref) => {
  const { open } = useNavCategoryContext_unstable();
  const { density } = useNavContext_unstable();
  return {
    open,
    components: {
      root: "div",
      collapseMotion: NavGroupMotion
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ...props,
      ref
    }), {
      elementType: "div"
    }),
    collapseMotion: presenceMotionSlot(props.collapseMotion, {
      elementType: NavGroupMotion,
      defaultProps: {
        visible: open,
        unmountOnExit: true,
        items: React651.Children.count(props.children),
        density
      }
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/renderNavSubItemGroup.js
var renderNavSubItemGroup_unstable = (state) => {
  assertSlots(state);
  return state.collapseMotion ? jsx(state.collapseMotion, {
    children: jsx(state.root, {})
  }) : jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/useNavSubItemGroupStyles.styles.js
var navSubItemGroupClassNames = {
  root: "fui-NavSubItemGroup"
};
var useStyles100 = __styles2({
  root: {
    Bz10aip: "f1yj8dow",
    B68tc82: 0,
    Bmxbyg5: 0,
    Bpg54ce: "f1a3p1vp"
  }
}, {
  d: [".f1yj8dow{transform:translateZ(0);}", [".f1a3p1vp{overflow:hidden;}", {
    p: -1
  }]]
});
var useNavSubItemGroupStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles100();
  state.root.className = mergeClasses(navSubItemGroupClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSubItemGroup/NavSubItemGroup.js
var NavSubItemGroup = React652.forwardRef((props, ref) => {
  const state = useNavSubItemGroup_unstable(props, ref);
  useNavSubItemGroupStyles_unstable(state);
  useCustomStyleHook("useNavSubItemGroupStyles_unstable")(state);
  return renderNavSubItemGroup_unstable(state);
});
NavSubItemGroup.displayName = "NavSubItemGroup";

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/NavDrawer.js
var React654 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawer.js
var React653 = __toESM(require_react());
var useNavDrawer_unstable = (props, ref) => {
  const { size: size3 = void 0, tabbable = false } = props;
  const navState = useNav_unstable(props, ref);
  return {
    ...navState,
    size: size3,
    tabbable,
    components: {
      // TODO: remove once React v18 slot API is modified
      // this is a problem with the lack of support for union types on React v18
      // ComponentState is using React.ComponentType which will try to infer propType
      // propTypes WeakValidator signature will break distributive unions making this type invalid
      root: Drawer
    },
    root: slot_exports.always({
      ref,
      role: "navigation",
      ...props
    }, {
      // TODO: remove once React v18 slot API is modified
      // this is a problem with the lack of support for union types on React v18
      // ComponentState is using React.ComponentType which will try to infer propType
      // propTypes WeakValidator signature will break distributive unions making this type invalid
      elementType: Drawer
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/renderNavDrawer.js
var renderNavDrawer_unstable = (state, contextValues) => {
  assertSlots(state);
  return jsx(NavProvider, {
    value: contextValues.nav,
    children: jsx(state.root, {})
  });
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/useNavDrawerStyles.styles.js
var navDrawerClassNames = {
  root: "fui-NavDrawer"
};
var useStyles101 = __styles2({
  root: {
    De3pzq: "f1ctqxl6",
    Bt984gj: "f3gca8"
  },
  defaultWidth: {
    a9b677: "f12j6lm0"
  }
}, {
  d: [".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".f3gca8{align-items:unset;}", ".f12j6lm0{width:260px;}"]
});
var useNavDrawerStyles_unstable = (state) => {
  "use no memo";
  const {
    size: size3
  } = state;
  const styles = useStyles101();
  state.root.className = mergeClasses(navDrawerClassNames.root, styles.root, !size3 && styles.defaultWidth, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawer/NavDrawer.js
var NavDrawer = React654.forwardRef((props, ref) => {
  const state = useNavDrawer_unstable(props, ref);
  const contextValues = useNavContextValues_unstable(state);
  useNavDrawerStyles_unstable(state);
  useCustomStyleHook("useNavDrawerStyles_unstable")(state);
  return renderNavDrawer_unstable(state, contextValues);
});
NavDrawer.displayName = "NavDrawer";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/NavDrawerFooter.js
var React656 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooter.js
var React655 = __toESM(require_react());
var useNavDrawerFooter_unstable = (props, ref) => {
  return useDrawerFooter_unstable(props, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/useNavDrawerFooterStyles.styles.js
var navDrawerFooterClassNames = {
  root: "fui-NavDrawerFooter"
};
var useStyles102 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f1j1cbdv",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "f1j0q4x9"
  }
}, {
  d: [[".f1j1cbdv{padding:var(--spacingVerticalXXS) var(--spacingHorizontalXS) var(--spacingVerticalXXS) var(--spacingVerticalXS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"]
});
var useNavDrawerFooterStyles_unstable = (state) => {
  "use no memo";
  useDrawerFooterStyles_unstable(state);
  const styles = useStyles102();
  state.root.className = mergeClasses(navDrawerFooterClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerFooter/NavDrawerFooter.js
var NavDrawerFooter = React656.forwardRef((props, ref) => {
  const state = useNavDrawerFooter_unstable(props, ref);
  useNavDrawerFooterStyles_unstable(state);
  useCustomStyleHook("useNavDrawerFooterStyles_unstable")(state);
  return renderDrawerFooter_unstable(state);
});
NavDrawerFooter.displayName = "NavDrawerFooter";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/NavDrawerHeader.js
var React658 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeaderStyles.styles.js
var navDrawerHeaderClassNames = {
  root: "fui-NavDrawerHeader"
};
var useStyles103 = __styles2({
  root: {
    jrapky: 0,
    Frg6f3: 0,
    t21cq0: 0,
    B6of3ja: 0,
    B74szlk: "f1r2n0t9",
    B1hrpyx: "f80d8h0",
    Dbcxam: 0,
    rjzwhg: 0,
    Bblux5w: "fesrmp8"
  }
}, {
  d: [[".f1r2n0t9{margin:unset;}", {
    p: -1
  }], ".f80d8h0{-webkit-padding-start:14px;padding-inline-start:14px;}", [".fesrmp8{padding-block:5px;}", {
    p: -1
  }]]
});
var useNavDrawerHeaderStyles_unstable = (state) => {
  "use no memo";
  useDrawerHeaderStyles_unstable(state);
  const styles = useStyles103();
  state.root.className = mergeClasses(navDrawerHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/useNavDrawerHeader.js
var React657 = __toESM(require_react());
var useNavDrawerHeader_unstable = (props, ref) => {
  return useDrawerHeader_unstable(props, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerHeader/NavDrawerHeader.js
var NavDrawerHeader = React658.forwardRef((props, ref) => {
  const state = useNavDrawerHeader_unstable(props, ref);
  useNavDrawerHeaderStyles_unstable(state);
  useCustomStyleHook("useNavDrawerHeaderStyles_unstable")(state);
  return renderDrawerHeader_unstable(state);
});
NavDrawerHeader.displayName = "NavDrawerHeader";

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/NavDrawerBody.js
var React660 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBody.js
var React659 = __toESM(require_react());
var useNavDrawerBody_unstable = (props, ref) => {
  const { tabbable } = useNavContext_unstable();
  const focusAttributes = useArrowNavigationGroup({
    axis: "vertical",
    circular: true,
    tabbable
  });
  return useDrawerBody_unstable({
    ...focusAttributes,
    ...props
  }, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/useNavDrawerBodyStyles.styles.js
var navDrawerBodyClassNames = {
  root: "fui-NavDrawerBody"
};
var useStyles104 = __styles2({
  root: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["fif7vu7", "f1htewbf"],
    Bt984gj: "f3gca8",
    mc9l5x: "f22iagw",
    Beiy3e4: "f1vx9l62",
    Belr9w4: "f1j0q4x9"
  }
}, {
  d: [[".fif7vu7{padding:0 var(--spacingHorizontalXS) 0 var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".f1htewbf{padding:0 var(--spacingHorizontalMNudge) 0 var(--spacingHorizontalXS);}", {
    p: -1
  }], ".f3gca8{align-items:unset;}", ".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f1j0q4x9{row-gap:var(--spacingVerticalXXS);}"]
});
var useNavDrawerBodyStyles_unstable = (state) => {
  "use no memo";
  useDrawerBodyStyles_unstable(state);
  const styles = useStyles104();
  state.root.className = mergeClasses(navDrawerBodyClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDrawerBody/NavDrawerBody.js
var NavDrawerBody = React660.forwardRef((props, ref) => {
  const state = useNavDrawerBody_unstable(props, ref);
  useNavDrawerBodyStyles_unstable(state);
  useCustomStyleHook("useNavDrawerBodyStyles_unstable")(state);
  return renderDrawerBody_unstable(state);
});
NavDrawerBody.displayName = "NavDrawerBody";

// node_modules/@fluentui/react-nav/lib/components/Hamburger/Hamburger.js
var React662 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburger.js
var React661 = __toESM(require_react());
var useHamburger_unstable = (props, ref) => {
  return useButton_unstable({
    icon: React661.createElement(Navigation20Filled, null),
    appearance: "transparent",
    ...props
  }, ref);
};

// node_modules/@fluentui/react-nav/lib/components/Hamburger/useHamburgerStyles.styles.js
var hamburgerClassNames = {
  root: "fui-Hamburger",
  icon: "fui-Hamburger__icon"
};
var useStyles105 = __styles2({
  root: {
    w71qe1: "f1iuv45f",
    De3pzq: "f1ctqxl6",
    Bgfg5da: 0,
    B9xav0g: 0,
    oivjwe: 0,
    Bn0qgzm: 0,
    B4g9neb: 0,
    zhjwy3: 0,
    wvpqe5: 0,
    ibv6hh: 0,
    u1mtju: 0,
    h3c5rm: 0,
    vrafjx: 0,
    Bekrc4i: 0,
    i8vvqc: 0,
    g2u3we: 0,
    icvyot: 0,
    B4j52fo: 0,
    irswps: "f3bhgqh",
    Jwef8y: "f11oyicx",
    ecr2s2: "f9fof1w"
  }
}, {
  d: [".f1iuv45f{text-decoration-line:none;}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", [".f3bhgqh{border:none;}", {
    p: -2
  }]],
  h: [".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}"],
  a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
});
var useHamburgerStyles_unstable = (state) => {
  "use no memo";
  useButtonStyles_unstable(state);
  const styles = useStyles105();
  state.root.className = mergeClasses(hamburgerClassNames.root, styles.root, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(hamburgerClassNames.icon, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/Hamburger/Hamburger.js
var Hamburger = React662.forwardRef((props, ref) => {
  const state = useHamburger_unstable(props, ref);
  useHamburgerStyles_unstable(state);
  useCustomStyleHook("useHamburgerStyles_unstable")(state);
  return renderButton_unstable(state);
});
Hamburger.displayName = "Hamburger";

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/NavSectionHeader.js
var React664 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeader.js
var React663 = __toESM(require_react());
var useNavSectionHeader_unstable = (props, ref) => {
  return {
    components: {
      root: "h3"
    },
    root: slot_exports.always(getIntrinsicElementProps("h3", {
      ref,
      ...props
    }), {
      elementType: "h3"
    })
  };
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/renderNavSectionHeader.js
var renderNavSectionHeader_unstable = (state) => {
  assertSlots(state);
  return jsx(state.root, {});
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/useNavSectionHeaderStyles.styles.js
var navSectionHeaderClassNames = {
  root: "fui-NavSectionHeader"
};
var useStyles106 = __styles2({
  root: {
    Jyy4pa: "f1gr6hdk",
    Bo78w4l: 0,
    Cgygva: 0,
    yil37a: "f1ulrxyd",
    Bahqtrf: "fk6fouc",
    Be2twd7: "fy9rknc",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "fwrc4pm"
  }
}, {
  d: [".f1gr6hdk{-webkit-margin-start:10px;margin-inline-start:10px;}", [".f1ulrxyd{margin-block:8px;}", {
    p: -1
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}"]
});
var useNavSectionHeaderStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles106();
  state.root.className = mergeClasses(navSectionHeaderClassNames.root, styles.root, state.root.className);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavSectionHeader/NavSectionHeader.js
var NavSectionHeader = React664.forwardRef((props, ref) => {
  const state = useNavSectionHeader_unstable(props, ref);
  useNavSectionHeaderStyles_unstable(state);
  useCustomStyleHook("useNavSectionHeaderStyles_unstable")(state);
  return renderNavSectionHeader_unstable(state);
});
NavSectionHeader.displayName = "NavSectionHeader";

// node_modules/@fluentui/react-nav/lib/components/NavDivider/NavDivider.js
var React666 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDivider.js
var React665 = __toESM(require_react());
var useNavDivider_unstable = (props, ref) => {
  return useDivider_unstable({
    appearance: "strong",
    ...props
  }, ref);
};

// node_modules/@fluentui/react-nav/lib/components/NavDivider/useNavDividerStyles.styles.js
var navDividerClassNames = {
  root: "fui-NavDivider",
  wrapper: "fui-NavDivider__wrapper"
};
var useStyles107 = __styles2({
  root: {
    Bh6795r: "f1jhi6b8",
    B6of3ja: "fvjh0tl",
    jrapky: "fd1gkq"
  }
}, {
  d: [".f1jhi6b8{flex-grow:0;}", ".fvjh0tl{margin-top:4px;}", ".fd1gkq{margin-bottom:4px;}"]
});
var useNavDividerStyles_unstable = (state) => {
  "use no memo";
  const styles = useStyles107();
  state.root.className = mergeClasses(navDividerClassNames.root, styles.root, state.root.className);
  state.wrapper.className = mergeClasses(navDividerClassNames.wrapper, state.wrapper.className);
  useDividerStyles_unstable(state);
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/NavDivider/NavDivider.js
var NavDivider = React666.forwardRef((props, ref) => {
  const state = useNavDivider_unstable(props, ref);
  useNavDividerStyles_unstable(state);
  useCustomStyleHook("useNavDividerStyles_unstable")(state);
  return renderDivider_unstable(state);
});
NavDivider.displayName = "NavDivider";

// node_modules/@fluentui/react-nav/lib/components/AppItem/AppItem.js
var React668 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItem.js
var React667 = __toESM(require_react());
var useAppItem_unstable = (props, ref) => {
  const { icon, as, href } = props;
  const rootElementType = as || (href ? "a" : "button");
  const { density = "medium" } = useNavContext_unstable();
  const root = slot_exports.always(getIntrinsicElementProps(rootElementType, useARIAButtonProps(rootElementType, {
    ...props
  })), {
    elementType: rootElementType,
    defaultProps: {
      ref,
      type: rootElementType
    }
  });
  return {
    components: {
      root: rootElementType,
      icon: "span"
    },
    root,
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/renderAppItem.js
var renderAppItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/useAppItemStyles.styles.js
var appItemClassNames = {
  root: "fui-AppItem",
  icon: "fui-AppItem__icon"
};
var useAppItemStyles = __styles2({
  root: {
    Bokbzmb: "f1x6gvzo",
    Jyy4pa: "f1djyvue",
    B1u1w3b: "feysv1g",
    a9b677: "f1jd6clc",
    Bt984gj: "f122n59",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1ga9sj3",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1fdqhks", "fnlwq4f"],
    Bahqtrf: "fk6fouc",
    Be2twd7: "fod5ikn",
    Bhrd7zp: "fl43uef",
    Bg96gwp: "faaz57k"
  },
  small: {
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: ["f1m1l4b8", "f1yxbtnt"],
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1let0xu"
  },
  absentIconRootAdjustment: {
    B1hrpyx: "ft8721j"
  }
}, {
  d: [[".feysv1g{margin-inline:4px;}", {
    p: -1
  }], ".f1jd6clc{width:revert;}", ".f122n59{align-items:center;}", [".f1ga9sj3{gap:10px;}", {
    p: -1
  }], ".f1djyvue{-webkit-margin-start:-6px;margin-inline-start:-6px;}", ".f1x6gvzo{-webkit-margin-end:0px;margin-inline-end:0px;}", [".f1fdqhks{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) var(--spacingHorizontalMNudge);}", {
    p: -1
  }], [".fnlwq4f{padding:var(--spacingVerticalS) var(--spacingHorizontalMNudge) var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", [".f1m1l4b8{padding:var(--spacingVerticalS) var(--spacingHorizontalS) var(--spacingVerticalS) 14px;}", {
    p: -1
  }], [".f1yxbtnt{padding:var(--spacingVerticalS) 14px var(--spacingVerticalS) var(--spacingHorizontalS);}", {
    p: -1
  }], [".f1let0xu{gap:14px;}", {
    p: -1
  }], ".ft8721j{-webkit-padding-start:16px;padding-inline-start:16px;}"]
});
var useAppItemStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const iconStyles = useIconStyles13();
  const appItemSpecificStyles = useAppItemStyles();
  const {
    density,
    icon
  } = state;
  state.root.className = mergeClasses(rootDefaultClassName, appItemClassNames.root, appItemSpecificStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(appItemClassNames.icon, iconStyles.base, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/AppItem/AppItem.js
var AppItem = React668.forwardRef((props, ref) => {
  const state = useAppItem_unstable(props, ref);
  useAppItemStyles_unstable(state);
  useCustomStyleHook("useAppItemStyles_unstable")(state);
  return renderAppItem_unstable(state);
});
AppItem.displayName = "AppItem";

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/AppItemStatic.js
var React670 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStatic.js
var React669 = __toESM(require_react());
var useAppItemStatic_unstable = (props, ref) => {
  const { icon } = props;
  const { density = "medium" } = useNavContext_unstable();
  return {
    components: {
      root: "div",
      icon: "span"
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props
    }), {
      elementType: "div"
    }),
    icon: slot_exports.optional(icon, {
      elementType: "span"
    }),
    density
  };
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/renderAppItemStatic.js
var renderAppItemStatic_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.icon && jsx(state.icon, {}),
      state.root.children
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/useAppItemStaticStyles.styles.js
var appItemStaticClassNames = {
  root: "fui-AppItemStatic",
  icon: "fui-AppItemStatic__icon"
};
var useAppItemStaticStyles = __styles2({
  root: {
    Bceei9c: "f158kwzp",
    Jwef8y: "fmaajru",
    ecr2s2: "f11z5bqc"
  }
}, {
  d: [".f158kwzp{cursor:default;}"],
  h: [".fmaajru:hover{background-color:unset;}"],
  a: [".f11z5bqc:active{background-color:unset;}"]
});
var useAppItemStaticStyles_unstable = (state) => {
  "use no memo";
  const rootDefaultClassName = useRootDefaultClassName();
  const iconStyles = useIconStyles13();
  const appItemSpecificStyles = useAppItemStyles();
  const appItemStaticStyles = useAppItemStaticStyles();
  const {
    density,
    icon
  } = state;
  state.root.className = mergeClasses(rootDefaultClassName, appItemStaticClassNames.root, appItemSpecificStyles.root, appItemStaticStyles.root, density === "small" && appItemSpecificStyles.small, !icon && appItemSpecificStyles.absentIconRootAdjustment, state.root.className);
  if (state.icon) {
    state.icon.className = mergeClasses(appItemStaticClassNames.icon, iconStyles.base, state.icon.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/AppItemStatic/AppItemStatic.js
var AppItemStatic = React670.forwardRef((props, ref) => {
  const state = useAppItemStatic_unstable(props, ref);
  useAppItemStaticStyles_unstable(state);
  useCustomStyleHook("useAppItemStaticStyles_unstable")(state);
  return renderAppItemStatic_unstable(state);
});
AppItemStatic.displayName = "AppItemStatic";

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/SplitNavItem.js
var React673 = __toESM(require_react());

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItem.js
var React671 = __toESM(require_react());
var useSplitNavItem_unstable = (props, ref) => {
  const { navItem, actionButton: actionButton2, toggleButton: toggleButton2, menuButton: menuButton2, actionButtonTooltip, toggleButtonTooltip, menuButtonTooltip, children } = props;
  const { density = "medium" } = useNavContext_unstable();
  const { value: potentialParenValue } = useNavCategoryContext_unstable();
  const isSubNav = potentialParenValue.length > 0 ? true : false;
  const navItemShorthand = slot_exports.always(navItem, {
    defaultProps: {
      children
    },
    elementType: isSubNav ? NavSubItem : NavItem
  });
  const actionButtonShorthand = slot_exports.optional(actionButton2, {
    defaultProps: {
      icon: React671.createElement(Pin20Regular, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: Button
  });
  const toggleButtonShorthand = slot_exports.optional(toggleButton2, {
    defaultProps: {
      icon: React671.createElement(Pin20Regular, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: ToggleButton
  });
  const menuButtonShorthand = slot_exports.optional(menuButton2, {
    defaultProps: {
      icon: React671.createElement(MoreHorizontalFilled, null),
      size: "small",
      appearance: "transparent"
    },
    elementType: MenuButton
  });
  const actionButtonTooltipShorthand = slot_exports.optional(actionButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  const toggleButtonTooltipShorthand = slot_exports.optional(toggleButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  const menuButtonTooltipShorthand = slot_exports.optional(menuButtonTooltip, {
    defaultProps: {
      relationship: "label"
    },
    elementType: Tooltip
  });
  return {
    components: {
      root: "div",
      navItem: isSubNav ? NavSubItem : NavItem,
      actionButton: Button,
      toggleButton: ToggleButton,
      menuButton: MenuButton,
      actionButtonTooltip: Tooltip,
      toggleButtonTooltip: Tooltip,
      menuButtonTooltip: Tooltip
    },
    root: slot_exports.always(getIntrinsicElementProps("div", {
      ref,
      ...props,
      // because we're passing in children to the NavItem,
      // We can be explicit about the children prop here
      children: null
    }), {
      elementType: "div"
    }),
    navItem: navItemShorthand,
    actionButton: actionButtonShorthand,
    toggleButton: toggleButtonShorthand,
    menuButton: menuButtonShorthand,
    actionButtonTooltip: actionButtonTooltipShorthand,
    toggleButtonTooltip: toggleButtonTooltipShorthand,
    menuButtonTooltip: menuButtonTooltipShorthand,
    density,
    isSubNav
  };
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/renderSplitNavItem.js
var React672 = __toESM(require_react());
var renderButtonSlot = (Button2, ButtonTooltip) => {
  if (!Button2) {
    return null;
  }
  if (ButtonTooltip) {
    return jsx(ButtonTooltip, {
      children: jsx(Button2, {})
    });
  }
  return jsx(Button2, {});
};
var renderSplitNavItem_unstable = (state) => {
  assertSlots(state);
  return jsxs(state.root, {
    children: [
      state.navItem && jsx(state.navItem, {}),
      renderButtonSlot(state.actionButton, state.actionButtonTooltip),
      renderButtonSlot(state.menuButton, state.menuButtonTooltip),
      renderButtonSlot(state.toggleButton, state.toggleButtonTooltip)
    ]
  });
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/useSplitNavItemStyles.styles.js
var splitNavItemClassNames = {
  root: "fui-SplitNavItem",
  navItem: "fui-SplitNavItem__navItem",
  actionButton: "fui-SplitNavItem__actionButton",
  toggleButton: "fui-SplitNavItem__toggleButton",
  menuButton: "fui-SplitNavItem__menuButton",
  /**
  * Tooltips don't have a class name prop, so this is just to satisfy the linter.
  */
  actionButtonTooltip: "fui-SplitNavItem__actionButtonTooltip",
  toggleButtonTooltip: "fui-SplitNavItem__toggleButtonTooltip",
  menuButtonTooltip: "fui-SplitNavItem__menuButtonTooltip"
};
var {
  actionButton,
  toggleButton,
  menuButton
} = splitNavItemClassNames;
var buttonHoverStyles = {
  [`& .${actionButton}, & .${toggleButton}, & .${menuButton}`]: {
    opacity: 1,
    pointerEvents: "auto"
  }
};
var useSplitNaveItemStyles = __styles2({
  baseRoot: {
    mc9l5x: "f22iagw",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "fx80lhs",
    Bt984gj: "f1q9h2pe",
    Byoj8tv: 0,
    uwmqm3: 0,
    z189sj: 0,
    z8tnut: 0,
    B0ocmuz: "f19jm9xf",
    fsow6f: "fgusgyc",
    De3pzq: "f1ctqxl6",
    B3o57yi: "fnsygzv",
    Bkqvd7p: "f1e9ux7i",
    Bmy1vo4: "f1xfaukr",
    Jwef8y: "f11oyicx",
    xwko9w: "f8z0t4e",
    mcc9px: "f9ueil3",
    B02v5zz: "f1g2hb8n",
    i4x37a: "fpq6je",
    ecr2s2: "f9fof1w"
  },
  baseNavItem: {
    mc9l5x: "f22iagw",
    B9bfxx9: "f1cxpek8",
    qb2dma: "f1ub7u0d",
    fsow6f: ["f1o700av", "fes3tcz"],
    qhf8xq: "f10pi13n",
    Brf1p80: "f1s9ku6b",
    i8kkvl: 0,
    Belr9w4: 0,
    rmohyg: "f1u2hskj",
    De3pzq: "f3rmtva"
  },
  baseSecondary: {
    Bf4jedk: "f107v6xj",
    Bnt446c: "f1y335lp",
    B1hrpyx: "f12pses1",
    rjzwhg: "fibmr9j",
    Bt984gj: "f1s2louj"
  },
  baseMedium: {
    rjzwhg: "fjtod8q"
  },
  baseLarge: {
    rjzwhg: "f16gijt3"
  },
  hoverAction: {
    abs64n: "fk73vx1",
    Bkecrkj: "f1aehjj5",
    Bn62ygk: 0,
    Cwk7ip: 0,
    B3o57yi: 0,
    Bmy1vo4: 0,
    Bkqvd7p: 0,
    Bi2q7bf: ["fr12795", "fcl876f"],
    Es3by: "f1gqqdtu"
  }
}, {
  d: [".f22iagw{display:flex;}", [".fx80lhs{gap:unset;}", {
    p: -1
  }], ".f1q9h2pe{align-items:stretch;}", [".f19jm9xf{padding:unset;}", {
    p: -1
  }], ".fgusgyc{text-align:unset;}", ".f1ctqxl6{background-color:var(--colorNeutralBackground4);}", ".fnsygzv{transition-duration:var(--durationFaster);}", ".f1e9ux7i{transition-timing-function:var(--curveLinear);}", ".f1xfaukr{transition-property:background;}", ".f1cxpek8{text-transform:none;}", ".f1ub7u0d{align-self:stretch;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".f10pi13n{position:relative;}", ".f1s9ku6b{justify-content:start;}", [".f1u2hskj{gap:var(--spacingVerticalL);}", {
    p: -1
  }], ".f3rmtva{background-color:transparent;}", ".f107v6xj{min-width:28px;}", ".f1y335lp{-webkit-padding-end:12px;padding-inline-end:12px;}", ".f12pses1{-webkit-padding-start:5px;padding-inline-start:5px;}", ".fibmr9j{padding-block-start:5px;}", ".f1s2louj{align-items:start;}", ".fjtod8q{padding-block-start:9px;}", ".f16gijt3{padding-block-start:12px;}", ".fk73vx1{opacity:0;}", ".f1aehjj5{pointer-events:none;}", [".fr12795{transition:opacity 150ms cubic-bezier(0.33,0,0.67,1);}", {
    p: -1
  }], [".fcl876f{transition:opacity 150ms cubic-bezier(0.33, 0, 0.67, 1);}", {
    p: -1
  }], ".f1gqqdtu{will-change:opacity;}"],
  h: [".f11oyicx:hover{background-color:var(--colorNeutralBackground4Hover);}", ".f8z0t4e:hover .fui-SplitNavItem__actionButton,.f8z0t4e:hover .fui-SplitNavItem__toggleButton,.f8z0t4e:hover .fui-SplitNavItem__menuButton{opacity:1;}", ".f9ueil3:hover .fui-SplitNavItem__actionButton,.f9ueil3:hover .fui-SplitNavItem__toggleButton,.f9ueil3:hover .fui-SplitNavItem__menuButton{pointer-events:auto;}"],
  w: [".f1g2hb8n:focus-within .fui-SplitNavItem__actionButton,.f1g2hb8n:focus-within .fui-SplitNavItem__toggleButton,.f1g2hb8n:focus-within .fui-SplitNavItem__menuButton{opacity:1;}", ".fpq6je:focus-within .fui-SplitNavItem__actionButton,.fpq6je:focus-within .fui-SplitNavItem__toggleButton,.fpq6je:focus-within .fui-SplitNavItem__menuButton{pointer-events:auto;}"],
  a: [".f9fof1w:active{background-color:var(--colorNeutralBackground4Pressed);}"]
});
var useSplitNavItemStyles_unstable = (state) => {
  "use no memo";
  const splitNavItemStyles = useSplitNaveItemStyles();
  const sharedRootClassNames = useRootDefaultClassName();
  state.root.className = mergeClasses(splitNavItemClassNames.root, sharedRootClassNames, splitNavItemStyles.baseRoot, state.root.className);
  if (state.navItem) {
    state.navItem.className = mergeClasses(splitNavItemClassNames.navItem, splitNavItemStyles.baseNavItem, state.navItem.className);
  }
  if (state.actionButton) {
    state.actionButton.className = mergeClasses(splitNavItemClassNames.actionButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.actionButton.className);
  }
  if (state.toggleButton) {
    state.toggleButton.className = mergeClasses(splitNavItemClassNames.toggleButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.toggleButton.className);
  }
  if (state.menuButton) {
    state.menuButton.className = mergeClasses(splitNavItemClassNames.menuButton, splitNavItemStyles.baseSecondary, splitNavItemStyles.hoverAction, state.density === "medium" && splitNavItemStyles.baseMedium, state.menuButton.className);
  }
  return state;
};

// node_modules/@fluentui/react-nav/lib/components/SplitNavItem/SplitNavItem.js
var SplitNavItem = React673.forwardRef((props, ref) => {
  const state = useSplitNavItem_unstable(props, ref);
  useSplitNavItemStyles_unstable(state);
  useCustomStyleHook("useSplitNavItemStyles_unstable")(state);
  return renderSplitNavItem_unstable(state);
});
SplitNavItem.displayName = "SplitNavItem";
export {
  Accordion,
  AccordionHeader,
  AccordionItem,
  AccordionItemProvider,
  AccordionPanel,
  AccordionProvider,
  AlphaSlider,
  AnnounceProvider,
  AppItem,
  AppItemStatic,
  AriaLiveAnnouncer,
  Avatar,
  AvatarGroup,
  AvatarGroupItem,
  AvatarGroupPopover,
  AvatarGroupProvider,
  Badge,
  Body1,
  Body1Strong,
  Body1Stronger,
  Body2,
  Breadcrumb,
  BreadcrumbButton,
  BreadcrumbDivider,
  BreadcrumbItem,
  BreadcrumbProvider,
  Button,
  Caption1,
  Caption1Strong,
  Caption1Stronger,
  Caption2,
  Caption2Strong,
  Card,
  CardFooter,
  CardHeader,
  CardPreview,
  Carousel,
  CarouselAutoplayButton,
  CarouselButton,
  CarouselCard,
  CarouselNav,
  CarouselNavButton,
  CarouselNavContainer,
  CarouselNavImageButton,
  CarouselProvider2 as CarouselProvider,
  CarouselSlider,
  CarouselViewport,
  Checkbox,
  ColorArea,
  ColorPicker,
  ColorSlider,
  ColorSwatch,
  ColumnIdContextProvider,
  Combobox,
  ComboboxProvider,
  CompoundButton,
  CounterBadge,
  DATA_OVERFLOWING2 as DATA_OVERFLOWING,
  DATA_OVERFLOW_DIVIDER,
  DATA_OVERFLOW_ITEM,
  DATA_OVERFLOW_MENU,
  DataGrid,
  DataGridBody,
  DataGridCell,
  DataGridContextProvider,
  DataGridHeader,
  DataGridHeaderCell,
  DataGridRow,
  DataGridSelectionCell,
  Dialog,
  DialogActions,
  DialogBody,
  DialogContent,
  DialogProvider,
  DialogSurface,
  DialogTitle,
  DialogTrigger,
  Display,
  Divider,
  Drawer,
  DrawerBody,
  DrawerFooter,
  DrawerHeader,
  DrawerHeaderNavigation,
  DrawerHeaderTitle,
  DrawerProvider,
  Dropdown,
  EmptySwatch,
  Field,
  FieldContextProvider,
  FlatTree,
  FlatTreeItem,
  FluentProvider,
  Hamburger,
  IdPrefixProvider,
  Image,
  ImageSwatch,
  InfoButton,
  InfoLabel,
  InlineDrawer,
  Input,
  InteractionTag,
  InteractionTagPrimary,
  InteractionTagSecondary,
  Label,
  LargeTitle,
  Link2 as Link,
  List,
  ListItem,
  Listbox,
  ListboxProvider,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuGroupContextProvider,
  MenuGroupHeader,
  MenuItem,
  MenuItemCheckbox,
  MenuItemLink,
  MenuItemRadio,
  MenuItemSwitch,
  MenuList,
  MenuListProvider,
  MenuPopover,
  MenuProvider,
  MenuSplitGroup,
  MenuTrigger,
  MenuTriggerContextProvider,
  MessageBar,
  MessageBarActions,
  MessageBarBody,
  MessageBarContextProvider,
  MessageBarGroup,
  MessageBarTitle,
  Nav,
  NavCategory,
  NavCategoryItem,
  NavCategoryItemProvider,
  NavCategoryProvider,
  NavDivider,
  NavDrawer,
  NavDrawerBody,
  NavDrawerFooter,
  NavDrawerHeader,
  NavItem,
  NavProvider,
  NavSectionHeader,
  NavSubItem,
  NavSubItemGroup,
  Option,
  OptionGroup,
  Overflow,
  OverflowDivider,
  OverflowItem,
  OverlayDrawer,
  Persona,
  Popover,
  PopoverProvider,
  PopoverSurface,
  PopoverTrigger,
  Portal,
  PortalMountNodeProvider,
  PositioningConfigurationProvider,
  PresenceBadge,
  PresenceGroup,
  ProgressBar,
  Radio,
  RadioGroup,
  RadioGroupProvider,
  Rating,
  RatingDisplay,
  RatingItem,
  RatingItemProvider,
  RendererProvider,
  SSRProvider,
  SearchBox,
  Select2 as Select,
  Skeleton,
  SkeletonContextProvider,
  SkeletonItem,
  Slider,
  SpinButton,
  Spinner,
  SplitButton,
  SplitNavItem,
  Subtitle1,
  Subtitle2,
  Subtitle2Stronger,
  SwatchPicker,
  SwatchPickerProvider,
  SwatchPickerRow,
  Switch,
  Tab2 as Tab,
  TabList,
  TabListProvider,
  Table,
  TableBody,
  TableCell,
  TableCellActions,
  TableCellLayout,
  TableContextProvider,
  TableHeader,
  TableHeaderCell,
  TableHeaderContextProvider,
  TableResizeHandle,
  TableRow,
  TableRowIdContextProvider,
  TableSelectionCell,
  Tag,
  TagGroup,
  TagPicker,
  TagPickerButton,
  TagPickerControl,
  TagPickerGroup,
  TagPickerInput,
  TagPickerList,
  TagPickerOption,
  TagPickerOptionGroup,
  TeachingPopover,
  TeachingPopoverBody,
  TeachingPopoverCarousel,
  TeachingPopoverCarouselCard,
  TeachingPopoverCarouselFooter,
  TeachingPopoverCarouselNav,
  TeachingPopoverCarouselNavButton,
  TeachingPopoverCarouselPageCount,
  TeachingPopoverFooter,
  TeachingPopoverHeader,
  TeachingPopoverSurface,
  TeachingPopoverTitle,
  TeachingPopoverTrigger,
  Text,
  Textarea,
  Title1,
  Title2,
  Title3,
  Toast,
  ToastBody,
  ToastFooter,
  ToastTitle,
  ToastTrigger,
  Toaster,
  ToggleButton,
  Toolbar,
  ToolbarButton,
  ToolbarDivider,
  ToolbarGroup,
  ToolbarRadioButton,
  ToolbarRadioGroup,
  ToolbarToggleButton,
  Tooltip,
  Tree,
  TreeItem,
  TreeItemLayout,
  TreeItemPersonaLayout,
  TreeItemProvider,
  TreeProvider,
  TreeRootReset,
  __css,
  __resetCSS,
  __resetStyles,
  __styles2 as __styles,
  accordionClassNames,
  accordionHeaderClassNames,
  accordionItemClassNames,
  accordionPanelClassNames,
  alphaSliderClassNames,
  appItemClassNames,
  appItemStaticClassNames,
  arrowHeights,
  assertSlots,
  avatarClassNames,
  avatarGroupClassNames,
  avatarGroupItemClassNames,
  avatarGroupPopoverClassNames,
  badgeClassNames,
  body1ClassNames,
  body1StrongClassNames,
  body1StrongerClassNames,
  body2ClassNames,
  breadcrumbButtonClassNames,
  breadcrumbClassNames,
  breadcrumbDividerClassNames,
  breadcrumbItemClassNames,
  buttonClassNames,
  caption1ClassNames,
  caption1StrongClassNames,
  caption1StrongerClassNames,
  caption2ClassNames,
  caption2StrongClassNames,
  cardCSSVars,
  cardClassNames,
  cardFooterClassNames,
  cardHeaderCSSVars,
  cardHeaderClassNames,
  cardPreviewClassNames,
  carouselAutoplayButtonClassNames,
  carouselButtonClassNames,
  carouselCardClassNames,
  carouselClassNames,
  carouselContextDefaultValue2 as carouselContextDefaultValue,
  carouselNavButtonClassNames,
  carouselNavClassNames,
  carouselNavContainerClassNames,
  carouselNavImageButtonClassNames,
  carouselSliderClassNames,
  carouselViewportClassNames,
  checkboxClassNames,
  colorAreaClassNames,
  colorPickerClassNames,
  colorSliderClassNames,
  colorSwatchClassNames,
  comboboxClassNames,
  compoundButtonClassNames,
  counterBadgeClassNames,
  createCSSRuleFromTheme,
  createCustomFocusIndicatorStyle,
  createDOMRenderer,
  createDarkTheme,
  createFocusOutlineStyle,
  createHighContrastTheme,
  createLightTheme,
  createMotionComponent,
  createMotionComponentVariant,
  createPresenceComponent,
  createPresenceComponentVariant,
  createTableColumn,
  createTeamsDarkTheme,
  dataGridBodyClassNames,
  dataGridCellClassNames,
  dataGridClassNames,
  dataGridHeaderCellClassNames,
  dataGridHeaderClassNames,
  dataGridRowClassNames,
  dataGridSelectionCellClassNames,
  dialogActionsClassNames,
  dialogBodyClassNames,
  dialogContentClassNames,
  dialogSurfaceClassNames,
  dialogTitleClassNames,
  displayClassNames,
  dividerClassNames,
  drawerBodyClassNames,
  drawerFooterClassNames,
  drawerHeaderClassNames,
  drawerHeaderNavigationClassNames,
  drawerHeaderTitleClassNames,
  dropdownClassNames,
  emptySwatchClassNames,
  fieldClassNames,
  flatTreeClassNames,
  flattenTree_unstable,
  fluentProviderClassNames,
  getIntrinsicElementProps,
  getNativeElementProps,
  getPartitionedNativeProps,
  getSlotClassNameProp as getSlotClassNameProp_unstable,
  getSlots,
  hamburgerClassNames,
  imageClassNames,
  imageSwatchClassNames,
  infoButtonClassNames,
  infoLabelClassNames,
  inlineDrawerClassNames,
  inputClassNames,
  interactionTagClassNames,
  interactionTagPrimaryClassNames,
  interactionTagSecondaryClassNames,
  isHTMLElement,
  isTruncatableBreadcrumbContent,
  labelClassNames,
  largeTitleClassNames,
  linkClassNames,
  listClassNames,
  listItemClassNames,
  listboxClassNames,
  makeResetStyles,
  makeStaticStyles,
  makeStyles,
  menuButtonClassNames,
  menuDividerClassNames,
  menuGroupClassNames,
  menuGroupHeaderClassNames,
  menuItemCheckboxClassNames,
  menuItemClassNames,
  menuItemLinkClassNames,
  menuItemRadioClassNames,
  menuItemSwitchClassNames,
  menuListClassNames,
  menuPopoverClassNames,
  menuSplitGroupClassNames,
  mergeCallbacks,
  mergeClasses,
  messageBarActionsClassNames,
  messageBarBodyClassNames,
  messageBarClassNames,
  messageBarGroupClassNames,
  messageBarTitleClassNames,
  motionTokens,
  navCategoryItemClassNames,
  navClassNames,
  navDividerClassNames,
  navDrawerBodyClassNames,
  navDrawerClassNames,
  navDrawerFooterClassNames,
  navDrawerHeaderClassNames,
  navItemClassNames,
  navSectionHeaderClassNames,
  navSubItemClassNames,
  navSubItemGroupClassNames,
  optionClassNames,
  optionGroupClassNames,
  overlayDrawerClassNames,
  partitionAvatarGroupItems,
  partitionBreadcrumbItems,
  personaClassNames,
  popoverSurfaceClassNames,
  presenceAvailableFilled,
  presenceAvailableRegular,
  presenceAwayFilled,
  presenceAwayRegular,
  presenceBadgeClassNames,
  presenceBlockedRegular,
  presenceBusyFilled,
  presenceDndFilled,
  presenceDndRegular,
  presenceOfflineRegular,
  presenceOofRegular,
  presenceUnknownRegular,
  progressBarClassNames,
  radioClassNames,
  radioGroupClassNames,
  ratingClassNames,
  ratingDisplayClassNames,
  ratingItemClassNames,
  renderAccordionHeader_unstable,
  renderAccordionItem_unstable,
  renderAccordionPanel_unstable,
  renderAccordion_unstable,
  renderAlphaSlider_unstable,
  renderAppItemStatic_unstable,
  renderAppItem_unstable,
  renderAriaLiveAnnouncer_unstable,
  renderAvatarGroupItem_unstable,
  renderAvatarGroupPopover_unstable,
  renderAvatarGroup_unstable,
  renderAvatar_unstable,
  renderBadge_unstable,
  renderBreadcrumbButton_unstable,
  renderBreadcrumbDivider_unstable,
  renderBreadcrumbItem_unstable,
  renderBreadcrumb_unstable,
  renderButton_unstable,
  renderCardFooter_unstable,
  renderCardHeader_unstable,
  renderCardPreview_unstable,
  renderCard_unstable,
  renderCarouselAutoplayButton_unstable,
  renderCarouselButton_unstable,
  renderCarouselCard_unstable,
  renderCarouselNavButton_unstable,
  renderCarouselNavContainer_unstable,
  renderCarouselNavImageButton_unstable,
  renderCarouselNav_unstable,
  renderCarouselSlider_unstable,
  renderCarouselViewport_unstable,
  renderCarousel_unstable,
  renderCheckbox_unstable,
  renderColorArea_unstable,
  renderColorPicker_unstable,
  renderColorSlider_unstable,
  renderColorSwatch_unstable,
  renderCombobox_unstable,
  renderCompoundButton_unstable,
  renderDataGridBody_unstable,
  renderDataGridCell_unstable,
  renderDataGridHeaderCell_unstable,
  renderDataGridHeader_unstable,
  renderDataGridRow_unstable,
  renderDataGridSelectionCell_unstable,
  renderDataGrid_unstable,
  renderDialogActions_unstable,
  renderDialogBody_unstable,
  renderDialogContent_unstable,
  renderDialogSurface_unstable,
  renderDialogTitle_unstable,
  renderDialogTrigger_unstable,
  renderDialog_unstable,
  renderDivider_unstable,
  renderDrawerBody_unstable,
  renderDrawerFooter_unstable,
  renderDrawerHeaderNavigation_unstable,
  renderDrawerHeaderTitle_unstable,
  renderDrawerHeader_unstable,
  renderDrawer_unstable,
  renderDropdown_unstable,
  renderEmptySwatch_unstable,
  renderField_unstable,
  renderFlatTree_unstable,
  renderFluentProvider_unstable,
  renderImageSwatch_unstable,
  renderImage_unstable,
  renderInfoButton_unstable,
  renderInfoLabel_unstable,
  renderInlineDrawer_unstable,
  renderInput_unstable,
  renderInteractionTagPrimary_unstable,
  renderInteractionTagSecondary_unstable,
  renderInteractionTag_unstable,
  renderLabel_unstable,
  renderLink_unstable,
  renderListItem_unstable,
  renderList_unstable,
  renderListbox_unstable,
  renderMenuButton_unstable,
  renderMenuDivider_unstable,
  renderMenuGroupHeader_unstable,
  renderMenuGroup_unstable,
  renderMenuItemCheckbox_unstable,
  renderMenuItemLink_unstable,
  renderMenuItemRadio_unstable,
  renderMenuItemSwitch_unstable,
  renderMenuItem_unstable,
  renderMenuList_unstable,
  renderMenuPopover_unstable,
  renderMenuSplitGroup_unstable,
  renderMenuTrigger_unstable,
  renderMenu_unstable,
  renderMessageBarActions_unstable,
  renderMessageBarBody_unstable,
  renderMessageBarGroup_unstable,
  renderMessageBarTitle_unstable,
  renderMessageBar_unstable,
  renderNavCategoryItem_unstable,
  renderNavCategory_unstable,
  renderNavDrawer_unstable,
  renderNavItem_unstable,
  renderNavSectionHeader_unstable,
  renderNavSubItemGroup_unstable,
  renderNavSubItem_unstable,
  renderNav_unstable,
  renderOptionGroup_unstable,
  renderOption_unstable,
  renderOverlayDrawer_unstable,
  renderPersona_unstable,
  renderPopoverSurface_unstable,
  renderPopoverTrigger_unstable,
  renderPopover_unstable,
  renderPortal_unstable,
  renderProgressBar_unstable,
  renderRadioGroup_unstable,
  renderRadio_unstable,
  renderRatingDisplay_unstable,
  renderRatingItem_unstable,
  renderRating_unstable,
  renderSearchBox_unstable,
  renderSelect_unstable,
  renderSkeletonItem_unstable,
  renderSkeleton_unstable,
  renderSlider_unstable,
  renderSpinButton_unstable,
  renderSpinner_unstable,
  renderSplitButton_unstable,
  renderSplitNavItem_unstable,
  renderSwatchPickerGrid,
  renderSwatchPickerRow_unstable,
  renderSwatchPicker_unstable,
  renderSwitch_unstable,
  renderTabList_unstable,
  renderTab_unstable,
  renderTableBody_unstable,
  renderTableCellActions_unstable,
  renderTableCellLayout_unstable,
  renderTableCell_unstable,
  renderTableHeaderCell_unstable,
  renderTableHeader_unstable,
  renderTableResizeHandle_unstable,
  renderTableRow_unstable,
  renderTableSelectionCell_unstable,
  renderTable_unstable,
  renderTagGroup_unstable,
  renderTagPickerButton_unstable,
  renderTagPickerControl_unstable,
  renderTagPickerGroup_unstable,
  renderTagPickerInput_unstable,
  renderTagPickerList_unstable,
  renderTagPickerOptionGroup,
  renderTagPickerOption_unstable,
  renderTagPicker_unstable,
  renderTag_unstable,
  renderTeachingPopoverBody_unstable,
  renderTeachingPopoverCarouselCard_unstable,
  renderTeachingPopoverCarouselFooter_unstable,
  renderTeachingPopoverCarouselNavButton_unstable,
  renderTeachingPopoverCarouselNav_unstable,
  renderTeachingPopoverCarouselPageCount_unstable,
  renderTeachingPopoverCarousel_unstable,
  renderTeachingPopoverFooter_unstable,
  renderTeachingPopoverHeader_unstable,
  renderTeachingPopoverSurface_unstable,
  renderTeachingPopoverTitle_unstable,
  renderTeachingPopoverTrigger_unstable,
  renderTeachingPopover_unstable,
  renderText_unstable,
  renderTextarea_unstable,
  renderToStyleElements,
  renderToastBody_unstable,
  renderToastFooter_unstable,
  renderToastTitle_unstable,
  renderToastTrigger_unstable,
  renderToast_unstable,
  renderToaster_unstable,
  renderButton_unstable as renderToggleButton_unstable,
  renderToolbarGroup_unstable,
  renderToolbar_unstable,
  renderTooltip_unstable,
  renderTreeItemLayout_unstable,
  renderTreeItemPersonaLayout_unstable,
  renderTreeItem_unstable,
  renderTree_unstable,
  resetIdsForTests,
  resolvePositioningShorthand,
  resolveShorthand2 as resolveShorthand,
  searchBoxClassNames,
  selectClassNames,
  shorthands,
  skeletonClassNames,
  skeletonItemClassNames,
  sliderCSSVars,
  sliderClassNames,
  slot_exports as slot,
  spinButtonClassNames,
  spinnerClassNames,
  splitButtonClassNames,
  splitNavItemClassNames,
  subtitle1ClassNames,
  subtitle2ClassNames,
  subtitle2StrongerClassNames,
  swatchCSSVars,
  swatchPickerClassNames,
  swatchPickerContextDefaultValue,
  swatchPickerRowClassNames,
  switchClassNames,
  tabClassNames,
  tabListClassNames,
  tableBodyClassName,
  tableBodyClassNames,
  tableCellActionsClassNames,
  tableCellClassName,
  tableCellClassNames,
  tableCellLayoutClassNames,
  tableClassName,
  tableClassNames,
  tableHeaderCellClassName,
  tableHeaderCellClassNames,
  tableHeaderClassName,
  tableHeaderClassNames,
  tableResizeHandleClassNames,
  tableRowClassName,
  tableRowClassNames,
  tableSelectionCellClassNames,
  tagClassNames,
  tagGroupClassNames,
  tagPickerButtonClassNames,
  tagPickerControlClassNames,
  tagPickerGroupClassNames,
  tagPickerInputClassNames,
  tagPickerListClassNames,
  tagPickerOptionClassNames,
  tagPickerOptionGroupClassNames,
  teachingPopoverBodyClassNames,
  teachingPopoverCarouselCardClassNames,
  teachingPopoverCarouselClassNames,
  teachingPopoverCarouselFooterClassNames,
  teachingPopoverCarouselNavButtonClassNames,
  teachingPopoverCarouselNavClassNames,
  teachingPopoverCarouselPageCountClassNames,
  teachingPopoverFooterClassNames,
  teachingPopoverHeaderClassNames,
  teachingPopoverSurfaceClassNames,
  teachingPopoverTitleClassNames,
  teamsDarkTheme,
  teamsDarkV21Theme,
  teamsHighContrastTheme,
  teamsLightTheme,
  teamsLightV21Theme,
  textClassNames,
  textareaClassNames,
  themeToTokensObject,
  title1ClassNames,
  title2ClassNames,
  title3ClassNames,
  toMountNodeProps,
  toastBodyClassNames,
  toastFooterClassNames,
  toastTitleClassNames,
  toasterClassNames,
  toggleButtonClassNames,
  tokens,
  toolbarClassNames,
  toolbarGroupClassNames,
  tooltipClassNames,
  treeClassNames,
  treeItemClassNames,
  treeItemLayoutClassNames,
  treeItemLevelToken,
  treeItemPersonaLayoutClassNames,
  truncateBreadcrumLongTooltip,
  truncateBreadcrumbLongName,
  typographyStyles,
  useAccordionContextValues_unstable,
  useAccordionContext_unstable,
  useAccordionHeaderContextValues_unstable,
  useAccordionHeaderStyles_unstable,
  useAccordionHeader_unstable,
  useAccordionItemContextValues_unstable,
  useAccordionItemContext_unstable,
  useAccordionItemStyles_unstable,
  useAccordionItem_unstable,
  useAccordionPanelStyles_unstable,
  useAccordionPanel_unstable,
  useAccordionStyles_unstable,
  useAccordion_unstable,
  useAlphaSliderStyles_unstable,
  useAlphaSlider_unstable,
  useAnimationFrame,
  useAnnounce,
  useAppItemStaticStyles_unstable,
  useAppItemStatic_unstable,
  useAppItemStyles_unstable,
  useAppItem_unstable,
  useApplyScrollbarWidth,
  useAriaLiveAnnouncerContextValues_unstable,
  useAriaLiveAnnouncer_unstable,
  useArrowNavigationGroup,
  useAvatarGroupContextValues,
  useAvatarGroupContext_unstable,
  useAvatarGroupItemStyles_unstable,
  useAvatarGroupItem_unstable,
  useAvatarGroupPopoverContextValues_unstable,
  useAvatarGroupPopoverStyles_unstable,
  useAvatarGroupPopover_unstable,
  useAvatarGroupStyles_unstable,
  useAvatarGroup_unstable,
  useAvatarStyles_unstable,
  useAvatar_unstable,
  useBadgeStyles_unstable,
  useBadge_unstable,
  useBreadcrumbButtonStyles_unstable,
  useBreadcrumbButton_unstable,
  useBreadcrumbContext_unstable,
  useBreadcrumbDividerStyles_unstable,
  useBreadcrumbDivider_unstable,
  useBreadcrumbItemStyles_unstable,
  useBreadcrumbItem_unstable,
  useBreadcrumbStyles_unstable,
  useBreadcrumb_unstable,
  useButtonStyles_unstable,
  useButton_unstable,
  useCardFooterStyles_unstable,
  useCardFooter_unstable,
  useCardHeaderStyles_unstable,
  useCardHeader_unstable,
  useCardPreviewStyles_unstable,
  useCardPreview_unstable,
  useCardStyles_unstable,
  useCard_unstable,
  useCarouselAutoplayButtonStyles_unstable,
  useCarouselAutoplayButton_unstable,
  useCarouselButtonStyles_unstable,
  useCarouselButton_unstable,
  useCarouselCardStyles_unstable,
  useCarouselCard_unstable,
  useCarouselContext_unstable2 as useCarouselContext_unstable,
  useCarouselNavButtonStyles_unstable,
  useCarouselNavButton_unstable,
  useCarouselNavContainerStyles_unstable,
  useCarouselNavContainer_unstable,
  useCarouselNavImageButtonStyles_unstable,
  useCarouselNavImageButton_unstable,
  useCarouselNavStyles_unstable,
  useCarouselNav_unstable,
  useCarouselSliderStyles_unstable,
  useCarouselSlider_unstable,
  useCarouselStyles_unstable,
  useCarouselViewportStyles_unstable,
  useCarouselViewport_unstable,
  useCarousel_unstable2 as useCarousel_unstable,
  useCheckboxStyles_unstable,
  useCheckbox_unstable,
  useCheckmarkStyles_unstable,
  useColorAreaStyles_unstable,
  useColorArea_unstable,
  useColorPickerStyles_unstable,
  useColorPicker_unstable,
  useColorSliderStyles_unstable,
  useColorSlider_unstable,
  useColorSwatchStyles_unstable,
  useColorSwatch_unstable,
  useColumnIdContext,
  useComboboxContextValues,
  useComboboxFilter,
  useComboboxStyles_unstable,
  useCombobox_unstable,
  useCompoundButtonStyles_unstable,
  useCompoundButton_unstable,
  useCounterBadgeStyles_unstable,
  useCounterBadge_unstable,
  useDataGridBodyStyles_unstable,
  useDataGridBody_unstable,
  useDataGridCellStyles_unstable,
  useDataGridCell_unstable,
  useDataGridContextValues_unstable,
  useDataGridContext_unstable,
  useDataGridHeaderCellStyles_unstable,
  useDataGridHeaderCell_unstable,
  useDataGridHeaderStyles_unstable,
  useDataGridHeader_unstable,
  useDataGridRowStyles_unstable,
  useDataGridRow_unstable,
  useDataGridSelectionCellStyles_unstable,
  useDataGridSelectionCell_unstable,
  useDataGridStyles_unstable,
  useDataGrid_unstable,
  useDialogActionsStyles_unstable,
  useDialogActions_unstable,
  useDialogBodyStyles_unstable,
  useDialogBody_unstable,
  useDialogContentStyles_unstable,
  useDialogContent_unstable,
  useDialogContext_unstable,
  useDialogSurfaceContextValues_unstable,
  useDialogSurfaceContext_unstable,
  useDialogSurfaceStyles_unstable,
  useDialogSurface_unstable,
  useDialogTitleStyles_unstable,
  useDialogTitle_unstable,
  useDialogTrigger_unstable,
  useDialog_unstable,
  useDividerStyles_unstable,
  useDivider_unstable,
  useDrawerBodyStyles_unstable,
  useDrawerBody_unstable,
  useDrawerContextValue,
  useDrawerContext_unstable,
  useDrawerFooterStyles_unstable,
  useDrawerFooter_unstable,
  useDrawerHeaderNavigationStyles_unstable,
  useDrawerHeaderNavigation_unstable,
  useDrawerHeaderStyles_unstable,
  useDrawerHeaderTitleStyles_unstable,
  useDrawerHeaderTitle_unstable,
  useDrawerHeader_unstable,
  useDrawerStyles_unstable,
  useDrawer_unstable,
  useDropdownStyles_unstable,
  useDropdown_unstable,
  useEmptySwatchStyles_unstable,
  useEmptySwatch_unstable,
  useEventCallback,
  useFieldContextValues_unstable,
  useFieldContext_unstable,
  useFieldControlProps_unstable,
  useFieldStyles_unstable,
  useField_unstable,
  useFlatTreeContextValues_unstable,
  useFlatTreeStyles_unstable,
  useFlatTree_unstable,
  useFluent,
  useFluentProviderContextValues_unstable,
  useFluentProviderStyles_unstable,
  useFluentProviderThemeStyleTag,
  useFluentProvider_unstable,
  useFocusFinders,
  useFocusObserved,
  useFocusVisible,
  useFocusWithin,
  useFocusableGroup,
  useHamburgerStyles_unstable,
  useHamburger_unstable,
  useHeadlessFlatTree_unstable,
  useId2 as useId,
  useImageStyles_unstable,
  useImageSwatchStyles_unstable,
  useImageSwatch_unstable,
  useImage_unstable,
  useInfoButtonStyles_unstable,
  useInfoButton_unstable,
  useInfoLabelStyles_unstable,
  useInfoLabel_unstable,
  useInlineDrawerStyles_unstable,
  useInlineDrawer_unstable,
  useInputStyles_unstable,
  useInput_unstable,
  useInteractionTagContextValues_unstable,
  useInteractionTagPrimaryStyles_unstable,
  useInteractionTagPrimary_unstable,
  useInteractionTagSecondaryStyles_unstable,
  useInteractionTagSecondary_unstable,
  useInteractionTagStyles_unstable,
  useInteractionTag_unstable,
  useIsInTableHeader,
  useIsOverflowGroupVisible,
  useIsOverflowItemVisible,
  useIsSSR,
  useIsomorphicLayoutEffect,
  useKeyboardNavAttribute,
  useLabelStyles_unstable,
  useLabel_unstable,
  useLinkState_unstable,
  useLinkStyles_unstable,
  useLink_unstable,
  useListItemStyles_unstable,
  useListItem_unstable,
  useListStyles_unstable,
  useList_unstable,
  useListboxContextValues,
  useListboxContext_unstable,
  useListboxStyles_unstable,
  useListbox_unstable,
  useMenuButtonStyles_unstable,
  useMenuButton_unstable,
  useMenuContextValues_unstable,
  useMenuContext_unstable,
  useMenuDividerStyles_unstable,
  useMenuDivider_unstable,
  useMenuGroupContextValues_unstable,
  useMenuGroupContext_unstable,
  useMenuGroupHeaderStyles_unstable,
  useMenuGroupHeader_unstable,
  useMenuGroupStyles_unstable,
  useMenuGroup_unstable,
  useMenuItemCheckboxStyles_unstable,
  useMenuItemCheckbox_unstable,
  useMenuItemLinkStyles_unstable,
  useMenuItemLink_unstable,
  useMenuItemRadioStyles_unstable,
  useMenuItemRadio_unstable,
  useMenuItemStyles_unstable,
  useMenuItemSwitchStyles_unstable,
  useMenuItemSwitch_unstable,
  useMenuItem_unstable,
  useMenuListContextValues_unstable,
  useMenuListContext_unstable,
  useMenuListStyles_unstable,
  useMenuList_unstable,
  useMenuPopoverStyles_unstable,
  useMenuPopover_unstable,
  useMenuSplitGroupStyles_unstable,
  useMenuSplitGroup_unstable,
  useMenuTriggerContext_unstable,
  useMenuTrigger_unstable,
  useMenu_unstable,
  useMergedRefs,
  useMessageBarActionsContextValue_unstable,
  useMessageBarActionsStyles_unstable,
  useMessageBarActions_unstable,
  useMessageBarBodyStyles_unstable,
  useMessageBarBody_unstable,
  useMessageBarContext,
  useMessageBarContextValue_unstable,
  useMessageBarGroupStyles_unstable,
  useMessageBarGroup_unstable,
  useMessageBarStyles_unstable,
  useMessageBarTitleStyles_unstable,
  useMessageBarTitle_unstable,
  useMessageBar_unstable,
  useModalAttributes,
  useNavCategoryContextValues_unstable,
  useNavCategoryContext_unstable,
  useNavCategoryItemContextValues_unstable,
  useNavCategoryItemContext_unstable,
  useNavCategoryItemStyles_unstable,
  useNavCategoryItem_unstable,
  useNavCategory_unstable,
  useNavContextValues_unstable,
  useNavContext_unstable,
  useNavDividerStyles_unstable,
  useNavDivider_unstable,
  useNavDrawerBodyStyles_unstable,
  useNavDrawerBody_unstable,
  useNavDrawerFooterStyles_unstable,
  useNavDrawerFooter_unstable,
  useNavDrawerHeaderStyles_unstable,
  useNavDrawerHeader_unstable,
  useNavDrawerStyles_unstable,
  useNavDrawer_unstable,
  useNavItemStyles_unstable,
  useNavItem_unstable,
  useNavSectionHeaderStyles_unstable,
  useNavSectionHeader_unstable,
  useNavStyles_unstable,
  useNavSubItemGroupStyles_unstable,
  useNavSubItemGroup_unstable,
  useNavSubItemStyles_unstable,
  useNavSubItem_unstable,
  useNav_unstable,
  useObservedElement,
  useOptionGroupStyles_unstable,
  useOptionGroup_unstable,
  useOptionStyles_unstable,
  useOption_unstable,
  useOverflowCount,
  useOverflowMenu,
  useOverflowVisibility,
  useOverlayDrawerStyles_unstable,
  useOverlayDrawer_unstable,
  usePersonaStyles_unstable,
  usePersona_unstable,
  usePopoverContext_unstable,
  usePopoverSurfaceStyles_unstable,
  usePopoverSurface_unstable,
  usePopoverTrigger_unstable,
  usePopover_unstable,
  usePortalMountNode,
  usePortal_unstable,
  usePositioning,
  usePresenceBadgeStyles_unstable,
  usePresenceBadge_unstable,
  useProgressBarStyles_unstable,
  useProgressBar_unstable,
  useRadioGroupContextValue_unstable,
  useRadioGroupContextValues,
  useRadioGroupContext_unstable,
  useRadioGroupStyles_unstable,
  useRadioGroup_unstable,
  useRadioStyles_unstable,
  useRadio_unstable,
  useRatingContextValues,
  useRatingDisplayContextValues,
  useRatingDisplayStyles_unstable,
  useRatingDisplay_unstable,
  useRatingItemContextValue_unstable,
  useRatingItemStyles_unstable,
  useRatingItem_unstable,
  useRatingStyles_unstable,
  useRating_unstable,
  useRestoreFocusSource,
  useRestoreFocusTarget,
  useSafeZoneArea,
  useScrollbarWidth,
  useSearchBoxStyles_unstable,
  useSearchBox_unstable,
  useSelectStyles_unstable,
  useSelect_unstable,
  useSelection,
  useSkeletonContext,
  useSkeletonItemStyles_unstable,
  useSkeletonItem_unstable,
  useSkeletonStyles_unstable,
  useSkeleton_unstable,
  useSliderState_unstable,
  useSliderStyles_unstable,
  useSlider_unstable,
  useSpinButtonStyles_unstable,
  useSpinButton_unstable,
  useSpinnerStyles_unstable,
  useSpinner_unstable,
  useSplitButtonStyles_unstable,
  useSplitButton_unstable,
  useSplitNavItemStyles_unstable,
  useSplitNavItem_unstable,
  useSubtreeContext_unstable,
  useSwatchPickerContextValue_unstable,
  useSwatchPickerContextValues,
  useSwatchPickerRowStyles_unstable,
  useSwatchPickerRow_unstable,
  useSwatchPickerStyles_unstable,
  useSwatchPicker_unstable,
  useSwitchStyles_unstable,
  useSwitch_unstable,
  useTabListContextValues_unstable,
  useTabListContext_unstable,
  useTabListStyles_unstable,
  useTabList_unstable,
  useTabStyles_unstable,
  useTab_unstable,
  useTableBodyStyles_unstable,
  useTableBody_unstable,
  useTableCellActionsStyles_unstable,
  useTableCellActions_unstable,
  useTableCellLayoutStyles_unstable,
  useTableCellLayout_unstable,
  useTableCellStyles_unstable,
  useTableCell_unstable,
  useTableColumnSizing_unstable,
  useTableCompositeNavigation,
  useTableContext,
  useTableFeatures,
  useTableHeaderCellStyles_unstable,
  useTableHeaderCell_unstable,
  useTableHeaderStyles_unstable,
  useTableHeader_unstable,
  useTableResizeHandleStyles_unstable,
  useTableResizeHandle_unstable,
  useTableRowIdContext,
  useTableRowStyles_unstable,
  useTableRow_unstable,
  useTableSelection,
  useTableSelectionCellStyles_unstable,
  useTableSelectionCell_unstable,
  useTableSort,
  useTableStyles_unstable,
  useTable_unstable,
  useTagAvatarContextValues_unstable,
  useTagGroupContextValues_unstable,
  useTagGroupStyles_unstable,
  useTagGroup_unstable,
  useTagPickerButtonStyles_unstable,
  useTagPickerButton_unstable,
  useTagPickerContext_unstable,
  useTagPickerControlStyles_unstable,
  useTagPickerControl_unstable,
  useTagPickerFilter,
  useTagPickerGroupStyles_unstable,
  useTagPickerGroup_unstable,
  useTagPickerInputStyles_unstable,
  useTagPickerInput_unstable,
  useTagPickerListStyles_unstable,
  useTagPickerList_unstable,
  useTagPickerOptionGroup,
  useTagPickerOptionGroupStyles,
  useTagPickerOptionStyles_unstable,
  useTagPickerOption_unstable,
  useTagPicker_unstable,
  useTagStyles_unstable,
  useTag_unstable,
  useTeachingPopoverBodyStyles_unstable,
  useTeachingPopoverBody_unstable,
  useTeachingPopoverCarouselCardStyles_unstable,
  useTeachingPopoverCarouselCard_unstable,
  useTeachingPopoverCarouselContextValues_unstable,
  useTeachingPopoverCarouselFooterStyles_unstable,
  useTeachingPopoverCarouselFooter_unstable,
  useTeachingPopoverCarouselNavButtonStyles_unstable,
  useTeachingPopoverCarouselNavButton_unstable,
  useTeachingPopoverCarouselNavStyles_unstable,
  useTeachingPopoverCarouselNav_unstable,
  useTeachingPopoverCarouselPageCountStyles_unstable,
  useTeachingPopoverCarouselPageCount_unstable,
  useTeachingPopoverCarouselStyles_unstable,
  useTeachingPopoverCarousel_unstable,
  useTeachingPopoverFooter_unstable,
  useTeachingPopoverHeaderStyles_unstable,
  useTeachingPopoverHeader_unstable,
  useTeachingPopoverSurfaceStyles_unstable,
  useTeachingPopoverSurface_unstable,
  useTeachingPopoverTitleStyles_unstable,
  useTeachingPopoverTitle_unstable,
  useTeachingPopoverTrigger_unstable,
  useTeachingPopover_unstable,
  useTextStyles_unstable,
  useText_unstable,
  useTextareaStyles_unstable,
  useTextarea_unstable,
  useThemeClassName,
  useTimeout,
  useToastBodyStyles_unstable,
  useToastBody_unstable,
  useToastController,
  useToastFooterStyles_unstable,
  useToastFooter_unstable,
  useToastStyles_unstable,
  useToastTitleStyles_unstable,
  useToastTitle_unstable,
  useToastTrigger_unstable,
  useToast_unstable,
  useToasterStyles_unstable,
  useToaster_unstable,
  useToggleButtonStyles_unstable,
  useToggleButton_unstable,
  useToggleState,
  useToolbarButtonStyles_unstable,
  useToolbarButton_unstable,
  useToolbarDividerStyles_unstable,
  useToolbarDivider_unstable,
  useToolbarGroupStyles_unstable,
  useToolbarGroup_unstable,
  useToolbarRadioButtonStyles_unstable,
  useToolbarRadioButton_unstable,
  useToolbarStyles_unstable,
  useToolbarToggleButtonStyles_unstable,
  useToolbarToggleButton_unstable,
  useToolbar_unstable,
  useTooltipStyles_unstable,
  useTooltipVisibility,
  useTooltip_unstable,
  useTreeContextValues_unstable,
  useTreeContext_unstable,
  useTreeItemContextValues_unstable,
  useTreeItemContext_unstable,
  useTreeItemLayoutStyles_unstable,
  useTreeItemLayout_unstable,
  useTreeItemPersonaLayoutStyles_unstable,
  useTreeItemPersonaLayout_unstable,
  useTreeItemStyles_unstable,
  useTreeItem_unstable,
  useTreeNavigation,
  useTreeStyles_unstable,
  useTree_unstable,
  useTypingAnnounce,
  useUncontrolledFocus,
  webDarkTheme,
  webLightTheme
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

keyborg/dist/esm/index.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

tabster/dist/tabster.esm.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)

@fluentui/react-tabster/lib/tabster-types-6.0.1-do-not-use.js:
  (*!
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=@fluentui_react-components.js.map
