{"version":3,"sources":["../src/components/FlatTree/useFlatControllableCheckedItems.ts"],"sourcesContent":["'use client';\n\nimport { useControllableState } from '@fluentui/react-utilities';\nimport { TreeItemValue } from '../../TreeItem';\nimport { ImmutableMap } from '../../utils/ImmutableMap';\nimport * as React from 'react';\nimport type { HeadlessTree, HeadlessTreeItemProps } from '../../utils/createHeadlessTree';\nimport { createCheckedItems } from '../../utils/createCheckedItems';\nimport type { TreeCheckedChangeData, TreeSelectionValue } from '../Tree/Tree.types';\nimport { HeadlessFlatTreeOptions } from './useHeadlessFlatTree';\n\nexport function useFlatControllableCheckedItems<Props extends HeadlessTreeItemProps>(\n  props: Pick<HeadlessFlatTreeOptions, 'checkedItems' | 'defaultCheckedItems' | 'selectionMode'>,\n  headlessTree: HeadlessTree<Props>,\n): [ImmutableMap<TreeItemValue, TreeSelectionValue>, React.Dispatch<ImmutableMap<TreeItemValue, TreeSelectionValue>>] {\n  return useControllableState({\n    initialState: ImmutableMap.empty,\n    state: React.useMemo(\n      () => (props.selectionMode ? props.checkedItems && createCheckedItems(props.checkedItems) : undefined),\n      [props.checkedItems, props.selectionMode],\n    ),\n    defaultState: props.defaultCheckedItems ? () => initializeCheckedItems(props, headlessTree) : undefined,\n  });\n}\n\nexport function createNextFlatCheckedItems(\n  data: Pick<TreeCheckedChangeData, 'value' | 'checked' | 'selectionMode'>,\n  previousCheckedItems: ImmutableMap<TreeItemValue, 'mixed' | boolean>,\n  headlessTree: HeadlessTree<HeadlessTreeItemProps>,\n): ImmutableMap<TreeItemValue, 'mixed' | boolean> {\n  if (data.selectionMode === 'single') {\n    return ImmutableMap.from([[data.value, data.checked]]);\n  }\n\n  const treeItem = headlessTree.get(data.value);\n  if (!treeItem) {\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.error(/* #__DE-INDENT__ */ `\n        @fluentui/react-tree [useHeadlessFlatTree]:\n        Tree item ${data.value} not found.\n      `);\n    }\n    return previousCheckedItems;\n  }\n\n  // Calling `ImmutableMap.set()` creates a new ImmutableMap - avoid this in loops.\n  // Instead write all updates to a native Map and create a new ImmutableMap at the end.\n  // Note that all descendants of the toggled item are processed even if they are collapsed,\n  // making the choice of algorithm more important.\n\n  const nextCheckedItemsMap = new Map(ImmutableMap.dangerouslyGetInternalMap(previousCheckedItems));\n\n  // The toggled item itself\n  nextCheckedItemsMap.set(data.value, data.checked);\n\n  // Descendant updates\n  for (const children of headlessTree.subtree(data.value)) {\n    nextCheckedItemsMap.set(children.value, data.checked);\n  }\n\n  // Ancestor updates - must be done after adding descendants and the toggle item.\n  // If any ancestor is mixed, all ancestors above it are mixed too.\n  let isAncestorsMixed = false;\n\n  for (const ancestor of headlessTree.ancestors(treeItem.value)) {\n    if (isAncestorsMixed) {\n      nextCheckedItemsMap.set(ancestor.value, 'mixed');\n      continue;\n    }\n\n    // For each ancestor, if all of its children now have the same checked state as the toggled item,\n    // set the ancestor to that checked state too. Otherwise it is 'mixed'.\n    let childrenWithSameState = 0;\n    for (const child of headlessTree.children(ancestor.value)) {\n      if ((nextCheckedItemsMap.get(child.value) || false) === data.checked) {\n        childrenWithSameState++;\n      }\n    }\n\n    if (childrenWithSameState === ancestor.childrenValues.length) {\n      nextCheckedItemsMap.set(ancestor.value, data.checked);\n    } else {\n      nextCheckedItemsMap.set(ancestor.value, 'mixed');\n      isAncestorsMixed = true;\n    }\n  }\n\n  const nextCheckedItems = ImmutableMap.from(nextCheckedItemsMap);\n  return nextCheckedItems;\n}\n\nfunction initializeCheckedItems(\n  props: Pick<HeadlessFlatTreeOptions, 'selectionMode' | 'defaultCheckedItems'>,\n  headlessTree: HeadlessTree<HeadlessTreeItemProps>,\n) {\n  if (!props.selectionMode) {\n    return ImmutableMap.empty;\n  }\n  let state = createCheckedItems(props.defaultCheckedItems);\n  // if selectionMode is multiselect, we need to calculate the checked state of all children\n  // and ancestors of the defaultCheckedItems\n  if (props.selectionMode === 'multiselect') {\n    for (const [value, checked] of state) {\n      state = createNextFlatCheckedItems({ value, checked, selectionMode: props.selectionMode }, state, headlessTree);\n    }\n  }\n  return state;\n}\n"],"names":["useControllableState","ImmutableMap","React","createCheckedItems","useFlatControllableCheckedItems","props","headlessTree","initialState","empty","state","useMemo","selectionMode","checkedItems","undefined","defaultState","defaultCheckedItems","initializeCheckedItems","createNextFlatCheckedItems","data","previousCheckedItems","from","value","checked","treeItem","get","process","env","NODE_ENV","console","error","nextCheckedItemsMap","Map","dangerouslyGetInternalMap","set","children","subtree","isAncestorsMixed","ancestor","ancestors","childrenWithSameState","child","childrenValues","length","nextCheckedItems"],"mappings":"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"}