{"version":3,"sources":["../src/choreography/Stagger/useStaggerItemsVisibility.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useAnimationFrame, useEventCallback } from '@fluentui/react-utilities';\nimport type { StaggerProps } from './stagger-types';\nimport {\n  staggerItemsVisibilityAtTime,\n  type StaggerItemsVisibilityAtTimeParams,\n  DEFAULT_ITEM_DURATION,\n  type StaggerChildMapping,\n} from './utils';\n\nexport interface UseStaggerItemsVisibilityParams\n  extends Pick<StaggerProps, 'onMotionFinish'>,\n    Omit<StaggerItemsVisibilityAtTimeParams, 'elapsed' | 'itemCount'> {\n  hideMode: StaggerProps['hideMode'];\n  childMapping: StaggerChildMapping;\n}\n\n/**\n * Hook that tracks the visibility of a staggered sequence of items as time progresses.\n *\n * Behavior summary for all hide modes:\n * - On the first render, items are placed in their final state (enter => visible, exit => hidden)\n *   and no animation runs.\n * - On subsequent renders when direction changes, items animate from the opposite state\n *   to the final state over the stagger timeline.\n * - Changes to the `reversed` prop do not trigger re-animation; they only affect the order\n *   during the next direction change animation.\n *\n * This hook uses child key mapping instead of item count to track individual items.\n * This allows it to correctly handle:\n * - Items being added and removed simultaneously (when count stays the same)\n * - Items being reordered\n * - Individual item identity across renders\n *\n * @param childMapping - Mapping of child keys to elements and indices\n * @param itemDelay - Milliseconds between the start of each item's animation\n * @param itemDuration - Milliseconds each item's animation lasts\n * @param direction - 'enter' (show items) or 'exit' (hide items)\n * @param reversed - Whether to reverse the stagger order (last item first)\n * @param onMotionFinish - Callback fired when the full stagger sequence completes\n * @param hideMode - How children's visibility is managed: 'visibleProp', 'visibilityStyle', or 'unmount'\n *\n * @returns An object with `itemsVisibility: Record<string, boolean>` indicating which items are currently visible by key\n */\nexport function useStaggerItemsVisibility({\n  childMapping,\n  itemDelay,\n  itemDuration = DEFAULT_ITEM_DURATION,\n  direction,\n  reversed = false,\n  onMotionFinish,\n  hideMode = 'visibleProp',\n}: UseStaggerItemsVisibilityParams): { itemsVisibility: Record<string, boolean> } {\n  const [requestAnimationFrame, cancelAnimationFrame] = useAnimationFrame();\n\n  // Stabilize the callback reference to avoid re-triggering effects on every render\n  const handleMotionFinish = useEventCallback(\n    onMotionFinish ??\n      (() => {\n        return;\n      }),\n  );\n\n  // Track animation state independently of child changes\n  const [animationKey, setAnimationKey] = React.useState(0);\n  const prevDirection = React.useRef(direction);\n\n  // Only trigger new animation when direction actually changes, not when children change\n  React.useEffect(() => {\n    if (prevDirection.current !== direction) {\n      setAnimationKey(prev => prev + 1);\n      prevDirection.current = direction;\n    }\n  }, [direction]);\n\n  // State: visibility mapping for all items by key\n  const [itemsVisibility, setItemsVisibility] = React.useState<Record<string, boolean>>(() => {\n    const initial: Record<string, boolean> = {};\n    // All hide modes start in final state: visible for 'enter', hidden for 'exit'\n    const initialState = direction === 'enter';\n    Object.keys(childMapping).forEach(key => {\n      initial[key] = initialState;\n    });\n    return initial;\n  });\n\n  // Update visibility mapping when childMapping changes\n  React.useEffect(() => {\n    setItemsVisibility(prev => {\n      const next: Record<string, boolean> = {};\n      const targetState = direction === 'enter';\n\n      // Add or update items from new mapping\n      Object.keys(childMapping).forEach(key => {\n        if (key in prev) {\n          // Existing item - preserve its visibility state\n          next[key] = prev[key];\n        } else {\n          // New item - set to target state\n          next[key] = targetState;\n        }\n      });\n\n      // Note: Items that were in prev but not in childMapping are automatically removed\n      // because we only iterate over keys in childMapping\n\n      return next;\n    });\n  }, [childMapping, direction]);\n\n  // Refs: animation timing and control\n  const startTimeRef = React.useRef<number | null>(null);\n  const frameRef = React.useRef<number | null>(null);\n  const finishedRef = React.useRef(false);\n  const isFirstRender = React.useRef(true);\n\n  // Use ref to avoid re-running the animation when child mapping changes\n  const childMappingRef = React.useRef(childMapping);\n\n  // Update childMapping ref whenever it changes\n  React.useEffect(() => {\n    childMappingRef.current = childMapping;\n  }, [childMapping]);\n\n  // Use ref for reversed to avoid re-running animation when it changes\n  const reversedRef = React.useRef(reversed);\n\n  // Update reversed ref whenever it changes\n  React.useEffect(() => {\n    reversedRef.current = reversed;\n  }, [reversed]);\n\n  // ====== ANIMATION EFFECT ======\n\n  React.useEffect(() => {\n    let cancelled = false;\n    startTimeRef.current = null;\n    finishedRef.current = false;\n\n    // All hide modes skip animation on first render - items are already in their final state\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      // Items are already in their final state from useState, no animation needed\n      handleMotionFinish();\n      return; // No cleanup needed for first render\n    }\n\n    // For animations after first render, start from the opposite of the final state\n    // - Enter animation: start hidden (false), animate to visible (true)\n    // - Exit animation: start visible (true), animate to hidden (false)\n    const startState = direction === 'exit';\n    // Use childMappingRef.current to avoid adding childMapping to dependencies\n    const initialVisibility: Record<string, boolean> = {};\n    Object.keys(childMappingRef.current).forEach(key => {\n      initialVisibility[key] = startState;\n    });\n    setItemsVisibility(initialVisibility);\n\n    // Animation loop: update visibility on each frame until complete\n    const tick = (now: number) => {\n      if (cancelled) {\n        return;\n      }\n      if (startTimeRef.current === null) {\n        startTimeRef.current = now;\n      }\n      const elapsed = now - (startTimeRef.current as number);\n\n      const childKeys = Object.keys(childMappingRef.current);\n      const itemCount = childKeys.length;\n\n      const result = staggerItemsVisibilityAtTime({\n        itemCount,\n        elapsed,\n        itemDelay,\n        itemDuration,\n        direction,\n        reversed: reversedRef.current,\n      });\n\n      // Convert boolean array to keyed object\n      const nextVisibility: Record<string, boolean> = {};\n      childKeys.forEach((key, idx) => {\n        nextVisibility[key] = result.itemsVisibility[idx];\n      });\n\n      setItemsVisibility(nextVisibility);\n\n      if (elapsed < result.totalDuration) {\n        frameRef.current = requestAnimationFrame(tick);\n      } else if (!finishedRef.current) {\n        finishedRef.current = true;\n        handleMotionFinish();\n      }\n    };\n\n    frameRef.current = requestAnimationFrame(tick);\n    return () => {\n      cancelled = true;\n      if (frameRef.current) {\n        cancelAnimationFrame();\n      }\n    };\n  }, [\n    animationKey,\n    itemDelay,\n    itemDuration,\n    direction,\n    requestAnimationFrame,\n    cancelAnimationFrame,\n    handleMotionFinish,\n  ]);\n\n  return { itemsVisibility };\n}\n"],"names":["React","useAnimationFrame","useEventCallback","staggerItemsVisibilityAtTime","DEFAULT_ITEM_DURATION","useStaggerItemsVisibility","childMapping","itemDelay","itemDuration","direction","reversed","onMotionFinish","hideMode","requestAnimationFrame","cancelAnimationFrame","handleMotionFinish","animationKey","setAnimationKey","useState","prevDirection","useRef","useEffect","current","prev","itemsVisibility","setItemsVisibility","initial","initialState","Object","keys","forEach","key","next","targetState","startTimeRef","frameRef","finishedRef","isFirstRender","childMappingRef","reversedRef","cancelled","startState","initialVisibility","tick","now","elapsed","childKeys","itemCount","length","result","nextVisibility","idx","totalDuration"],"mappings":"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"}